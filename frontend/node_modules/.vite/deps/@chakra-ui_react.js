import {
  require_jsx_runtime
} from "./chunk-HJ3XIB4S.js";
import {
  require_react_dom
} from "./chunk-TS7Y3X5F.js";
import {
  __commonJS,
  __export,
  __toESM,
  require_react
} from "./chunk-XV7VEYX3.js";

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment16 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal2 = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement3(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment16;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal2;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement3;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
    "use strict";
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics2(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics2(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e) {
            }
          }
        }
      }
      return targetComponent;
    }
    module.exports = hoistNonReactStatics2;
  }
});

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports, module) {
    module.exports = stringify3;
    stringify3.default = stringify3;
    stringify3.stable = deterministicStringify;
    stringify3.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions2() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify3(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions2();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace3, val, k, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k, { value: replace3 });
          arr.push([parent, k, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k, replace3]);
        }
      } else {
        parent[k] = replace3;
        arr.push([parent, k, val]);
      }
    }
    function decirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            decirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var keys = Object.keys(val);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            decirc(val[key], key, i, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a2, b2) {
      if (a2 < b2) {
        return -1;
      }
      if (a2 > b2) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions2();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_) {
          return;
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            deterministicDecirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var tmp = {};
          var keys = Object.keys(val).sort(compareFunction);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            deterministicDecirc(val[key], key, i, stack, val, depth, options);
            tmp[key] = val[key];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k, val]);
            parent[k] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
        return v;
      };
      return function(key, val) {
        if (replacerStack.length > 0) {
          for (var i = 0; i < replacerStack.length; i++) {
            var part = replacerStack[i];
            if (part[1] === key && part[0] === val) {
              val = part[2];
              replacerStack.splice(i, 1);
              break;
            }
          }
        }
        return replacer.call(this, key, val);
      };
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/color-swatch/index.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/cx.js
var cx = (...classNames) => classNames.filter(Boolean).map((r) => r.trim()).join(" ");

// node_modules/@chakra-ui/react/dist/esm/styled-system/create-recipe-context.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/create-context.js
var import_react = __toESM(require_react(), 1);
function getErrorMessage(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext(options = {}) {
  const {
    name,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue
  } = options;
  const Context = (0, import_react.createContext)(defaultValue);
  Context.displayName = name;
  function useContext$1() {
    var _a8;
    const context = (0, import_react.useContext)(Context);
    if (!context && strict) {
      const error = new Error(
        errorMessage ?? getErrorMessage(hookName, providerName)
      );
      error.name = "ContextError";
      (_a8 = Error.captureStackTrace) == null ? void 0 : _a8.call(Error, error, useContext$1);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext$1, Context];
}

// node_modules/@chakra-ui/react/dist/esm/utils/call-all.js
function callAll(...fns) {
  return function mergedFn(...args) {
    fns.forEach((fn) => fn == null ? void 0 : fn(...args));
  };
}

// node_modules/@chakra-ui/react/dist/esm/merge-props.js
var clsx = (...args) => args.map((str) => {
  var _a8;
  return (_a8 = str == null ? void 0 : str.trim) == null ? void 0 : _a8.call(str);
}).filter(Boolean).join(" ");
var eventRegex = /^on[A-Z]/;
function mergeProps(...args) {
  let result = {};
  for (let props34 of args) {
    for (let key in result) {
      if (eventRegex.test(key) && typeof result[key] === "function" && typeof props34[key] === "function") {
        result[key] = callAll(result[key], props34[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx(result[key], props34[key]);
        continue;
      }
      if (key === "style") {
        result[key] = Object.assign({}, result[key] ?? {}, props34[key] ?? {});
        continue;
      }
      result[key] = props34[key] !== void 0 ? props34[key] : result[key];
    }
    for (let key in props34) {
      if (result[key] === void 0) {
        result[key] = props34[key];
      }
    }
  }
  return result;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/empty.js
var EMPTY_STYLES = Object.freeze({});
var EMPTY_SLOT_STYLES = Object.freeze(
  {}
);

// node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);

// node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize(fn) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache2[arg] === void 0) cache2[arg] = fn(arg);
    return cache2[arg];
  };
}

// node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = memoize(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);

// node_modules/@emotion/react/dist/emotion-element-489459f2.browser.development.esm.js
var React2 = __toESM(require_react());
var import_react2 = __toESM(require_react());

// node_modules/@emotion/sheet/dist/emotion-sheet.development.esm.js
var isDevelopment = true;
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
  return void 0;
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? !isDevelopment : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert2(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    {
      var isImportRule3 = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
      if (isImportRule3 && this._alreadyInsertedOrderInsensitiveRule) {
        console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule3;
    }
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
        if (!/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
          console.error('There was a problem inserting the following rule: "' + rule + '"', e);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
    {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };
  return StyleSheet2;
}();

// node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}

// node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props34, children, length2) {
  return { value, root, parent, type, props: props34, children, line, column, length: length2, return: "" };
}
function copy(root, props34) {
  return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props34);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      // ] ) " '
      case type:
        return position;
      // " '
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      // (
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      // \
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index) {
  while (!token(peek()))
    next();
  return slice(index, position);
}

// node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset3 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props34 = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      // (
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      // \
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      // /
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      // {
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      // } ; \0
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          // \0 }
          case 0:
          case 125:
            scanning = 0;
          // ;
          case 59 + offset3:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          // @ ;
          case 59:
            characters2 += ";";
          // { rule/at-rule
          default:
            append(reference = ruleset(characters2, root, parent, index, offset3, rules, points, type, props34 = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset3 === 0)
                parse(characters2, root, reference, reference, props34, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props34 = [], length2), children), rules, children, length2, points, rule ? props34 : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index = offset3 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      // :
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          // &
          case 38:
            ampersand = offset3 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          // ,
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          // @
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset3 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          // -
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index, offset3, rules, points, type, props34, children, length2) {
  var post = offset3 - 1;
  var rule = offset3 === 0 ? rules : [""];
  var size3 = sizeof(rule);
  for (var i = 0, j = 0, k = 0; i < index; ++i)
    for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size3; ++x)
      if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
        props34[k++] = z;
  return node(value, root, parent, offset3 === 0 ? RULESET : type, props34, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify(element, index, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

// node_modules/stylis/src/Middleware.js
function middleware(collection4) {
  var length2 = sizeof(collection4);
  return function(element, index, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection4[i](element, index, children, callback) || "";
    return output;
  };
}

// node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js
var weakMemoize = function weakMemoize2(func) {
  var cache2 = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache2.has(arg)) {
      return cache2.get(arg);
    }
    var ret = func(arg);
    cache2.set(arg, ret);
    return ret;
  };
};

// node_modules/@emotion/cache/dist/emotion-cache.browser.development.esm.js
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index] = 1;
        }
        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;
      case 2:
        parsed[index] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index] = peek() === 58 ? "&\f" : "";
          points[index] = parsed[index].length;
          break;
        }
      // fallthrough
      default:
        parsed[index] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value;
  var parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
var ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
var isIgnoringComment = function isIgnoringComment2(element) {
  return element.type === "comm" && element.children.indexOf(ignoreFlag) > -1;
};
var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm2(cache2) {
  return function(element, index, children) {
    if (element.type !== "rule" || cache2.compat) return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
    if (unsafePseudoClasses) {
      var isNested = !!element.parent;
      var commentContainer = isNested ? element.parent.children : (
        // global rule at the root level
        children
      );
      for (var i = commentContainer.length - 1; i >= 0; i--) {
        var node2 = commentContainer[i];
        if (node2.line < element.line) {
          break;
        }
        if (node2.column < element.column) {
          if (isIgnoringComment(node2)) {
            return;
          }
          break;
        }
      }
      unsafePseudoClasses.forEach(function(unsafePseudoClass) {
        console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
      });
    }
  };
};
var isImportRule = function isImportRule2(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};
var isPrependedWithRegularRules = function isPrependedWithRegularRules2(index, children) {
  for (var i = index - 1; i >= 0; i--) {
    if (!isImportRule(children[i])) {
      return true;
    }
  }
  return false;
};
var nullifyElement = function nullifyElement2(element) {
  element.type = "";
  element.value = "";
  element["return"] = "";
  element.children = "";
  element.props = "";
};
var incorrectImportAlarm = function incorrectImportAlarm2(element, index, children) {
  if (!isImportRule(element)) {
    return;
  }
  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};
function prefix2(value, length2) {
  switch (hash(value, length2)) {
    // color-adjust
    case 5103:
      return WEBKIT + "print-" + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    // flex, flex-direction
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    // order
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    // align-items
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    // align-self
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    // align-content
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    // flex-shrink
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    // flex-basis
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    // flex-grow
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    // transition
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    // cursor
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    // background, background-image
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    // justify-content
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        // (s)tretch
        case 115:
          return ~indexof(value, "stretch") ? prefix2(replace(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    // position: sticky
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        // stic(k)y
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        // (inline-)?fl(e)x
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    // writing-mode
    case 5936:
      switch (charat(value, length2 + 11)) {
        // vertical-l(r)
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        // vertical-r(l)
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        // horizontal(-)tb
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index, children, callback) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix2(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element.length) return combine(element.props, function(value) {
          switch (match(value, /(::plac\w+|:read-\w+)/)) {
            // :read-(only|write)
            case ":read-only":
            case ":read-write":
              return serialize([copy(element, {
                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            // :placeholder
            case "::placeholder":
              return serialize([copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var getSourceMap;
{
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
  getSourceMap = function getSourceMap2(styles) {
    var matches = styles.match(sourceMapPattern);
    if (!matches) return;
    return matches[matches.length - 1];
  };
}
var sourceMapPattern;
var createCache = function createCache2(options) {
  var key = options.key;
  if (!key) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
  }
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  {
    if (/[^a-z-]/.test(key)) {
      throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
    }
  }
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache2.compat;
      }
    }), incorrectImportAlarm);
  }
  {
    var currentSheet;
    var finalizingPlugins = [stringify, function(element) {
      if (!element.root) {
        if (element["return"]) {
          currentSheet.insert(element["return"]);
        } else if (element.value && element.type !== COMMENT) {
          currentSheet.insert(element.value + "{}");
        }
      }
    }];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles) {
      return serialize(compile(styles), serializer);
    };
    _insert = function insert2(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      if (getSourceMap) {
        var sourceMap = getSourceMap(serialized.styles);
        if (sourceMap) {
          currentSheet = {
            insert: function insert3(rule) {
              sheet.insert(rule + sourceMap);
            }
          };
        }
      }
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache2.inserted[serialized.name] = true;
      }
    };
  }
  var cache2 = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache2.sheet.hydrate(nodesToHydrate);
  return cache2;
};

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.esm.js
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());

// node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache2, serialized, isStringTag) {
  var className = cache2.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache2.registered[className] === void 0
  ) {
    cache2.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache2, serialized, isStringTag) {
  registerStyles(cache2, serialized, isStringTag);
  var className = cache2.key + "-" + serialized.name;
  if (cache2.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};

// node_modules/@emotion/hash/dist/emotion-hash.esm.js
function murmur2(str) {
  var h = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= /* k >>> r: */
    k >>> 24;
    h = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = /* Math.imul(h, m): */
  (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}

// node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

// node_modules/@emotion/serialize/dist/emotion-serialize.development.esm.js
var isDevelopment2 = true;
var ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match5, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
{
  contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
  contentValues = ["normal", "none", "initial", "inherit", "unset"];
  oldProcessStyleValue = processStyleValue;
  msPattern = /^-ms-/;
  hyphenPattern = /-(.)/g;
  hyphenatedCache = {};
  processStyleValue = function processStyleValue3(key, value) {
    if (key === "content") {
      if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      }
    }
    var processed = oldProcessStyleValue(key, value);
    if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }
    return processed;
  };
}
var contentValuePattern;
var contentValues;
var oldProcessStyleValue;
var msPattern;
var hyphenPattern;
var hyphenatedCache;
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    if (String(componentSelector) === "NO_COMPONENT_SELECTOR") {
      throw new Error(noComponentSelectorMessage);
    }
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes2 = interpolation;
      if (keyframes2.anim === 1) {
        cursor = {
          name: keyframes2.name,
          styles: keyframes2.styles,
          next: cursor
        };
        return keyframes2.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next3 = serializedStyles.next;
        if (next3 !== void 0) {
          while (next3 !== void 0) {
            cursor = {
              name: next3.name,
              styles: next3.styles,
              next: cursor
            };
            next3 = next3.next;
          }
        }
        var styles = serializedStyles.styles + ";";
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      } else {
        console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      }
      break;
    }
    case "string":
      {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function(_match, _p1, p2) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, "") + "`");
          return "${" + fakeVarName + "}";
        });
        if (matched.length) {
          console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\ncss`" + replaced + "`");
        }
      }
      break;
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var key in obj) {
      var value = obj[key];
      if (typeof value !== "object") {
        var asString = value;
        if (registered != null && registered[asString] !== void 0) {
          string += key + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (key === "NO_COMPONENT_SELECTOR" && isDevelopment2) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i4 = 0; _i4 < value.length; _i4++) {
            if (isProcessableValue(value[_i4])) {
              string += processStyleName(key) + ":" + processStyleValue(key, value[_i4]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key) {
            case "animation":
            case "animationName": {
              string += processStyleName(key) + ":" + interpolated + ";";
              break;
            }
            default: {
              if (key === "undefined") {
                console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
              }
              string += key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    if (asTemplateStringsArr[0] === void 0) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }
    styles += asTemplateStringsArr[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      var templateStringsArr = strings;
      if (templateStringsArr[i] === void 0) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles += templateStringsArr[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match5;
  while ((match5 = labelPattern.exec(styles)) !== null) {
    identifierName += "-" + match5[1];
  }
  var name = murmur2(styles) + identifierName;
  {
    var devStyles = {
      name,
      styles,
      next: cursor,
      toString: function toString() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
    return devStyles;
  }
}

// node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js
var React = __toESM(require_react());
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect2 = React["useInsertionEffect"] ? React["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect2 || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect2 || React.useLayoutEffect;

// node_modules/@emotion/react/dist/emotion-element-489459f2.browser.development.esm.js
var EmotionCacheContext = React2.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? createCache({
    key: "css"
  }) : null
);
{
  EmotionCacheContext.displayName = "EmotionCacheContext";
}
var CacheProvider = EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return (0, import_react2.forwardRef)(function(props34, ref2) {
    var cache2 = (0, import_react2.useContext)(EmotionCacheContext);
    return func(props34, cache2, ref2);
  });
};
var ThemeContext = React2.createContext({});
{
  ThemeContext.displayName = "EmotionThemeContext";
}
var getTheme = function getTheme2(outerTheme, theme) {
  if (typeof theme === "function") {
    var mergedTheme = theme(outerTheme);
    if (mergedTheme == null || typeof mergedTheme !== "object" || Array.isArray(mergedTheme)) {
      throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
    }
    return mergedTheme;
  }
  if (theme == null || typeof theme !== "object" || Array.isArray(theme)) {
    throw new Error("[ThemeProvider] Please make your theme prop a plain object");
  }
  return _extends({}, outerTheme, theme);
};
var createCacheWithTheme = weakMemoize(function(outerTheme) {
  return weakMemoize(function(theme) {
    return getTheme(outerTheme, theme);
  });
});
var hasOwn = {}.hasOwnProperty;
var getLastPart = function getLastPart2(functionName) {
  var parts42 = functionName.split(".");
  return parts42[parts42.length - 1];
};
var getFunctionNameFromStackTraceLine = function getFunctionNameFromStackTraceLine2(line2) {
  var match5 = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(line2);
  if (match5) return getLastPart(match5[1]);
  match5 = /^([A-Za-z0-9$.]+)@/.exec(line2);
  if (match5) return getLastPart(match5[1]);
  return void 0;
};
var internalReactFunctionNames = /* @__PURE__ */ new Set(["renderWithHooks", "processChild", "finishClassComponent", "renderToString"]);
var sanitizeIdentifier = function sanitizeIdentifier2(identifier2) {
  return identifier2.replace(/\$/g, "-");
};
var getLabelFromStackTrace = function getLabelFromStackTrace2(stackTrace) {
  if (!stackTrace) return void 0;
  var lines = stackTrace.split("\n");
  for (var i = 0; i < lines.length; i++) {
    var functionName = getFunctionNameFromStackTraceLine(lines[i]);
    if (!functionName) continue;
    if (internalReactFunctionNames.has(functionName)) break;
    if (/^[A-Z]/.test(functionName)) return sanitizeIdentifier(functionName);
  }
  return void 0;
};
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var labelPropName = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props34) {
  if (typeof props34.css === "string" && // check if there is a css declaration
  props34.css.indexOf(":") !== -1) {
    throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + props34.css + "`");
  }
  var newProps = {};
  for (var _key in props34) {
    if (hasOwn.call(props34, _key)) {
      newProps[_key] = props34[_key];
    }
  }
  newProps[typePropName] = type;
  if (typeof globalThis !== "undefined" && !!globalThis.EMOTION_RUNTIME_AUTO_LABEL && !!props34.css && (typeof props34.css !== "object" || !("name" in props34.css) || typeof props34.css.name !== "string" || props34.css.name.indexOf("-") === -1)) {
    var label = getLabelFromStackTrace(new Error().stack);
    if (label) newProps[labelPropName] = label;
  }
  return newProps;
};
var Insertion = function Insertion2(_ref) {
  var cache2 = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
  registerStyles(cache2, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache2, serialized, isStringTag);
  });
  return null;
};
var Emotion = withEmotionCache(function(props34, cache2, ref2) {
  var cssProp = props34.css;
  if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
    cssProp = cache2.registered[cssProp];
  }
  var WrappedComponent = props34[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props34.className === "string") {
    className = getRegisteredStyles(cache2.registered, registeredStyles, props34.className);
  } else if (props34.className != null) {
    className = props34.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, React2.useContext(ThemeContext));
  if (serialized.name.indexOf("-") === -1) {
    var labelFromStack = props34[labelPropName];
    if (labelFromStack) {
      serialized = serializeStyles([serialized, "label:" + labelFromStack + ";"]);
    }
  }
  className += cache2.key + "-" + serialized.name;
  var newProps = {};
  for (var _key2 in props34) {
    if (hasOwn.call(props34, _key2) && _key2 !== "css" && _key2 !== typePropName && _key2 !== labelPropName) {
      newProps[_key2] = props34[_key2];
    }
  }
  newProps.className = className;
  if (ref2) {
    newProps.ref = ref2;
  }
  return React2.createElement(React2.Fragment, null, React2.createElement(Insertion, {
    cache: cache2,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), React2.createElement(WrappedComponent, newProps));
});
{
  Emotion.displayName = "EmotionCssPropInternal";
}
var Emotion$1 = Emotion;

// node_modules/@emotion/react/dist/emotion-react.browser.development.esm.js
var React3 = __toESM(require_react());
var import_hoist_non_react_statics2 = __toESM(require_hoist_non_react_statics_cjs());
var isDevelopment3 = true;
var pkg = {
  name: "@emotion/react",
  version: "11.14.0",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  types: "dist/emotion-react.cjs.d.ts",
  exports: {
    ".": {
      types: {
        "import": "./dist/emotion-react.cjs.mjs",
        "default": "./dist/emotion-react.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./dist/emotion-react.development.edge-light.esm.js",
          "import": "./dist/emotion-react.development.edge-light.cjs.mjs",
          "default": "./dist/emotion-react.development.edge-light.cjs.js"
        },
        worker: {
          module: "./dist/emotion-react.development.edge-light.esm.js",
          "import": "./dist/emotion-react.development.edge-light.cjs.mjs",
          "default": "./dist/emotion-react.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./dist/emotion-react.development.edge-light.esm.js",
          "import": "./dist/emotion-react.development.edge-light.cjs.mjs",
          "default": "./dist/emotion-react.development.edge-light.cjs.js"
        },
        browser: {
          module: "./dist/emotion-react.browser.development.esm.js",
          "import": "./dist/emotion-react.browser.development.cjs.mjs",
          "default": "./dist/emotion-react.browser.development.cjs.js"
        },
        module: "./dist/emotion-react.development.esm.js",
        "import": "./dist/emotion-react.development.cjs.mjs",
        "default": "./dist/emotion-react.development.cjs.js"
      },
      "edge-light": {
        module: "./dist/emotion-react.edge-light.esm.js",
        "import": "./dist/emotion-react.edge-light.cjs.mjs",
        "default": "./dist/emotion-react.edge-light.cjs.js"
      },
      worker: {
        module: "./dist/emotion-react.edge-light.esm.js",
        "import": "./dist/emotion-react.edge-light.cjs.mjs",
        "default": "./dist/emotion-react.edge-light.cjs.js"
      },
      workerd: {
        module: "./dist/emotion-react.edge-light.esm.js",
        "import": "./dist/emotion-react.edge-light.cjs.mjs",
        "default": "./dist/emotion-react.edge-light.cjs.js"
      },
      browser: {
        module: "./dist/emotion-react.browser.esm.js",
        "import": "./dist/emotion-react.browser.cjs.mjs",
        "default": "./dist/emotion-react.browser.cjs.js"
      },
      module: "./dist/emotion-react.esm.js",
      "import": "./dist/emotion-react.cjs.mjs",
      "default": "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      types: {
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
        },
        worker: {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
        },
        browser: {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.cjs.js"
        },
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.cjs.js"
      },
      "edge-light": {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
      },
      worker: {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
      },
      workerd: {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
      },
      browser: {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.cjs.js"
      },
      module: "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js",
      "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
      "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      types: {
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
        },
        worker: {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
        },
        browser: {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.cjs.js"
        },
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.cjs.js"
      },
      "edge-light": {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
      },
      worker: {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
      },
      workerd: {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
      },
      browser: {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.cjs.js"
      },
      module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js",
      "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
      "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      types: {
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
        },
        worker: {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
        },
        browser: {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.cjs.js"
        },
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.cjs.js"
      },
      "edge-light": {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
      },
      worker: {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
      },
      workerd: {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
      },
      browser: {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.cjs.js"
      },
      module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js",
      "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
      "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": {
      types: {
        "import": "./macro.d.mts",
        "default": "./macro.d.ts"
      },
      "default": "./macro.js"
    }
  },
  imports: {
    "#is-development": {
      development: "./src/conditions/true.ts",
      "default": "./src/conditions/false.ts"
    },
    "#is-browser": {
      "edge-light": "./src/conditions/false.ts",
      workerd: "./src/conditions/false.ts",
      worker: "./src/conditions/false.ts",
      browser: "./src/conditions/true.ts",
      "default": "./src/conditions/is-browser.ts"
    }
  },
  files: [
    "src",
    "dist",
    "jsx-runtime",
    "jsx-dev-runtime",
    "_isolated-hnrs",
    "types/css-prop.d.ts",
    "macro.*"
  ],
  sideEffects: false,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.13.5",
    "@emotion/cache": "^11.14.0",
    "@emotion/serialize": "^1.3.3",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.2.0",
    "@emotion/utils": "^1.4.2",
    "@emotion/weak-memoize": "^0.4.0",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@types/react": {
      optional: true
    }
  },
  devDependencies: {
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.13.5",
    "@emotion/css-prettifier": "1.2.0",
    "@emotion/server": "11.11.0",
    "@emotion/styled": "11.14.0",
    "@types/hoist-non-react-statics": "^3.3.5",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^5.4.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: [
      "./index.ts",
      "./jsx-runtime.ts",
      "./jsx-dev-runtime.ts",
      "./_isolated-hnrs.ts"
    ],
    umdName: "emotionReact",
    exports: {
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {
          types: {
            "import": "./macro.d.mts",
            "default": "./macro.d.ts"
          },
          "default": "./macro.js"
        }
      }
    }
  }
};
var jsx = function jsx2(type, props34) {
  var args = arguments;
  if (props34 == null || !hasOwn.call(props34, "css")) {
    return React3.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type, props34);
  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  }
  return React3.createElement.apply(null, createElementArgArray);
};
(function(_jsx) {
  var JSX;
  /* @__PURE__ */ (function(_JSX) {
  })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
})(jsx || (jsx = {}));
var warnedAboutCssPropForGlobal = false;
var Global = withEmotionCache(function(props34, cache2) {
  if (!warnedAboutCssPropForGlobal && // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // I don't really want to add it to the type since it shouldn't be used
  ("className" in props34 && props34.className || "css" in props34 && props34.css)) {
    console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
    warnedAboutCssPropForGlobal = true;
  }
  var styles = props34.styles;
  var serialized = serializeStyles([styles], void 0, React3.useContext(ThemeContext));
  var sheetRef = React3.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache2.key + "-global";
    var sheet = new cache2.sheet.constructor({
      key,
      nonce: cache2.sheet.nonce,
      container: cache2.sheet.container,
      speedy: cache2.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache2.sheet.tags.length) {
      sheet.before = cache2.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache2]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache2, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache2.insert("", serialized, sheet, false);
  }, [cache2, serialized.name]);
  return null;
});
{
  Global.displayName = "EmotionGlobal";
}
var classnames = function classnames2(args) {
  var len = args.length;
  var i = 0;
  var cls = "";
  for (; i < len; i++) {
    var arg = args[i];
    if (arg == null) continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames2(arg);
        } else {
          if (arg.styles !== void 0 && arg.name !== void 0) {
            console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
          }
          toAdd = "";
          for (var k in arg) {
            if (arg[k] && k) {
              toAdd && (toAdd += " ");
              toAdd += k;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};
function merge(registered, css2, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css2(registeredStyles);
}
var Insertion3 = function Insertion4(_ref) {
  var cache2 = _ref.cache, serializedArr = _ref.serializedArr;
  useInsertionEffectAlwaysWithSyncFallback(function() {
    for (var i = 0; i < serializedArr.length; i++) {
      insertStyles(cache2, serializedArr[i], false);
    }
  });
  return null;
};
var ClassNames = withEmotionCache(function(props34, cache2) {
  var hasRendered = false;
  var serializedArr = [];
  var css2 = function css3() {
    if (hasRendered && isDevelopment3) {
      throw new Error("css can only be used during render");
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args, cache2.registered);
    serializedArr.push(serialized);
    registerStyles(cache2, serialized, false);
    return cache2.key + "-" + serialized.name;
  };
  var cx2 = function cx3() {
    if (hasRendered && isDevelopment3) {
      throw new Error("cx can only be used during render");
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return merge(cache2.registered, css2, classnames(args));
  };
  var content = {
    css: css2,
    cx: cx2,
    theme: React3.useContext(ThemeContext)
  };
  var ele = props34.children(content);
  hasRendered = true;
  return React3.createElement(React3.Fragment, null, React3.createElement(Insertion3, {
    cache: cache2,
    serializedArr
  }), ele);
});
{
  ClassNames.displayName = "EmotionClassNames";
}
{
  isBrowser3 = typeof document !== "undefined";
  isTestEnv = typeof jest !== "undefined" || typeof vi !== "undefined";
  if (isBrowser3 && !isTestEnv) {
    globalContext = typeof globalThis !== "undefined" ? globalThis : isBrowser3 ? window : global;
    globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__";
    if (globalContext[globalKey]) {
      console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used.");
    }
    globalContext[globalKey] = true;
  }
}
var isBrowser3;
var isTestEnv;
var globalContext;
var globalKey;

// node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js
var React5 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/merge-refs.js
function assignRef(ref2, value) {
  if (ref2 == null) return;
  if (typeof ref2 === "function") {
    ref2(value);
    return;
  }
  try {
    ref2.current = value;
  } catch (error) {
    throw new Error(`Cannot assign value '${value}' to ref '${ref2}'`);
  }
}
function mergeRefs(...refs) {
  return (node2) => {
    refs.forEach((ref2) => {
      assignRef(ref2, node2);
    });
  };
}

// node_modules/@chakra-ui/react/dist/esm/utils/compact.js
function compact(object) {
  const clone3 = Object.assign({}, object);
  for (let key in clone3) {
    if (clone3[key] === void 0) delete clone3[key];
  }
  return clone3;
}

// node_modules/@chakra-ui/react/dist/esm/utils/interop.js
function interopDefault(mod2) {
  return mod2.default || mod2;
}

// node_modules/@chakra-ui/react/dist/esm/utils/ref.js
var React4 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/is.js
var isObject = (v) => v != null && typeof v === "object" && !Array.isArray(v);
var isCssVar = (v) => /^var\(--.+\)$/.test(v);
var isString = (v) => typeof v === "string";
var isFunction = (v) => typeof v === "function";

// node_modules/@chakra-ui/react/dist/esm/utils/ref.js
function getElementRef(el) {
  var _a8;
  const version2 = React4.version;
  if (!isString(version2)) return el == null ? void 0 : el.ref;
  if (version2.startsWith("18.")) return el == null ? void 0 : el.ref;
  return (_a8 = el == null ? void 0 : el.props) == null ? void 0 : _a8.ref;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/provider.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var [ChakraContextProvider, useChakraContext] = createContext({
  name: "ChakraContext",
  strict: true,
  providerName: "<ChakraProvider />"
});
function ChakraProvider(props34) {
  const { value: sys, children } = props34;
  return (0, import_jsx_runtime.jsxs)(ChakraContextProvider, { value: sys, children: [
    !sys._config.disableLayers && (0, import_jsx_runtime.jsx)(Global, { styles: sys.layers.atRule }),
    (0, import_jsx_runtime.jsx)(Global, { styles: sys._global }),
    children
  ] });
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/use-resolved-props.js
var import_react4 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/split-props.js
var splitPropFn = (props34, predicate) => {
  const rest = {};
  const result = {};
  const allKeys = Object.keys(props34);
  for (const key of allKeys) {
    if (predicate(key)) {
      result[key] = props34[key];
    } else {
      rest[key] = props34[key];
    }
  }
  return [result, rest];
};
var splitProps = (props34, keys) => {
  const predicate = isFunction(keys) ? keys : (key) => keys.includes(key);
  return splitPropFn(props34, predicate);
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/use-resolved-props.js
var htmlProps = /* @__PURE__ */ new Set([
  "htmlWidth",
  "htmlHeight",
  "htmlSize",
  "htmlTranslate"
]);
function isHtmlProp(prop) {
  return typeof prop === "string" && htmlProps.has(prop);
}
function useResolvedProps(inProps, cvaRecipe, shouldForwardProps) {
  const { css: css2, isValidProperty } = useChakraContext();
  const { children, ...props34 } = inProps;
  const result = (0, import_react4.useMemo)(() => {
    const [forwardedProps, restProps_B] = splitProps(
      props34,
      (key) => shouldForwardProps(key, cvaRecipe.variantKeys)
    );
    const [variantProps, restProps_C] = splitProps(
      restProps_B,
      cvaRecipe.variantKeys
    );
    const [styleProps, elementProps] = splitProps(restProps_C, isValidProperty);
    return {
      forwardedProps,
      variantProps,
      styleProps,
      elementProps
    };
  }, [cvaRecipe.variantKeys, shouldForwardProps, props34, isValidProperty]);
  const { css: cssStyles, ...propStyles } = result.styleProps;
  const cvaStyles = (0, import_react4.useMemo)(() => {
    const variantProps = { ...result.variantProps };
    if (!cvaRecipe.variantKeys.includes("colorPalette")) {
      variantProps.colorPalette = props34.colorPalette;
    }
    if (!cvaRecipe.variantKeys.includes("orientation")) {
      variantProps.orientation = props34.orientation;
    }
    return cvaRecipe(variantProps);
  }, [cvaRecipe, result.variantProps, props34.colorPalette, props34.orientation]);
  const styles = (0, import_react4.useMemo)(() => {
    return css2(cvaStyles, ...toArray(cssStyles), propStyles);
  }, [css2, cvaStyles, cssStyles, propStyles]);
  return {
    styles,
    props: {
      ...result.forwardedProps,
      ...result.elementProps,
      children
    }
  };
}
var toArray = (val) => {
  const res = Array.isArray(val) ? val : [val];
  return res.filter(Boolean).flat();
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js
var isPropValid2 = interopDefault(isPropValid);
var testOmitPropsOnStringTag = isPropValid2;
var testOmitPropsOnComponent = (key) => key !== "theme";
var composeShouldForwardProps = (tag, options, isReal) => {
  let shouldForwardProp;
  if (options) {
    const optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? (propName) => tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName) : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp !== "function" && isReal) {
    shouldForwardProp = tag.__emotion_forwardProp;
  }
  return shouldForwardProp;
};
var isBrowser2 = typeof document !== "undefined";
var Insertion5 = ({ cache: cache2, serialized, isStringTag }) => {
  registerStyles(cache2, serialized, isStringTag);
  const rules = useInsertionEffectAlwaysWithSyncFallback(
    () => insertStyles(cache2, serialized, isStringTag)
  );
  if (!isBrowser2 && rules !== void 0) {
    let serializedNames = serialized.name;
    let next3 = serialized.next;
    while (next3 !== void 0) {
      serializedNames = cx(serializedNames, next3.name);
      next3 = next3.next;
    }
    return (0, import_jsx_runtime2.jsx)(
      "style",
      {
        ...{
          [`data-emotion`]: cx(cache2.key, serializedNames),
          dangerouslySetInnerHTML: { __html: rules },
          nonce: cache2.sheet.nonce
        }
      }
    );
  }
  return null;
};
var createStyled = (tag, configOrCva = {}, options = {}) => {
  if (true) {
    if (tag === void 0) {
      throw new Error(
        "You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it."
      );
    }
  }
  const isReal = tag.__emotion_real === tag;
  const baseTag = isReal && tag.__emotion_base || tag;
  let identifierName;
  let targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  let styles = [];
  const Styled = withEmotionCache((inProps, cache2, ref2) => {
    var _a8;
    const { cva, isValidProperty } = useChakraContext();
    const cvaFn = configOrCva.__cva__ ? configOrCva : cva(configOrCva);
    const cvaRecipe = mergeCva(tag.__emotion_cva, cvaFn);
    const createShouldForwardProps = (props210) => {
      return (prop, variantKeys) => {
        if (props210.includes(prop)) return true;
        return !(variantKeys == null ? void 0 : variantKeys.includes(prop)) && !isValidProperty(prop);
      };
    };
    if (!options.shouldForwardProp && options.forwardProps) {
      options.shouldForwardProp = createShouldForwardProps(options.forwardProps);
    }
    const fallbackShouldForwardProp = (prop, variantKeys) => {
      const emotionSfp = typeof tag === "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
      const chakraSfp = !(variantKeys == null ? void 0 : variantKeys.includes(prop)) && !isValidProperty(prop);
      return emotionSfp(prop) && chakraSfp;
    };
    const shouldForwardProp = composeShouldForwardProps(tag, options, isReal) || fallbackShouldForwardProp;
    const propsWithDefault = React5.useMemo(
      () => Object.assign({}, options.defaultProps, compact(inProps)),
      [inProps]
    );
    const { props: props34, styles: styleProps } = useResolvedProps(
      propsWithDefault,
      cvaRecipe,
      shouldForwardProp
    );
    let className = "";
    let classInterpolations = [styleProps];
    let mergedProps = props34;
    if (props34.theme == null) {
      mergedProps = {};
      for (let key in props34) {
        mergedProps[key] = props34[key];
      }
      mergedProps.theme = React5.useContext(ThemeContext);
    }
    if (typeof props34.className === "string") {
      className = getRegisteredStyles(
        cache2.registered,
        classInterpolations,
        props34.className
      );
    } else if (props34.className != null) {
      className = cx(className, props34.className);
    }
    const serialized = serializeStyles(
      styles.concat(classInterpolations),
      cache2.registered,
      mergedProps
    );
    className = cx(className, `${cache2.key}-${serialized.name}`);
    if (targetClassName !== void 0) {
      className = cx(className, targetClassName);
    }
    const shouldUseAs = !shouldForwardProp("as");
    let FinalTag = shouldUseAs && props34.as || baseTag;
    let finalProps = {};
    for (let prop in props34) {
      if (shouldUseAs && prop === "as") continue;
      if (isHtmlProp(prop)) {
        const nativeProp = prop.replace("html", "").toLowerCase();
        finalProps[nativeProp] = props34[prop];
        continue;
      }
      if (shouldForwardProp(prop)) {
        finalProps[prop] = props34[prop];
      }
    }
    finalProps.className = className.trim();
    finalProps.ref = ref2;
    const forwardAsChild = options.forwardAsChild || ((_a8 = options.forwardProps) == null ? void 0 : _a8.includes("asChild"));
    if (props34.asChild && !forwardAsChild) {
      const child = React5.Children.only(props34.children);
      FinalTag = child.type;
      finalProps.children = null;
      Reflect.deleteProperty(finalProps, "asChild");
      finalProps = mergeProps(finalProps, child.props);
      finalProps.ref = mergeRefs(ref2, getElementRef(child));
    }
    if (finalProps.as && forwardAsChild) {
      finalProps.as = void 0;
      return (0, import_jsx_runtime2.jsxs)(React5.Fragment, { children: [
        (0, import_jsx_runtime2.jsx)(
          Insertion5,
          {
            cache: cache2,
            serialized,
            isStringTag: typeof FinalTag === "string"
          }
        ),
        (0, import_jsx_runtime2.jsx)(FinalTag, { asChild: true, ...finalProps, children: (0, import_jsx_runtime2.jsx)(props34.as, { children: finalProps.children }) })
      ] });
    }
    return (0, import_jsx_runtime2.jsxs)(React5.Fragment, { children: [
      (0, import_jsx_runtime2.jsx)(
        Insertion5,
        {
          cache: cache2,
          serialized,
          isStringTag: typeof FinalTag === "string"
        }
      ),
      (0, import_jsx_runtime2.jsx)(FinalTag, { ...finalProps })
    ] });
  });
  Styled.displayName = identifierName !== void 0 ? identifierName : `chakra(${typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component"})`;
  Styled.__emotion_real = Styled;
  Styled.__emotion_base = baseTag;
  Styled.__emotion_forwardProp = options.shouldForwardProp;
  Styled.__emotion_cva = configOrCva;
  Object.defineProperty(Styled, "toString", {
    value() {
      if (targetClassName === void 0 && true) {
        return "NO_COMPONENT_SELECTOR";
      }
      return `.${targetClassName}`;
    }
  });
  return Styled;
};
var styledFn = createStyled.bind();
var cache = /* @__PURE__ */ new Map();
var chakraImpl = new Proxy(styledFn, {
  apply(_, __, args) {
    return styledFn(...args);
  },
  get(_, el) {
    if (!cache.has(el)) {
      cache.set(el, styledFn(el));
    }
    return cache.get(el);
  }
});
var chakra = chakraImpl;
var mergeCva = (cvaA, cvaB) => {
  if (cvaA && !cvaB) return cvaA;
  if (!cvaA && cvaB) return cvaB;
  return cvaA.merge(cvaB);
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/use-recipe.js
var import_react6 = __toESM(require_react(), 1);
function useRecipe(options) {
  const { key, recipe: recipeProp } = options;
  const sys = useChakraContext();
  return (0, import_react6.useMemo)(() => {
    const recipe = recipeProp || (key != null ? sys.getRecipe(key) : {});
    return sys.cva(structuredClone(recipe));
  }, [key, recipeProp, sys]);
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/create-recipe-context.js
var upperFirst = (str) => str.charAt(0).toUpperCase() + str.slice(1);
function createRecipeContext(options) {
  const { key: recipeKey, recipe: recipeConfig } = options;
  const contextName = upperFirst(
    recipeKey || recipeConfig.className || "Component"
  );
  const [PropsProvider62, usePropsContext2] = createContext({
    strict: false,
    name: `${contextName}PropsContext`,
    providerName: `${contextName}PropsContext`
  });
  function useRecipeResult6(props34) {
    const { unstyled, ...restProps } = props34;
    const recipe = useRecipe({
      key: recipeKey,
      recipe: restProps.recipe || recipeConfig
    });
    const [variantProps, otherProps] = (0, import_react7.useMemo)(
      () => recipe.splitVariantProps(restProps),
      [recipe, restProps]
    );
    const styles = unstyled ? EMPTY_STYLES : recipe(variantProps);
    return {
      styles,
      className: recipe.className,
      props: otherProps
    };
  }
  const withContext60 = (Component, options2) => {
    const SuperComponent = chakra(Component, {}, options2);
    const StyledComponent = (0, import_react7.forwardRef)((inProps, ref2) => {
      const propsContext = usePropsContext2();
      const props34 = (0, import_react7.useMemo)(
        () => mergeProps(propsContext, inProps),
        [inProps, propsContext]
      );
      const { styles, className, props: localProps } = useRecipeResult6(props34);
      return (0, import_jsx_runtime3.jsx)(
        SuperComponent,
        {
          ...localProps,
          ref: ref2,
          css: [styles, props34.css],
          className: cx(className, props34.className)
        }
      );
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  function withPropsProvider2() {
    return PropsProvider62;
  }
  return {
    withContext: withContext60,
    PropsProvider: PropsProvider62,
    withPropsProvider: withPropsProvider2,
    usePropsContext: usePropsContext2,
    useRecipeResult: useRecipeResult6
  };
}

// node_modules/@chakra-ui/react/dist/esm/components/grid/grid.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
var Grid = (0, import_react8.forwardRef)(
  function Grid2(props34, ref2) {
    const {
      templateAreas,
      column: column2,
      row,
      autoFlow,
      autoRows,
      templateRows,
      autoColumns,
      templateColumns,
      inline: inline2,
      ...rest
    } = props34;
    return (0, import_jsx_runtime4.jsx)(
      chakra.div,
      {
        ...rest,
        ref: ref2,
        css: [
          {
            display: inline2 ? "inline-grid" : "grid",
            gridTemplateAreas: templateAreas,
            gridAutoColumns: autoColumns,
            gridColumn: column2,
            gridRow: row,
            gridAutoFlow: autoFlow,
            gridAutoRows: autoRows,
            gridTemplateRows: templateRows,
            gridTemplateColumns: templateColumns
          },
          props34.css
        ]
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/color-swatch/index.js
var { withPropsProvider, useRecipeResult } = createRecipeContext({
  key: "colorSwatch"
});
var ColorSwatch = (0, import_react9.forwardRef)(
  function ColorSwatch2(props34, ref2) {
    const { value, ...restProps } = props34;
    const { styles, className, props: localProps } = useRecipeResult(restProps);
    return (0, import_jsx_runtime5.jsx)(
      chakra.span,
      {
        ...localProps,
        ref: ref2,
        "data-value": value,
        css: [styles, { "--color": value }, props34.css],
        className: cx(className, props34.className)
      }
    );
  }
);
var ColorSwatchPropsProvider = withPropsProvider();
var ColorSwatchMix = (props34) => {
  const { items, ...restProps } = props34;
  if (items.length > 4) {
    throw new Error("ColorSwatchMix doesn't support more than 4 colors");
  }
  const isThreeColors = items.length === 3;
  return (0, import_jsx_runtime5.jsx)(ColorSwatch, { overflow: "hidden", ...restProps, value: "transparent", children: (0, import_jsx_runtime5.jsx)(Grid, { templateColumns: "var(--swatch-size) var(--swatch-size)", children: items.map((item, index) => {
    const isLast = index === items.length - 1;
    return (0, import_jsx_runtime5.jsx)(
      ColorSwatch,
      {
        size: "inherit",
        rounded: "none",
        value: item,
        boxShadow: "none",
        gridColumn: isThreeColors && isLast ? "span 2 / span 2" : void 0,
        width: isThreeColors && isLast ? "unset" : void 0
      },
      item
    );
  }) }) });
};

// node_modules/@ark-ui/react/dist/components/format/format-byte.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/dom-query/dist/index.mjs
var clamp = (value) => Math.max(0, Math.min(1, value));
var wrap = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
var pipe = (...fns) => (arg) => fns.reduce((acc, fn) => fn(acc), arg);
var noop = () => void 0;
var isObject2 = (v) => typeof v === "object" && v !== null;
var MAX_Z_INDEX = 2147483647;
var dataAttr = (guard) => guard ? "" : void 0;
var ariaAttr = (guard) => guard ? "true" : void 0;
var ELEMENT_NODE = 1;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;
var isHTMLElement = (el) => isObject2(el) && el.nodeType === ELEMENT_NODE && typeof el.nodeName === "string";
var isDocument = (el) => isObject2(el) && el.nodeType === DOCUMENT_NODE;
var isWindow = (el) => isObject2(el) && el === el.window;
var getNodeName = (node2) => {
  if (isHTMLElement(node2)) return node2.localName || "";
  return "#document";
};
function isRootElement(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
var isNode = (el) => isObject2(el) && el.nodeType !== void 0;
var isShadowRoot = (el) => isNode(el) && el.nodeType === DOCUMENT_FRAGMENT_NODE && "host" in el;
var isInputElement = (el) => isHTMLElement(el) && el.localName === "input";
var isAnchorElement = (el) => !!(el == null ? void 0 : el.matches("a[href]"));
var isElementVisible = (el) => {
  if (!isHTMLElement(el)) return false;
  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;
};
var TEXTAREA_SELECT_REGEX = /(textarea|select)/;
function isEditableElement(el) {
  if (el == null || !isHTMLElement(el)) return false;
  try {
    return isInputElement(el) && el.selectionStart != null || TEXTAREA_SELECT_REGEX.test(el.localName) || el.isContentEditable || el.getAttribute("contenteditable") === "true" || el.getAttribute("contenteditable") === "";
  } catch {
    return false;
  }
}
function contains(parent, child) {
  var _a8;
  if (!parent || !child) return false;
  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false;
  const rootNode = (_a8 = child.getRootNode) == null ? void 0 : _a8.call(child);
  if (parent === child) return true;
  if (parent.contains(child)) return true;
  if (rootNode && isShadowRoot(rootNode)) {
    let next3 = child;
    while (next3) {
      if (parent === next3) return true;
      next3 = next3.parentNode || next3.host;
    }
  }
  return false;
}
function getDocument(el) {
  if (isDocument(el)) return el;
  if (isWindow(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
function getDocumentElement(el) {
  return getDocument(el).documentElement;
}
function getWindow(el) {
  var _a8;
  if (isShadowRoot(el)) return getWindow(el.host);
  if (isDocument(el)) return el.defaultView ?? window;
  if (isHTMLElement(el)) return ((_a8 = el.ownerDocument) == null ? void 0 : _a8.defaultView) ?? window;
  return window;
}
function getActiveElement(rootNode) {
  let activeElement = rootNode.activeElement;
  while (activeElement == null ? void 0 : activeElement.shadowRoot) {
    const el = activeElement.shadowRoot.activeElement;
    if (el === activeElement) break;
    else activeElement = el;
  }
  return activeElement;
}
function getParentNode(node2) {
  if (getNodeName(node2) === "html") return node2;
  const result = node2.assignedSlot || node2.parentNode || isShadowRoot(node2) && node2.host || getDocumentElement(node2);
  return isShadowRoot(result) ? result.host : result;
}
var styleCache = /* @__PURE__ */ new WeakMap();
function getComputedStyle2(el) {
  if (!styleCache.has(el)) {
    styleCache.set(el, getWindow(el).getComputedStyle(el));
  }
  return styleCache.get(el);
}
function getDataUrl(svg, opts) {
  const { type, quality = 0.92, background } = opts;
  if (!svg) throw new Error("[zag-js > getDataUrl]: Could not find the svg element");
  const win = getWindow(svg);
  const doc = win.document;
  const svgBounds = svg.getBoundingClientRect();
  const svgClone = svg.cloneNode(true);
  if (!svgClone.hasAttribute("viewBox")) {
    svgClone.setAttribute("viewBox", `0 0 ${svgBounds.width} ${svgBounds.height}`);
  }
  const serializer = new win.XMLSerializer();
  const source = '<?xml version="1.0" standalone="no"?>\r\n' + serializer.serializeToString(svgClone);
  const svgString = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
  if (type === "image/svg+xml") {
    return Promise.resolve(svgString).then((str) => {
      svgClone.remove();
      return str;
    });
  }
  const dpr = win.devicePixelRatio || 1;
  const canvas = doc.createElement("canvas");
  const image = new win.Image();
  image.src = svgString;
  canvas.width = svgBounds.width * dpr;
  canvas.height = svgBounds.height * dpr;
  const context = canvas.getContext("2d");
  if (type === "image/jpeg" || background) {
    context.fillStyle = background || "white";
    context.fillRect(0, 0, canvas.width, canvas.height);
  }
  return new Promise((resolve) => {
    image.onload = () => {
      context == null ? void 0 : context.drawImage(image, 0, 0, canvas.width, canvas.height);
      resolve(canvas.toDataURL(type, quality));
      svgClone.remove();
    };
  });
}
var isDom = () => typeof document !== "undefined";
function getPlatform() {
  const agent = navigator.userAgentData;
  return (agent == null ? void 0 : agent.platform) ?? navigator.platform;
}
function getUserAgent() {
  const ua2 = navigator.userAgentData;
  if (ua2 && Array.isArray(ua2.brands)) {
    return ua2.brands.map(({ brand, version: version2 }) => `${brand}/${version2}`).join(" ");
  }
  return navigator.userAgent;
}
var pt = (v) => isDom() && v.test(getPlatform());
var ua = (v) => isDom() && v.test(getUserAgent());
var vn = (v) => isDom() && v.test(navigator.vendor);
var isMac = () => pt(/^Mac/);
var isSafari = () => isApple() && vn(/apple/i);
var isFirefox = () => ua(/firefox\//i);
var isApple = () => pt(/mac|iphone|ipad|ipod/i);
var isIos = () => pt(/iP(hone|ad|od)|iOS/);
function getBeforeInputValue(event) {
  const { selectionStart, selectionEnd, value } = event.currentTarget;
  return value.slice(0, selectionStart) + event.data + value.slice(selectionEnd);
}
function getComposedPath(event) {
  var _a8, _b7, _c6;
  return ((_a8 = event.composedPath) == null ? void 0 : _a8.call(event)) ?? ((_c6 = (_b7 = event.nativeEvent) == null ? void 0 : _b7.composedPath) == null ? void 0 : _c6.call(_b7));
}
function getEventTarget(event) {
  const composedPath = getComposedPath(event);
  return (composedPath == null ? void 0 : composedPath[0]) ?? event.target;
}
var isSelfTarget = (event) => {
  return contains(event.currentTarget, getEventTarget(event));
};
function isOpeningInNewTab(event) {
  const element = event.currentTarget;
  if (!element) return false;
  const isAppleDevice = isApple();
  if (isAppleDevice && !event.metaKey) return false;
  if (!isAppleDevice && !event.ctrlKey) return false;
  const localName = element.localName;
  if (localName === "a") return true;
  if (localName === "button" && element.type === "submit") return true;
  if (localName === "input" && element.type === "submit") return true;
  return false;
}
function isDownloadingEvent(event) {
  const element = event.currentTarget;
  if (!element) return false;
  const localName = element.localName;
  if (!event.altKey) return false;
  if (localName === "a") return true;
  if (localName === "button" && element.type === "submit") return true;
  if (localName === "input" && element.type === "submit") return true;
  return false;
}
function isComposingEvent(event) {
  return getNativeEvent(event).isComposing;
}
function isPrintableKey(e) {
  return e.key.length === 1 && !e.ctrlKey && !e.metaKey;
}
var isLeftClick = (e) => e.button === 0;
var isContextMenuEvent = (e) => {
  return e.button === 2 || isMac() && e.ctrlKey && e.button === 0;
};
var isModifierKey = (e) => e.ctrlKey || e.altKey || e.metaKey;
var isTouchEvent = (event) => "touches" in event && event.touches.length > 0;
var keyMap = {
  Up: "ArrowUp",
  Down: "ArrowDown",
  Esc: "Escape",
  " ": "Space",
  ",": "Comma",
  Left: "ArrowLeft",
  Right: "ArrowRight"
};
var rtlKeyMap = {
  ArrowLeft: "ArrowRight",
  ArrowRight: "ArrowLeft"
};
function getEventKey(event, options = {}) {
  const { dir = "ltr", orientation = "horizontal" } = options;
  let key = event.key;
  key = keyMap[key] ?? key;
  const isRtl = dir === "rtl" && orientation === "horizontal";
  if (isRtl && key in rtlKeyMap) key = rtlKeyMap[key];
  return key;
}
function getNativeEvent(event) {
  return event.nativeEvent ?? event;
}
var pageKeys = /* @__PURE__ */ new Set(["PageUp", "PageDown"]);
var arrowKeys = /* @__PURE__ */ new Set(["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]);
function getEventStep(event) {
  if (event.ctrlKey || event.metaKey) {
    return 0.1;
  } else {
    const isPageKey = pageKeys.has(event.key);
    const isSkipKey = isPageKey || event.shiftKey && arrowKeys.has(event.key);
    return isSkipKey ? 10 : 1;
  }
}
function getEventPoint(event, type = "client") {
  const point = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
  return { x: point[`${type}X`], y: point[`${type}Y`] };
}
var addDomEvent = (target, eventName, handler, options) => {
  const node2 = typeof target === "function" ? target() : target;
  node2 == null ? void 0 : node2.addEventListener(eventName, handler, options);
  return () => {
    node2 == null ? void 0 : node2.removeEventListener(eventName, handler, options);
  };
};
function getDescriptor(el, options) {
  const { type = "HTMLInputElement", property = "value" } = options;
  const proto = getWindow(el)[type].prototype;
  return Object.getOwnPropertyDescriptor(proto, property) ?? {};
}
function getElementType(el) {
  if (el.localName === "input") return "HTMLInputElement";
  if (el.localName === "textarea") return "HTMLTextAreaElement";
  if (el.localName === "select") return "HTMLSelectElement";
}
function setElementValue(el, value, property = "value") {
  var _a8;
  const type = getElementType(el);
  if (type) {
    const descriptor = getDescriptor(el, { type, property });
    (_a8 = descriptor.set) == null ? void 0 : _a8.call(el, value);
  }
  el.setAttribute(property, value);
}
function setElementChecked(el, checked) {
  var _a8;
  const descriptor = getDescriptor(el, { type: "HTMLInputElement", property: "checked" });
  (_a8 = descriptor.set) == null ? void 0 : _a8.call(el, checked);
  if (checked) el.setAttribute("checked", "");
  else el.removeAttribute("checked");
}
function dispatchInputValueEvent(el, options) {
  const { value, bubbles = true } = options;
  if (!el) return;
  const win = getWindow(el);
  if (!(el instanceof win.HTMLInputElement)) return;
  setElementValue(el, `${value}`);
  el.dispatchEvent(new win.Event("input", { bubbles }));
}
function dispatchInputCheckedEvent(el, options) {
  const { checked, bubbles = true } = options;
  if (!el) return;
  const win = getWindow(el);
  if (!(el instanceof win.HTMLInputElement)) return;
  setElementChecked(el, checked);
  el.dispatchEvent(new win.Event("click", { bubbles }));
}
function getClosestForm(el) {
  return isFormElement(el) ? el.form : el.closest("form");
}
function isFormElement(el) {
  return el.matches("textarea, input, select, button");
}
function trackFormReset(el, callback) {
  if (!el) return;
  const form = getClosestForm(el);
  const onReset = (e) => {
    if (e.defaultPrevented) return;
    callback();
  };
  form == null ? void 0 : form.addEventListener("reset", onReset, { passive: true });
  return () => form == null ? void 0 : form.removeEventListener("reset", onReset);
}
function trackFieldsetDisabled(el, callback) {
  const fieldset = el == null ? void 0 : el.closest("fieldset");
  if (!fieldset) return;
  callback(fieldset.disabled);
  const win = getWindow(fieldset);
  const obs = new win.MutationObserver(() => callback(fieldset.disabled));
  obs.observe(fieldset, {
    attributes: true,
    attributeFilter: ["disabled"]
  });
  return () => obs.disconnect();
}
function trackFormControl(el, options) {
  if (!el) return;
  const { onFieldsetDisabledChange, onFormReset } = options;
  const cleanups2 = [trackFormReset(el, onFormReset), trackFieldsetDisabled(el, onFieldsetDisabledChange)];
  return () => cleanups2.forEach((cleanup) => cleanup == null ? void 0 : cleanup());
}
var isFrame = (el) => isHTMLElement(el) && el.tagName === "IFRAME";
var hasTabIndex = (el) => !Number.isNaN(parseInt(el.getAttribute("tabindex") || "0", 10));
var hasNegativeTabIndex = (el) => parseInt(el.getAttribute("tabindex") || "0", 10) < 0;
var focusableSelector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type";
var getFocusables = (container, includeContainer = false) => {
  if (!container) return [];
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  const include = includeContainer == true || includeContainer == "if-empty" && elements.length === 0;
  if (include && isHTMLElement(container) && isFocusable(container)) {
    elements.unshift(container);
  }
  const focusableElements = elements.filter(isFocusable);
  focusableElements.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      focusableElements.splice(i, 1, ...getFocusables(frameBody));
    }
  });
  return focusableElements;
};
function isFocusable(element) {
  if (!element || element.closest("[inert]")) return false;
  return element.matches(focusableSelector) && isElementVisible(element);
}
function getTabbables(container, includeContainer) {
  if (!container) return [];
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  const tabbableElements = elements.filter(isTabbable);
  if (includeContainer && isTabbable(container)) {
    tabbableElements.unshift(container);
  }
  tabbableElements.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      const allFrameTabbable = getTabbables(frameBody);
      tabbableElements.splice(i, 1, ...allFrameTabbable);
    }
  });
  if (!tabbableElements.length && includeContainer) {
    return elements;
  }
  return tabbableElements;
}
function isTabbable(el) {
  if (el != null && el.tabIndex > 0) return true;
  return isFocusable(el) && !hasNegativeTabIndex(el);
}
function getTabbableEdges(container, includeContainer) {
  const elements = getTabbables(container, includeContainer);
  const first2 = elements[0] || null;
  const last2 = elements[elements.length - 1] || null;
  return [first2, last2];
}
function getNextTabbable(container, current) {
  const tabbables = getTabbables(container);
  const doc = (container == null ? void 0 : container.ownerDocument) || document;
  const currentElement = current ?? doc.activeElement;
  if (!currentElement) return null;
  const index = tabbables.indexOf(currentElement);
  return tabbables[index + 1] || null;
}
function getTabIndex(node2) {
  if (node2.tabIndex < 0) {
    if ((/^(audio|video|details)$/.test(node2.localName) || isEditableElement(node2)) && !hasTabIndex(node2)) {
      return 0;
    }
  }
  return node2.tabIndex;
}
function getInitialFocus(options) {
  const { root, getInitialEl, filter, enabled = true } = options;
  if (!enabled) return;
  let node2 = null;
  node2 || (node2 = typeof getInitialEl === "function" ? getInitialEl() : getInitialEl);
  node2 || (node2 = root == null ? void 0 : root.querySelector("[data-autofocus],[autofocus]"));
  if (!node2) {
    const tabbables = getTabbables(root);
    node2 = filter ? tabbables.filter(filter)[0] : tabbables[0];
  }
  return node2 || root || void 0;
}
function isValidTabEvent(event) {
  const container = event.currentTarget;
  if (!container) return false;
  const [firstTabbable, lastTabbable] = getTabbableEdges(container);
  const doc = container.ownerDocument || document;
  if (doc.activeElement === firstTabbable && event.shiftKey) return false;
  if (doc.activeElement === lastTabbable && !event.shiftKey) return false;
  if (!firstTabbable && !lastTabbable) return false;
  return true;
}
function nextTick(fn) {
  const set28 = /* @__PURE__ */ new Set();
  function raf22(fn2) {
    const id = globalThis.requestAnimationFrame(fn2);
    set28.add(() => globalThis.cancelAnimationFrame(id));
  }
  raf22(() => raf22(fn));
  return function cleanup() {
    set28.forEach((fn2) => fn2());
  };
}
function raf(fn) {
  const id = globalThis.requestAnimationFrame(fn);
  return () => {
    globalThis.cancelAnimationFrame(id);
  };
}
function queueBeforeEvent(el, type, cb) {
  const cancelTimer = raf(() => {
    el.removeEventListener(type, exec2, true);
    cb();
  });
  const exec2 = () => {
    cancelTimer();
    cb();
  };
  el.addEventListener(type, exec2, { once: true, capture: true });
  return cancelTimer;
}
function observeAttributesImpl(node2, options) {
  if (!node2) return;
  const { attributes, callback: fn } = options;
  const win = node2.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver((changes) => {
    for (const change of changes) {
      if (change.type === "attributes" && change.attributeName && attributes.includes(change.attributeName)) {
        fn(change);
      }
    }
  });
  obs.observe(node2, { attributes: true, attributeFilter: attributes });
  return () => obs.disconnect();
}
function observeAttributes(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(observeAttributesImpl(node2, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function observeChildrenImpl(node2, options) {
  const { callback: fn } = options;
  if (!node2) return;
  const win = node2.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver(fn);
  obs.observe(node2, { childList: true, subtree: true });
  return () => obs.disconnect();
}
function observeChildren(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(observeChildrenImpl(node2, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function clickIfLink(el) {
  const click = () => el.click();
  if (isFirefox()) {
    queueBeforeEvent(el, "keyup", click);
  } else {
    queueMicrotask(click);
  }
}
function getNearestOverflowAncestor(el) {
  const parentNode = getParentNode(el);
  if (isRootElement(parentNode)) return getDocument(parentNode).body;
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) return parentNode;
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(el, list = []) {
  const scrollableAncestor = getNearestOverflowAncestor(el);
  const isBody = scrollableAncestor === el.ownerDocument.body;
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));
}
var OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;
function isOverflowElement(el) {
  const win = getWindow(el);
  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el);
  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isScrollable(el) {
  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;
}
function scrollIntoView(el, options) {
  const { rootEl, ...scrollOptions } = options || {};
  if (!el || !rootEl) return;
  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) return;
  el.scrollIntoView(scrollOptions);
}
function getRelativePoint(point, element) {
  const { left, top, width, height } = element.getBoundingClientRect();
  const offset3 = { x: point.x - left, y: point.y - top };
  const percent = { x: clamp(offset3.x / width), y: clamp(offset3.y / height) };
  function getPercentValue2(options = {}) {
    const { dir = "ltr", orientation = "horizontal", inverted } = options;
    const invertX = typeof inverted === "object" ? inverted.x : inverted;
    const invertY = typeof inverted === "object" ? inverted.y : inverted;
    if (orientation === "horizontal") {
      return dir === "rtl" || invertX ? 1 - percent.x : percent.x;
    }
    return invertY ? 1 - percent.y : percent.y;
  }
  return { offset: offset3, percent, getPercentValue: getPercentValue2 };
}
function requestPointerLock(doc, fn) {
  const body = doc.body;
  const supported = "pointerLockElement" in doc || "mozPointerLockElement" in doc;
  const isLocked = () => !!doc.pointerLockElement;
  function onPointerChange() {
    fn == null ? void 0 : fn(isLocked());
  }
  function onPointerError(event) {
    if (isLocked()) fn == null ? void 0 : fn(false);
    console.error("PointerLock error occurred:", event);
    doc.exitPointerLock();
  }
  if (!supported) return;
  try {
    body.requestPointerLock();
  } catch {
  }
  const cleanup = [
    addDomEvent(doc, "pointerlockchange", onPointerChange, false),
    addDomEvent(doc, "pointerlockerror", onPointerError, false)
  ];
  return () => {
    cleanup.forEach((cleanup2) => cleanup2());
    doc.exitPointerLock();
  };
}
var state = "default";
var userSelect = "";
var elementMap = /* @__PURE__ */ new WeakMap();
function disableTextSelectionImpl(options = {}) {
  const { target, doc } = options;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state === "default") {
      userSelect = rootEl.style.webkitUserSelect;
      rootEl.style.webkitUserSelect = "none";
    }
    state = "disabled";
  } else if (target) {
    elementMap.set(target, target.style.userSelect);
    target.style.userSelect = "none";
  }
  return () => restoreTextSelection({ target, doc: docNode });
}
function restoreTextSelection(options = {}) {
  const { target, doc } = options;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state !== "disabled") return;
    state = "restoring";
    setTimeout(() => {
      nextTick(() => {
        if (state === "restoring") {
          if (rootEl.style.webkitUserSelect === "none") {
            rootEl.style.webkitUserSelect = userSelect || "";
          }
          userSelect = "";
          state = "default";
        }
      });
    }, 300);
  } else {
    if (target && elementMap.has(target)) {
      const prevUserSelect = elementMap.get(target);
      if (target.style.userSelect === "none") {
        target.style.userSelect = prevUserSelect ?? "";
      }
      if (target.getAttribute("style") === "") {
        target.removeAttribute("style");
      }
      elementMap.delete(target);
    }
  }
}
function disableTextSelection(options = {}) {
  const { defer, target, ...restOptions } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = typeof target === "function" ? target() : target;
      cleanups2.push(disableTextSelectionImpl({ ...restOptions, target: node2 }));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function trackPointerMove(doc, handlers) {
  const { onPointerMove, onPointerUp } = handlers;
  const handleMove = (event) => {
    const point = getEventPoint(event);
    const distance = Math.sqrt(point.x ** 2 + point.y ** 2);
    const moveBuffer = event.pointerType === "touch" ? 10 : 5;
    if (distance < moveBuffer) return;
    if (event.pointerType === "mouse" && event.button === 0) {
      onPointerUp();
      return;
    }
    onPointerMove({ point, event });
  };
  const cleanups2 = [
    addDomEvent(doc, "pointermove", handleMove, false),
    addDomEvent(doc, "pointerup", onPointerUp, false),
    addDomEvent(doc, "pointercancel", onPointerUp, false),
    addDomEvent(doc, "contextmenu", onPointerUp, false),
    disableTextSelection({ doc })
  ];
  return () => {
    cleanups2.forEach((cleanup) => cleanup());
  };
}
function trackPress(options) {
  const {
    pointerNode,
    keyboardNode = pointerNode,
    onPress,
    onPressStart,
    onPressEnd,
    isValidKey: isValidKey2 = (e) => e.key === "Enter"
  } = options;
  if (!pointerNode) return noop;
  const win = getWindow(pointerNode);
  const doc = getDocument(pointerNode);
  let removeStartListeners = noop;
  let removeEndListeners = noop;
  let removeAccessibleListeners = noop;
  const getInfo = (event) => ({
    point: getEventPoint(event),
    event
  });
  function startPress(event) {
    onPressStart == null ? void 0 : onPressStart(getInfo(event));
  }
  function cancelPress(event) {
    onPressEnd == null ? void 0 : onPressEnd(getInfo(event));
  }
  const startPointerPress = (startEvent) => {
    removeEndListeners();
    const endPointerPress = (endEvent) => {
      const target = getEventTarget(endEvent);
      if (contains(pointerNode, target)) {
        onPress == null ? void 0 : onPress(getInfo(endEvent));
      } else {
        onPressEnd == null ? void 0 : onPressEnd(getInfo(endEvent));
      }
    };
    const removePointerUpListener = addDomEvent(win, "pointerup", endPointerPress, { passive: !onPress });
    const removePointerCancelListener = addDomEvent(win, "pointercancel", cancelPress, { passive: !onPressEnd });
    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
    if (doc.activeElement === keyboardNode && startEvent.pointerType === "mouse") {
      startEvent.preventDefault();
    }
    startPress(startEvent);
  };
  const removePointerListener = addDomEvent(pointerNode, "pointerdown", startPointerPress, { passive: !onPressStart });
  const removeFocusListener = addDomEvent(keyboardNode, "focus", startAccessiblePress);
  removeStartListeners = pipe(removePointerListener, removeFocusListener);
  function startAccessiblePress() {
    const handleKeydown = (keydownEvent) => {
      if (!isValidKey2(keydownEvent)) return;
      const handleKeyup = (keyupEvent) => {
        if (!isValidKey2(keyupEvent)) return;
        const evt2 = new win.PointerEvent("pointerup");
        const info = getInfo(evt2);
        onPress == null ? void 0 : onPress(info);
        onPressEnd == null ? void 0 : onPressEnd(info);
      };
      removeEndListeners();
      removeEndListeners = addDomEvent(keyboardNode, "keyup", handleKeyup);
      const evt = new win.PointerEvent("pointerdown");
      startPress(evt);
    };
    const handleBlur = () => {
      const evt = new win.PointerEvent("pointercancel");
      cancelPress(evt);
    };
    const removeKeydownListener = addDomEvent(keyboardNode, "keydown", handleKeydown);
    const removeBlurListener = addDomEvent(keyboardNode, "blur", handleBlur);
    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
  }
  return () => {
    removeStartListeners();
    removeEndListeners();
    removeAccessibleListeners();
  };
}
function proxyTabFocusImpl(container, options = {}) {
  const { triggerElement, onFocus } = options;
  const doc = (container == null ? void 0 : container.ownerDocument) || document;
  const body = doc.body;
  function onKeyDown(event) {
    if (event.key !== "Tab") return;
    let elementToFocus = null;
    const [firstTabbable, lastTabbable] = getTabbableEdges(container, true);
    const noTabbableElements = !firstTabbable && !lastTabbable;
    if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {
      elementToFocus = triggerElement;
    } else if (!event.shiftKey && doc.activeElement === triggerElement) {
      elementToFocus = firstTabbable;
    } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {
      elementToFocus = getNextTabbable(body, triggerElement);
    }
    if (!elementToFocus) return;
    event.preventDefault();
    if (typeof onFocus === "function") {
      onFocus(elementToFocus);
    } else {
      elementToFocus.focus();
    }
  }
  return addDomEvent(doc, "keydown", onKeyDown, true);
}
function proxyTabFocus(container, options) {
  const { defer, triggerElement, ...restOptions } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = typeof container === "function" ? container() : container;
      const trigger = typeof triggerElement === "function" ? triggerElement() : triggerElement;
      cleanups2.push(proxyTabFocusImpl(node2, { triggerElement: trigger, ...restOptions }));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function queryAll(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function query(root, selector) {
  return (root == null ? void 0 : root.querySelector(selector)) ?? null;
}
var defaultItemToId = (v) => v.id;
function itemById(v, id, itemToId = defaultItemToId) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId(v, id, itemToId = defaultItemToId) {
  const item = itemById(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
function nextById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
  return v[idx];
}
function prevById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  if (idx === -1) return loop ? v[v.length - 1] : null;
  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
  return v[idx];
}
function createScope(methods) {
  const dom38 = {
    getRootNode: (ctx) => {
      var _a8;
      return ((_a8 = ctx.getRootNode) == null ? void 0 : _a8.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument(dom38.getRootNode(ctx)),
    getWin: (ctx) => dom38.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => getActiveElement(dom38.getRootNode(ctx)),
    isActiveElement: (ctx, elem) => elem === dom38.getActiveElement(ctx),
    getById: (ctx, id) => dom38.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      setElementValue(elem, value.toString());
    }
  };
  return { ...dom38, ...methods };
}
var sanitize = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText = (el) => {
  var _a8;
  return sanitize(((_a8 = el.dataset) == null ? void 0 : _a8.valuetext) ?? el.textContent ?? "");
};
var match2 = (valueText, query2) => {
  return valueText.trim().toLowerCase().startsWith(query2.toLowerCase());
};
function getByText(v, text, currentId, itemToId = defaultItemToId) {
  const index = currentId ? indexOfId(v, currentId, itemToId) : -1;
  let items = currentId ? wrap(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match2(getValueText(item), text));
}
var cleanups = /* @__PURE__ */ new WeakMap();
function set(element, key, setup) {
  if (!cleanups.has(element)) {
    cleanups.set(element, /* @__PURE__ */ new Map());
  }
  const elementCleanups = cleanups.get(element);
  const prevCleanup = elementCleanups.get(key);
  if (!prevCleanup) {
    elementCleanups.set(key, setup());
    return () => {
      var _a8;
      (_a8 = elementCleanups.get(key)) == null ? void 0 : _a8();
      elementCleanups.delete(key);
    };
  }
  const cleanup = setup();
  const nextCleanup = () => {
    cleanup();
    prevCleanup();
    elementCleanups.delete(key);
  };
  elementCleanups.set(key, nextCleanup);
  return () => {
    const isCurrent = elementCleanups.get(key) === nextCleanup;
    if (!isCurrent) return;
    cleanup();
    elementCleanups.set(key, prevCleanup);
  };
}
function setStyle(element, style) {
  if (!element) return () => {
  };
  const setup = () => {
    const prevStyle = element.style.cssText;
    Object.assign(element.style, style);
    return () => {
      element.style.cssText = prevStyle;
    };
  };
  return set(element, "style", setup);
}
function getByTypeaheadImpl(baseItems, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query2 = isRepeated ? search[0] : search;
  let items = baseItems.slice();
  const next3 = getByText(items, query2, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next3;
}
var getByTypeahead = Object.assign(getByTypeaheadImpl, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent
});
function isValidTypeaheadEvent(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var visuallyHiddenStyle = {
  border: "0",
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0",
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap",
  wordWrap: "normal"
};
var fps = 1e3 / 60;
function waitForElement(query2, cb) {
  const el = query2();
  if (isHTMLElement(el) && el.isConnected) {
    cb(el);
    return () => void 0;
  } else {
    const timerId = setInterval(() => {
      const el2 = query2();
      if (isHTMLElement(el2) && el2.isConnected) {
        cb(el2);
        clearInterval(timerId);
      }
    }, fps);
    return () => clearInterval(timerId);
  }
}
function waitForElements(queries, cb) {
  const cleanups2 = [];
  queries == null ? void 0 : queries.forEach((query2) => {
    const clean = waitForElement(query2, cb);
    cleanups2.push(clean);
  });
  return () => {
    cleanups2.forEach((fn) => fn());
  };
}

// node_modules/@zag-js/i18n-utils/dist/index.mjs
function i18nCache(Ins) {
  const formatterCache = /* @__PURE__ */ new Map();
  return function create(locale, options) {
    const cacheKey = locale + (options ? Object.entries(options).sort((a2, b2) => a2[0] < b2[0] ? -1 : 1).join() : "");
    if (formatterCache.has(cacheKey)) {
      return formatterCache.get(cacheKey);
    }
    let formatter = new Ins(locale, options);
    formatterCache.set(cacheKey, formatter);
    return formatter;
  };
}
var collatorCache = i18nCache(Intl.Collator);
var getNumberFormatter = i18nCache(Intl.NumberFormat);
function formatNumber(v, locale, options = {}) {
  const formatter = getNumberFormatter(locale, options);
  return formatter.format(v);
}
var bitPrefixes = ["", "kilo", "mega", "giga", "tera"];
var bytePrefixes = ["", "kilo", "mega", "giga", "tera", "peta"];
var formatBytes = (bytes, locale = "en-US", options = {}) => {
  if (isNaN(bytes)) return "";
  if (bytes === 0) return "0 B";
  const { unit = "byte", unitDisplay = "short" } = options;
  const prefix3 = unit === "bit" ? bitPrefixes : bytePrefixes;
  const index = Math.max(0, Math.min(Math.floor(Math.log10(bytes) / 3), prefix3.length - 1));
  const _unit = prefix3[index] + unit;
  const _unitDisplay = unitDisplay || "short";
  const v = parseFloat((bytes / Math.pow(1e3, index)).toPrecision(3));
  return formatNumber(v, locale, {
    style: "unit",
    unit: _unit,
    unitDisplay: _unitDisplay
  });
};
var getListFormatter = i18nCache(Intl.ListFormat);
var getRelativeTimeFormatter = i18nCache(Intl.RelativeTimeFormat);
var MINUTE_TO_MS = 1e3 * 60;
var HOUR_TO_MS = 1e3 * 60 * 60;
var DAY_TO_MS = 1e3 * 60 * 60 * 24;
var WEEK_TO_MS = 1e3 * 60 * 60 * 24 * 7;
var MONTH_TO_MS = 1e3 * 60 * 60 * 24 * 30;
var YEAR_TO_MS = 1e3 * 60 * 60 * 24 * 365;
var RTL_SCRIPTS = /* @__PURE__ */ new Set([
  "Avst",
  "Arab",
  "Armi",
  "Syrc",
  "Samr",
  "Mand",
  "Thaa",
  "Mend",
  "Nkoo",
  "Adlm",
  "Rohg",
  "Hebr"
]);
var RTL_LANGS = /* @__PURE__ */ new Set([
  "ae",
  "ar",
  "arc",
  "bcc",
  "bqi",
  "ckb",
  "dv",
  "fa",
  "glk",
  "he",
  "ku",
  "mzn",
  "nqo",
  "pnb",
  "ps",
  "sd",
  "ug",
  "ur",
  "yi"
]);
function isRTL(locale) {
  if (Intl.Locale) {
    const script = new Intl.Locale(locale).maximize().script ?? "";
    return RTL_SCRIPTS.has(script);
  }
  const lang = locale.split("-")[0];
  return RTL_LANGS.has(lang);
}

// node_modules/@ark-ui/react/dist/components/format/format-byte.js
var import_react11 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/create-context.js
var import_react10 = __toESM(require_react(), 1);
function getErrorMessage2(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext3(options = {}) {
  const {
    name,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue
  } = options;
  const Context = (0, import_react10.createContext)(defaultValue);
  Context.displayName = name;
  function useContext$1() {
    var _a8;
    const context = (0, import_react10.useContext)(Context);
    if (!context && strict) {
      const error = new Error(errorMessage ?? getErrorMessage2(hookName, providerName));
      error.name = "ContextError";
      (_a8 = Error.captureStackTrace) == null ? void 0 : _a8.call(Error, error, useContext$1);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext$1, Context];
}

// node_modules/@ark-ui/react/dist/providers/locale/use-locale-context.js
var [LocaleContextProvider, useLocaleContext] = createContext3({
  name: "LocaleContext",
  hookName: "useLocaleContext",
  providerName: "<LocaleProvider />",
  strict: false,
  defaultValue: { dir: "ltr", locale: "en-US" }
});

// node_modules/@ark-ui/react/dist/components/format/format-byte.js
var FormatByte = (props34) => {
  const { value, ...intlOptions } = props34;
  const { locale } = useLocaleContext();
  const text = (0, import_react11.useMemo)(() => formatBytes(value, locale, intlOptions), [value, locale, intlOptions]);
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: text });
};
FormatByte.displayName = "FormatByte";

// node_modules/@ark-ui/react/dist/components/format/format-number.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);
var FormatNumber = (props34) => {
  const { value, ...intlOptions } = props34;
  const { locale } = useLocaleContext();
  const text = (0, import_react12.useMemo)(() => formatNumber(value, locale, intlOptions), [value, locale, intlOptions]);
  return (0, import_jsx_runtime7.jsx)(import_jsx_runtime7.Fragment, { children: text });
};
FormatNumber.displayName = "FormatNumber";

// node_modules/@ark-ui/react/dist/components/format/format.js
var format_exports = {};
__export(format_exports, {
  Byte: () => FormatByte,
  Number: () => FormatNumber
});

// node_modules/@chakra-ui/react/dist/esm/components/format/index.js
var FormatNumber2 = format_exports.Number;
var FormatByte2 = format_exports.Byte;

// node_modules/@ark-ui/react/dist/components/presence/presence.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react18 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/compose-refs.js
function setRef(ref2, value) {
  if (typeof ref2 === "function") {
    ref2(value);
  } else if (ref2 !== null && ref2 !== void 0) {
    ref2.current = value;
  }
}
function composeRefs(...refs) {
  return (node2) => {
    for (const ref2 of refs) {
      setRef(ref2, node2);
    }
  };
}

// node_modules/proxy-compare/dist/index.js
var TRACK_MEMO_SYMBOL = Symbol();
var GET_ORIGINAL_SYMBOL = Symbol();
var AFFECTED_PROPERTY = "a";
var IS_TARGET_COPIED_PROPERTY = "f";
var PROXY_PROPERTY = "p";
var PROXY_CACHE_PROPERTY = "c";
var TARGET_CACHE_PROPERTY = "t";
var HAS_KEY_PROPERTY = "h";
var ALL_OWN_KEYS_PROPERTY = "w";
var HAS_OWN_KEY_PROPERTY = "o";
var KEYS_PROPERTY = "k";
var newProxy = (target, handler) => new Proxy(target, handler);
var getProto = Object.getPrototypeOf;
var objectsToTrack = /* @__PURE__ */ new WeakMap();
var isObjectToTrack = (obj) => obj && (objectsToTrack.has(obj) ? objectsToTrack.get(obj) : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);
var isObject3 = (x) => typeof x === "object" && x !== null;
var needsToCopyTargetObject = (obj) => Object.values(Object.getOwnPropertyDescriptors(obj)).some((descriptor) => !descriptor.configurable && !descriptor.writable);
var copyTargetObject = (obj) => {
  if (Array.isArray(obj)) {
    return Array.from(obj);
  }
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  Object.values(descriptors).forEach((desc) => {
    desc.configurable = true;
  });
  return Object.create(getProto(obj), descriptors);
};
var createProxyHandler = (origObj, isTargetCopied) => {
  const state2 = {
    [IS_TARGET_COPIED_PROPERTY]: isTargetCopied
  };
  let trackObject = false;
  const recordUsage = (type, key) => {
    if (!trackObject) {
      let used = state2[AFFECTED_PROPERTY].get(origObj);
      if (!used) {
        used = {};
        state2[AFFECTED_PROPERTY].set(origObj, used);
      }
      if (type === ALL_OWN_KEYS_PROPERTY) {
        used[ALL_OWN_KEYS_PROPERTY] = true;
      } else {
        let set28 = used[type];
        if (!set28) {
          set28 = /* @__PURE__ */ new Set();
          used[type] = set28;
        }
        set28.add(key);
      }
    }
  };
  const recordObjectAsUsed = () => {
    trackObject = true;
    state2[AFFECTED_PROPERTY].delete(origObj);
  };
  const handler = {
    get(target, key) {
      if (key === GET_ORIGINAL_SYMBOL) {
        return origObj;
      }
      recordUsage(KEYS_PROPERTY, key);
      return createProxy(Reflect.get(target, key), state2[AFFECTED_PROPERTY], state2[PROXY_CACHE_PROPERTY], state2[TARGET_CACHE_PROPERTY]);
    },
    has(target, key) {
      if (key === TRACK_MEMO_SYMBOL) {
        recordObjectAsUsed();
        return true;
      }
      recordUsage(HAS_KEY_PROPERTY, key);
      return Reflect.has(target, key);
    },
    getOwnPropertyDescriptor(target, key) {
      recordUsage(HAS_OWN_KEY_PROPERTY, key);
      return Reflect.getOwnPropertyDescriptor(target, key);
    },
    ownKeys(target) {
      recordUsage(ALL_OWN_KEYS_PROPERTY);
      return Reflect.ownKeys(target);
    }
  };
  if (isTargetCopied) {
    handler.set = handler.deleteProperty = () => false;
  }
  return [handler, state2];
};
var getOriginalObject = (obj) => (
  // unwrap proxy
  obj[GET_ORIGINAL_SYMBOL] || // otherwise
  obj
);
var createProxy = (obj, affected, proxyCache, targetCache3) => {
  if (!isObjectToTrack(obj))
    return obj;
  let targetAndCopied = targetCache3 && targetCache3.get(obj);
  if (!targetAndCopied) {
    const target2 = getOriginalObject(obj);
    if (needsToCopyTargetObject(target2)) {
      targetAndCopied = [target2, copyTargetObject(target2)];
    } else {
      targetAndCopied = [target2];
    }
    targetCache3 === null || targetCache3 === void 0 ? void 0 : targetCache3.set(obj, targetAndCopied);
  }
  const [target, copiedTarget] = targetAndCopied;
  let handlerAndState = proxyCache && proxyCache.get(target);
  if (!handlerAndState || handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget) {
    handlerAndState = createProxyHandler(target, !!copiedTarget);
    handlerAndState[1][PROXY_PROPERTY] = newProxy(copiedTarget || target, handlerAndState[0]);
    if (proxyCache) {
      proxyCache.set(target, handlerAndState);
    }
  }
  handlerAndState[1][AFFECTED_PROPERTY] = affected;
  handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache;
  handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache3;
  return handlerAndState[1][PROXY_PROPERTY];
};
var isAllOwnKeysChanged = (prevObj, nextObj) => {
  const prevKeys = Reflect.ownKeys(prevObj);
  const nextKeys = Reflect.ownKeys(nextObj);
  return prevKeys.length !== nextKeys.length || prevKeys.some((k, i) => k !== nextKeys[i]);
};
var isChanged = (prevObj, nextObj, affected, cache2, isEqual3 = Object.is) => {
  if (isEqual3(prevObj, nextObj)) {
    return false;
  }
  if (!isObject3(prevObj) || !isObject3(nextObj))
    return true;
  const used = affected.get(getOriginalObject(prevObj));
  if (!used)
    return true;
  if (cache2) {
    const hit = cache2.get(prevObj);
    if (hit === nextObj) {
      return false;
    }
    cache2.set(prevObj, nextObj);
  }
  let changed = null;
  for (const key of used[HAS_KEY_PROPERTY] || []) {
    changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);
    if (changed)
      return changed;
  }
  if (used[ALL_OWN_KEYS_PROPERTY] === true) {
    changed = isAllOwnKeysChanged(prevObj, nextObj);
    if (changed)
      return changed;
  } else {
    for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {
      const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);
      const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);
      changed = hasPrev !== hasNext;
      if (changed)
        return changed;
    }
  }
  for (const key of used[KEYS_PROPERTY] || []) {
    changed = isChanged(prevObj[key], nextObj[key], affected, cache2, isEqual3);
    if (changed)
      return changed;
  }
  if (changed === null)
    throw new Error("invalid used");
  return changed;
};
var trackMemo = (obj) => {
  if (isObjectToTrack(obj)) {
    return TRACK_MEMO_SYMBOL in obj;
  }
  return false;
};
var getUntracked = (obj) => {
  if (isObjectToTrack(obj)) {
    return obj[GET_ORIGINAL_SYMBOL] || null;
  }
  return null;
};
var markToTrack = (obj, mark = true) => {
  objectsToTrack.set(obj, mark);
};

// node_modules/@zag-js/store/dist/index.mjs
function glob() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function globalRef(key, value) {
  const g = glob();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var refSet = globalRef("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var isReactElement = (x) => typeof x === "object" && x !== null && "$$typeof" in x && "props" in x;
var isVueElement = (x) => typeof x === "object" && x !== null && "__v_isVNode" in x;
var isDOMElement = (x) => typeof x === "object" && x !== null && "nodeType" in x && typeof x.nodeName === "string";
var isElement = (x) => isReactElement(x) || isVueElement(x) || isDOMElement(x);
var isObject4 = (x) => x !== null && typeof x === "object";
var canProxy = (x) => isObject4(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !isElement(x) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer) && !(x instanceof Promise);
var isDev = () => true;
function set2(obj, key, val) {
  if (typeof val.value === "object" && !canProxy(val.value)) val.value = clone(val.value);
  if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === "__proto__") {
    Object.defineProperty(obj, key, val);
  } else obj[key] = val.value;
}
function clone(x) {
  if (typeof x !== "object") return x;
  var i = 0, k, list, tmp, str = Object.prototype.toString.call(x);
  if (str === "[object Object]") {
    tmp = Object.create(Object.getPrototypeOf(x) || null);
  } else if (str === "[object Array]") {
    tmp = Array(x.length);
  } else if (str === "[object Set]") {
    tmp = /* @__PURE__ */ new Set();
    x.forEach(function(val) {
      tmp.add(clone(val));
    });
  } else if (str === "[object Map]") {
    tmp = /* @__PURE__ */ new Map();
    x.forEach(function(val, key) {
      tmp.set(clone(key), clone(val));
    });
  } else if (str === "[object Date]") {
    tmp = /* @__PURE__ */ new Date(+x);
  } else if (str === "[object RegExp]") {
    tmp = new RegExp(x.source, x.flags);
  } else if (str === "[object DataView]") {
    tmp = new x.constructor(clone(x.buffer));
  } else if (str === "[object ArrayBuffer]") {
    tmp = x.slice(0);
  } else if (str === "[object Blob]") {
    tmp = x.slice();
  } else if (str.slice(-6) === "Array]") {
    tmp = new x.constructor(x);
  }
  if (tmp) {
    for (list = Object.getOwnPropertySymbols(x); i < list.length; i++) {
      set2(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));
    }
    for (i = 0, list = Object.getOwnPropertyNames(x); i < list.length; i++) {
      if (Object.hasOwnProperty.call(tmp, k = list[i]) && tmp[k] === x[k]) continue;
      set2(tmp, k, Object.getOwnPropertyDescriptor(x, k));
    }
  }
  return tmp || x;
}
var proxyStateMap = globalRef("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var buildProxyFunction = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version2) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version2) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version2, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (proxyStateMap.has(value)) {
      snap[key] = snapshot(value);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction2 = (initialObject) => {
  if (!isObject4(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version2 = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version2 !== nextVersion) {
      version2 = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version2) {
          version2 = propVersion;
        }
      });
    }
    return version2;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a8;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a8 = entry[1]) == null ? void 0 : _a8.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a8;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject4(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a8 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a8.set) ;
      else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxy(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction2,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return proxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (isDev() && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot(proxyObject) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (isDev() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion());
}
function ref(obj) {
  refSet.add(obj);
  return obj;
}
function proxyWithComputed(initialObject, computedFns) {
  const keys = Object.keys(computedFns);
  keys.forEach((key) => {
    if (Object.getOwnPropertyDescriptor(initialObject, key)) {
      throw new Error("object property already defined");
    }
    const computedFn = computedFns[key];
    const { get, set: set28 } = typeof computedFn === "function" ? { get: computedFn } : computedFn;
    const desc = {};
    desc.get = () => get(snapshot(proxyObject));
    if (set28) {
      desc.set = (newValue) => set28(proxyObject, newValue);
    }
    Object.defineProperty(initialObject, key, desc);
  });
  const proxyObject = proxy(initialObject);
  return proxyObject;
}

// node_modules/@zag-js/utils/dist/index.mjs
var fromLength = (length2) => Array.from(Array(length2).keys());
var first = (v) => v[0];
var last = (v) => v[v.length - 1];
var has = (v, t) => v.indexOf(t) !== -1;
var add = (v, ...items) => v.concat(items);
var remove = (v, ...items) => v.filter((t) => !items.includes(t));
var removeAt = (v, i) => v.filter((_, idx) => idx !== i);
var uniq = (v) => Array.from(new Set(v));
var addOrRemove = (v, item) => {
  if (has(v, item)) return remove(v, item);
  return add(v, item);
};
function clear(v) {
  while (v.length > 0) v.pop();
  return v;
}
function nextIndex(v, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  const next22 = idx + step;
  const len = v.length;
  const last2 = len - 1;
  if (idx === -1) return step > 0 ? 0 : last2;
  if (next22 < 0) return loop ? last2 : 0;
  if (next22 >= len) return loop ? 0 : idx > len ? len : idx;
  return next22;
}
function next2(v, idx, opts = {}) {
  return v[nextIndex(v, idx, opts)];
}
function prevIndex(v, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  return nextIndex(v, idx, { step: -step, loop });
}
function prev2(v, index, opts = {}) {
  return v[prevIndex(v, index, opts)];
}
var chunk = (v, size3) => {
  const res = [];
  return v.reduce((rows, value, index) => {
    var _a8;
    if (index % size3 === 0) rows.push([value]);
    else (_a8 = last(rows)) == null ? void 0 : _a8.push(value);
    return rows;
  }, res);
};
var isArrayLike = (value) => (value == null ? void 0 : value.constructor.name) === "Array";
var isArrayEqual = (a2, b2) => {
  if (a2.length !== b2.length) return false;
  for (let i = 0; i < a2.length; i++) {
    if (!isEqual(a2[i], b2[i])) return false;
  }
  return true;
};
var isEqual = (a2, b2) => {
  if (Object.is(a2, b2)) return true;
  if (a2 == null && b2 != null || a2 != null && b2 == null) return false;
  if (typeof (a2 == null ? void 0 : a2.isEqual) === "function" && typeof (b2 == null ? void 0 : b2.isEqual) === "function") {
    return a2.isEqual(b2);
  }
  if (typeof a2 === "function" && typeof b2 === "function") {
    return a2.toString() === b2.toString();
  }
  if (isArrayLike(a2) && isArrayLike(b2)) {
    return isArrayEqual(Array.from(a2), Array.from(b2));
  }
  if (!(typeof a2 === "object") || !(typeof b2 === "object")) return false;
  const keys = Object.keys(b2 ?? /* @__PURE__ */ Object.create(null));
  const length2 = keys.length;
  for (let i = 0; i < length2; i++) {
    const hasKey = Reflect.has(a2, keys[i]);
    if (!hasKey) return false;
  }
  for (let i = 0; i < length2; i++) {
    const key = keys[i];
    if (!isEqual(a2[key], b2[key])) return false;
  }
  return true;
};
var runIfFn = (v, ...a2) => {
  const res = typeof v === "function" ? v(...a2) : v;
  return res ?? void 0;
};
var cast = (v) => v;
var noop2 = () => {
};
var callAll2 = (...fns) => (...a2) => {
  fns.forEach(function(fn) {
    fn == null ? void 0 : fn(...a2);
  });
};
var uuid = /* @__PURE__ */ (() => {
  let id = 0;
  return () => {
    id++;
    return id.toString(36);
  };
})();
function match3(key, record, ...args) {
  var _a8;
  if (key in record) {
    const fn = record[key];
    return typeof fn === "function" ? fn(...args) : fn;
  }
  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`);
  (_a8 = Error.captureStackTrace) == null ? void 0 : _a8.call(Error, error, match3);
  throw error;
}
var tryCatch = (fn, fallback4) => {
  var _a8;
  try {
    return fn();
  } catch (error) {
    if (error instanceof Error) {
      (_a8 = Error.captureStackTrace) == null ? void 0 : _a8.call(Error, error, tryCatch);
    }
    return fallback4 == null ? void 0 : fallback4();
  }
};
var isDev2 = () => true;
var isArray = (v) => Array.isArray(v);
var isBoolean = (v) => v === true || v === false;
var isObjectLike = (v) => v != null && typeof v === "object";
var isObject5 = (v) => isObjectLike(v) && !isArray(v);
var isNumber = (v) => typeof v === "number" && !Number.isNaN(v);
var isString2 = (v) => typeof v === "string";
var isFunction2 = (v) => typeof v === "function";
var isNull = (v) => v == null;
var hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
var baseGetTag = (v) => Object.prototype.toString.call(v);
var fnToString = Function.prototype.toString;
var objectCtorString = fnToString.call(Object);
var isPlainObject = (v) => {
  if (!isObjectLike(v) || baseGetTag(v) != "[object Object]") return false;
  const proto = Object.getPrototypeOf(v);
  if (proto === null) return true;
  const Ctor = hasProp(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && fnToString.call(Ctor) == objectCtorString;
};
var { floor, abs: abs2, round, min, max, pow, sign } = Math;
var isNaN2 = (v) => Number.isNaN(v);
var nan = (v) => isNaN2(v) ? 0 : v;
var mod = (v, m) => (v % m + m) % m;
var wrap2 = (v, vmax) => (v % vmax + vmax) % vmax;
var getMinValueAtIndex = (i, v, vmin) => i === 0 ? vmin : v[i - 1];
var getMaxValueAtIndex = (i, v, vmax) => i === v.length - 1 ? vmax : v[i + 1];
var isValueAtMax = (v, vmax) => nan(v) >= vmax;
var isValueAtMin = (v, vmin) => nan(v) <= vmin;
var isValueWithinRange = (v, vmin, vmax) => nan(v) >= vmin && nan(v) <= vmax;
var roundValue = (v, vmin, step) => round((nan(v) - vmin) / step) * step + vmin;
var clampValue = (v, vmin, vmax) => min(max(nan(v), vmin), vmax);
var getValuePercent = (v, vmin, vmax) => (nan(v) - vmin) / (vmax - vmin);
var getPercentValue = (p, vmin, vmax, step) => clampValue(roundValue(p * (vmax - vmin) + vmin, vmin, step), vmin, vmax);
var roundToStepPrecision = (v, step) => {
  let rv = v;
  let ss = step.toString();
  let pi = ss.indexOf(".");
  let p = pi >= 0 ? ss.length - pi : 0;
  if (p > 0) {
    let pw = pow(10, p);
    rv = round(rv * pw) / pw;
  }
  return rv;
};
var roundToDpr = (v, dpr) => typeof dpr === "number" ? floor(v * dpr + 0.5) / dpr : round(v);
var snapValueToStep = (v, vmin, vmax, step) => {
  vmin = Number(vmin);
  vmax = Number(vmax);
  let remainder = (v - (isNaN2(vmin) ? 0 : vmin)) % step;
  let sv = roundToStepPrecision(
    abs2(remainder) * 2 >= step ? v + sign(remainder) * (step - abs2(remainder)) : v - remainder,
    step
  );
  if (!isNaN2(vmin)) {
    if (sv < vmin) {
      sv = vmin;
    } else if (!isNaN2(vmax) && sv > vmax) {
      sv = vmin + floor(roundToStepPrecision((vmax - vmin) / step, step)) * step;
    }
  } else if (!isNaN2(vmax) && sv > vmax) {
    sv = vmin + floor(roundToStepPrecision((vmax - vmin) / step, step)) * step;
  }
  return roundToStepPrecision(sv, step);
};
var setValueAtIndex = (vs, i, v) => {
  if (vs[i] === v) return vs;
  return [...vs.slice(0, i), v, ...vs.slice(i + 1)];
};
function getValueSetterAtIndex(index, ctx) {
  const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min);
  const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max);
  let nextValues = ctx.values.slice();
  return function setValue(value) {
    let nextValue = snapValueToStep(value, minValueAtIndex, maxValueAtIndex, ctx.step);
    nextValues = setValueAtIndex(nextValues, index, value);
    nextValues[index] = nextValue;
    return nextValues;
  };
}
function getNextStepValue(index, ctx) {
  const nextValue = ctx.values[index] + ctx.step;
  return getValueSetterAtIndex(index, ctx)(nextValue);
}
function getPreviousStepValue(index, ctx) {
  const nextValue = ctx.values[index] - ctx.step;
  return getValueSetterAtIndex(index, ctx)(nextValue);
}
var getClosestValueIndex = (vs, t) => {
  let i = vs.findIndex((v) => t - v < 0);
  if (i === 0) return i;
  if (i === -1) return vs.length - 1;
  let vLeft = vs[i - 1];
  let vRight = vs[i];
  if (abs2(vLeft - t) < abs2(vRight - t)) return i - 1;
  return i;
};
var getValueRanges = (vs, vmin, vmax, gap) => vs.map((v, i) => ({
  min: i === 0 ? vmin : vs[i - 1] + gap,
  max: i === vs.length - 1 ? vmax : vs[i + 1] - gap,
  value: v
}));
var getValueTransformer = (va, vb) => {
  const [a2, b2] = va;
  const [c, d] = vb;
  return (v) => a2 === b2 || c === d ? c : c + (d - c) / (b2 - a2) * (v - a2);
};
var toFixedNumber = (v, d = 0, b2 = 10) => {
  const pow2 = Math.pow(b2, d);
  return round(v * pow2) / pow2;
};
var countDecimals = (value) => {
  if (!Number.isFinite(value)) return 0;
  let e = 1, p = 0;
  while (Math.round(value * e) / e !== value) {
    e *= 10;
    p += 1;
  }
  return p;
};
var decimalOp = (a2, op, b2) => {
  let result = op === "+" ? a2 + b2 : a2 - b2;
  if (a2 % 1 !== 0 || b2 % 1 !== 0) {
    const multiplier = 10 ** Math.max(countDecimals(a2), countDecimals(b2));
    a2 = Math.round(a2 * multiplier);
    b2 = Math.round(b2 * multiplier);
    result = op === "+" ? a2 + b2 : a2 - b2;
    result /= multiplier;
  }
  return result;
};
var incrementValue = (v, s) => decimalOp(nan(v), "+", s);
var decrementValue = (v, s) => decimalOp(nan(v), "-", s);
function compact2(obj) {
  if (!isPlainObject2(obj) || obj === void 0) return obj;
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact2(value);
    }
  }
  return filtered;
}
var isPlainObject2 = (v) => {
  return v && typeof v === "object" && v.constructor === Object;
};
function splitProps2(props34, keys) {
  const rest = {};
  const result = {};
  const keySet = new Set(keys);
  for (const key in props34) {
    if (keySet.has(key)) {
      result[key] = props34[key];
    } else {
      rest[key] = props34[key];
    }
  }
  return [result, rest];
}
var createSplitProps = (keys) => {
  return function split(props34) {
    return splitProps2(props34, keys);
  };
};
function warn(...a2) {
  const m = a2.length === 1 ? a2[0] : a2[1];
  const c = a2.length === 2 ? a2[0] : true;
  if (c && true) {
    console.warn(m);
  }
}
function invariant(...a2) {
  const m = a2.length === 1 ? a2[0] : a2[1];
  const c = a2.length === 2 ? a2[0] : true;
  if (c && true) {
    throw new Error(m);
  }
}

// node_modules/@zag-js/core/dist/index.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
function deepMerge(source, ...objects) {
  if (!isPlainObject(source)) {
    throw new TypeError("Source argument must be a plain object");
  }
  for (const obj of objects) {
    if (!isPlainObject(obj)) continue;
    const target = compact2(obj);
    for (const key in target) {
      if (!Object.prototype.hasOwnProperty.call(target, key)) continue;
      if (key === "__proto__" || key === "constructor" || key === "prototype") continue;
      const sourceVal = source[key];
      const targetVal = obj[key];
      if (isPlainObject(targetVal)) {
        source[key] = isPlainObject(sourceVal) ? deepMerge(sourceVal, targetVal) : { ...targetVal };
      } else {
        source[key] = targetVal;
      }
    }
  }
  return source;
}
function toEvent(event) {
  const obj = isString2(event) ? { type: event } : event;
  return obj;
}
function toArray2(value) {
  if (!value) return [];
  return isArray(value) ? value.slice() : [value];
}
function isGuardHelper(value) {
  return isObject5(value) && value.predicate != null;
}
var Truthy = () => true;
function exec(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a8;
    if (isString2(guard)) {
      return !!((_a8 = guardMap[guard]) == null ? void 0 : _a8.call(guardMap, ctx, event, meta));
    }
    if (isFunction2(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards = { or, and, not, stateIn };
function choose(actions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      var _a8;
      return (_a8 = actions.find((def) => {
        const guard = def.guard ?? Truthy;
        return exec(guardMap, ctx, event, meta)(guard);
      })) == null ? void 0 : _a8.actions;
    }
  };
}
function determineGuardFn(guard, guardMap) {
  guard = guard ?? Truthy;
  return (context, event, meta) => {
    if (isString2(guard)) {
      const value = guardMap[guard];
      return isFunction2(value) ? value(context, event, meta) : value;
    }
    if (isGuardHelper(guard)) {
      return guard.predicate(guardMap)(context, event, meta);
    }
    return guard == null ? void 0 : guard(context, event, meta);
  };
}
function determineActionsFn(values, guardMap) {
  return (context, event, meta) => {
    if (isGuardHelper(values)) {
      return values.predicate(guardMap)(context, event, meta);
    }
    return values;
  };
}
function createProxy2(config) {
  var _a8, _b7;
  const computedContext = config.computed ?? cast({});
  const initialContext = config.context ?? cast({});
  const initialTags = config.initial ? (_b7 = (_a8 = config.states) == null ? void 0 : _a8[config.initial]) == null ? void 0 : _b7.tags : [];
  const state2 = proxy({
    value: config.initial ?? "",
    previousValue: "",
    event: cast({}),
    previousEvent: cast({}),
    context: proxyWithComputed(initialContext, computedContext),
    done: false,
    tags: initialTags ?? [],
    hasTag(tag) {
      return this.tags.includes(tag);
    },
    matches(...value) {
      return value.includes(this.value);
    },
    can(event) {
      return cast(this).nextEvents.includes(event);
    },
    get nextEvents() {
      var _a9, _b8;
      const stateEvents = ((_b8 = (_a9 = config.states) == null ? void 0 : _a9[this.value]) == null ? void 0 : _b8["on"]) ?? {};
      const globalEvents = (config == null ? void 0 : config.on) ?? {};
      return Object.keys({ ...stateEvents, ...globalEvents });
    },
    get changed() {
      if (this.event.value === "machine.init" || !this.previousValue) return false;
      return this.value !== this.previousValue;
    }
  });
  return cast(state2);
}
function determineDelayFn(delay2, delaysMap) {
  return (context, event) => {
    if (isNumber(delay2)) return delay2;
    if (isFunction2(delay2)) {
      return delay2(context, event);
    }
    if (isString2(delay2)) {
      const value = Number.parseFloat(delay2);
      if (!Number.isNaN(value)) {
        return value;
      }
      if (delaysMap) {
        const valueOrFn = delaysMap == null ? void 0 : delaysMap[delay2];
        invariant(
          valueOrFn == null,
          `[@zag-js/core > determine-delay] Cannot determine delay for \`${delay2}\`. It doesn't exist in \`options.delays\``
        );
        return isFunction2(valueOrFn) ? valueOrFn(context, event) : valueOrFn;
      }
    }
  };
}
function toTarget(target) {
  return isString2(target) ? { target } : target;
}
function determineTransitionFn(transitions, guardMap) {
  return (context, event, meta) => {
    return toArray2(transitions).map(toTarget).find((transition) => {
      const determineGuard = determineGuardFn(transition.guard, guardMap);
      const guard = determineGuard(context, event, meta);
      return guard ?? transition.target ?? transition.actions;
    });
  };
}
var Machine = class {
  // Let's get started!
  constructor(config, options) {
    var _a8, _b7, _c6, _d6, _e7;
    __publicField(
      this,
      "status",
      "Not Started"
      /* NotStarted */
    );
    __publicField(this, "state");
    __publicField(this, "initialState");
    __publicField(this, "initialContext");
    __publicField(this, "id");
    __publicField(
      this,
      "type",
      "machine"
      /* Machine */
    );
    __publicField(this, "activityEvents", /* @__PURE__ */ new Map());
    __publicField(this, "delayedEvents", /* @__PURE__ */ new Map());
    __publicField(this, "stateListeners", /* @__PURE__ */ new Set());
    __publicField(this, "doneListeners", /* @__PURE__ */ new Set());
    __publicField(this, "contextWatchers", /* @__PURE__ */ new Set());
    __publicField(this, "removeStateListener", noop2);
    __publicField(this, "parent");
    __publicField(this, "children", /* @__PURE__ */ new Map());
    __publicField(this, "guardMap");
    __publicField(this, "actionMap");
    __publicField(this, "delayMap");
    __publicField(this, "activityMap");
    __publicField(this, "sync");
    __publicField(this, "options");
    __publicField(this, "config");
    __publicField(this, "_created", () => {
      if (!this.config.created) return;
      const event = toEvent(
        "machine.created"
        /* Created */
      );
      this.executeActions(this.config.created, event);
    });
    __publicField(this, "start", (init) => {
      this.state.value = "";
      this.state.tags = [];
      if (this.status === "Running") {
        return this;
      }
      this.status = "Running";
      this.removeStateListener = subscribe(
        this.state,
        () => {
          this.stateListeners.forEach((listener) => {
            listener(this.stateSnapshot);
          });
        },
        this.sync
      );
      this.setupContextWatchers();
      this.executeActivities(
        toEvent(
          "machine.start"
          /* Start */
        ),
        toArray2(this.config.activities),
        "machine.start"
        /* Start */
      );
      this.executeActions(this.config.entry, toEvent(
        "machine.start"
        /* Start */
      ));
      const event = toEvent(
        "machine.init"
        /* Init */
      );
      const target = isObject5(init) ? init.value : init;
      const context = isObject5(init) ? init.context : void 0;
      if (context) {
        this.setContext(context);
      }
      const transition = {
        target: target ?? this.config.initial
      };
      const next3 = this.getNextStateInfo(transition, event);
      this.initialState = next3;
      this.performStateChangeEffects(this.state.value, next3, event);
      return this;
    });
    __publicField(this, "setupContextWatchers", () => {
      const { watch } = this.config;
      if (!watch) return;
      let prev3 = snapshot(this.state.context);
      const cleanup = subscribe(this.state.context, () => {
        var _a9;
        const next3 = snapshot(this.state.context);
        for (const [key, fn] of Object.entries(watch)) {
          const isEqual3 = ((_a9 = this.options.compareFns) == null ? void 0 : _a9[key]) ?? Object.is;
          if (isEqual3(prev3[key], next3[key])) continue;
          this.executeActions(fn, this.state.event);
        }
        prev3 = next3;
      });
      this.contextWatchers.add(cleanup);
    });
    __publicField(this, "stop", () => {
      if (this.status === "Stopped") return;
      this.performExitEffects(this.state.value, toEvent(
        "machine.stop"
        /* Stop */
      ));
      this.executeActions(this.config.exit, toEvent(
        "machine.stop"
        /* Stop */
      ));
      this.setState("");
      this.setEvent(
        "machine.stop"
        /* Stop */
      );
      this.stopStateListeners();
      this.stopChildren();
      this.stopActivities();
      this.stopDelayedEvents();
      this.stopContextWatchers();
      this.status = "Stopped";
      return this;
    });
    __publicField(this, "stopStateListeners", () => {
      this.removeStateListener();
      this.stateListeners.clear();
    });
    __publicField(this, "stopContextWatchers", () => {
      this.contextWatchers.forEach((fn) => fn());
      this.contextWatchers.clear();
    });
    __publicField(this, "stopDelayedEvents", () => {
      this.delayedEvents.forEach((state2) => {
        state2.forEach((stop) => stop());
      });
      this.delayedEvents.clear();
    });
    __publicField(this, "stopActivities", (state2) => {
      var _a9, _b8;
      if (state2) {
        (_a9 = this.activityEvents.get(state2)) == null ? void 0 : _a9.forEach((stop) => stop());
        (_b8 = this.activityEvents.get(state2)) == null ? void 0 : _b8.clear();
        this.activityEvents.delete(state2);
      } else {
        this.activityEvents.forEach((state22) => {
          state22.forEach((stop) => stop());
          state22.clear();
        });
        this.activityEvents.clear();
      }
    });
    __publicField(this, "sendChild", (evt, to) => {
      const event = toEvent(evt);
      const id = runIfFn(to, this.contextSnapshot);
      const child = this.children.get(id);
      if (!child) {
        invariant(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`);
      }
      child.send(event);
    });
    __publicField(this, "stopChild", (id) => {
      if (!this.children.has(id)) {
        invariant(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`);
      }
      this.children.get(id).stop();
      this.children.delete(id);
    });
    __publicField(this, "removeChild", (id) => {
      this.children.delete(id);
    });
    __publicField(this, "stopChildren", () => {
      this.children.forEach((child) => child.stop());
      this.children.clear();
    });
    __publicField(this, "setParent", (parent) => {
      this.parent = parent;
    });
    __publicField(this, "spawn", (src, id) => {
      const actor = runIfFn(src);
      if (id) actor.id = id;
      actor.type = "machine.actor";
      actor.setParent(this);
      this.children.set(actor.id, cast(actor));
      actor.onDone(() => {
        this.removeChild(actor.id);
      }).start();
      return cast(ref(actor));
    });
    __publicField(this, "stopActivity", (key) => {
      var _a9;
      if (!this.state.value) return;
      const cleanups2 = this.activityEvents.get(this.state.value);
      (_a9 = cleanups2 == null ? void 0 : cleanups2.get(key)) == null ? void 0 : _a9();
      cleanups2 == null ? void 0 : cleanups2.delete(key);
    });
    __publicField(this, "addActivityCleanup", (state2, key, cleanup) => {
      var _a9;
      if (!state2) return;
      if (!this.activityEvents.has(state2)) {
        this.activityEvents.set(state2, /* @__PURE__ */ new Map([[key, cleanup]]));
      } else {
        (_a9 = this.activityEvents.get(state2)) == null ? void 0 : _a9.set(key, cleanup);
      }
    });
    __publicField(this, "setState", (target) => {
      this.state.previousValue = this.state.value;
      this.state.value = target;
      const stateNode = this.getStateNode(target);
      if (target == null) {
        clear(this.state.tags);
      } else {
        this.state.tags = toArray2(stateNode == null ? void 0 : stateNode.tags);
      }
    });
    __publicField(this, "setContext", (context) => {
      if (!context) return;
      deepMerge(this.state.context, context);
    });
    __publicField(this, "setOptions", (options2) => {
      const opts = compact2(options2);
      this.actionMap = { ...this.actionMap, ...opts.actions };
      this.delayMap = { ...this.delayMap, ...opts.delays };
      this.activityMap = { ...this.activityMap, ...opts.activities };
      this.guardMap = { ...this.guardMap, ...opts.guards };
    });
    __publicField(this, "getStateNode", (state2) => {
      var _a9;
      if (!state2) return;
      return (_a9 = this.config.states) == null ? void 0 : _a9[state2];
    });
    __publicField(this, "getNextStateInfo", (transitions, event) => {
      const transition = this.determineTransition(transitions, event);
      const isTargetless = !(transition == null ? void 0 : transition.target);
      const target = (transition == null ? void 0 : transition.target) ?? this.state.value;
      const changed = this.state.value !== target;
      const stateNode = this.getStateNode(target);
      const reenter = !isTargetless && !changed && !(transition == null ? void 0 : transition.internal);
      const info = {
        reenter,
        transition,
        stateNode,
        target,
        changed
      };
      this.log("NextState:", `[${event.type}]`, this.state.value, "---->", info.target);
      return info;
    });
    __publicField(this, "getAfterActions", (transition, delay2) => {
      let id;
      const current = this.state.value;
      return {
        entry: () => {
          id = globalThis.setTimeout(() => {
            const next3 = this.getNextStateInfo(transition, this.state.event);
            this.performStateChangeEffects(current, next3, this.state.event);
          }, delay2);
        },
        exit: () => {
          globalThis.clearTimeout(id);
        }
      };
    });
    __publicField(this, "getDelayedEventActions", (state2) => {
      const stateNode = this.getStateNode(state2);
      const event = this.state.event;
      if (!stateNode || !stateNode.after) return;
      const entries = [];
      const exits = [];
      if (isArray(stateNode.after)) {
        const transition = this.determineTransition(stateNode.after, event);
        if (!transition) return;
        if (!hasProp(transition, "delay")) {
          throw new Error(`[@zag-js/core > after] Delay is required for after transition: ${JSON.stringify(transition)}`);
        }
        const determineDelay = determineDelayFn(transition.delay, this.delayMap);
        const __delay = determineDelay(this.contextSnapshot, event);
        const actions = this.getAfterActions(transition, __delay);
        entries.push(actions.entry);
        exits.push(actions.exit);
        return { entries, exits };
      }
      if (isObject5(stateNode.after)) {
        for (const delay2 in stateNode.after) {
          const transition = stateNode.after[delay2];
          const determineDelay = determineDelayFn(delay2, this.delayMap);
          const __delay = determineDelay(this.contextSnapshot, event);
          const actions = this.getAfterActions(transition, __delay);
          entries.push(actions.entry);
          exits.push(actions.exit);
        }
      }
      return { entries, exits };
    });
    __publicField(this, "executeActions", (actions, event) => {
      var _a9;
      const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta);
      for (const action of toArray2(pickedActions)) {
        const fn = isString2(action) ? (_a9 = this.actionMap) == null ? void 0 : _a9[action] : action;
        warn(
          isString2(action) && !fn,
          `[@zag-js/core > execute-actions] No implementation found for action: \`${action}\``
        );
        fn == null ? void 0 : fn(this.state.context, event, this.meta);
      }
    });
    __publicField(this, "executeActivities", (event, activities, state2) => {
      var _a9;
      for (const activity of activities) {
        const fn = isString2(activity) ? (_a9 = this.activityMap) == null ? void 0 : _a9[activity] : activity;
        if (!fn) {
          warn(`[@zag-js/core > execute-activity] No implementation found for activity: \`${activity}\``);
          continue;
        }
        const cleanup = fn(this.state.context, event, this.meta);
        if (cleanup) {
          const key = isString2(activity) ? activity : activity.name || uuid();
          this.addActivityCleanup(state2 ?? this.state.value, key, cleanup);
        }
      }
    });
    __publicField(this, "createEveryActivities", (every, callbackfn) => {
      if (!every) return;
      if (isArray(every)) {
        const picked = toArray2(every).find((transition) => {
          const delayOrFn = transition.delay;
          const determineDelay2 = determineDelayFn(delayOrFn, this.delayMap);
          const delay22 = determineDelay2(this.contextSnapshot, this.state.event);
          const determineGuard = determineGuardFn(transition.guard, this.guardMap);
          const guard = determineGuard(this.contextSnapshot, this.state.event, this.guardMeta);
          return guard ?? delay22 != null;
        });
        if (!picked) return;
        const determineDelay = determineDelayFn(picked.delay, this.delayMap);
        const delay2 = determineDelay(this.contextSnapshot, this.state.event);
        const activity = () => {
          const id = globalThis.setInterval(() => {
            this.executeActions(picked.actions, this.state.event);
          }, delay2);
          return () => {
            globalThis.clearInterval(id);
          };
        };
        callbackfn(activity);
      } else {
        for (const interval in every) {
          const actions = every == null ? void 0 : every[interval];
          const determineDelay = determineDelayFn(interval, this.delayMap);
          const delay2 = determineDelay(this.contextSnapshot, this.state.event);
          const activity = () => {
            const id = globalThis.setInterval(() => {
              this.executeActions(actions, this.state.event);
            }, delay2);
            return () => {
              globalThis.clearInterval(id);
            };
          };
          callbackfn(activity);
        }
      }
    });
    __publicField(this, "setEvent", (event) => {
      this.state.previousEvent = this.state.event;
      this.state.event = ref(toEvent(event));
    });
    __publicField(this, "performExitEffects", (current, event) => {
      const currentState = this.state.value;
      if (currentState === "") return;
      const stateNode = current ? this.getStateNode(current) : void 0;
      this.stopActivities(currentState);
      const _exit = determineActionsFn(stateNode == null ? void 0 : stateNode.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta);
      const exitActions = toArray2(_exit);
      const afterExitActions = this.delayedEvents.get(currentState);
      if (afterExitActions) {
        exitActions.push(...afterExitActions);
      }
      this.executeActions(exitActions, event);
      this.delayedEvents.delete(currentState);
    });
    __publicField(this, "performEntryEffects", (next3, event) => {
      const stateNode = this.getStateNode(next3);
      const activities = toArray2(stateNode == null ? void 0 : stateNode.activities);
      this.createEveryActivities(stateNode == null ? void 0 : stateNode.every, (activity) => {
        activities.unshift(activity);
      });
      if (activities.length > 0) {
        this.executeActivities(event, activities);
      }
      const pickedActions = determineActionsFn(stateNode == null ? void 0 : stateNode.entry, this.guardMap)(
        this.contextSnapshot,
        event,
        this.guardMeta
      );
      const entryActions = toArray2(pickedActions);
      const afterActions = this.getDelayedEventActions(next3);
      if ((stateNode == null ? void 0 : stateNode.after) && afterActions) {
        this.delayedEvents.set(next3, afterActions == null ? void 0 : afterActions.exits);
        entryActions.push(...afterActions.entries);
      }
      this.executeActions(entryActions, event);
      if ((stateNode == null ? void 0 : stateNode.type) === "final") {
        this.state.done = true;
        this.doneListeners.forEach((listener) => {
          listener(this.stateSnapshot);
        });
        this.stop();
      }
    });
    __publicField(this, "performTransitionEffects", (transitions, event) => {
      const transition = this.determineTransition(transitions, event);
      this.executeActions(transition == null ? void 0 : transition.actions, event);
    });
    __publicField(this, "performStateChangeEffects", (current, next3, event) => {
      this.setEvent(event);
      const changed = next3.changed || next3.reenter;
      if (changed) {
        this.performExitEffects(current, event);
      }
      this.performTransitionEffects(next3.transition, event);
      this.setState(next3.target);
      if (changed) {
        this.performEntryEffects(next3.target, event);
      }
    });
    __publicField(this, "determineTransition", (transition, event) => {
      const fn = determineTransitionFn(transition, this.guardMap);
      return fn == null ? void 0 : fn(this.contextSnapshot, event, this.guardMeta);
    });
    __publicField(this, "sendParent", (evt) => {
      var _a9;
      if (!this.parent) {
        invariant("[@zag-js/core > send-parent] Cannot send event to an unknown parent");
      }
      const event = toEvent(evt);
      (_a9 = this.parent) == null ? void 0 : _a9.send(event);
    });
    __publicField(this, "log", (...args) => {
      if (isDev2() && this.options.debug) {
        console.log(...args);
      }
    });
    __publicField(this, "send", (evt) => {
      const event = toEvent(evt);
      this.transition(this.state.value, event);
    });
    __publicField(this, "transition", (state2, evt) => {
      var _a9, _b8;
      const stateNode = isString2(state2) ? this.getStateNode(state2) : state2 == null ? void 0 : state2.stateNode;
      const event = toEvent(evt);
      if (!stateNode && !this.config.on) {
        const msg = this.status === "Stopped" ? "[@zag-js/core > transition] Cannot transition a stopped machine" : `[@zag-js/core > transition] State does not have a definition for \`state\`: ${state2}, \`event\`: ${event.type}`;
        warn(msg);
        return;
      }
      const transitions = (
        // @ts-expect-error - Fix this
        ((_a9 = stateNode == null ? void 0 : stateNode.on) == null ? void 0 : _a9[event.type]) ?? ((_b8 = this.config.on) == null ? void 0 : _b8[event.type])
      );
      const next3 = this.getNextStateInfo(transitions, event);
      this.performStateChangeEffects(this.state.value, next3, event);
      return next3.stateNode;
    });
    __publicField(this, "subscribe", (listener) => {
      this.stateListeners.add(listener);
      if (this.status === "Running") {
        listener(this.stateSnapshot);
      }
      return () => {
        this.stateListeners.delete(listener);
      };
    });
    __publicField(this, "onDone", (listener) => {
      this.doneListeners.add(listener);
      return this;
    });
    __publicField(this, "onTransition", (listener) => {
      this.stateListeners.add(listener);
      if (this.status === "Running") {
        listener(this.stateSnapshot);
      }
      return this;
    });
    this.config = clone(config);
    this.options = clone(options ?? {});
    this.id = this.config.id ?? `machine-${uuid()}`;
    this.guardMap = ((_a8 = this.options) == null ? void 0 : _a8.guards) ?? {};
    this.actionMap = ((_b7 = this.options) == null ? void 0 : _b7.actions) ?? {};
    this.delayMap = ((_c6 = this.options) == null ? void 0 : _c6.delays) ?? {};
    this.activityMap = ((_d6 = this.options) == null ? void 0 : _d6.activities) ?? {};
    this.sync = ((_e7 = this.options) == null ? void 0 : _e7.sync) ?? false;
    this.state = createProxy2(this.config);
    this.initialContext = snapshot(this.state.context);
  }
  // immutable state value
  get stateSnapshot() {
    return cast(snapshot(this.state));
  }
  getState() {
    return this.stateSnapshot;
  }
  // immutable context value
  get contextSnapshot() {
    return this.stateSnapshot.context;
  }
  /**
   * A reference to the instance methods of the machine.
   * Useful when spawning child machines and managing the communication between them.
   */
  get self() {
    const self2 = this;
    return {
      id: this.id,
      send: this.send.bind(this),
      sendParent: this.sendParent.bind(this),
      sendChild: this.sendChild.bind(this),
      stop: this.stop.bind(this),
      stopChild: this.stopChild.bind(this),
      spawn: this.spawn.bind(this),
      stopActivity: this.stopActivity.bind(this),
      get state() {
        return self2.stateSnapshot;
      },
      get initialContext() {
        return self2.initialContext;
      },
      get initialState() {
        var _a8;
        return ((_a8 = self2.initialState) == null ? void 0 : _a8.target) ?? "";
      }
    };
  }
  get meta() {
    var _a8;
    return {
      state: this.stateSnapshot,
      guards: this.guardMap,
      send: this.send.bind(this),
      self: this.self,
      initialContext: this.initialContext,
      initialState: ((_a8 = this.initialState) == null ? void 0 : _a8.target) ?? "",
      getState: () => this.stateSnapshot,
      getAction: (key) => this.actionMap[key],
      getGuard: (key) => this.guardMap[key]
    };
  }
  get guardMeta() {
    return {
      state: this.stateSnapshot
    };
  }
  get [Symbol.toStringTag]() {
    return "Machine";
  }
  getHydrationState() {
    const state2 = this.getState();
    return {
      value: state2.value,
      tags: state2.tags
    };
  }
};
var createMachine = (config, options) => new Machine(config, options);
var isMachine = (value) => {
  return value instanceof Machine || (value == null ? void 0 : value.type) === "machine";
};
var clsx2 = (...args) => args.map((str) => {
  var _a8;
  return (_a8 = str == null ? void 0 : str.trim) == null ? void 0 : _a8.call(str);
}).filter(Boolean).join(" ");
var CSS_REGEX = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
var serialize2 = (style) => {
  const res = {};
  let match5;
  while (match5 = CSS_REGEX.exec(style)) {
    res[match5[1]] = match5[2];
  }
  return res;
};
var css = (a2, b2) => {
  if (isString2(a2)) {
    if (isString2(b2)) return `${a2};${b2}`;
    a2 = serialize2(a2);
  } else if (isString2(b2)) {
    b2 = serialize2(b2);
  }
  return Object.assign({}, a2 ?? {}, b2 ?? {});
};
function mergeProps2(...args) {
  let result = {};
  for (let props34 of args) {
    for (let key in result) {
      if (key.startsWith("on") && typeof result[key] === "function" && typeof props34[key] === "function") {
        result[key] = callAll2(props34[key], result[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx2(result[key], props34[key]);
        continue;
      }
      if (key === "style") {
        result[key] = css(result[key], props34[key]);
        continue;
      }
      result[key] = props34[key] !== void 0 ? props34[key] : result[key];
    }
    for (let key in props34) {
      if (result[key] === void 0) {
        result[key] = props34[key];
      }
    }
  }
  return result;
}

// node_modules/@ark-ui/react/dist/components/factory.js
var import_react13 = __toESM(require_react());
function getRef(element) {
  var _a8, _b7;
  let getter = (_a8 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a8.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b7 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b7.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var withAsChild = (Component) => {
  const Comp = (0, import_react13.memo)(
    (0, import_react13.forwardRef)((props34, ref2) => {
      const { asChild, children, ...restProps } = props34;
      if (!asChild) {
        return (0, import_react13.createElement)(Component, { ...restProps, ref: ref2 }, children);
      }
      const onlyChild = import_react13.Children.only(children);
      if (!(0, import_react13.isValidElement)(onlyChild)) {
        return null;
      }
      const childRef = getRef(onlyChild);
      return (0, import_react13.cloneElement)(onlyChild, {
        ...mergeProps2(restProps, onlyChild.props),
        ref: ref2 ? composeRefs(ref2, childRef) : childRef
      });
    })
  );
  Comp.displayName = Component.displayName || Component.name;
  return Comp;
};
var jsxFactory = () => {
  const cache2 = /* @__PURE__ */ new Map();
  return new Proxy(withAsChild, {
    apply(_target, _thisArg, argArray) {
      return withAsChild(argArray[0]);
    },
    get(_, element) {
      const asElement = element;
      if (!cache2.has(asElement)) {
        cache2.set(asElement, withAsChild(asElement));
      }
      return cache2.get(asElement);
    }
  });
};
var ark = jsxFactory();

// node_modules/@ark-ui/react/dist/utils/create-split-props.js
var createSplitProps2 = () => (props34, keys) => keys.reduce(
  (previousValue, currentValue) => {
    const [target, source] = previousValue;
    const key = currentValue;
    if (source[key] !== void 0) {
      target[key] = source[key];
    }
    delete source[key];
    return [target, source];
  },
  [{}, { ...props34 }]
);

// node_modules/@ark-ui/react/dist/components/presence/split-presence-props.js
var splitPresenceProps = (props34) => createSplitProps2()(props34, [
  "immediate",
  "lazyMount",
  "onExitComplete",
  "present",
  "unmountOnExit"
]);

// node_modules/@zag-js/types/dist/index.mjs
function createNormalizer(fn) {
  return new Proxy({}, {
    get() {
      return fn;
    }
  });
}
var createProps = () => (props34) => Array.from(new Set(props34));

// node_modules/@zag-js/presence/dist/index.mjs
function connect(state2, send, _normalize) {
  const present = state2.matches("mounted", "unmountSuspended");
  return {
    skip: !state2.context.initial && present,
    present,
    setNode(node2) {
      if (!node2) return;
      send({ type: "NODE.SET", node: node2 });
    },
    unmount() {
      send({ type: "UNMOUNT" });
    }
  };
}
function machine(ctx) {
  return createMachine(
    {
      initial: ctx.present ? "mounted" : "unmounted",
      context: {
        node: null,
        styles: null,
        unmountAnimationName: null,
        prevAnimationName: null,
        present: false,
        initial: false,
        ...ctx
      },
      exit: ["clearInitial", "cleanupNode"],
      watch: {
        present: ["setInitial", "syncPresence"]
      },
      on: {
        "NODE.SET": {
          actions: ["setNode", "setStyles"]
        }
      },
      states: {
        mounted: {
          on: {
            UNMOUNT: {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            },
            "UNMOUNT.SUSPEND": "unmountSuspended"
          }
        },
        unmountSuspended: {
          activities: ["trackAnimationEvents"],
          after: {
            // Fallback to timeout to ensure we exit this state even if the `animationend` event
            // did not get trigger
            ANIMATION_DURATION: {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            }
          },
          on: {
            MOUNT: {
              target: "mounted",
              actions: ["setPrevAnimationName"]
            },
            UNMOUNT: {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            }
          }
        },
        unmounted: {
          entry: ["clearPrevAnimationName"],
          on: {
            MOUNT: {
              target: "mounted",
              actions: ["setPrevAnimationName"]
            }
          }
        }
      }
    },
    {
      delays: {
        ANIMATION_DURATION(ctx2) {
          var _a8, _b7;
          return parseMs((_a8 = ctx2.styles) == null ? void 0 : _a8.animationDuration) + parseMs((_b7 = ctx2.styles) == null ? void 0 : _b7.animationDelay) + ANIMATION_TIMEOUT_MARGIN;
        }
      },
      actions: {
        setInitial(ctx2) {
          ctx2.initial = true;
        },
        clearInitial(ctx2) {
          ctx2.initial = false;
        },
        cleanupNode(ctx2) {
          ctx2.node = null;
          ctx2.styles = null;
        },
        invokeOnExitComplete(ctx2) {
          var _a8;
          (_a8 = ctx2.onExitComplete) == null ? void 0 : _a8.call(ctx2);
        },
        setNode(ctx2, evt) {
          ctx2.node = ref(evt.node);
        },
        setStyles(ctx2, evt) {
          const win = evt.node.ownerDocument.defaultView || window;
          ctx2.styles = ref(win.getComputedStyle(evt.node));
        },
        syncPresence(ctx2, _evt, { send }) {
          var _a8;
          if (ctx2.present) {
            send({ type: "MOUNT", src: "presence.changed" });
            return;
          }
          if (!ctx2.present && ((_a8 = ctx2.node) == null ? void 0 : _a8.ownerDocument.visibilityState) === "hidden") {
            send({ type: "UNMOUNT", src: "visibilitychange" });
            return;
          }
          const animationName = getAnimationName(ctx2.styles);
          const exec2 = ctx2.immediate ? queueMicrotask : requestAnimationFrame;
          exec2(() => {
            var _a9, _b7;
            ctx2.unmountAnimationName = animationName;
            if (animationName === "none" || animationName === ctx2.prevAnimationName || ((_a9 = ctx2.styles) == null ? void 0 : _a9.display) === "none" || ((_b7 = ctx2.styles) == null ? void 0 : _b7.animationDuration) === "0s") {
              send({ type: "UNMOUNT", src: "presence.changed" });
            } else {
              send({ type: "UNMOUNT.SUSPEND" });
            }
          });
        },
        setPrevAnimationName(ctx2) {
          const exec2 = ctx2.immediate ? queueMicrotask : requestAnimationFrame;
          exec2(() => {
            ctx2.prevAnimationName = getAnimationName(ctx2.styles);
          });
        },
        clearPrevAnimationName(ctx2) {
          ctx2.prevAnimationName = null;
        }
      },
      activities: {
        trackAnimationEvents(ctx2, _evt, { send }) {
          const node2 = ctx2.node;
          if (!node2) return;
          const onStart = (event) => {
            var _a8, _b7;
            const target = ((_b7 = (_a8 = event.composedPath) == null ? void 0 : _a8.call(event)) == null ? void 0 : _b7[0]) ?? event.target;
            if (target === node2) {
              ctx2.prevAnimationName = getAnimationName(ctx2.styles);
            }
          };
          const onEnd = (event) => {
            var _a8, _b7;
            const animationName = getAnimationName(ctx2.styles);
            const target = ((_b7 = (_a8 = event.composedPath) == null ? void 0 : _a8.call(event)) == null ? void 0 : _b7[0]) ?? event.target;
            if (target === node2 && animationName === ctx2.unmountAnimationName) {
              send({ type: "UNMOUNT", src: "animationend" });
            }
          };
          node2.addEventListener("animationstart", onStart);
          node2.addEventListener("animationcancel", onEnd);
          node2.addEventListener("animationend", onEnd);
          return () => {
            node2.removeEventListener("animationstart", onStart);
            node2.removeEventListener("animationcancel", onEnd);
            node2.removeEventListener("animationend", onEnd);
          };
        }
      }
    }
  );
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function parseMs(value) {
  return parseFloat(value || "0") * 1e3;
}
var ANIMATION_TIMEOUT_MARGIN = 16.667;
var props = createProps()(["onExitComplete", "present", "immediate"]);

// node_modules/@zag-js/react/dist/index.mjs
var import_react14 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var normalizeProps = createNormalizer((v) => v);
var isArrayLike2 = (value) => (value == null ? void 0 : value.constructor.name) === "Array";
var isArrayEqual2 = (a2, b2) => {
  if (a2.length !== b2.length) return false;
  for (let i = 0; i < a2.length; i++) {
    if (!isEqual2(a2[i], b2[i])) return false;
  }
  return true;
};
var isEqual2 = (a2, b2) => {
  if (Object.is(a2, b2)) return true;
  if (a2 == null && b2 != null || a2 != null && b2 == null) return false;
  if (typeof (a2 == null ? void 0 : a2.isEqual) === "function" && typeof (b2 == null ? void 0 : b2.isEqual) === "function") {
    return a2.isEqual(b2);
  }
  if (typeof a2 === "function" && typeof b2 === "function") {
    return a2.toString() === b2.toString();
  }
  if (isArrayLike2(a2) && isArrayLike2(b2)) {
    return isArrayEqual2(Array.from(a2), Array.from(b2));
  }
  if (!(typeof a2 === "object") || !(typeof b2 === "object")) return false;
  const keys = Object.keys(b2 ?? /* @__PURE__ */ Object.create(null));
  const length2 = keys.length;
  for (let i = 0; i < length2; i++) {
    const hasKey = Reflect.has(a2, keys[i]);
    if (!hasKey) return false;
  }
  for (let i = 0; i < length2; i++) {
    const key = keys[i];
    if (!isEqual2(a2[key], b2[key])) return false;
  }
  return true;
};
var isDev3 = () => true;
var fnToString2 = Function.prototype.toString;
fnToString2.call(Object);
function compact3(obj) {
  if (!isPlainObject3(obj) || obj === void 0) return obj;
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact3(value);
    }
  }
  return filtered;
}
var isPlainObject3 = (v) => {
  return v && typeof v === "object" && v.constructor === Object;
};
function useUpdateEffect(callback, deps) {
  const render = (0, import_react14.useRef)(false);
  const effect = (0, import_react14.useRef)(false);
  (0, import_react14.useEffect)(() => {
    const mounted = render.current;
    const run = mounted && effect.current;
    if (run) {
      return callback();
    }
    effect.current = true;
  }, deps);
  (0, import_react14.useEffect)(() => {
    render.current = true;
    return () => {
      render.current = false;
    };
  }, []);
}
var targetCache = globalRef("__zag__targetCache", () => /* @__PURE__ */ new WeakMap());
function useSnapshot(service, options) {
  const { actions, context, sync: notifyInSync } = options ?? {};
  const lastSnapshot = (0, import_react14.useRef)(void 0);
  const lastAffected = (0, import_react14.useRef)(void 0);
  const currSnapshot = (0, import_react14.useSyncExternalStore)(
    (0, import_react14.useCallback)((callback) => subscribe(service.state, callback, notifyInSync), [notifyInSync]),
    () => {
      const nextSnapshot = snapshot(service.state);
      try {
        if (lastSnapshot.current && lastAffected.current && !isChanged(lastSnapshot.current, nextSnapshot, lastAffected.current, /* @__PURE__ */ new WeakMap())) {
          return lastSnapshot.current;
        }
      } catch {
      }
      return nextSnapshot;
    },
    () => snapshot(service.state)
  );
  service.setOptions({ actions });
  const ctx = (0, import_react14.useMemo)(() => compact3(context ?? {}), [context]);
  useUpdateEffect(() => {
    const entries = Object.entries(ctx);
    const previousCtx = service.contextSnapshot ?? {};
    const equality = entries.map(([key, value]) => ({
      key,
      curr: value,
      prev: previousCtx[key],
      equal: isEqual2(previousCtx[key], value)
    }));
    const allEqual = equality.every(({ equal }) => equal);
    if (!allEqual) {
      service.setContext(ctx);
    }
  }, [ctx]);
  const currAffected = /* @__PURE__ */ new WeakMap();
  (0, import_react14.useEffect)(() => {
    lastSnapshot.current = currSnapshot;
    lastAffected.current = currAffected;
  });
  const proxyCache = (0, import_react14.useMemo)(() => /* @__PURE__ */ new WeakMap(), []);
  return createProxy(currSnapshot, currAffected, proxyCache, targetCache);
}
function useActor(service) {
  const state2 = useSnapshot(service);
  return [state2, service.send];
}
function useConstant(fn) {
  const ref2 = (0, import_react14.useRef)(void 0);
  if (!ref2.current) ref2.current = { v: fn() };
  return ref2.current.v;
}
var useSafeLayoutEffect = typeof document !== "undefined" ? import_react14.useLayoutEffect : import_react14.useEffect;
function useService(machine38, options) {
  const { state: hydratedState, context } = options ?? {};
  const service = useConstant(() => {
    const instance = typeof machine38 === "function" ? machine38() : machine38;
    if (context) instance.setContext(context);
    instance._created();
    return instance;
  });
  const snapshotRef = (0, import_react14.useRef)(void 0);
  useSafeLayoutEffect(() => {
    const stateInit = hydratedState ?? snapshotRef.current;
    service.start(stateInit);
    return () => {
      if (isDev3()) {
        snapshotRef.current = service.getHydrationState();
      }
      service.stop();
    };
  }, []);
  return service;
}
function useMachine(machine38, options) {
  const service = useService(machine38, options);
  const state2 = useSnapshot(service, options);
  return [state2, service.send, service];
}

// node_modules/@ark-ui/react/dist/components/presence/use-presence.js
var import_react17 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/use-event.js
var import_react15 = __toESM(require_react(), 1);
function useEvent(callback, opts = {}) {
  const { sync: sync6 = false } = opts;
  const callbackRef = useLatestRef(callback);
  return (0, import_react15.useCallback)(
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    (...args) => {
      var _a8;
      if (sync6) return queueMicrotask(() => {
        var _a9;
        return (_a9 = callbackRef.current) == null ? void 0 : _a9.call(callbackRef, ...args);
      });
      return (_a8 = callbackRef.current) == null ? void 0 : _a8.call(callbackRef, ...args);
    },
    [sync6, callbackRef]
  );
}
function useLatestRef(value) {
  const ref2 = (0, import_react15.useRef)(value);
  ref2.current = value;
  return ref2;
}

// node_modules/@ark-ui/react/dist/components/presence/use-presence.js
var usePresence = (props34) => {
  const { lazyMount, unmountOnExit, present, ...rest } = props34;
  const wasEverPresent = (0, import_react17.useRef)(false);
  const context = {
    ...rest,
    present,
    onExitComplete: useEvent(props34.onExitComplete)
  };
  const [state2, send] = useMachine(machine(context), { context });
  const api = connect(state2, send, normalizeProps);
  if (api.present) {
    wasEverPresent.current = true;
  }
  const unmounted = !api.present && !wasEverPresent.current && lazyMount || unmountOnExit && !api.present && wasEverPresent.current;
  const getPresenceProps = () => ({
    "data-state": present ? "open" : "closed",
    hidden: !api.present
  });
  return {
    ref: api.setNode,
    getPresenceProps,
    present: api.present,
    unmounted
  };
};

// node_modules/@ark-ui/react/dist/components/presence/presence.js
var Presence = (0, import_react18.forwardRef)((props34, ref2) => {
  const [presenceProps, localProps] = splitPresenceProps(props34);
  const presence = usePresence(presenceProps);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime9.jsx)(
    ark.div,
    {
      ...localProps,
      ...presence.getPresenceProps(),
      "data-scope": "presence",
      "data-part": "root",
      ref: composeRefs(presence.ref, ref2)
    }
  );
});
Presence.displayName = "Presence";

// node_modules/@ark-ui/react/dist/components/presence/use-presence-context.js
var [PresenceProvider, usePresenceContext] = createContext3({
  name: "PresenceContext",
  hookName: "usePresenceContext",
  providerName: "<PresenceProvider />"
});

// node_modules/@chakra-ui/react/dist/esm/components/presence/index.js
var Presence2 = chakra(Presence);

// node_modules/@chakra-ui/react/dist/esm/components/theme.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react19 = __toESM(require_react(), 1);
var Theme = (0, import_react19.forwardRef)(
  function Theme2(props34, ref2) {
    const {
      appearance,
      style,
      className,
      hasBackground = true,
      ...rest
    } = props34;
    return (0, import_jsx_runtime10.jsx)(
      chakra.div,
      {
        color: "fg",
        bg: hasBackground ? "bg" : void 0,
        colorPalette: "gray",
        ...rest,
        className: cx("chakra-theme", appearance, className),
        style: { ...style, colorScheme: appearance },
        ref: ref2
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/hooks/use-media-query.js
var import_react21 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/hooks/use-callback-ref.js
var import_react20 = __toESM(require_react(), 1);
function useCallbackRef(callback, deps = []) {
  const callbackRef = (0, import_react20.useRef)(() => {
    throw new Error("Cannot call an event handler while rendering.");
  });
  (0, import_react20.useInsertionEffect)(() => {
    callbackRef.current = callback;
  });
  return (0, import_react20.useCallback)((...args) => {
    var _a8;
    return (_a8 = callbackRef.current) == null ? void 0 : _a8.call(callbackRef, ...args);
  }, deps);
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-media-query.js
function listen(query2, callback) {
  try {
    query2.addEventListener("change", callback);
    return () => query2.removeEventListener("change", callback);
  } catch (e) {
    query2.addListener(callback);
    return () => query2.removeListener(callback);
  }
}
function useMediaQuery(query2, options) {
  const { fallback: _fallback, ssr = true, getWindow: getWindow3 } = options;
  const getWin = useCallbackRef(getWindow3);
  const queries = Array.isArray(query2) ? query2 : [query2];
  const fallback4 = _fallback == null ? void 0 : _fallback.filter((v) => v != null);
  const [value, setValue] = (0, import_react21.useState)(() => {
    return queries.map((query22, index) => {
      if (!ssr) {
        const { media, matches } = ((getWindow3 == null ? void 0 : getWindow3()) ?? window).matchMedia(query22);
        return { media, matches };
      }
      return { media: query22, matches: !!fallback4[index] };
    });
  });
  (0, import_react21.useEffect)(() => {
    const win = getWin() ?? window;
    setValue((prev3) => {
      const current = queries.map((query22) => {
        const { media, matches } = win.matchMedia(query22);
        return { media, matches };
      });
      return prev3.every(
        (v, i) => v.matches === current[i].matches && v.media === current[i].media
      ) ? prev3 : current;
    });
    const mql = queries.map((query22) => win.matchMedia(query22));
    const handler = (evt) => {
      setValue((prev3) => {
        return prev3.slice().map((item) => {
          if (item.media === evt.media) return { ...item, matches: evt.matches };
          return item;
        });
      });
    };
    const cleanups2 = mql.map((v) => listen(v, handler));
    return () => cleanups2.forEach((fn) => fn());
  }, [getWin]);
  return value.map((item) => item.matches);
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-breakpoint.js
function useBreakpoint(options = {}) {
  var _a8;
  options.fallback || (options.fallback = "base");
  const sys = useChakraContext();
  let fallbackPassed = false;
  const allBreakpoints = sys.breakpoints.values;
  const breakpoints2 = allBreakpoints.map(({ min: min4, name: breakpoint }) => {
    const item = {
      breakpoint,
      query: `(min-width: ${min4})`,
      fallback: !fallbackPassed
    };
    if (breakpoint === options.fallback) {
      fallbackPassed = true;
    }
    return item;
  }).filter(({ breakpoint }) => {
    var _a9;
    return !!((_a9 = options.breakpoints) == null ? void 0 : _a9.includes(breakpoint));
  });
  const fallback4 = breakpoints2.map(({ fallback: fallback22 }) => fallback22);
  const values = useMediaQuery(
    breakpoints2.map((bp) => bp.query),
    { fallback: fallback4, ssr: options.ssr }
  );
  const index = values.lastIndexOf(true);
  return ((_a8 = breakpoints2[index]) == null ? void 0 : _a8.breakpoint) ?? options.fallback;
}
function useBreakpointValue(value, opts) {
  const sys = useChakraContext();
  const normalized = sys.normalizeValue(value);
  const breakpoint = useBreakpoint({
    breakpoints: Object.keys(normalized),
    ...opts
  });
  return normalized[breakpoint];
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-const.js
var import_react22 = __toESM(require_react(), 1);
function useConst(init) {
  const ref2 = (0, import_react22.useRef)(null);
  if (ref2.current === null) {
    ref2.current = typeof init === "function" ? init() : init;
  }
  return ref2.current;
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-controllable-state.js
var import_react23 = __toESM(require_react(), 1);
function useControllableProp(prop, state2) {
  const controlled = typeof prop !== "undefined";
  const value = controlled ? prop : state2;
  return (0, import_react23.useMemo)(() => [controlled, value], [controlled, value]);
}
function useControllableState(props34) {
  const {
    value: valueProp,
    defaultValue,
    onChange,
    shouldUpdate = (prev3, next3) => prev3 !== next3
  } = props34;
  const onChangeProp = useCallbackRef(onChange);
  const shouldUpdateProp = useCallbackRef(shouldUpdate);
  const [uncontrolledState, setUncontrolledState] = (0, import_react23.useState)(defaultValue);
  const controlled = valueProp !== void 0;
  const value = controlled ? valueProp : uncontrolledState;
  const setValue = useCallbackRef(
    (next3) => {
      const setter = next3;
      const nextValue = typeof next3 === "function" ? setter(value) : next3;
      if (!shouldUpdateProp(value, nextValue)) {
        return;
      }
      if (!controlled) {
        setUncontrolledState(nextValue);
      }
      onChangeProp(nextValue);
    },
    [controlled, onChangeProp, value, shouldUpdateProp]
  );
  return [value, setValue];
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-disclosure.js
var import_react24 = __toESM(require_react(), 1);
function useDisclosure(props34 = {}) {
  const handleOpen = useCallbackRef(props34.onOpen);
  const handleClose = useCallbackRef(props34.onClose);
  const [openState, setOpen] = (0, import_react24.useState)(props34.defaultOpen || false);
  const open = props34.open !== void 0 ? props34.open : openState;
  const controlled = props34.open !== void 0;
  const onClose = (0, import_react24.useCallback)(() => {
    if (!controlled) setOpen(false);
    handleClose == null ? void 0 : handleClose();
  }, [controlled, handleClose]);
  const onOpen = (0, import_react24.useCallback)(() => {
    if (!controlled) setOpen(true);
    handleOpen == null ? void 0 : handleOpen();
  }, [controlled, handleOpen]);
  const onToggle = (0, import_react24.useCallback)(() => {
    if (open) {
      onClose();
    } else {
      onOpen();
    }
  }, [open, onOpen, onClose]);
  return {
    open,
    onOpen,
    onClose,
    onToggle,
    setOpen
  };
}

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion-context.js
var [AccordionProvider, useAccordionContext] = createContext3({
  name: "AccordionContext",
  hookName: "useAccordionContext",
  providerName: "<AccordionProvider />"
});

// node_modules/@ark-ui/react/dist/components/accordion/accordion-context.js
var AccordionContext = (props34) => props34.children(useAccordionContext());

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/anatomy/dist/index.mjs
var createAnatomy = (name, parts42 = []) => ({
  parts: (...values) => {
    if (isEmpty(parts42)) {
      return createAnatomy(name, values);
    }
    throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
  },
  extendWith: (...values) => createAnatomy(name, [...parts42, ...values]),
  rename: (newName) => createAnatomy(newName, parts42),
  keys: () => parts42,
  build: () => [...new Set(parts42)].reduce(
    (prev3, part) => Object.assign(prev3, {
      [part]: {
        selector: [
          `&[data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`,
          `& [data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`
        ].join(", "),
        attrs: { "data-scope": toKebabCase(name), "data-part": toKebabCase(part) }
      }
    }),
    {}
  )
});
var toKebabCase = (value) => value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var isEmpty = (v) => v.length === 0;

// node_modules/@zag-js/accordion/dist/index.mjs
var anatomy = createAnatomy("accordion").parts("root", "item", "itemTrigger", "itemContent", "itemIndicator");
var parts = anatomy.build();
var dom = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `accordion:${ctx.id}`;
  },
  getItemId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, value)) ?? `accordion:${ctx.id}:item:${value}`;
  },
  getItemContentId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemContent) == null ? void 0 : _b7.call(_a8, value)) ?? `accordion:${ctx.id}:content:${value}`;
  },
  getItemTriggerId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemTrigger) == null ? void 0 : _b7.call(_a8, value)) ?? `accordion:${ctx.id}:trigger:${value}`;
  },
  getRootEl: (ctx) => dom.getById(ctx, dom.getRootId(ctx)),
  getTriggerEls: (ctx) => {
    const ownerId = CSS.escape(dom.getRootId(ctx));
    const selector = `[aria-controls][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom.getRootEl(ctx), selector);
  },
  getFirstTriggerEl: (ctx) => first(dom.getTriggerEls(ctx)),
  getLastTriggerEl: (ctx) => last(dom.getTriggerEls(ctx)),
  getNextTriggerEl: (ctx, id) => nextById(dom.getTriggerEls(ctx), dom.getItemTriggerId(ctx, id)),
  getPrevTriggerEl: (ctx, id) => prevById(dom.getTriggerEls(ctx), dom.getItemTriggerId(ctx, id))
});
function connect2(state2, send, normalize3) {
  const focusedValue = state2.context.focusedValue;
  const value = state2.context.value;
  const multiple = state2.context.multiple;
  function setValue(value2) {
    let nextValue = value2;
    if (!multiple && nextValue.length > 1) {
      nextValue = [nextValue[0]];
    }
    send({ type: "VALUE.SET", value: nextValue });
  }
  function getItemState(props210) {
    return {
      expanded: value.includes(props210.value),
      focused: focusedValue === props210.value,
      disabled: Boolean(props210.disabled ?? state2.context.disabled)
    };
  }
  return {
    focusedValue,
    value,
    setValue,
    getItemState,
    getRootProps() {
      return normalize3.element({
        ...parts.root.attrs,
        dir: state2.context.dir,
        id: dom.getRootId(state2.context),
        "data-orientation": state2.context.orientation
      });
    },
    getItemProps(props210) {
      const itemState = getItemState(props210);
      return normalize3.element({
        ...parts.item.attrs,
        dir: state2.context.dir,
        id: dom.getItemId(state2.context, props210.value),
        "data-state": itemState.expanded ? "open" : "closed",
        "data-focus": dataAttr(itemState.focused),
        "data-disabled": dataAttr(itemState.disabled),
        "data-orientation": state2.context.orientation
      });
    },
    getItemContentProps(props210) {
      const itemState = getItemState(props210);
      return normalize3.element({
        ...parts.itemContent.attrs,
        dir: state2.context.dir,
        role: "region",
        id: dom.getItemContentId(state2.context, props210.value),
        "aria-labelledby": dom.getItemTriggerId(state2.context, props210.value),
        hidden: !itemState.expanded,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(itemState.disabled),
        "data-focus": dataAttr(itemState.focused),
        "data-orientation": state2.context.orientation
      });
    },
    getItemIndicatorProps(props210) {
      const itemState = getItemState(props210);
      return normalize3.element({
        ...parts.itemIndicator.attrs,
        dir: state2.context.dir,
        "aria-hidden": true,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(itemState.disabled),
        "data-focus": dataAttr(itemState.focused),
        "data-orientation": state2.context.orientation
      });
    },
    getItemTriggerProps(props210) {
      const { value: value2 } = props210;
      const itemState = getItemState(props210);
      return normalize3.button({
        ...parts.itemTrigger.attrs,
        type: "button",
        dir: state2.context.dir,
        id: dom.getItemTriggerId(state2.context, value2),
        "aria-controls": dom.getItemContentId(state2.context, value2),
        "aria-expanded": itemState.expanded,
        disabled: itemState.disabled,
        "data-orientation": state2.context.orientation,
        "aria-disabled": itemState.disabled,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-ownedby": dom.getRootId(state2.context),
        onFocus() {
          if (itemState.disabled) return;
          send({ type: "TRIGGER.FOCUS", value: value2 });
        },
        onBlur() {
          if (itemState.disabled) return;
          send("TRIGGER.BLUR");
        },
        onClick(event) {
          if (itemState.disabled) return;
          if (isSafari()) {
            event.currentTarget.focus();
          }
          send({ type: "TRIGGER.CLICK", value: value2 });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (itemState.disabled) return;
          const keyMap2 = {
            ArrowDown() {
              if (state2.context.isHorizontal) return;
              send({ type: "GOTO.NEXT", value: value2 });
            },
            ArrowUp() {
              if (state2.context.isHorizontal) return;
              send({ type: "GOTO.PREV", value: value2 });
            },
            ArrowRight() {
              if (!state2.context.isHorizontal) return;
              send({ type: "GOTO.NEXT", value: value2 });
            },
            ArrowLeft() {
              if (!state2.context.isHorizontal) return;
              send({ type: "GOTO.PREV", value: value2 });
            },
            Home() {
              send({ type: "GOTO.FIRST", value: value2 });
            },
            End() {
              send({ type: "GOTO.LAST", value: value2 });
            }
          };
          const key = getEventKey(event, {
            dir: state2.context.dir,
            orientation: state2.context.orientation
          });
          const exec2 = keyMap2[key];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        }
      });
    }
  };
}
var { and: and2, not: not2 } = guards;
function machine2(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "accordion",
      initial: "idle",
      context: {
        focusedValue: null,
        value: [],
        collapsible: false,
        multiple: false,
        orientation: "vertical",
        ...ctx
      },
      watch: {
        value: "coarseValue",
        multiple: "coarseValue"
      },
      created: "coarseValue",
      computed: {
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal"
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        }
      },
      states: {
        idle: {
          on: {
            "TRIGGER.FOCUS": {
              target: "focused",
              actions: "setFocusedValue"
            }
          }
        },
        focused: {
          on: {
            "GOTO.NEXT": {
              actions: "focusNextTrigger"
            },
            "GOTO.PREV": {
              actions: "focusPrevTrigger"
            },
            "TRIGGER.CLICK": [
              {
                guard: and2("isExpanded", "canToggle"),
                actions: ["collapse"]
              },
              {
                guard: not2("isExpanded"),
                actions: ["expand"]
              }
            ],
            "GOTO.FIRST": {
              actions: "focusFirstTrigger"
            },
            "GOTO.LAST": {
              actions: "focusLastTrigger"
            },
            "TRIGGER.BLUR": {
              target: "idle",
              actions: "clearFocusedValue"
            }
          }
        }
      }
    },
    {
      guards: {
        canToggle: (ctx2) => !!ctx2.collapsible || !!ctx2.multiple,
        isExpanded: (ctx2, evt) => ctx2.value.includes(evt.value)
      },
      actions: {
        collapse(ctx2, evt) {
          const next3 = ctx2.multiple ? remove(ctx2.value, evt.value) : [];
          set3.value(ctx2, ctx2.multiple ? next3 : []);
        },
        expand(ctx2, evt) {
          const next3 = ctx2.multiple ? add(ctx2.value, evt.value) : [evt.value];
          set3.value(ctx2, next3);
        },
        focusFirstTrigger(ctx2) {
          var _a8;
          (_a8 = dom.getFirstTriggerEl(ctx2)) == null ? void 0 : _a8.focus();
        },
        focusLastTrigger(ctx2) {
          var _a8;
          (_a8 = dom.getLastTriggerEl(ctx2)) == null ? void 0 : _a8.focus();
        },
        focusNextTrigger(ctx2) {
          if (!ctx2.focusedValue) return;
          const triggerEl = dom.getNextTriggerEl(ctx2, ctx2.focusedValue);
          triggerEl == null ? void 0 : triggerEl.focus();
        },
        focusPrevTrigger(ctx2) {
          if (!ctx2.focusedValue) return;
          const triggerEl = dom.getPrevTriggerEl(ctx2, ctx2.focusedValue);
          triggerEl == null ? void 0 : triggerEl.focus();
        },
        setFocusedValue(ctx2, evt) {
          set3.focusedValue(ctx2, evt.value);
        },
        clearFocusedValue(ctx2) {
          set3.focusedValue(ctx2, null);
        },
        setValue(ctx2, evt) {
          set3.value(ctx2, evt.value);
        },
        coarseValue(ctx2) {
          if (!ctx2.multiple && ctx2.value.length > 1) {
            warn(`The value of accordion should be a single value when multiple is false.`);
            ctx2.value = [ctx2.value[0]];
          }
        }
      }
    }
  );
}
var invoke = {
  change(ctx) {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value: Array.from(ctx.value) });
  },
  focusChange(ctx) {
    var _a8;
    (_a8 = ctx.onFocusChange) == null ? void 0 : _a8.call(ctx, { value: ctx.focusedValue });
  }
};
var set3 = {
  value(ctx, value) {
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke.change(ctx);
  },
  focusedValue(ctx, value) {
    if (isEqual(ctx.focusedValue, value)) return;
    ctx.focusedValue = value;
    invoke.focusChange(ctx);
  }
};
var props2 = createProps()([
  "collapsible",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "multiple",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "value"
]);
var splitProps3 = createSplitProps(props2);
var itemProps = createProps()(["value", "disabled"]);
var splitItemProps = createSplitProps(itemProps);

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item.js
var import_react30 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion-item-context.js
var [AccordionItemProvider, useAccordionItemContext] = createContext3({
  name: "AccordionItemContext",
  hookName: "useAccordionItemContext",
  providerName: "<AccordionItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-root.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react28 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/collapsible/split-collapsible-props.js
var splitCollapsibleProps = (props34) => createSplitProps2()(props34, [
  "defaultOpen",
  "disabled",
  "id",
  "ids",
  "lazyMount",
  "onExitComplete",
  "onOpenChange",
  "open",
  "unmountOnExit"
]);

// node_modules/@zag-js/collapsible/dist/index.mjs
var anatomy2 = createAnatomy("collapsible").parts("root", "trigger", "content");
var parts2 = anatomy2.build();
var dom2 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `collapsible:${ctx.id}`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `collapsible:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `collapsible:${ctx.id}:trigger`;
  },
  getRootEl: (ctx) => dom2.getById(ctx, dom2.getRootId(ctx)),
  getContentEl: (ctx) => dom2.getById(ctx, dom2.getContentId(ctx)),
  getTriggerEl: (ctx) => dom2.getById(ctx, dom2.getTriggerId(ctx))
});
function connect3(state2, send, normalize3) {
  const visible = state2.matches("open", "closing");
  const open = state2.matches("open");
  const height = state2.context.height;
  const width = state2.context.width;
  const disabled = !!state2.context.disabled;
  const skip = !state2.context.initial && open;
  return {
    disabled,
    visible,
    open,
    measureSize() {
      send("SIZE.MEASURE");
    },
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    getRootProps() {
      return normalize3.element({
        ...parts2.root.attrs,
        "data-state": open ? "open" : "closed",
        dir: state2.context.dir,
        id: dom2.getRootId(state2.context)
      });
    },
    getContentProps() {
      return normalize3.element({
        ...parts2.content.attrs,
        "data-collapsible": "",
        "data-state": skip ? void 0 : open ? "open" : "closed",
        id: dom2.getContentId(state2.context),
        "data-disabled": dataAttr(disabled),
        hidden: !visible,
        style: {
          "--height": height != null ? `${height}px` : void 0,
          "--width": width != null ? `${width}px` : void 0
        }
      });
    },
    getTriggerProps() {
      return normalize3.element({
        ...parts2.trigger.attrs,
        id: dom2.getTriggerId(state2.context),
        dir: state2.context.dir,
        type: "button",
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "aria-controls": dom2.getContentId(state2.context),
        "aria-expanded": visible || false,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          send({ type: open ? "CLOSE" : "OPEN", src: "trigger.click" });
        }
      });
    }
  };
}
function machine3(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "collapsible",
      initial: ctx.open ? "open" : "closed",
      context: {
        ...ctx,
        height: 0,
        width: 0,
        initial: false,
        stylesRef: null,
        unmountAnimationName: null
      },
      watch: {
        open: ["setInitial", "computeSize", "toggleVisibility"]
      },
      exit: ["clearInitial", "cleanupNode"],
      states: {
        closed: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": "open",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitial", "computeSize", "invokeOnOpen"]
              }
            ]
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackExitAnimation"],
          on: {
            "CONTROLLED.CLOSE": "closed",
            "CONTROLLED.OPEN": "open",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitial", "invokeOnOpen"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnExitComplete"]
              },
              {
                target: "closed",
                actions: ["setInitial", "computeSize", "invokeOnExitComplete"]
              }
            ],
            "ANIMATION.END": {
              target: "closed",
              actions: ["invokeOnExitComplete", "clearInitial"]
            }
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackEnterAnimation"],
          on: {
            "CONTROLLED.CLOSE": "closing",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closing",
                actions: ["setInitial", "computeSize", "invokeOnClose"]
              }
            ],
            "SIZE.MEASURE": {
              actions: ["measureSize"]
            },
            "ANIMATION.END": {
              actions: ["clearInitial"]
            }
          }
        }
      }
    },
    {
      guards: {
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackEnterAnimation(ctx2, _evt, { send }) {
          let cleanup;
          const rafCleanup = raf(() => {
            const contentEl = dom2.getContentEl(ctx2);
            if (!contentEl) return;
            const animationName = getComputedStyle2(contentEl).animationName;
            const hasNoAnimation = !animationName || animationName === "none";
            if (hasNoAnimation) {
              send({ type: "ANIMATION.END" });
              return;
            }
            const onEnd = (event) => {
              const target = getEventTarget(event);
              if (target === contentEl) {
                send({ type: "ANIMATION.END" });
              }
            };
            contentEl.addEventListener("animationend", onEnd);
            cleanup = () => {
              contentEl.removeEventListener("animationend", onEnd);
            };
          });
          return () => {
            rafCleanup();
            cleanup == null ? void 0 : cleanup();
          };
        },
        trackExitAnimation(ctx2, _evt, { send }) {
          let cleanup;
          const rafCleanup = raf(() => {
            const contentEl = dom2.getContentEl(ctx2);
            if (!contentEl) return;
            const animationName = getComputedStyle2(contentEl).animationName;
            const hasNoAnimation = !animationName || animationName === "none";
            if (hasNoAnimation) {
              send({ type: "ANIMATION.END" });
              return;
            }
            const onEnd = (event) => {
              const win = contentEl.ownerDocument.defaultView || window;
              const animationName2 = win.getComputedStyle(contentEl).animationName;
              const target = getEventTarget(event);
              if (target === contentEl && animationName2 === ctx2.unmountAnimationName) {
                send({ type: "ANIMATION.END" });
              }
            };
            contentEl.addEventListener("animationend", onEnd);
            cleanup = () => {
              contentEl.removeEventListener("animationend", onEnd);
            };
          });
          return () => {
            rafCleanup();
            cleanup == null ? void 0 : cleanup();
          };
        }
      },
      actions: {
        setInitial(ctx2) {
          ctx2.initial = true;
        },
        clearInitial(ctx2) {
          raf(() => {
            ctx2.initial = false;
          });
        },
        cleanupNode(ctx2) {
          ctx2.stylesRef = null;
        },
        measureSize(ctx2) {
          const contentEl = dom2.getContentEl(ctx2);
          if (!contentEl) return;
          const { height, width } = contentEl.getBoundingClientRect();
          ctx2.height = height;
          ctx2.width = width;
        },
        computeSize(ctx2, evt) {
          var _a8;
          (_a8 = ctx2._rafCleanup) == null ? void 0 : _a8.call(ctx2);
          ctx2._rafCleanup = raf(() => {
            const contentEl = dom2.getContentEl(ctx2);
            if (!contentEl) return;
            ctx2.stylesRef || (ctx2.stylesRef = ref({
              animationName: contentEl.style.animationName,
              animationDuration: contentEl.style.animationDuration
            }));
            if (evt.type === "CLOSE" || !ctx2.open) {
              const win = contentEl.ownerDocument.defaultView || window;
              ctx2.unmountAnimationName = win.getComputedStyle(contentEl).animationName;
            }
            const hidden = contentEl.hidden;
            contentEl.style.animationName = "none";
            contentEl.style.animationDuration = "0s";
            contentEl.hidden = false;
            const rect = contentEl.getBoundingClientRect();
            ctx2.height = rect.height;
            ctx2.width = rect.width;
            if (ctx2.initial) {
              contentEl.style.animationName = ctx2.stylesRef.animationName;
              contentEl.style.animationDuration = ctx2.stylesRef.animationDuration;
            }
            contentEl.hidden = hidden;
          });
        },
        invokeOnOpen: (ctx2) => {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose: (ctx2) => {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        invokeOnExitComplete(ctx2) {
          var _a8;
          (_a8 = ctx2.onExitComplete) == null ? void 0 : _a8.call(ctx2);
        },
        toggleVisibility: (ctx2, _evt, { send }) => {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE" });
        }
      }
    }
  );
}
var props3 = createProps()([
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "onExitComplete",
  "onOpenChange",
  "open.controlled",
  "open"
]);
var splitProps4 = createSplitProps(props3);

// node_modules/@ark-ui/react/dist/components/collapsible/use-collapsible.js
var import_react26 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/providers/environment/use-environment-context.js
var [EnvironmentContextProvider, useEnvironmentContext] = createContext3({
  name: "EnvironmentContext",
  hookName: "useEnvironmentContext",
  providerName: "<EnvironmentProvider />",
  strict: false,
  defaultValue: {
    getRootNode: () => document,
    getDocument: () => document,
    getWindow: () => window
  }
});

// node_modules/@ark-ui/react/dist/components/collapsible/use-collapsible.js
var useCollapsible = (props34 = {}) => {
  const { lazyMount, unmountOnExit, ...collapsibleProps } = props34;
  const wasVisible = (0, import_react26.useRef)(false);
  const { dir } = useLocaleContext();
  const { getRootNode } = useEnvironmentContext();
  const initialContext = {
    id: (0, import_react26.useId)(),
    dir,
    getRootNode,
    open: props34.defaultOpen,
    "open.controlled": props34.open !== void 0,
    ...collapsibleProps
  };
  const context = {
    ...initialContext,
    open: props34.open,
    onOpenChange: useEvent(props34.onOpenChange, { sync: true })
  };
  const [state2, send] = useMachine(machine3(initialContext), { context });
  const api = connect3(state2, send, normalizeProps);
  if (api.visible) {
    wasVisible.current = true;
  }
  const isUnmounted = !api.visible && !wasVisible.current && lazyMount || unmountOnExit && !api.visible && wasVisible.current;
  return { ...api, isUnmounted };
};

// node_modules/@ark-ui/react/dist/components/collapsible/use-collapsible-context.js
var [CollapsibleProvider, useCollapsibleContext] = createContext3({
  name: "CollapsibleContext",
  hookName: "useCollapsibleContext",
  providerName: "<CollapsibleProvider />"
});

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-root.js
var CollapsibleRoot = (0, import_react28.forwardRef)((props34, ref2) => {
  const [useCollapsibleProps, localProps] = splitCollapsibleProps(props34);
  const collapsible = useCollapsible(useCollapsibleProps);
  const mergedProps = mergeProps2(collapsible.getRootProps(), localProps);
  return (0, import_jsx_runtime11.jsx)(CollapsibleProvider, { value: collapsible, children: (0, import_jsx_runtime11.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
CollapsibleRoot.displayName = "CollapsibleRoot";

// node_modules/@zag-js/color-utils/dist/index.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, key + "", value);
var generateRGB_R = (orientation, dir, zValue) => {
  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
  const result = {
    areaStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,0),rgb(${zValue},255,0))`
    },
    areaGradientStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,255),rgb(${zValue},255,255))`,
      WebkitMaskImage: maskImage,
      maskImage
    }
  };
  return result;
};
var generateRGB_G = (orientation, dir, zValue) => {
  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
  const result = {
    areaStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},0),rgb(255,${zValue},0))`
    },
    areaGradientStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},255),rgb(255,${zValue},255))`,
      WebkitMaskImage: maskImage,
      maskImage
    }
  };
  return result;
};
var generateRGB_B = (orientation, dir, zValue) => {
  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
  const result = {
    areaStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,0,${zValue}),rgb(255,0,${zValue}))`
    },
    areaGradientStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,255,${zValue}),rgb(255,255,${zValue}))`,
      WebkitMaskImage: maskImage,
      maskImage
    }
  };
  return result;
};
var generateHSL_H = (orientation, dir, zValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(dir)]}, hsla(0,0%,0%,1) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,1) 100%)`,
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,50%),hsla(0,0%,50%,0))`,
        `hsl(${zValue}, 100%, 50%)`
      ].join(",")
    }
  };
  return result;
};
var generateHSL_S = (orientation, dir, alphaValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(!dir)]}, hsla(0,0%,0%,${alphaValue}) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,${alphaValue}) 100%)`,
        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
        "hsl(0, 0%, 50%)"
      ].join(",")
    }
  };
  return result;
};
var generateHSL_L = (orientation, dir, zValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      backgroundImage: [
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,${zValue}%),hsla(0,0%,${zValue}%,0))`,
        `linear-gradient(to ${orientation[Number(dir)]},hsl(0,100%,${zValue}%),hsl(60,100%,${zValue}%),hsl(120,100%,${zValue}%),hsl(180,100%,${zValue}%),hsl(240,100%,${zValue}%),hsl(300,100%,${zValue}%),hsl(360,100%,${zValue}%))`
      ].join(",")
    }
  };
  return result;
};
var generateHSB_H = (orientation, dir, zValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(dir)]},hsl(0,0%,0%),hsla(0,0%,0%,0))`,
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,100%),hsla(0,0%,100%,0))`,
        `hsl(${zValue}, 100%, 50%)`
      ].join(",")
    }
  };
  return result;
};
var generateHSB_S = (orientation, dir, alphaValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,0%,${alphaValue}),hsla(0,0%,0%,0))`,
        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,0%),hsl(0,0%,100%))`
      ].join(",")
    }
  };
  return result;
};
var generateHSB_B = (orientation, dir, alphaValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,100%,${alphaValue}),hsla(0,0%,100%,0))`,
        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
        "#000"
      ].join(",")
    }
  };
  return result;
};
function getColorAreaGradient(color, options) {
  const { xChannel, yChannel, dir: dirProp = "ltr" } = options;
  const { zChannel } = color.getColorAxes({ xChannel, yChannel });
  const zValue = color.getChannelValue(zChannel);
  const { minValue: zMin, maxValue: zMax } = color.getChannelRange(zChannel);
  const orientation = ["top", dirProp === "rtl" ? "left" : "right"];
  let dir = false;
  let background = { areaStyles: {}, areaGradientStyles: {} };
  let alphaValue = (zValue - zMin) / (zMax - zMin);
  let isHSL = color.getFormat() === "hsla";
  switch (zChannel) {
    case "red": {
      dir = xChannel === "green";
      background = generateRGB_R(orientation, dir, zValue);
      break;
    }
    case "green": {
      dir = xChannel === "red";
      background = generateRGB_G(orientation, dir, zValue);
      break;
    }
    case "blue": {
      dir = xChannel === "red";
      background = generateRGB_B(orientation, dir, zValue);
      break;
    }
    case "hue": {
      dir = xChannel !== "saturation";
      if (isHSL) {
        background = generateHSL_H(orientation, dir, zValue);
      } else {
        background = generateHSB_H(orientation, dir, zValue);
      }
      break;
    }
    case "saturation": {
      dir = xChannel === "hue";
      if (isHSL) {
        background = generateHSL_S(orientation, dir, alphaValue);
      } else {
        background = generateHSB_S(orientation, dir, alphaValue);
      }
      break;
    }
    case "brightness": {
      dir = xChannel === "hue";
      background = generateHSB_B(orientation, dir, alphaValue);
      break;
    }
    case "lightness": {
      dir = xChannel === "hue";
      background = generateHSL_L(orientation, dir, zValue);
      break;
    }
  }
  return background;
}
var isEqualObject = (a2, b2) => {
  if (Object.keys(a2).length !== Object.keys(b2).length) return false;
  for (let key in a2) if (a2[key] !== b2[key]) return false;
  return true;
};
var Color = class {
  toHexInt() {
    return this.toFormat("rgba").toHexInt();
  }
  getChannelValue(channel) {
    if (channel in this) return this[channel];
    throw new Error("Unsupported color channel: " + channel);
  }
  getChannelValuePercent(channel, valueToCheck) {
    const value = valueToCheck ?? this.getChannelValue(channel);
    const { minValue, maxValue: maxValue2 } = this.getChannelRange(channel);
    return getValuePercent(value, minValue, maxValue2);
  }
  getChannelPercentValue(channel, percentToCheck) {
    const { minValue, maxValue: maxValue2, step } = this.getChannelRange(channel);
    const percentValue = getPercentValue(percentToCheck, minValue, maxValue2, step);
    return snapValueToStep(percentValue, minValue, maxValue2, step);
  }
  withChannelValue(channel, value) {
    const { minValue, maxValue: maxValue2 } = this.getChannelRange(channel);
    if (channel in this) {
      let clone3 = this.clone();
      clone3[channel] = clampValue(value, minValue, maxValue2);
      return clone3;
    }
    throw new Error("Unsupported color channel: " + channel);
  }
  getColorAxes(xyChannels) {
    let { xChannel, yChannel } = xyChannels;
    let xCh = xChannel || this.getChannels().find((c) => c !== yChannel);
    let yCh = yChannel || this.getChannels().find((c) => c !== xCh);
    let zCh = this.getChannels().find((c) => c !== xCh && c !== yCh);
    return { xChannel: xCh, yChannel: yCh, zChannel: zCh };
  }
  incrementChannel(channel, stepSize) {
    const { minValue, maxValue: maxValue2, step } = this.getChannelRange(channel);
    const value = snapValueToStep(
      clampValue(this.getChannelValue(channel) + stepSize, minValue, maxValue2),
      minValue,
      maxValue2,
      step
    );
    return this.withChannelValue(channel, value);
  }
  decrementChannel(channel, stepSize) {
    return this.incrementChannel(channel, -stepSize);
  }
  isEqual(color) {
    const isSame = isEqualObject(this.toJSON(), color.toJSON());
    return isSame && this.getChannelValue("alpha") === color.getChannelValue("alpha");
  }
};
var _RGBColor = class _RGBColor2 extends Color {
  constructor(red, green, blue, alpha) {
    super();
    this.red = red;
    this.green = green;
    this.blue = blue;
    this.alpha = alpha;
  }
  static parse(value) {
    let colors2 = [];
    if (/^#[\da-f]+$/i.test(value) && [4, 5, 7, 9].includes(value.length)) {
      const values = (value.length < 6 ? value.replace(/[^#]/gi, "$&$&") : value).slice(1).split("");
      while (values.length > 0) {
        colors2.push(parseInt(values.splice(0, 2).join(""), 16));
      }
      colors2[3] = colors2[3] !== void 0 ? colors2[3] / 255 : void 0;
    }
    const match5 = value.match(/^rgba?\((.*)\)$/);
    if (match5 == null ? void 0 : match5[1]) {
      colors2 = match5[1].split(",").map((value2) => Number(value2.trim())).map((num, i) => clampValue(num, 0, i < 3 ? 255 : 1));
    }
    return colors2.length < 3 ? void 0 : new _RGBColor2(colors2[0], colors2[1], colors2[2], colors2[3] ?? 1);
  }
  toString(format) {
    switch (format) {
      case "hex":
        return "#" + (this.red.toString(16).padStart(2, "0") + this.green.toString(16).padStart(2, "0") + this.blue.toString(16).padStart(2, "0")).toUpperCase();
      case "hexa":
        return "#" + (this.red.toString(16).padStart(2, "0") + this.green.toString(16).padStart(2, "0") + this.blue.toString(16).padStart(2, "0") + Math.round(this.alpha * 255).toString(16).padStart(2, "0")).toUpperCase();
      case "rgb":
        return `rgb(${this.red}, ${this.green}, ${this.blue})`;
      case "css":
      case "rgba":
        return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;
      case "hsl":
        return this.toHSL().toString("hsl");
      case "hsb":
        return this.toHSB().toString("hsb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "rgba":
        return this;
      case "hsba":
        return this.toHSB();
      case "hsla":
        return this.toHSL();
      default:
        throw new Error("Unsupported color conversion: rgb -> " + format);
    }
  }
  toHexInt() {
    return this.red << 16 | this.green << 8 | this.blue;
  }
  /**
   * Converts an RGB color value to HSB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.
   * @returns An HSBColor object.
   */
  toHSB() {
    const red = this.red / 255;
    const green = this.green / 255;
    const blue = this.blue / 255;
    const min4 = Math.min(red, green, blue);
    const brightness = Math.max(red, green, blue);
    const chroma = brightness - min4;
    const saturation = brightness === 0 ? 0 : chroma / brightness;
    let hue = 0;
    if (chroma !== 0) {
      switch (brightness) {
        case red:
          hue = (green - blue) / chroma + (green < blue ? 6 : 0);
          break;
        case green:
          hue = (blue - red) / chroma + 2;
          break;
        case blue:
          hue = (red - green) / chroma + 4;
          break;
      }
      hue /= 6;
    }
    return new HSBColor(
      toFixedNumber(hue * 360, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(brightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  /**
   * Converts an RGB color value to HSL.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.
   * @returns An HSLColor object.
   */
  toHSL() {
    const red = this.red / 255;
    const green = this.green / 255;
    const blue = this.blue / 255;
    const min4 = Math.min(red, green, blue);
    const max4 = Math.max(red, green, blue);
    const lightness = (max4 + min4) / 2;
    const chroma = max4 - min4;
    let hue = -1;
    let saturation = -1;
    if (chroma === 0) {
      hue = saturation = 0;
    } else {
      saturation = chroma / (lightness < 0.5 ? max4 + min4 : 2 - max4 - min4);
      switch (max4) {
        case red:
          hue = (green - blue) / chroma + (green < blue ? 6 : 0);
          break;
        case green:
          hue = (blue - red) / chroma + 2;
          break;
        case blue:
          hue = (red - green) / chroma + 4;
          break;
      }
      hue /= 6;
    }
    return new HSLColor(
      toFixedNumber(hue * 360, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(lightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  clone() {
    return new _RGBColor2(this.red, this.green, this.blue, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "red":
      case "green":
      case "blue":
        return { style: "decimal" };
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "red":
      case "green":
      case "blue":
        return { minValue: 0, maxValue: 255, step: 1, pageSize: 17 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { r: this.red, g: this.green, b: this.blue, a: this.alpha };
  }
  getFormat() {
    return "rgba";
  }
  getChannels() {
    return _RGBColor2.colorChannels;
  }
};
__publicField2(_RGBColor, "colorChannels", ["red", "green", "blue"]);
var RGBColor = _RGBColor;
var HSL_REGEX = /hsl\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsla\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
var _HSLColor = class _HSLColor2 extends Color {
  constructor(hue, saturation, lightness, alpha) {
    super();
    this.hue = hue;
    this.saturation = saturation;
    this.lightness = lightness;
    this.alpha = alpha;
  }
  static parse(value) {
    let m;
    if (m = value.match(HSL_REGEX)) {
      const [h, s, l2, a2] = (m[1] ?? m[2]).split(",").map((n) => Number(n.trim().replace("%", "")));
      return new _HSLColor2(mod(h, 360), clampValue(s, 0, 100), clampValue(l2, 0, 100), clampValue(a2 ?? 1, 0, 1));
    }
  }
  toString(format) {
    switch (format) {
      case "hex":
        return this.toRGB().toString("hex");
      case "hexa":
        return this.toRGB().toString("hexa");
      case "hsl":
        return `hsl(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%)`;
      case "css":
      case "hsla":
        return `hsla(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%, ${this.alpha})`;
      case "hsb":
        return this.toHSB().toString("hsb");
      case "rgb":
        return this.toRGB().toString("rgb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "hsla":
        return this;
      case "hsba":
        return this.toHSB();
      case "rgba":
        return this.toRGB();
      default:
        throw new Error("Unsupported color conversion: hsl -> " + format);
    }
  }
  /**
   * Converts a HSL color to HSB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV.
   * @returns An HSBColor object.
   */
  toHSB() {
    let saturation = this.saturation / 100;
    let lightness = this.lightness / 100;
    let brightness = lightness + saturation * Math.min(lightness, 1 - lightness);
    saturation = brightness === 0 ? 0 : 2 * (1 - lightness / brightness);
    return new HSBColor(
      toFixedNumber(this.hue, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(brightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  /**
   * Converts a HSL color to RGB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative.
   * @returns An RGBColor object.
   */
  toRGB() {
    let hue = this.hue;
    let saturation = this.saturation / 100;
    let lightness = this.lightness / 100;
    let a2 = saturation * Math.min(lightness, 1 - lightness);
    let fn = (n, k = (n + hue / 30) % 12) => lightness - a2 * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return new RGBColor(
      Math.round(fn(0) * 255),
      Math.round(fn(8) * 255),
      Math.round(fn(4) * 255),
      toFixedNumber(this.alpha, 2)
    );
  }
  clone() {
    return new _HSLColor2(this.hue, this.saturation, this.lightness, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "hue":
        return { style: "unit", unit: "degree", unitDisplay: "narrow" };
      case "saturation":
      case "lightness":
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    if (channel === "saturation" || channel === "lightness") {
      value /= 100;
    }
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "hue":
        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };
      case "saturation":
      case "lightness":
        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { h: this.hue, s: this.saturation, l: this.lightness, a: this.alpha };
  }
  getFormat() {
    return "hsla";
  }
  getChannels() {
    return _HSLColor2.colorChannels;
  }
};
__publicField2(_HSLColor, "colorChannels", ["hue", "saturation", "lightness"]);
var HSLColor = _HSLColor;
var HSB_REGEX = /hsb\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsba\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
var _HSBColor = class _HSBColor2 extends Color {
  constructor(hue, saturation, brightness, alpha) {
    super();
    this.hue = hue;
    this.saturation = saturation;
    this.brightness = brightness;
    this.alpha = alpha;
  }
  static parse(value) {
    let m;
    if (m = value.match(HSB_REGEX)) {
      const [h, s, b2, a2] = (m[1] ?? m[2]).split(",").map((n) => Number(n.trim().replace("%", "")));
      return new _HSBColor2(mod(h, 360), clampValue(s, 0, 100), clampValue(b2, 0, 100), clampValue(a2 ?? 1, 0, 1));
    }
  }
  toString(format) {
    switch (format) {
      case "css":
        return this.toHSL().toString("css");
      case "hex":
        return this.toRGB().toString("hex");
      case "hexa":
        return this.toRGB().toString("hexa");
      case "hsb":
        return `hsb(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%)`;
      case "hsba":
        return `hsba(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%, ${this.alpha})`;
      case "hsl":
        return this.toHSL().toString("hsl");
      case "rgb":
        return this.toRGB().toString("rgb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "hsba":
        return this;
      case "hsla":
        return this.toHSL();
      case "rgba":
        return this.toRGB();
      default:
        throw new Error("Unsupported color conversion: hsb -> " + format);
    }
  }
  /**
   * Converts a HSB color to HSL.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL.
   * @returns An HSLColor object.
   */
  toHSL() {
    let saturation = this.saturation / 100;
    let brightness = this.brightness / 100;
    let lightness = brightness * (1 - saturation / 2);
    saturation = lightness === 0 || lightness === 1 ? 0 : (brightness - lightness) / Math.min(lightness, 1 - lightness);
    return new HSLColor(
      toFixedNumber(this.hue, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(lightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  /**
   * Converts a HSV color value to RGB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative.
   * @returns An RGBColor object.
   */
  toRGB() {
    let hue = this.hue;
    let saturation = this.saturation / 100;
    let brightness = this.brightness / 100;
    let fn = (n, k = (n + hue / 60) % 6) => brightness - saturation * brightness * Math.max(Math.min(k, 4 - k, 1), 0);
    return new RGBColor(
      Math.round(fn(5) * 255),
      Math.round(fn(3) * 255),
      Math.round(fn(1) * 255),
      toFixedNumber(this.alpha, 2)
    );
  }
  clone() {
    return new _HSBColor2(this.hue, this.saturation, this.brightness, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "hue":
        return { style: "unit", unit: "degree", unitDisplay: "narrow" };
      case "saturation":
      case "brightness":
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    if (channel === "saturation" || channel === "brightness") {
      value /= 100;
    }
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "hue":
        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };
      case "saturation":
      case "brightness":
        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { h: this.hue, s: this.saturation, b: this.brightness, a: this.alpha };
  }
  getFormat() {
    return "hsba";
  }
  getChannels() {
    return _HSBColor2.colorChannels;
  }
};
__publicField2(_HSBColor, "colorChannels", ["hue", "saturation", "brightness"]);
var HSBColor = _HSBColor;
var nativeColors = "aliceblue:f0f8ff,antiquewhite:faebd7,aqua:00ffff,aquamarine:7fffd4,azure:f0ffff,beige:f5f5dc,bisque:ffe4c4,black:000000,blanchedalmond:ffebcd,blue:0000ff,blueviolet:8a2be2,brown:a52a2a,burlywood:deb887,cadetblue:5f9ea0,chartreuse:7fff00,chocolate:d2691e,coral:ff7f50,cornflowerblue:6495ed,cornsilk:fff8dc,crimson:dc143c,cyan:00ffff,darkblue:00008b,darkcyan:008b8b,darkgoldenrod:b8860b,darkgray:a9a9a9,darkgreen:006400,darkkhaki:bdb76b,darkmagenta:8b008b,darkolivegreen:556b2f,darkorange:ff8c00,darkorchid:9932cc,darkred:8b0000,darksalmon:e9967a,darkseagreen:8fbc8f,darkslateblue:483d8b,darkslategray:2f4f4f,darkturquoise:00ced1,darkviolet:9400d3,deeppink:ff1493,deepskyblue:00bfff,dimgray:696969,dodgerblue:1e90ff,firebrick:b22222,floralwhite:fffaf0,forestgreen:228b22,fuchsia:ff00ff,gainsboro:dcdcdc,ghostwhite:f8f8ff,gold:ffd700,goldenrod:daa520,gray:808080,green:008000,greenyellow:adff2f,honeydew:f0fff0,hotpink:ff69b4,indianred:cd5c5c,indigo:4b0082,ivory:fffff0,khaki:f0e68c,lavender:e6e6fa,lavenderblush:fff0f5,lawngreen:7cfc00,lemonchiffon:fffacd,lightblue:add8e6,lightcoral:f08080,lightcyan:e0ffff,lightgoldenrodyellow:fafad2,lightgrey:d3d3d3,lightgreen:90ee90,lightpink:ffb6c1,lightsalmon:ffa07a,lightseagreen:20b2aa,lightskyblue:87cefa,lightslategray:778899,lightsteelblue:b0c4de,lightyellow:ffffe0,lime:00ff00,limegreen:32cd32,linen:faf0e6,magenta:ff00ff,maroon:800000,mediumaquamarine:66cdaa,mediumblue:0000cd,mediumorchid:ba55d3,mediumpurple:9370d8,mediumseagreen:3cb371,mediumslateblue:7b68ee,mediumspringgreen:00fa9a,mediumturquoise:48d1cc,mediumvioletred:c71585,midnightblue:191970,mintcream:f5fffa,mistyrose:ffe4e1,moccasin:ffe4b5,navajowhite:ffdead,navy:000080,oldlace:fdf5e6,olive:808000,olivedrab:6b8e23,orange:ffa500,orangered:ff4500,orchid:da70d6,palegoldenrod:eee8aa,palegreen:98fb98,paleturquoise:afeeee,palevioletred:d87093,papayawhip:ffefd5,peachpuff:ffdab9,peru:cd853f,pink:ffc0cb,plum:dda0dd,powderblue:b0e0e6,purple:800080,rebeccapurple:663399,red:ff0000,rosybrown:bc8f8f,royalblue:4169e1,saddlebrown:8b4513,salmon:fa8072,sandybrown:f4a460,seagreen:2e8b57,seashell:fff5ee,sienna:a0522d,silver:c0c0c0,skyblue:87ceeb,slateblue:6a5acd,slategray:708090,snow:fffafa,springgreen:00ff7f,steelblue:4682b4,tan:d2b48c,teal:008080,thistle:d8bfd8,tomato:ff6347,turquoise:40e0d0,violet:ee82ee,wheat:f5deb3,white:ffffff,whitesmoke:f5f5f5,yellow:ffff00,yellowgreen:9acd32";
var makeMap = (str) => {
  const map2 = /* @__PURE__ */ new Map();
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    const [key, val] = list[i].split(":");
    map2.set(key, `#${val}`);
    if (key.includes("gray")) map2.set(key.replace("gray", "grey"), `#${val}`);
  }
  return map2;
};
var nativeColorMap = makeMap(nativeColors);
var parseColor = (value) => {
  var _a8;
  if (nativeColorMap.has(value)) {
    return parseColor(nativeColorMap.get(value));
  }
  const result = RGBColor.parse(value) || HSBColor.parse(value) || HSLColor.parse(value);
  if (!result) {
    const error = new Error("Invalid color value: " + value);
    (_a8 = Error.captureStackTrace) == null ? void 0 : _a8.call(Error, error, parseColor);
    throw error;
  }
  return result;
};
var normalizeColor = (v) => {
  return typeof v === "string" ? parseColor(v) : v;
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min2 = Math.min;
var max2 = Math.max;
var round2 = Math.round;
var floor2 = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp2(start, value, end) {
  return max2(start, min2(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length2 = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length2] > rects.floating[length2]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware2.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state2, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state2;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state2);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state2) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state2;
    const {
      element,
      padding = 0
    } = evaluate(options, state2) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length2 = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length2] + rects.reference[axis] - coords[axis] - rects.floating[length2];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length2];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length2] / 2 - 1;
    const minPadding = min2(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min2(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max4 = clientSize - arrowDimensions[length2] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length2] / 2 + centerToReference;
    const offset3 = clamp2(min$1, center, max4);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset3 && rects.reference[length2] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length2] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max4 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset3,
        centerOffset: center - offset3 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state2) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state2);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex2 = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex2];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex2,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state2) {
      const {
        rects
      } = state2;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state2);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state2, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state2, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state2, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state2;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state2);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state2) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state2;
      const diffCoords = await convertValueToCoords(state2, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state2) {
      const {
        x,
        y,
        placement
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state2);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min4 = mainAxisCoord + overflow[minSide];
        const max4 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp2(min4, mainAxisCoord, max4);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min4 = crossAxisCoord + overflow[minSide];
        const max4 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp2(min4, crossAxisCoord, max4);
      }
      const limitedCoords = limiter.fn({
        ...state2,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state2) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state2;
      const {
        offset: offset3 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state2);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset3, state2);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state2) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state2;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state2);
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min2(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min2(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state2.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state2.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state2.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max2(overflow.left, 0);
        const xMax = max2(overflow.right, 0);
        const yMin = max2(overflow.top, 0);
        const yMax = max2(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max2(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max2(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state2,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName2(node2) {
  if (isNode2(node2)) {
    return (node2.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow2(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement2(node2) {
  var _ref;
  return (_ref = (isNode2(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow2(value).Node;
}
function isElement2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow2(value).Element;
}
function isHTMLElement2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow2(value).HTMLElement;
}
function isShadowRoot2(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow2(value).ShadowRoot;
}
function isOverflowElement2(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle3(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName2(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css2 = isElement2(elementOrCss) ? getComputedStyle3(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css2[value] ? css2[value] !== "none" : false) || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode2(element);
  while (isHTMLElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode2(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName2(node2));
}
function getComputedStyle3(element) {
  return getWindow2(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement2(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode2(node2) {
  if (getNodeName2(node2) === "html") {
    return node2;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot2(node2) && node2.host || // Fallback.
    getDocumentElement2(node2)
  );
  return isShadowRoot2(result) ? result.host : result;
}
function getNearestOverflowAncestor2(node2) {
  const parentNode = getParentNode2(node2);
  if (isLastTraversableNode(parentNode)) {
    return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
  }
  if (isHTMLElement2(parentNode) && isOverflowElement2(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor2(parentNode);
}
function getOverflowAncestors2(node2, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor2(node2);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow2(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement2(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors2(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors2(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css2 = getComputedStyle3(element);
  let width = parseFloat(css2.width) || 0;
  let height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement2(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round2(width) !== offsetWidth || round2(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement2(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement2(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x = ($2 ? round2(rect.width) : rect.width) / width;
  let y = ($2 ? round2(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow2(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow2(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement2(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow2(domElement);
    const offsetWin = offsetParent && isElement2(offsetParent) ? getWindow2(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle3(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow2(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement2(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement2(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement2(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max2(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max2(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle3(body).direction === "rtl") {
    x += max2(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow2(element);
  const html = getDocumentElement2(element);
  const visualViewport2 = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport2) {
    width = visualViewport2.width;
    height = visualViewport2.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport2.offsetLeft;
      y = visualViewport2.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement2(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement2(element));
  } else if (isElement2(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode2(element);
  if (parentNode === stopNode || !isElement2(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle3(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors2(element, [], false).filter((el) => isElement2(el) && getNodeName2(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle3(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode2(element) : element;
  while (isElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle3(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement2(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode2(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement2(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle3(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement2(element) || getComputedStyle3(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement2(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow2(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement2(element)) {
    let svgOffsetParent = getParentNode2(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement2(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode2(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL2(element) {
  return getComputedStyle3(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement: getDocumentElement2,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement2,
  isRTL: isRTL2
};
function rectsAreEqual(a2, b2) {
  return a2.x === b2.x && a2.y === b2.y && a2.width === b2.width && a2.height === b2.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement2(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor2(top);
    const insetRight = floor2(root.clientWidth - (left + width));
    const insetBottom = floor2(root.clientHeight - (top + height));
    const insetLeft = floor2(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max2(0, min2(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors2(referenceEl) : [], ...getOverflowAncestors2(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@zag-js/popper/dist/index.mjs
function createDOMRect(x = 0, y = 0, width = 0, height = 0) {
  if (typeof DOMRect === "function") {
    return new DOMRect(x, y, width, height);
  }
  const rect = {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x
  };
  return { ...rect, toJSON: () => rect };
}
function getDOMRect(anchorRect) {
  if (!anchorRect) return createDOMRect();
  const { x, y, width, height } = anchorRect;
  return createDOMRect(x, y, width, height);
}
function getAnchorElement(anchorElement, getAnchorRect) {
  return {
    contextElement: isHTMLElement(anchorElement) ? anchorElement : void 0,
    getBoundingClientRect: () => {
      const anchor = anchorElement;
      const anchorRect = getAnchorRect == null ? void 0 : getAnchorRect(anchor);
      if (anchorRect || !anchor) {
        return getDOMRect(anchorRect);
      }
      return anchor.getBoundingClientRect();
    }
  };
}
var toVar = (value) => ({ variable: value, reference: `var(${value})` });
var cssVars = {
  arrowSize: toVar("--arrow-size"),
  arrowSizeHalf: toVar("--arrow-size-half"),
  arrowBg: toVar("--arrow-background"),
  transformOrigin: toVar("--transform-origin"),
  arrowOffset: toVar("--arrow-offset")
};
var getTransformOrigin = (arrow22) => ({
  top: "bottom center",
  "top-start": arrow22 ? `${arrow22.x}px bottom` : "left bottom",
  "top-end": arrow22 ? `${arrow22.x}px bottom` : "right bottom",
  bottom: "top center",
  "bottom-start": arrow22 ? `${arrow22.x}px top` : "top left",
  "bottom-end": arrow22 ? `${arrow22.x}px top` : "top right",
  left: "right center",
  "left-start": arrow22 ? `right ${arrow22.y}px` : "right top",
  "left-end": arrow22 ? `right ${arrow22.y}px` : "right bottom",
  right: "left center",
  "right-start": arrow22 ? `left ${arrow22.y}px` : "left top",
  "right-end": arrow22 ? `left ${arrow22.y}px` : "left bottom"
});
var transformOriginMiddleware = {
  name: "transformOrigin",
  fn({ placement, elements, middlewareData }) {
    const { arrow: arrow22 } = middlewareData;
    const transformOrigin = getTransformOrigin(arrow22)[placement];
    const { floating } = elements;
    floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin);
    return {
      data: { transformOrigin }
    };
  }
};
var rectMiddleware = {
  name: "rects",
  fn({ rects }) {
    return {
      data: rects
    };
  }
};
var shiftArrowMiddleware = (arrowEl) => {
  if (!arrowEl) return;
  return {
    name: "shiftArrow",
    fn({ placement, middlewareData }) {
      if (!middlewareData.arrow) return {};
      const { x, y } = middlewareData.arrow;
      const dir = placement.split("-")[0];
      Object.assign(arrowEl.style, {
        left: x != null ? `${x}px` : "",
        top: y != null ? `${y}px` : "",
        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`
      });
      return {};
    }
  };
};
function getPlacementDetails(placement) {
  const [side, align] = placement.split("-");
  return { side, align, hasAlign: align != null };
}
function getPlacementSide(placement) {
  return placement.split("-")[0];
}
var defaultOptions = {
  strategy: "absolute",
  placement: "bottom",
  listeners: true,
  gutter: 8,
  flip: true,
  slide: true,
  overlap: false,
  sameWidth: false,
  fitViewport: false,
  overflowPadding: 8,
  arrowPadding: 4
};
function roundByDpr(win, value) {
  const dpr = win.devicePixelRatio || 1;
  return Math.round(value * dpr) / dpr;
}
function getBoundaryMiddleware(opts) {
  return runIfFn(opts.boundary);
}
function getArrowMiddleware(arrowElement, opts) {
  if (!arrowElement) return;
  return arrow2({
    element: arrowElement,
    padding: opts.arrowPadding
  });
}
function getOffsetMiddleware(arrowElement, opts) {
  if (isNull(opts.offset ?? opts.gutter)) return;
  return offset2(({ placement }) => {
    var _a8, _b7;
    const arrowOffset = ((arrowElement == null ? void 0 : arrowElement.clientHeight) || 0) / 2;
    const gutter = ((_a8 = opts.offset) == null ? void 0 : _a8.mainAxis) ?? opts.gutter;
    const mainAxis = typeof gutter === "number" ? gutter + arrowOffset : gutter ?? arrowOffset;
    const { hasAlign } = getPlacementDetails(placement);
    const shift22 = !hasAlign ? opts.shift : void 0;
    const crossAxis = ((_b7 = opts.offset) == null ? void 0 : _b7.crossAxis) ?? shift22;
    return compact2({
      crossAxis,
      mainAxis,
      alignmentAxis: opts.shift
    });
  });
}
function getFlipMiddleware(opts) {
  if (!opts.flip) return;
  return flip2({
    boundary: getBoundaryMiddleware(opts),
    padding: opts.overflowPadding,
    fallbackPlacements: opts.flip === true ? void 0 : opts.flip
  });
}
function getShiftMiddleware(opts) {
  if (!opts.slide && !opts.overlap) return;
  return shift2({
    boundary: getBoundaryMiddleware(opts),
    mainAxis: opts.slide,
    crossAxis: opts.overlap,
    padding: opts.overflowPadding,
    limiter: limitShift2()
  });
}
function getSizeMiddleware(opts) {
  return size2({
    padding: opts.overflowPadding,
    apply({ elements, rects, availableHeight, availableWidth }) {
      const floating = elements.floating;
      const referenceWidth = Math.round(rects.reference.width);
      availableWidth = Math.floor(availableWidth);
      availableHeight = Math.floor(availableHeight);
      floating.style.setProperty("--reference-width", `${referenceWidth}px`);
      floating.style.setProperty("--available-width", `${availableWidth}px`);
      floating.style.setProperty("--available-height", `${availableHeight}px`);
    }
  });
}
function hideWhenDetachedMiddleware(opts) {
  var _a8;
  if (!opts.hideWhenDetached) return;
  return hide2({ strategy: "referenceHidden", boundary: ((_a8 = opts.boundary) == null ? void 0 : _a8.call(opts)) ?? "clippingAncestors" });
}
function getAutoUpdateOptions(opts) {
  if (!opts) return {};
  if (opts === true) {
    return { ancestorResize: true, ancestorScroll: true, elementResize: true, layoutShift: true };
  }
  return opts;
}
function getPlacementImpl(referenceOrVirtual, floating, opts = {}) {
  const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect);
  if (!floating || !reference) return;
  const options = Object.assign({}, defaultOptions, opts);
  const arrowEl = floating.querySelector("[data-part=arrow]");
  const middleware2 = [
    getOffsetMiddleware(arrowEl, options),
    getFlipMiddleware(options),
    getShiftMiddleware(options),
    getArrowMiddleware(arrowEl, options),
    shiftArrowMiddleware(arrowEl),
    transformOriginMiddleware,
    getSizeMiddleware(options),
    hideWhenDetachedMiddleware(options),
    rectMiddleware
  ];
  const { placement, strategy, onComplete, onPositioned } = options;
  const updatePosition = async () => {
    var _a8;
    if (!reference || !floating) return;
    const pos = await computePosition2(reference, floating, {
      placement,
      middleware: middleware2,
      strategy
    });
    onComplete == null ? void 0 : onComplete(pos);
    onPositioned == null ? void 0 : onPositioned({ placed: true });
    const win = getWindow(floating);
    const x = roundByDpr(win, pos.x);
    const y = roundByDpr(win, pos.y);
    floating.style.setProperty("--x", `${x}px`);
    floating.style.setProperty("--y", `${y}px`);
    if (options.hideWhenDetached) {
      const isHidden = (_a8 = pos.middlewareData.hide) == null ? void 0 : _a8.referenceHidden;
      if (isHidden) {
        floating.style.setProperty("visibility", "hidden");
        floating.style.setProperty("pointer-events", "none");
      } else {
        floating.style.removeProperty("visibility");
        floating.style.removeProperty("pointer-events");
      }
    }
    const contentEl = floating.firstElementChild;
    if (contentEl) {
      const styles = getComputedStyle2(contentEl);
      floating.style.setProperty("--z-index", styles.zIndex);
    }
  };
  const update = async () => {
    if (opts.updatePosition) {
      await opts.updatePosition({ updatePosition });
      onPositioned == null ? void 0 : onPositioned({ placed: true });
    } else {
      await updatePosition();
    }
  };
  const autoUpdateOptions = getAutoUpdateOptions(options.listeners);
  const cancelAutoUpdate = options.listeners ? autoUpdate(reference, floating, update, autoUpdateOptions) : noop2;
  update();
  return () => {
    cancelAutoUpdate == null ? void 0 : cancelAutoUpdate();
    onPositioned == null ? void 0 : onPositioned({ placed: false });
  };
}
function getPlacement(referenceOrFn, floatingOrFn, opts = {}) {
  const { defer, ...options } = opts;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const reference = typeof referenceOrFn === "function" ? referenceOrFn() : referenceOrFn;
      const floating = typeof floatingOrFn === "function" ? floatingOrFn() : floatingOrFn;
      cleanups2.push(getPlacementImpl(reference, floating, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
var ARROW_FLOATING_STYLE = {
  bottom: "rotate(45deg)",
  left: "rotate(135deg)",
  top: "rotate(225deg)",
  right: "rotate(315deg)"
};
function getPlacementStyles(options = {}) {
  const { placement, sameWidth, fitViewport, strategy = "absolute" } = options;
  return {
    arrow: {
      position: "absolute",
      width: cssVars.arrowSize.reference,
      height: cssVars.arrowSize.reference,
      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,
      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`
    },
    arrowTip: {
      // @ts-expect-error - Fix this
      transform: placement ? ARROW_FLOATING_STYLE[placement.split("-")[0]] : void 0,
      background: cssVars.arrowBg.reference,
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      position: "absolute",
      zIndex: "inherit"
    },
    floating: {
      position: strategy,
      isolation: "isolate",
      minWidth: sameWidth ? void 0 : "max-content",
      width: sameWidth ? "var(--reference-width)" : void 0,
      maxWidth: fitViewport ? "var(--available-width)" : void 0,
      maxHeight: fitViewport ? "var(--available-height)" : void 0,
      top: "0px",
      left: "0px",
      // move off-screen if placement is not defined
      transform: placement ? "translate3d(var(--x), var(--y), 0)" : "translate3d(0, -100vh, 0)",
      zIndex: "var(--z-index)"
    }
  };
}

// node_modules/@zag-js/interact-outside/dist/index.mjs
function getWindowFrames(win) {
  const frames = {
    each(cb) {
      var _a8;
      for (let i = 0; i < ((_a8 = win.frames) == null ? void 0 : _a8.length); i += 1) {
        const frame = win.frames[i];
        if (frame) cb(frame);
      }
    },
    addEventListener(event, listener, options) {
      frames.each((frame) => {
        try {
          frame.document.addEventListener(event, listener, options);
        } catch {
        }
      });
      return () => {
        try {
          frames.removeEventListener(event, listener, options);
        } catch {
        }
      };
    },
    removeEventListener(event, listener, options) {
      frames.each((frame) => {
        try {
          frame.document.removeEventListener(event, listener, options);
        } catch {
        }
      });
    }
  };
  return frames;
}
function getParentWindow(win) {
  const parent = win.frameElement != null ? win.parent : null;
  return {
    addEventListener: (event, listener, options) => {
      try {
        parent == null ? void 0 : parent.addEventListener(event, listener, options);
      } catch {
      }
      return () => {
        try {
          parent == null ? void 0 : parent.removeEventListener(event, listener, options);
        } catch {
        }
      };
    },
    removeEventListener: (event, listener, options) => {
      try {
        parent == null ? void 0 : parent.removeEventListener(event, listener, options);
      } catch {
      }
    }
  };
}
var POINTER_OUTSIDE_EVENT = "pointerdown.outside";
var FOCUS_OUTSIDE_EVENT = "focus.outside";
function isComposedPathFocusable(composedPath) {
  for (const node2 of composedPath) {
    if (isHTMLElement(node2) && isFocusable(node2)) return true;
  }
  return false;
}
var isPointerEvent = (event) => "clientY" in event;
function isEventPointWithin(node2, event) {
  if (!isPointerEvent(event) || !node2) return false;
  const rect = node2.getBoundingClientRect();
  if (rect.width === 0 || rect.height === 0) return false;
  return rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;
}
function isPointInRect(rect, point) {
  return rect.y <= point.y && point.y <= rect.y + rect.height && rect.x <= point.x && point.x <= rect.x + rect.width;
}
function isEventWithinScrollbar(event, ancestor) {
  if (!ancestor || !isPointerEvent(event)) return false;
  const isScrollableY = ancestor.scrollHeight > ancestor.clientHeight;
  const onScrollbarY = isScrollableY && event.clientX > ancestor.offsetLeft + ancestor.clientWidth;
  const isScrollableX = ancestor.scrollWidth > ancestor.clientWidth;
  const onScrollbarX = isScrollableX && event.clientY > ancestor.offsetTop + ancestor.clientHeight;
  const rect = {
    x: ancestor.offsetLeft,
    y: ancestor.offsetTop,
    width: ancestor.clientWidth + (isScrollableY ? 16 : 0),
    height: ancestor.clientHeight + (isScrollableX ? 16 : 0)
  };
  const point = {
    x: event.clientX,
    y: event.clientY
  };
  if (!isPointInRect(rect, point)) return false;
  return onScrollbarY || onScrollbarX;
}
function trackInteractOutsideImpl(node2, options) {
  const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside, defer } = options;
  if (!node2) return;
  const doc = getDocument(node2);
  const win = getWindow(node2);
  const frames = getWindowFrames(win);
  const parentWin = getParentWindow(win);
  function isEventOutside(event) {
    const target = getEventTarget(event);
    if (!isHTMLElement(target)) return false;
    if (!target.isConnected) return false;
    if (contains(node2, target)) return false;
    if (isEventPointWithin(node2, event)) return false;
    const triggerEl = doc.querySelector(`[aria-controls="${node2.id}"]`);
    if (triggerEl) {
      const triggerAncestor = getNearestOverflowAncestor(triggerEl);
      if (isEventWithinScrollbar(event, triggerAncestor)) return false;
    }
    const nodeAncestor = getNearestOverflowAncestor(node2);
    if (isEventWithinScrollbar(event, nodeAncestor)) return false;
    return !(exclude == null ? void 0 : exclude(target));
  }
  const pointerdownCleanups = /* @__PURE__ */ new Set();
  function onPointerDown(event) {
    function handler() {
      var _a8;
      const func = defer ? raf : (v) => v();
      const composedPath = ((_a8 = event.composedPath) == null ? void 0 : _a8.call(event)) ?? [event.target];
      func(() => {
        if (!node2 || !isEventOutside(event)) return;
        if (onPointerDownOutside || onInteractOutside) {
          const handler2 = callAll2(onPointerDownOutside, onInteractOutside);
          node2.addEventListener(POINTER_OUTSIDE_EVENT, handler2, { once: true });
        }
        fireCustomEvent(node2, POINTER_OUTSIDE_EVENT, {
          bubbles: false,
          cancelable: true,
          detail: {
            originalEvent: event,
            contextmenu: isContextMenuEvent(event),
            focusable: isComposedPathFocusable(composedPath)
          }
        });
      });
    }
    if (event.pointerType === "touch") {
      pointerdownCleanups.forEach((fn) => fn());
      pointerdownCleanups.add(addDomEvent(doc, "click", handler, { once: true }));
      pointerdownCleanups.add(parentWin.addEventListener("click", handler, { once: true }));
      pointerdownCleanups.add(frames.addEventListener("click", handler, { once: true }));
    } else {
      handler();
    }
  }
  const cleanups2 = /* @__PURE__ */ new Set();
  const timer = setTimeout(() => {
    cleanups2.add(addDomEvent(doc, "pointerdown", onPointerDown, true));
    cleanups2.add(parentWin.addEventListener("pointerdown", onPointerDown, true));
    cleanups2.add(frames.addEventListener("pointerdown", onPointerDown, true));
  }, 0);
  function onFocusin(event) {
    const func = defer ? raf : (v) => v();
    func(() => {
      if (!node2 || !isEventOutside(event)) return;
      if (onFocusOutside || onInteractOutside) {
        const handler = callAll2(onFocusOutside, onInteractOutside);
        node2.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true });
      }
      fireCustomEvent(node2, FOCUS_OUTSIDE_EVENT, {
        bubbles: false,
        cancelable: true,
        detail: {
          originalEvent: event,
          contextmenu: false,
          focusable: isFocusable(getEventTarget(event))
        }
      });
    });
  }
  cleanups2.add(addDomEvent(doc, "focusin", onFocusin, true));
  cleanups2.add(parentWin.addEventListener("focusin", onFocusin, true));
  cleanups2.add(frames.addEventListener("focusin", onFocusin, true));
  return () => {
    clearTimeout(timer);
    pointerdownCleanups.forEach((fn) => fn());
    cleanups2.forEach((fn) => fn());
  };
}
function trackInteractOutside(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(trackInteractOutsideImpl(node2, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function fireCustomEvent(el, type, init) {
  const win = el.ownerDocument.defaultView || window;
  const event = new win.CustomEvent(type, init);
  return el.dispatchEvent(event);
}

// node_modules/@zag-js/dismissable/dist/index.mjs
function trackEscapeKeydown(node2, fn) {
  const handleKeyDown = (event) => {
    if (event.key !== "Escape") return;
    if (event.isComposing) return;
    fn == null ? void 0 : fn(event);
  };
  return addDomEvent(getDocument(node2), "keydown", handleKeyDown, { capture: true });
}
var layerStack = {
  layers: [],
  branches: [],
  count() {
    return this.layers.length;
  },
  pointerBlockingLayers() {
    return this.layers.filter((layer) => layer.pointerBlocking);
  },
  topMostPointerBlockingLayer() {
    return [...this.pointerBlockingLayers()].slice(-1)[0];
  },
  hasPointerBlockingLayer() {
    return this.pointerBlockingLayers().length > 0;
  },
  isBelowPointerBlockingLayer(node2) {
    var _a8;
    const index = this.indexOf(node2);
    const highestBlockingIndex = this.topMostPointerBlockingLayer() ? this.indexOf((_a8 = this.topMostPointerBlockingLayer()) == null ? void 0 : _a8.node) : -1;
    return index < highestBlockingIndex;
  },
  isTopMost(node2) {
    const layer = this.layers[this.count() - 1];
    return (layer == null ? void 0 : layer.node) === node2;
  },
  getNestedLayers(node2) {
    return Array.from(this.layers).slice(this.indexOf(node2) + 1);
  },
  isInNestedLayer(node2, target) {
    return this.getNestedLayers(node2).some((layer) => contains(layer.node, target));
  },
  isInBranch(target) {
    return Array.from(this.branches).some((branch) => contains(branch, target));
  },
  add(layer) {
    const num = this.layers.push(layer);
    layer.node.style.setProperty("--layer-index", `${num}`);
  },
  addBranch(node2) {
    this.branches.push(node2);
  },
  remove(node2) {
    const index = this.indexOf(node2);
    if (index < 0) return;
    if (index < this.count() - 1) {
      const _layers = this.getNestedLayers(node2);
      _layers.forEach((layer) => layer.dismiss());
    }
    this.layers.splice(index, 1);
    node2.style.removeProperty("--layer-index");
  },
  removeBranch(node2) {
    const index = this.branches.indexOf(node2);
    if (index >= 0) this.branches.splice(index, 1);
  },
  indexOf(node2) {
    return this.layers.findIndex((layer) => layer.node === node2);
  },
  dismiss(node2) {
    var _a8;
    (_a8 = this.layers[this.indexOf(node2)]) == null ? void 0 : _a8.dismiss();
  },
  clear() {
    this.remove(this.layers[0].node);
  }
};
var originalBodyPointerEvents;
function assignPointerEventToLayers() {
  layerStack.layers.forEach(({ node: node2 }) => {
    node2.style.pointerEvents = layerStack.isBelowPointerBlockingLayer(node2) ? "none" : "auto";
  });
}
function clearPointerEvent(node2) {
  node2.style.pointerEvents = "";
}
function disablePointerEventsOutside(node2, persistentElements) {
  const doc = getDocument(node2);
  const cleanups2 = [];
  if (layerStack.hasPointerBlockingLayer() && !doc.body.hasAttribute("data-inert")) {
    originalBodyPointerEvents = document.body.style.pointerEvents;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = "none";
      doc.body.setAttribute("data-inert", "");
    });
  }
  if (persistentElements) {
    const persistedCleanup = waitForElements(persistentElements, (el) => {
      cleanups2.push(setStyle(el, { pointerEvents: "auto" }));
    });
    cleanups2.push(persistedCleanup);
  }
  return () => {
    if (layerStack.hasPointerBlockingLayer()) return;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = originalBodyPointerEvents;
      doc.body.removeAttribute("data-inert");
      if (doc.body.style.length === 0) doc.body.removeAttribute("style");
    });
    cleanups2.forEach((fn) => fn());
  };
}
function trackDismissableElementImpl(node2, options) {
  if (!node2) {
    warn("[@zag-js/dismissable] node is `null` or `undefined`");
    return;
  }
  const { onDismiss, pointerBlocking, exclude: excludeContainers, debug } = options;
  const layer = { dismiss: onDismiss, node: node2, pointerBlocking };
  layerStack.add(layer);
  assignPointerEventToLayers();
  function onPointerDownOutside(event) {
    var _a8, _b7;
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isBelowPointerBlockingLayer(node2) || layerStack.isInBranch(target)) return;
    (_a8 = options.onPointerDownOutside) == null ? void 0 : _a8.call(options, event);
    (_b7 = options.onInteractOutside) == null ? void 0 : _b7.call(options, event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onPointerDownOutside:", event.detail.originalEvent);
    }
    onDismiss == null ? void 0 : onDismiss();
  }
  function onFocusOutside(event) {
    var _a8, _b7;
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isInBranch(target)) return;
    (_a8 = options.onFocusOutside) == null ? void 0 : _a8.call(options, event);
    (_b7 = options.onInteractOutside) == null ? void 0 : _b7.call(options, event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onFocusOutside:", event.detail.originalEvent);
    }
    onDismiss == null ? void 0 : onDismiss();
  }
  function onEscapeKeyDown(event) {
    var _a8;
    if (!layerStack.isTopMost(node2)) return;
    (_a8 = options.onEscapeKeyDown) == null ? void 0 : _a8.call(options, event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }
  function exclude(target) {
    var _a8;
    if (!node2) return false;
    const containers = typeof excludeContainers === "function" ? excludeContainers() : excludeContainers;
    const _containers = Array.isArray(containers) ? containers : [containers];
    const persistentElements = (_a8 = options.persistentElements) == null ? void 0 : _a8.map((fn) => fn()).filter(isHTMLElement);
    if (persistentElements) _containers.push(...persistentElements);
    return _containers.some((node22) => contains(node22, target)) || layerStack.isInNestedLayer(node2, target);
  }
  const cleanups2 = [
    pointerBlocking ? disablePointerEventsOutside(node2, options.persistentElements) : void 0,
    trackEscapeKeydown(node2, onEscapeKeyDown),
    trackInteractOutside(node2, { exclude, onFocusOutside, onPointerDownOutside, defer: options.defer })
  ];
  return () => {
    layerStack.remove(node2);
    assignPointerEventToLayers();
    clearPointerEvent(node2);
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function trackDismissableElement(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = isFunction2(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      cleanups2.push(trackDismissableElementImpl(node2, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function trackDismissableBranch(nodeOrFn, options = {}) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = isFunction2(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      if (!node2) {
        warn("[@zag-js/dismissable] branch node is `null` or `undefined`");
        return;
      }
      layerStack.addBranch(node2);
      cleanups2.push(() => {
        layerStack.removeBranch(node2);
      });
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}

// node_modules/@zag-js/color-picker/dist/index.mjs
var anatomy3 = createAnatomy("color-picker", [
  "root",
  "label",
  "control",
  "trigger",
  "positioner",
  "content",
  "area",
  "areaThumb",
  "valueText",
  "areaBackground",
  "channelSlider",
  "channelSliderLabel",
  "channelSliderTrack",
  "channelSliderThumb",
  "channelSliderValueText",
  "channelInput",
  "transparencyGrid",
  "swatchGroup",
  "swatchTrigger",
  "swatchIndicator",
  "swatch",
  "eyeDropperTrigger",
  "formatTrigger",
  "formatSelect"
]);
var parts3 = anatomy3.build();
var dom3 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `color-picker:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `color-picker:${ctx.id}:label`;
  },
  getHiddenInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `color-picker:${ctx.id}:hidden-input`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `color-picker:${ctx.id}:control`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `color-picker:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `color-picker:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `color-picker:${ctx.id}:positioner`;
  },
  getFormatSelectId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.formatSelect) ?? `color-picker:${ctx.id}:format-select`;
  },
  getAreaId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.area) ?? `color-picker:${ctx.id}:area`;
  },
  getAreaGradientId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.areaGradient) ?? `color-picker:${ctx.id}:area-gradient`;
  },
  getAreaThumbId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.areaThumb) ?? `color-picker:${ctx.id}:area-thumb`;
  },
  getChannelSliderTrackId: (ctx, channel) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.channelSliderTrack) == null ? void 0 : _b7.call(_a8, channel)) ?? `color-picker:${ctx.id}:slider-track:${channel}`;
  },
  getChannelSliderThumbId: (ctx, channel) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.channelSliderThumb) == null ? void 0 : _b7.call(_a8, channel)) ?? `color-picker:${ctx.id}:slider-thumb:${channel}`;
  },
  getContentEl: (ctx) => dom3.getById(ctx, dom3.getContentId(ctx)),
  getAreaThumbEl: (ctx) => dom3.getById(ctx, dom3.getAreaThumbId(ctx)),
  getChannelSliderThumbEl: (ctx, channel) => dom3.getById(ctx, dom3.getChannelSliderThumbId(ctx, channel)),
  getChannelInputEl: (ctx, channel) => {
    const selector = `input[data-channel="${channel}"]`;
    return [
      ...queryAll(dom3.getContentEl(ctx), selector),
      ...queryAll(dom3.getControlEl(ctx), selector)
    ];
  },
  getFormatSelectEl: (ctx) => dom3.getById(ctx, dom3.getFormatSelectId(ctx)),
  getHiddenInputEl: (ctx) => dom3.getById(ctx, dom3.getHiddenInputId(ctx)),
  getAreaEl: (ctx) => dom3.getById(ctx, dom3.getAreaId(ctx)),
  getAreaValueFromPoint(ctx, point) {
    const areaEl = dom3.getAreaEl(ctx);
    if (!areaEl) return;
    const { percent } = getRelativePoint(point, areaEl);
    return percent;
  },
  getControlEl: (ctx) => dom3.getById(ctx, dom3.getControlId(ctx)),
  getTriggerEl: (ctx) => dom3.getById(ctx, dom3.getTriggerId(ctx)),
  getPositionerEl: (ctx) => dom3.getById(ctx, dom3.getPositionerId(ctx)),
  getChannelSliderTrackEl: (ctx, channel) => {
    return dom3.getById(ctx, dom3.getChannelSliderTrackId(ctx, channel));
  },
  getChannelSliderValueFromPoint(ctx, point, channel) {
    const trackEl = dom3.getChannelSliderTrackEl(ctx, channel);
    if (!trackEl) return;
    const { percent } = getRelativePoint(point, trackEl);
    return percent;
  },
  getChannelInputEls: (ctx) => {
    return [
      ...queryAll(dom3.getContentEl(ctx), "input[data-channel]"),
      ...queryAll(dom3.getControlEl(ctx), "input[data-channel]")
    ];
  }
});
function getChannelDisplayColor(color, channel) {
  switch (channel) {
    case "hue":
      return parseColor(`hsl(${color.getChannelValue("hue")}, 100%, 50%)`);
    case "lightness":
    case "brightness":
    case "saturation":
    case "red":
    case "green":
    case "blue":
      return color.withChannelValue("alpha", 1);
    case "alpha": {
      return color;
    }
    default:
      throw new Error("Unknown color channel: " + channel);
  }
}
function getChannelValue(color, channel) {
  if (channel == null) return "";
  if (channel === "hex") {
    return color.toString("hex");
  }
  if (channel === "css") {
    return color.toString("css");
  }
  if (channel in color) {
    return color.getChannelValue(channel).toString();
  }
  const isHSL = color.getFormat() === "hsla";
  switch (channel) {
    case "hue":
      return isHSL ? color.toFormat("hsla").getChannelValue("hue").toString() : color.toFormat("hsba").getChannelValue("hue").toString();
    case "saturation":
      return isHSL ? color.toFormat("hsla").getChannelValue("saturation").toString() : color.toFormat("hsba").getChannelValue("saturation").toString();
    case "lightness":
      return color.toFormat("hsla").getChannelValue("lightness").toString();
    case "brightness":
      return color.toFormat("hsba").getChannelValue("brightness").toString();
    case "red":
    case "green":
    case "blue":
      return color.toFormat("rgba").getChannelValue(channel).toString();
    default:
      return color.getChannelValue(channel).toString();
  }
}
function getChannelRange(color, channel) {
  switch (channel) {
    case "hex":
      const minColor = parseColor("#000000");
      const maxColor = parseColor("#FFFFFF");
      return {
        minValue: minColor.toHexInt(),
        maxValue: maxColor.toHexInt(),
        pageSize: 10,
        step: 1
      };
    case "css":
      return void 0;
    case "hue":
    case "saturation":
    case "lightness":
      return color.toFormat("hsla").getChannelRange(channel);
    case "brightness":
      return color.toFormat("hsba").getChannelRange(channel);
    case "red":
    case "green":
    case "blue":
      return color.toFormat("rgba").getChannelRange(channel);
    default:
      return color.getChannelRange(channel);
  }
}
function getSliderBackgroundDirection(orientation, dir) {
  if (orientation === "vertical") {
    return "top";
  } else if (dir === "ltr") {
    return "right";
  } else {
    return "left";
  }
}
var getSliderBackground = (props34) => {
  const { channel, value, dir, orientation } = props34;
  const bgDirection = getSliderBackgroundDirection(orientation, dir);
  const { minValue, maxValue: maxValue2 } = value.getChannelRange(channel);
  switch (channel) {
    case "hue":
      return `linear-gradient(to ${bgDirection}, rgb(255, 0, 0) 0%, rgb(255, 255, 0) 17%, rgb(0, 255, 0) 33%, rgb(0, 255, 255) 50%, rgb(0, 0, 255) 67%, rgb(255, 0, 255) 83%, rgb(255, 0, 0) 100%)`;
    case "lightness": {
      let start = value.withChannelValue(channel, minValue).toString("css");
      let middle = value.withChannelValue(channel, (maxValue2 - minValue) / 2).toString("css");
      let end = value.withChannelValue(channel, maxValue2).toString("css");
      return `linear-gradient(to ${bgDirection}, ${start}, ${middle}, ${end})`;
    }
    case "saturation":
    case "brightness":
    case "red":
    case "green":
    case "blue":
    case "alpha": {
      let start = value.withChannelValue(channel, minValue).toString("css");
      let end = value.withChannelValue(channel, maxValue2).toString("css");
      return `linear-gradient(to ${bgDirection}, ${start}, ${end})`;
    }
    default:
      throw new Error("Unknown color channel: " + channel);
  }
};
function connect4(state2, send, normalize3) {
  const value = state2.context.value;
  const areaValue = state2.context.areaValue;
  const valueAsString = state2.context.valueAsString;
  const disabled = state2.context.isDisabled;
  const interactive = state2.context.isInteractive;
  const dragging = state2.hasTag("dragging");
  const open = state2.hasTag("open");
  const focused = state2.hasTag("focused");
  const getAreaChannels = (props34) => {
    const channels = areaValue.getChannels();
    return {
      xChannel: props34.xChannel ?? channels[1],
      yChannel: props34.yChannel ?? channels[2]
    };
  };
  const currentPlacement = state2.context.currentPlacement;
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: currentPlacement
  });
  function getSwatchTriggerState(props34) {
    const color = normalizeColor(props34.value).toFormat(state2.context.format);
    return {
      value: color,
      valueAsString: color.toString("hex"),
      checked: color.isEqual(value),
      disabled: props34.disabled || !interactive
    };
  }
  return {
    dragging,
    open,
    valueAsString,
    value,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    setValue(value2) {
      send({ type: "VALUE.SET", value: normalizeColor(value2), src: "set-color" });
    },
    getChannelValue(channel) {
      return getChannelValue(value, channel);
    },
    getChannelValueText(channel, locale) {
      return value.formatChannelValue(channel, locale);
    },
    setChannelValue(channel, channelValue) {
      const color = value.withChannelValue(channel, channelValue);
      send({ type: "VALUE.SET", value: color, src: "set-channel" });
    },
    format: state2.context.format,
    setFormat(format) {
      const formatValue2 = value.toFormat(format);
      send({ type: "VALUE.SET", value: formatValue2, src: "set-format" });
    },
    alpha: value.getChannelValue("alpha"),
    setAlpha(alphaValue) {
      const color = value.withChannelValue("alpha", alphaValue);
      send({ type: "VALUE.SET", value: color, src: "set-alpha" });
    },
    getRootProps() {
      return normalize3.element({
        ...parts3.root.attrs,
        dir: state2.context.dir,
        id: dom3.getRootId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        "data-invalid": dataAttr(state2.context.invalid),
        style: {
          "--value": value.toString("css")
        }
      });
    },
    getLabelProps() {
      return normalize3.element({
        ...parts3.label.attrs,
        dir: state2.context.dir,
        id: dom3.getLabelId(state2.context),
        htmlFor: dom3.getHiddenInputId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-focus": dataAttr(focused),
        onClick(event) {
          event.preventDefault();
          const inputEl = query(dom3.getControlEl(state2.context), "[data-channel=hex]");
          inputEl == null ? void 0 : inputEl.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize3.element({
        ...parts3.control.attrs,
        id: dom3.getControlId(state2.context),
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr(focused)
      });
    },
    getTriggerProps() {
      return normalize3.button({
        ...parts3.trigger.attrs,
        id: dom3.getTriggerId(state2.context),
        dir: state2.context.dir,
        disabled,
        "aria-label": `select color. current color is ${valueAsString}`,
        "aria-controls": dom3.getContentId(state2.context),
        "aria-labelledby": dom3.getLabelId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-placement": currentPlacement,
        "aria-expanded": dataAttr(open),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr(focused),
        type: "button",
        onClick() {
          if (!interactive) return;
          send({ type: "TRIGGER.CLICK" });
        },
        onBlur() {
          if (!interactive) return;
          send({ type: "TRIGGER.BLUR" });
        },
        style: {
          position: "relative"
        }
      });
    },
    getPositionerProps() {
      return normalize3.element({
        ...parts3.positioner.attrs,
        id: dom3.getPositionerId(state2.context),
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize3.element({
        ...parts3.content.attrs,
        id: dom3.getContentId(state2.context),
        dir: state2.context.dir,
        "data-placement": currentPlacement,
        "data-state": open ? "open" : "closed",
        hidden: !open
      });
    },
    getValueTextProps() {
      return normalize3.element({
        ...parts3.valueText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused)
      });
    },
    getAreaProps(props34 = {}) {
      const { xChannel, yChannel } = getAreaChannels(props34);
      const { areaStyles } = getColorAreaGradient(areaValue, {
        xChannel,
        yChannel,
        dir: state2.context.dir
      });
      return normalize3.element({
        ...parts3.area.attrs,
        id: dom3.getAreaId(state2.context),
        role: "group",
        "data-invalid": dataAttr(state2.context.invalid),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick(event)) return;
          if (isModifierKey(event)) return;
          const point = getEventPoint(event);
          const channel = { xChannel, yChannel };
          send({ type: "AREA.POINTER_DOWN", point, channel, id: "area" });
          event.preventDefault();
        },
        style: {
          position: "relative",
          touchAction: "none",
          forcedColorAdjust: "none",
          ...areaStyles
        }
      });
    },
    getAreaBackgroundProps(props34 = {}) {
      const { xChannel, yChannel } = getAreaChannels(props34);
      const { areaGradientStyles } = getColorAreaGradient(areaValue, {
        xChannel,
        yChannel,
        dir: state2.context.dir
      });
      return normalize3.element({
        ...parts3.areaBackground.attrs,
        id: dom3.getAreaGradientId(state2.context),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        style: {
          position: "relative",
          touchAction: "none",
          forcedColorAdjust: "none",
          ...areaGradientStyles
        }
      });
    },
    getAreaThumbProps(props34 = {}) {
      const { xChannel, yChannel } = getAreaChannels(props34);
      const channel = { xChannel, yChannel };
      const xPercent = areaValue.getChannelValuePercent(xChannel);
      const yPercent = 1 - areaValue.getChannelValuePercent(yChannel);
      const xValue = areaValue.getChannelValue(xChannel);
      const yValue = areaValue.getChannelValue(yChannel);
      const color = areaValue.withChannelValue("alpha", 1).toString("css");
      return normalize3.element({
        ...parts3.areaThumb.attrs,
        id: dom3.getAreaThumbId(state2.context),
        dir: state2.context.dir,
        tabIndex: disabled ? void 0 : 0,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-readonly": dataAttr(state2.context.readOnly),
        role: "slider",
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuenow": xValue,
        "aria-label": `${xChannel} and ${yChannel}`,
        "aria-roledescription": "2d slider",
        "aria-valuetext": `${xChannel} ${xValue}, ${yChannel} ${yValue}`,
        style: {
          position: "absolute",
          left: `${xPercent * 100}%`,
          top: `${yPercent * 100}%`,
          transform: "translate(-50%, -50%)",
          touchAction: "none",
          forcedColorAdjust: "none",
          "--color": color,
          background: color
        },
        onFocus() {
          if (!interactive) return;
          send({ type: "AREA.FOCUS", id: "area", channel });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const step = getEventStep(event);
          const keyMap2 = {
            ArrowUp() {
              send({ type: "AREA.ARROW_UP", channel, step });
            },
            ArrowDown() {
              send({ type: "AREA.ARROW_DOWN", channel, step });
            },
            ArrowLeft() {
              send({ type: "AREA.ARROW_LEFT", channel, step });
            },
            ArrowRight() {
              send({ type: "AREA.ARROW_RIGHT", channel, step });
            },
            PageUp() {
              send({ type: "AREA.PAGE_UP", channel, step });
            },
            PageDown() {
              send({ type: "AREA.PAGE_DOWN", channel, step });
            },
            Escape(event2) {
              event2.stopPropagation();
            }
          };
          const exec2 = keyMap2[getEventKey(event, state2.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        }
      });
    },
    getTransparencyGridProps(props34 = {}) {
      const { size: size3 = "12px" } = props34;
      return normalize3.element({
        ...parts3.transparencyGrid.attrs,
        style: {
          "--size": size3,
          width: "100%",
          height: "100%",
          position: "absolute",
          backgroundColor: "#fff",
          backgroundImage: "conic-gradient(#eeeeee 0 25%, transparent 0 50%, #eeeeee 0 75%, transparent 0)",
          backgroundSize: "var(--size) var(--size)",
          inset: "0px",
          zIndex: "auto",
          pointerEvents: "none"
        }
      });
    },
    getChannelSliderProps(props34) {
      const { orientation = "horizontal", channel, format } = props34;
      return normalize3.element({
        ...parts3.channelSlider.attrs,
        "data-channel": channel,
        "data-orientation": orientation,
        role: "presentation",
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick(event)) return;
          if (isModifierKey(event)) return;
          const point = getEventPoint(event);
          send({ type: "CHANNEL_SLIDER.POINTER_DOWN", channel, format, point, id: channel, orientation });
          event.preventDefault();
        },
        style: {
          position: "relative",
          touchAction: "none"
        }
      });
    },
    getChannelSliderTrackProps(props34) {
      const { orientation = "horizontal", channel, format } = props34;
      const normalizedValue = format ? value.toFormat(format) : areaValue;
      return normalize3.element({
        ...parts3.channelSliderTrack.attrs,
        id: dom3.getChannelSliderTrackId(state2.context, channel),
        role: "group",
        "data-channel": channel,
        "data-orientation": orientation,
        style: {
          position: "relative",
          forcedColorAdjust: "none",
          backgroundImage: getSliderBackground({
            orientation,
            channel,
            dir: state2.context.dir,
            value: normalizedValue
          })
        }
      });
    },
    getChannelSliderLabelProps(props34) {
      const { channel } = props34;
      return normalize3.element({
        ...parts3.channelSliderLabel.attrs,
        "data-channel": channel,
        onClick(event) {
          var _a8;
          if (!interactive) return;
          event.preventDefault();
          const thumbId = dom3.getChannelSliderThumbId(state2.context, channel);
          (_a8 = dom3.getById(state2.context, thumbId)) == null ? void 0 : _a8.focus({ preventScroll: true });
        },
        style: {
          userSelect: "none",
          WebkitUserSelect: "none"
        }
      });
    },
    getChannelSliderValueTextProps(props34) {
      return normalize3.element({
        ...parts3.channelSliderValueText.attrs,
        "data-channel": props34.channel
      });
    },
    getChannelSliderThumbProps(props34) {
      const { orientation = "horizontal", channel, format } = props34;
      const normalizedValue = format ? value.toFormat(format) : areaValue;
      const channelRange = normalizedValue.getChannelRange(channel);
      const channelValue = normalizedValue.getChannelValue(channel);
      const offset3 = (channelValue - channelRange.minValue) / (channelRange.maxValue - channelRange.minValue);
      const placementStyles = orientation === "horizontal" ? { left: `${offset3 * 100}%`, top: "50%" } : { top: `${offset3 * 100}%`, left: "50%" };
      return normalize3.element({
        ...parts3.channelSliderThumb.attrs,
        id: dom3.getChannelSliderThumbId(state2.context, channel),
        role: "slider",
        "aria-label": channel,
        tabIndex: disabled ? void 0 : 0,
        "data-channel": channel,
        "data-disabled": dataAttr(disabled),
        "data-orientation": orientation,
        "aria-disabled": dataAttr(disabled),
        "aria-orientation": orientation,
        "aria-valuemax": channelRange.maxValue,
        "aria-valuemin": channelRange.minValue,
        "aria-valuenow": channelValue,
        "aria-valuetext": `${channel} ${channelValue}`,
        style: {
          forcedColorAdjust: "none",
          position: "absolute",
          background: getChannelDisplayColor(areaValue, channel).toString("css"),
          ...placementStyles
        },
        onFocus() {
          if (!interactive) return;
          send({ type: "CHANNEL_SLIDER.FOCUS", channel });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const step = getEventStep(event) * channelRange.step;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "CHANNEL_SLIDER.ARROW_UP", channel, step });
            },
            ArrowDown() {
              send({ type: "CHANNEL_SLIDER.ARROW_DOWN", channel, step });
            },
            ArrowLeft() {
              send({ type: "CHANNEL_SLIDER.ARROW_LEFT", channel, step });
            },
            ArrowRight() {
              send({ type: "CHANNEL_SLIDER.ARROW_RIGHT", channel, step });
            },
            PageUp() {
              send({ type: "CHANNEL_SLIDER.PAGE_UP", channel });
            },
            PageDown() {
              send({ type: "CHANNEL_SLIDER.PAGE_DOWN", channel });
            },
            Home() {
              send({ type: "CHANNEL_SLIDER.HOME", channel });
            },
            End() {
              send({ type: "CHANNEL_SLIDER.END", channel });
            },
            Escape(event2) {
              event2.stopPropagation();
            }
          };
          const exec2 = keyMap2[getEventKey(event, state2.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        }
      });
    },
    getChannelInputProps(props34) {
      const { channel } = props34;
      const isTextField = channel === "hex" || channel === "css";
      const channelRange = getChannelRange(value, channel);
      return normalize3.input({
        ...parts3.channelInput.attrs,
        dir: state2.context.dir,
        type: isTextField ? "text" : "number",
        "data-channel": channel,
        "aria-label": channel,
        spellCheck: false,
        autoComplete: "off",
        disabled,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-readonly": dataAttr(state2.context.readOnly),
        readOnly: state2.context.readOnly,
        defaultValue: getChannelValue(value, channel),
        min: channelRange == null ? void 0 : channelRange.minValue,
        max: channelRange == null ? void 0 : channelRange.maxValue,
        step: channelRange == null ? void 0 : channelRange.step,
        onBeforeInput(event) {
          if (isTextField || !interactive) return;
          const value2 = event.currentTarget.value;
          if (value2.match(/[^0-9.]/g)) {
            event.preventDefault();
          }
        },
        onFocus(event) {
          if (!interactive) return;
          send({ type: "CHANNEL_INPUT.FOCUS", channel });
          event.currentTarget.select();
        },
        onBlur(event) {
          if (!interactive) return;
          const value2 = isTextField ? event.currentTarget.value : event.currentTarget.valueAsNumber;
          send({ type: "CHANNEL_INPUT.BLUR", channel, value: value2, isTextField });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          if (event.key === "Enter") {
            const value2 = isTextField ? event.currentTarget.value : event.currentTarget.valueAsNumber;
            send({ type: "CHANNEL_INPUT.CHANGE", channel, value: value2, isTextField });
            event.preventDefault();
          }
        },
        style: {
          appearance: "none",
          WebkitAppearance: "none",
          MozAppearance: "textfield"
        }
      });
    },
    getHiddenInputProps() {
      return normalize3.input({
        type: "text",
        disabled,
        name: state2.context.name,
        tabIndex: -1,
        readOnly: state2.context.readOnly,
        required: state2.context.required,
        id: dom3.getHiddenInputId(state2.context),
        style: visuallyHiddenStyle,
        defaultValue: valueAsString
      });
    },
    getEyeDropperTriggerProps() {
      return normalize3.button({
        ...parts3.eyeDropperTrigger.attrs,
        type: "button",
        dir: state2.context.dir,
        disabled,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-readonly": dataAttr(state2.context.readOnly),
        "aria-label": "Pick a color from the screen",
        onClick() {
          if (!interactive) return;
          send("EYEDROPPER.CLICK");
        }
      });
    },
    getSwatchGroupProps() {
      return normalize3.element({
        ...parts3.swatchGroup.attrs,
        role: "group"
      });
    },
    getSwatchTriggerState,
    getSwatchTriggerProps(props34) {
      const swatchState = getSwatchTriggerState(props34);
      return normalize3.button({
        ...parts3.swatchTrigger.attrs,
        disabled: swatchState.disabled,
        dir: state2.context.dir,
        type: "button",
        "aria-label": `select ${swatchState.valueAsString} as the color`,
        "data-state": swatchState.checked ? "checked" : "unchecked",
        "data-value": swatchState.valueAsString,
        "data-disabled": dataAttr(swatchState.disabled),
        onClick() {
          if (swatchState.disabled) return;
          send({ type: "SWATCH_TRIGGER.CLICK", value: swatchState.value });
        },
        style: {
          "--color": swatchState.valueAsString,
          position: "relative"
        }
      });
    },
    getSwatchIndicatorProps(props34) {
      const swatchState = getSwatchTriggerState(props34);
      return normalize3.element({
        ...parts3.swatchIndicator.attrs,
        dir: state2.context.dir,
        hidden: !swatchState.checked
      });
    },
    getSwatchProps(props34) {
      const { respectAlpha = true } = props34;
      const swatchState = getSwatchTriggerState(props34);
      const color = swatchState.value.toString(respectAlpha ? "css" : "hex");
      return normalize3.element({
        ...parts3.swatch.attrs,
        dir: state2.context.dir,
        "data-state": swatchState.checked ? "checked" : "unchecked",
        "data-value": swatchState.valueAsString,
        style: {
          "--color": color,
          position: "relative",
          background: color
        }
      });
    },
    getFormatTriggerProps() {
      return normalize3.button({
        ...parts3.formatTrigger.attrs,
        dir: state2.context.dir,
        type: "button",
        "aria-label": `change color format to ${getNextFormat(state2.context.format)}`,
        onClick(event) {
          if (event.currentTarget.disabled) return;
          const nextFormat = getNextFormat(state2.context.format);
          send({ type: "FORMAT.SET", format: nextFormat, src: "format-trigger" });
        }
      });
    },
    getFormatSelectProps() {
      return normalize3.select({
        ...parts3.formatSelect.attrs,
        "aria-label": "change color format",
        dir: state2.context.dir,
        defaultValue: state2.context.format,
        disabled,
        onChange(event) {
          const format = assertFormat(event.currentTarget.value);
          send({ type: "FORMAT.SET", format, src: "format-select" });
        }
      });
    }
  };
}
var formats = ["hsba", "hsla", "rgba"];
var formatRegex = new RegExp(`^(${formats.join("|")})$`);
function getNextFormat(format) {
  const index = formats.indexOf(format);
  return formats[index + 1] ?? formats[0];
}
function assertFormat(format) {
  if (formatRegex.test(format)) return format;
  throw new Error(`Unsupported color format: ${format}`);
}
var parse2 = (colorString) => {
  return parseColor(colorString);
};
var { and: and3 } = guards;
function machine4(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "color-picker",
      initial: ctx.open ? "open" : "idle",
      context: {
        dir: "ltr",
        value: parse2("#000000"),
        format: "rgba",
        disabled: false,
        closeOnSelect: false,
        openAutoFocus: true,
        ...ctx,
        activeId: null,
        activeChannel: null,
        activeOrientation: null,
        fieldsetDisabled: false,
        restoreFocus: true,
        positioning: {
          ...ctx.positioning,
          placement: "bottom"
        }
      },
      computed: {
        isRtl: (ctx2) => ctx2.dir === "rtl",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.isDisabled || ctx2.readOnly),
        valueAsString: (ctx2) => ctx2.value.toString(ctx2.format),
        areaValue: (ctx2) => {
          const format = ctx2.format.startsWith("hsl") ? "hsla" : "hsba";
          return ctx2.value.toFormat(format);
        }
      },
      activities: ["trackFormControl"],
      watch: {
        value: ["syncInputElements"],
        format: ["syncFormatSelectElement"],
        open: ["toggleVisibility"]
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        },
        "FORMAT.SET": {
          actions: ["setFormat"]
        },
        "CHANNEL_INPUT.CHANGE": {
          actions: ["setChannelColorFromInput"]
        },
        "EYEDROPPER.CLICK": {
          actions: ["openEyeDropper"]
        },
        "SWATCH_TRIGGER.CLICK": {
          actions: ["setValue"]
        }
      },
      states: {
        idle: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["setInitialFocus"]
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            "CHANNEL_INPUT.FOCUS": {
              target: "focused",
              actions: ["setActiveChannel"]
            }
          }
        },
        focused: {
          tags: ["closed", "focused"],
          on: {
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["setInitialFocus"]
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            "CHANNEL_INPUT.FOCUS": {
              actions: ["setActiveChannel"]
            },
            "CHANNEL_INPUT.BLUR": {
              target: "idle",
              actions: ["setChannelColorFromInput"]
            },
            "TRIGGER.BLUR": {
              target: "idle"
            }
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackPositioning", "trackDismissableElement"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["setReturnFocus"]
              },
              {
                target: "idle"
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            "AREA.POINTER_DOWN": {
              target: "open:dragging",
              actions: ["setActiveChannel", "setAreaColorFromPoint", "focusAreaThumb"]
            },
            "AREA.FOCUS": {
              actions: ["setActiveChannel"]
            },
            "CHANNEL_SLIDER.POINTER_DOWN": {
              target: "open:dragging",
              actions: ["setActiveChannel", "setChannelColorFromPoint", "focusChannelThumb"]
            },
            "CHANNEL_SLIDER.FOCUS": {
              actions: ["setActiveChannel"]
            },
            "AREA.ARROW_LEFT": {
              actions: ["decrementAreaXChannel"]
            },
            "AREA.ARROW_RIGHT": {
              actions: ["incrementAreaXChannel"]
            },
            "AREA.ARROW_UP": {
              actions: ["incrementAreaYChannel"]
            },
            "AREA.ARROW_DOWN": {
              actions: ["decrementAreaYChannel"]
            },
            "AREA.PAGE_UP": {
              actions: ["incrementAreaXChannel"]
            },
            "AREA.PAGE_DOWN": {
              actions: ["decrementAreaXChannel"]
            },
            "CHANNEL_SLIDER.ARROW_LEFT": {
              actions: ["decrementChannel"]
            },
            "CHANNEL_SLIDER.ARROW_RIGHT": {
              actions: ["incrementChannel"]
            },
            "CHANNEL_SLIDER.ARROW_UP": {
              actions: ["incrementChannel"]
            },
            "CHANNEL_SLIDER.ARROW_DOWN": {
              actions: ["decrementChannel"]
            },
            "CHANNEL_SLIDER.PAGE_UP": {
              actions: ["incrementChannel"]
            },
            "CHANNEL_SLIDER.PAGE_DOWN": {
              actions: ["decrementChannel"]
            },
            "CHANNEL_SLIDER.HOME": {
              actions: ["setChannelToMin"]
            },
            "CHANNEL_SLIDER.END": {
              actions: ["setChannelToMax"]
            },
            "CHANNEL_INPUT.BLUR": {
              actions: ["setChannelColorFromInput"]
            },
            INTERACT_OUTSIDE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["invokeOnClose", "setReturnFocus"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            "SWATCH_TRIGGER.CLICK": [
              {
                guard: and3("isOpenControlled", "closeOnSelect"),
                actions: ["setValue", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["setValue", "invokeOnClose", "setReturnFocus"]
              },
              {
                actions: ["setValue"]
              }
            ]
          }
        },
        "open:dragging": {
          tags: ["open"],
          exit: ["clearActiveChannel"],
          activities: ["trackPointerMove", "disableTextSelection", "trackPositioning", "trackDismissableElement"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["setReturnFocus"]
              },
              {
                target: "idle"
              }
            ],
            "AREA.POINTER_MOVE": {
              actions: ["setAreaColorFromPoint", "focusAreaThumb"]
            },
            "AREA.POINTER_UP": {
              target: "open",
              actions: ["invokeOnChangeEnd"]
            },
            "CHANNEL_SLIDER.POINTER_MOVE": {
              actions: ["setChannelColorFromPoint", "focusChannelThumb"]
            },
            "CHANNEL_SLIDER.POINTER_UP": {
              target: "open",
              actions: ["invokeOnChangeEnd"]
            },
            INTERACT_OUTSIDE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["invokeOnClose", "setReturnFocus"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        closeOnSelect: (ctx2) => !!ctx2.closeOnSelect,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        shouldRestoreFocus: (ctx2) => !!ctx2.restoreFocus
      },
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement || (ctx2.currentPlacement = ctx2.positioning.placement);
          const anchorEl = dom3.getTriggerEl(ctx2);
          const getPositionerEl = () => dom3.getPositionerEl(ctx2);
          return getPlacement(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom3.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            exclude: dom3.getTriggerEl(ctx2),
            defer: true,
            onInteractOutside(event) {
              var _a8;
              (_a8 = ctx2.onInteractOutside) == null ? void 0 : _a8.call(ctx2, event);
              if (event.defaultPrevented) return;
              ctx2.restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
            },
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onFocusOutside: ctx2.onFocusOutside,
            onDismiss() {
              send({ type: "INTERACT_OUTSIDE" });
            }
          });
        },
        trackFormControl(ctx2, _evt, { send, initialContext }) {
          const inputEl = dom3.getHiddenInputEl(ctx2);
          return trackFormControl(inputEl, {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "VALUE.SET", value: initialContext.value, src: "form.reset" });
            }
          });
        },
        trackPointerMove(ctx2, evt, { send }) {
          return trackPointerMove(dom3.getDoc(ctx2), {
            onPointerMove({ point }) {
              const type = ctx2.activeId === "area" ? "AREA.POINTER_MOVE" : "CHANNEL_SLIDER.POINTER_MOVE";
              send({ type, point, format: evt.format });
            },
            onPointerUp() {
              const type = ctx2.activeId === "area" ? "AREA.POINTER_UP" : "CHANNEL_SLIDER.POINTER_UP";
              send({ type });
            }
          });
        },
        disableTextSelection(ctx2) {
          return disableTextSelection({ doc: dom3.getDoc(ctx2), target: dom3.getContentEl(ctx2) });
        }
      },
      actions: {
        openEyeDropper(ctx2) {
          const isSupported = "EyeDropper" in dom3.getWin(ctx2);
          if (!isSupported) return;
          const win = dom3.getWin(ctx2);
          const picker = new win.EyeDropper();
          picker.open().then(({ sRGBHex }) => {
            var _a8;
            const format = ctx2.value.getFormat();
            const color = parseColor(sRGBHex).toFormat(format);
            set4.value(ctx2, color);
            (_a8 = ctx2.onValueChangeEnd) == null ? void 0 : _a8.call(ctx2, { value: ctx2.value, valueAsString: ctx2.valueAsString });
          }).catch(() => void 0);
        },
        setActiveChannel(ctx2, evt) {
          ctx2.activeId = evt.id;
          if (evt.channel) ctx2.activeChannel = evt.channel;
          if (evt.orientation) ctx2.activeOrientation = evt.orientation;
        },
        clearActiveChannel(ctx2) {
          ctx2.activeChannel = null;
          ctx2.activeId = null;
          ctx2.activeOrientation = null;
        },
        setAreaColorFromPoint(ctx2, evt) {
          const normalizedValue = evt.format ? ctx2.value.toFormat(evt.format) : ctx2.areaValue;
          const { xChannel, yChannel } = evt.channel || ctx2.activeChannel;
          const percent = dom3.getAreaValueFromPoint(ctx2, evt.point);
          if (!percent) return;
          const xValue = normalizedValue.getChannelPercentValue(xChannel, percent.x);
          const yValue = normalizedValue.getChannelPercentValue(yChannel, 1 - percent.y);
          const color = normalizedValue.withChannelValue(xChannel, xValue).withChannelValue(yChannel, yValue);
          set4.value(ctx2, color);
        },
        setChannelColorFromPoint(ctx2, evt) {
          const channel = evt.channel || ctx2.activeId;
          const normalizedValue = evt.format ? ctx2.value.toFormat(evt.format) : ctx2.areaValue;
          const percent = dom3.getChannelSliderValueFromPoint(ctx2, evt.point, channel);
          if (!percent) return;
          const orientation = ctx2.activeOrientation || "horizontal";
          const channelPercent = orientation === "horizontal" ? percent.x : percent.y;
          const value = normalizedValue.getChannelPercentValue(channel, channelPercent);
          const color = normalizedValue.withChannelValue(channel, value);
          set4.value(ctx2, color);
        },
        setValue(ctx2, evt) {
          set4.value(ctx2, evt.value);
        },
        setFormat(ctx2, evt) {
          set4.format(ctx2, evt.format);
        },
        syncInputElements(ctx2) {
          sync.inputs(ctx2);
        },
        invokeOnChangeEnd(ctx2) {
          invoke2.changeEnd(ctx2);
        },
        setChannelColorFromInput(ctx2, evt) {
          const { channel, isTextField, value } = evt;
          const currentAlpha = ctx2.value.getChannelValue("alpha");
          let color;
          if (channel === "alpha") {
            let valueAsNumber = parseFloat(value);
            valueAsNumber = Number.isNaN(valueAsNumber) ? currentAlpha : valueAsNumber;
            color = ctx2.value.withChannelValue("alpha", valueAsNumber);
          } else if (isTextField) {
            color = tryCatch(
              () => parse2(value).withChannelValue("alpha", currentAlpha),
              () => ctx2.value
            );
          } else {
            const current = ctx2.value.toFormat(ctx2.format);
            const valueAsNumber = Number.isNaN(value) ? current.getChannelValue(channel) : value;
            color = current.withChannelValue(channel, valueAsNumber);
          }
          sync.inputs(ctx2, color);
          set4.value(ctx2, color);
        },
        incrementChannel(ctx2, evt) {
          const color = ctx2.value.incrementChannel(evt.channel, evt.step);
          set4.value(ctx2, color);
        },
        decrementChannel(ctx2, evt) {
          const color = ctx2.value.decrementChannel(evt.channel, evt.step);
          set4.value(ctx2, color);
        },
        incrementAreaXChannel(ctx2, evt) {
          const { xChannel } = evt.channel;
          const color = ctx2.areaValue.incrementChannel(xChannel, evt.step);
          set4.value(ctx2, color);
        },
        decrementAreaXChannel(ctx2, evt) {
          const { xChannel } = evt.channel;
          const color = ctx2.areaValue.decrementChannel(xChannel, evt.step);
          set4.value(ctx2, color);
        },
        incrementAreaYChannel(ctx2, evt) {
          const { yChannel } = evt.channel;
          const color = ctx2.areaValue.incrementChannel(yChannel, evt.step);
          set4.value(ctx2, color);
        },
        decrementAreaYChannel(ctx2, evt) {
          const { yChannel } = evt.channel;
          const color = ctx2.areaValue.decrementChannel(yChannel, evt.step);
          set4.value(ctx2, color);
        },
        setChannelToMax(ctx2, evt) {
          const range2 = ctx2.value.getChannelRange(evt.channel);
          const color = ctx2.value.withChannelValue(evt.channel, range2.maxValue);
          set4.value(ctx2, color);
        },
        setChannelToMin(ctx2, evt) {
          const range2 = ctx2.value.getChannelRange(evt.channel);
          const color = ctx2.value.withChannelValue(evt.channel, range2.minValue);
          set4.value(ctx2, color);
        },
        focusAreaThumb(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom3.getAreaThumbEl(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        focusChannelThumb(ctx2, evt) {
          raf(() => {
            var _a8;
            (_a8 = dom3.getChannelSliderThumbEl(ctx2, evt.channel)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        setInitialFocus(ctx2) {
          if (!ctx2.openAutoFocus) return;
          raf(() => {
            const element = getInitialFocus({
              root: dom3.getContentEl(ctx2),
              getInitialEl: ctx2.initialFocusEl
            });
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        setReturnFocus(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom3.getTriggerEl(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        syncFormatSelectElement(ctx2) {
          sync.formatSelect(ctx2);
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      },
      compareFns: {
        value: (a2, b2) => a2.isEqual(b2)
      }
    }
  );
}
var sync = {
  // sync channel inputs
  inputs(ctx, color) {
    const channelInputs = dom3.getChannelInputEls(ctx);
    raf(() => {
      channelInputs.forEach((inputEl) => {
        const channel = inputEl.dataset.channel;
        dom3.setValue(inputEl, getChannelValue(color || ctx.value, channel));
      });
    });
  },
  // sync format select
  formatSelect(ctx) {
    const selectEl = dom3.getFormatSelectEl(ctx);
    raf(() => {
      dom3.setValue(selectEl, ctx.format);
    });
  }
};
var invoke2 = {
  changeEnd(ctx) {
    var _a8;
    const value = ctx.value.toFormat(ctx.format);
    (_a8 = ctx.onValueChangeEnd) == null ? void 0 : _a8.call(ctx, {
      value,
      valueAsString: ctx.valueAsString
    });
  },
  change(ctx) {
    var _a8;
    const value = ctx.value.toFormat(ctx.format);
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, {
      value,
      valueAsString: ctx.valueAsString
    });
    dispatchInputValueEvent(dom3.getHiddenInputEl(ctx), { value: ctx.valueAsString });
  },
  formatChange(ctx) {
    var _a8;
    (_a8 = ctx.onFormatChange) == null ? void 0 : _a8.call(ctx, { format: ctx.format });
  }
};
var set4 = {
  value(ctx, color) {
    if (!color || ctx.value.isEqual(color)) return;
    ctx.value = color;
    invoke2.change(ctx);
  },
  format(ctx, format) {
    if (ctx.format === format) return;
    ctx.format = format;
    invoke2.formatChange(ctx);
  }
};

// node_modules/@internationalized/date/dist/utils.mjs
function $2b4dce13dd5a17fa$export$842a2cf37af977e1(amount, numerator) {
  return amount - numerator * Math.floor(amount / numerator);
}

// node_modules/@internationalized/date/dist/GregorianCalendar.mjs
var $3b62074eb05584b2$var$EPOCH = 1721426;
function $3b62074eb05584b2$export$f297eb839006d339(era, year, month, day) {
  year = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year);
  let y1 = year - 1;
  let monthOffset = -2;
  if (month <= 2) monthOffset = 0;
  else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) monthOffset = -1;
  return $3b62074eb05584b2$var$EPOCH - 1 + 365 * y1 + Math.floor(y1 / 4) - Math.floor(y1 / 100) + Math.floor(y1 / 400) + Math.floor((367 * month - 362) / 12 + monthOffset + day);
}
function $3b62074eb05584b2$export$553d7fa8e3805fc0(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year) {
  return era === "BC" ? 1 - year : year;
}
function $3b62074eb05584b2$export$4475b7e617eb123c(year) {
  let era = "AD";
  if (year <= 0) {
    era = "BC";
    year = 1 - year;
  }
  return [
    era,
    year
  ];
}
var $3b62074eb05584b2$var$daysInMonth = {
  standard: [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ],
  leapyear: [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ]
};
var $3b62074eb05584b2$export$80ee6245ec4f29ec = class {
  fromJulianDay(jd) {
    let jd0 = jd;
    let depoch = jd0 - $3b62074eb05584b2$var$EPOCH;
    let quadricent = Math.floor(depoch / 146097);
    let dqc = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(depoch, 146097);
    let cent = Math.floor(dqc / 36524);
    let dcent = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(dqc, 36524);
    let quad = Math.floor(dcent / 1461);
    let dquad = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(dcent, 1461);
    let yindex = Math.floor(dquad / 365);
    let extendedYear = quadricent * 400 + cent * 100 + quad * 4 + yindex + (cent !== 4 && yindex !== 4 ? 1 : 0);
    let [era, year] = $3b62074eb05584b2$export$4475b7e617eb123c(extendedYear);
    let yearDay = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, 1, 1);
    let leapAdj = 2;
    if (jd0 < $3b62074eb05584b2$export$f297eb839006d339(era, year, 3, 1)) leapAdj = 0;
    else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) leapAdj = 1;
    let month = Math.floor(((yearDay + leapAdj) * 12 + 373) / 367);
    let day = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, month, 1) + 1;
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(era, year, month, day);
  }
  toJulianDay(date) {
    return $3b62074eb05584b2$export$f297eb839006d339(date.era, date.year, date.month, date.day);
  }
  getDaysInMonth(date) {
    return $3b62074eb05584b2$var$daysInMonth[$3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? "leapyear" : "standard"][date.month - 1];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getMonthsInYear(date) {
    return 12;
  }
  getDaysInYear(date) {
    return $3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? 366 : 365;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearsInEra(date) {
    return 9999;
  }
  getEras() {
    return [
      "BC",
      "AD"
    ];
  }
  isInverseEra(date) {
    return date.era === "BC";
  }
  balanceDate(date) {
    if (date.year <= 0) {
      date.era = date.era === "BC" ? "AD" : "BC";
      date.year = 1 - date.year;
    }
  }
  constructor() {
    this.identifier = "gregory";
  }
};

// node_modules/@internationalized/date/dist/weekStartData.mjs
var $2fe286d2fb449abb$export$7a5acbd77d414bd9 = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BY: 1,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  HR: 1,
  HU: 1,
  IE: 1,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JO: 6,
  KG: 1,
  KW: 6,
  KZ: 1,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MK: 1,
  MN: 1,
  MQ: 1,
  MV: 5,
  MY: 1,
  NL: 1,
  NO: 1,
  NZ: 1,
  OM: 6,
  PL: 1,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SD: 6,
  SE: 1,
  SI: 1,
  SK: 1,
  SM: 1,
  SY: 6,
  TJ: 1,
  TM: 1,
  TR: 1,
  UA: 1,
  UY: 1,
  UZ: 1,
  VA: 1,
  VN: 1,
  XK: 1
};

// node_modules/@internationalized/date/dist/queries.mjs
function $14e0f24ef4ac5c92$export$ea39ec197993aef0(a2, b2) {
  b2 = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(b2, a2.calendar);
  return a2.era === b2.era && a2.year === b2.year && a2.month === b2.month && a2.day === b2.day;
}
function $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(a2, b2) {
  return a2.calendar.identifier === b2.calendar.identifier && a2.era === b2.era && a2.year === b2.year && a2.month === b2.month && a2.day === b2.day;
}
function $14e0f24ef4ac5c92$export$629b0a497aa65267(date, timeZone) {
  return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone));
}
var $14e0f24ef4ac5c92$var$DAY_MAP = {
  sun: 0,
  mon: 1,
  tue: 2,
  wed: 3,
  thu: 4,
  fri: 5,
  sat: 6
};
function $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale, firstDayOfWeek) {
  let julian = date.calendar.toJulianDay(date);
  let weekStart = firstDayOfWeek ? $14e0f24ef4ac5c92$var$DAY_MAP[firstDayOfWeek] : $14e0f24ef4ac5c92$var$getWeekStart(locale);
  let dayOfWeek = Math.ceil(julian + 1 - weekStart) % 7;
  if (dayOfWeek < 0) dayOfWeek += 7;
  return dayOfWeek;
}
function $14e0f24ef4ac5c92$export$461939dd4422153(timeZone) {
  return (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(Date.now(), timeZone);
}
function $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone) {
  return (0, $11d87f3f76e88657$export$93522d1a439f3617)($14e0f24ef4ac5c92$export$461939dd4422153(timeZone));
}
function $14e0f24ef4ac5c92$export$68781ddf31c0090f(a2, b2) {
  return a2.calendar.toJulianDay(a2) - b2.calendar.toJulianDay(b2);
}
function $14e0f24ef4ac5c92$export$c19a80a9721b80f6(a2, b2) {
  return $14e0f24ef4ac5c92$var$timeToMs(a2) - $14e0f24ef4ac5c92$var$timeToMs(b2);
}
function $14e0f24ef4ac5c92$var$timeToMs(a2) {
  return a2.hour * 36e5 + a2.minute * 6e4 + a2.second * 1e3 + a2.millisecond;
}
var $14e0f24ef4ac5c92$var$localTimeZone = null;
function $14e0f24ef4ac5c92$export$aa8b41735afcabd2() {
  if ($14e0f24ef4ac5c92$var$localTimeZone == null) $14e0f24ef4ac5c92$var$localTimeZone = new Intl.DateTimeFormat().resolvedOptions().timeZone;
  return $14e0f24ef4ac5c92$var$localTimeZone;
}
function $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date) {
  return date.subtract({
    days: date.day - 1
  });
}
function $14e0f24ef4ac5c92$export$a2258d9c4118825c(date) {
  return date.add({
    days: date.calendar.getDaysInMonth(date) - date.day
  });
}
function $14e0f24ef4ac5c92$export$f91e89d3d0406102(date) {
  return $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date.subtract({
    months: date.month - 1
  }));
}
function $14e0f24ef4ac5c92$export$8b7aa55c66d5569e(date) {
  return $14e0f24ef4ac5c92$export$a2258d9c4118825c(date.add({
    months: date.calendar.getMonthsInYear(date) - date.month
  }));
}
function $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale, firstDayOfWeek) {
  let dayOfWeek = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale, firstDayOfWeek);
  return date.subtract({
    days: dayOfWeek
  });
}
function $14e0f24ef4ac5c92$export$ef8b6d9133084f4e(date, locale, firstDayOfWeek) {
  return $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale, firstDayOfWeek).add({
    days: 6
  });
}
var $14e0f24ef4ac5c92$var$cachedRegions = /* @__PURE__ */ new Map();
function $14e0f24ef4ac5c92$var$getRegion(locale) {
  if (Intl.Locale) {
    let region = $14e0f24ef4ac5c92$var$cachedRegions.get(locale);
    if (!region) {
      region = new Intl.Locale(locale).maximize().region;
      if (region) $14e0f24ef4ac5c92$var$cachedRegions.set(locale, region);
    }
    return region;
  }
  let part = locale.split("-")[1];
  return part === "u" ? void 0 : part;
}
function $14e0f24ef4ac5c92$var$getWeekStart(locale) {
  let region = $14e0f24ef4ac5c92$var$getRegion(locale);
  return region ? (0, $2fe286d2fb449abb$export$7a5acbd77d414bd9)[region] || 0 : 0;
}
function $14e0f24ef4ac5c92$export$ccc1b2479e7dd654(date, locale, firstDayOfWeek) {
  let days = date.calendar.getDaysInMonth(date);
  return Math.ceil(($14e0f24ef4ac5c92$export$2061056d06d7cdf7($14e0f24ef4ac5c92$export$a5a3b454ada2268e(date), locale, firstDayOfWeek) + days) / 7);
}
function $14e0f24ef4ac5c92$export$5c333a116e949cdd(a2, b2) {
  if (a2 && b2) return a2.compare(b2) <= 0 ? a2 : b2;
  return a2 || b2;
}
function $14e0f24ef4ac5c92$export$a75f2bff57811055(a2, b2) {
  if (a2 && b2) return a2.compare(b2) >= 0 ? a2 : b2;
  return a2 || b2;
}
var $14e0f24ef4ac5c92$var$WEEKEND_DATA = {
  AF: [
    4,
    5
  ],
  AE: [
    5,
    6
  ],
  BH: [
    5,
    6
  ],
  DZ: [
    5,
    6
  ],
  EG: [
    5,
    6
  ],
  IL: [
    5,
    6
  ],
  IQ: [
    5,
    6
  ],
  IR: [
    5,
    5
  ],
  JO: [
    5,
    6
  ],
  KW: [
    5,
    6
  ],
  LY: [
    5,
    6
  ],
  OM: [
    5,
    6
  ],
  QA: [
    5,
    6
  ],
  SA: [
    5,
    6
  ],
  SD: [
    5,
    6
  ],
  SY: [
    5,
    6
  ],
  YE: [
    5,
    6
  ]
};
function $14e0f24ef4ac5c92$export$618d60ea299da42(date, locale) {
  let julian = date.calendar.toJulianDay(date);
  let dayOfWeek = Math.ceil(julian + 1) % 7;
  if (dayOfWeek < 0) dayOfWeek += 7;
  let region = $14e0f24ef4ac5c92$var$getRegion(locale);
  let [start, end] = $14e0f24ef4ac5c92$var$WEEKEND_DATA[region] || [
    6,
    0
  ];
  return dayOfWeek === start || dayOfWeek === end;
}

// node_modules/@internationalized/date/dist/conversion.mjs
function $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) {
  date = $11d87f3f76e88657$export$b4a036af3fc0b032(date, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
  let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(date.era, date.year);
  return $11d87f3f76e88657$var$epochFromParts(year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);
}
function $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, millisecond) {
  let date = /* @__PURE__ */ new Date();
  date.setUTCHours(hour, minute, second, millisecond);
  date.setUTCFullYear(year, month - 1, day);
  return date.getTime();
}
function $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone) {
  if (timeZone === "UTC") return 0;
  if (ms > 0 && timeZone === (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)()) return new Date(ms).getTimezoneOffset() * -6e4;
  let { year, month, day, hour, minute, second } = $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone);
  let utc = $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, 0);
  return utc - Math.floor(ms / 1e3) * 1e3;
}
var $11d87f3f76e88657$var$formattersByTimeZone = /* @__PURE__ */ new Map();
function $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone) {
  let formatter = $11d87f3f76e88657$var$formattersByTimeZone.get(timeZone);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat("en-US", {
      timeZone,
      hour12: false,
      era: "short",
      year: "numeric",
      month: "numeric",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric"
    });
    $11d87f3f76e88657$var$formattersByTimeZone.set(timeZone, formatter);
  }
  let parts42 = formatter.formatToParts(new Date(ms));
  let namedParts = {};
  for (let part of parts42) if (part.type !== "literal") namedParts[part.type] = part.value;
  return {
    // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
    year: namedParts.era === "BC" || namedParts.era === "B" ? -namedParts.year + 1 : +namedParts.year,
    month: +namedParts.month,
    day: +namedParts.day,
    hour: namedParts.hour === "24" ? 0 : +namedParts.hour,
    minute: +namedParts.minute,
    second: +namedParts.second
  };
}
var $11d87f3f76e88657$var$DAYMILLIS = 864e5;
function $11d87f3f76e88657$var$getValidWallTimes(date, timeZone, earlier, later) {
  let found = earlier === later ? [
    earlier
  ] : [
    earlier,
    later
  ];
  return found.filter((absolute) => $11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute));
}
function $11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute) {
  let parts42 = $11d87f3f76e88657$var$getTimeZoneParts(absolute, timeZone);
  return date.year === parts42.year && date.month === parts42.month && date.day === parts42.day && date.hour === parts42.hour && date.minute === parts42.minute && date.second === parts42.second;
}
function $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation = "compatible") {
  let dateTime = $11d87f3f76e88657$export$b21e0b124e224484(date);
  if (timeZone === "UTC") return $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);
  if (timeZone === (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)() && disambiguation === "compatible") {
    dateTime = $11d87f3f76e88657$export$b4a036af3fc0b032(dateTime, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
    let date2 = /* @__PURE__ */ new Date();
    let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(dateTime.era, dateTime.year);
    date2.setFullYear(year, dateTime.month - 1, dateTime.day);
    date2.setHours(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);
    return date2.getTime();
  }
  let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);
  let offsetBefore = $11d87f3f76e88657$export$59c99f3515d3493f(ms - $11d87f3f76e88657$var$DAYMILLIS, timeZone);
  let offsetAfter = $11d87f3f76e88657$export$59c99f3515d3493f(ms + $11d87f3f76e88657$var$DAYMILLIS, timeZone);
  let valid = $11d87f3f76e88657$var$getValidWallTimes(dateTime, timeZone, ms - offsetBefore, ms - offsetAfter);
  if (valid.length === 1) return valid[0];
  if (valid.length > 1) switch (disambiguation) {
    // 'compatible' means 'earlier' for "fall back" transitions
    case "compatible":
    case "earlier":
      return valid[0];
    case "later":
      return valid[valid.length - 1];
    case "reject":
      throw new RangeError("Multiple possible absolute times found");
  }
  switch (disambiguation) {
    case "earlier":
      return Math.min(ms - offsetBefore, ms - offsetAfter);
    // 'compatible' means 'later' for "spring forward" transitions
    case "compatible":
    case "later":
      return Math.max(ms - offsetBefore, ms - offsetAfter);
    case "reject":
      throw new RangeError("No such absolute time found");
  }
}
function $11d87f3f76e88657$export$e67a095c620b86fe(dateTime, timeZone, disambiguation = "compatible") {
  return new Date($11d87f3f76e88657$export$5107c82f94518f5c(dateTime, timeZone, disambiguation));
}
function $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone) {
  let offset3 = $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone);
  let date = new Date(ms + offset3);
  let year = date.getUTCFullYear();
  let month = date.getUTCMonth() + 1;
  let day = date.getUTCDate();
  let hour = date.getUTCHours();
  let minute = date.getUTCMinutes();
  let second = date.getUTCSeconds();
  let millisecond = date.getUTCMilliseconds();
  return new (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)(year < 1 ? "BC" : "AD", year < 1 ? -year + 1 : year, month, day, timeZone, offset3, hour, minute, second, millisecond);
}
function $11d87f3f76e88657$export$93522d1a439f3617(dateTime) {
  return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(dateTime.calendar, dateTime.era, dateTime.year, dateTime.month, dateTime.day);
}
function $11d87f3f76e88657$export$b21e0b124e224484(date, time) {
  let hour = 0, minute = 0, second = 0, millisecond = 0;
  if ("timeZone" in date) ({ hour, minute, second, millisecond } = date);
  else if ("hour" in date && !time) return date;
  if (time) ({ hour, minute, second, millisecond } = time);
  return new (0, $35ea8db9cb2ccb90$export$ca871e8dbb80966f)(date.calendar, date.era, date.year, date.month, date.day, hour, minute, second, millisecond);
}
function $11d87f3f76e88657$export$b4a036af3fc0b032(date, calendar) {
  if (date.calendar.identifier === calendar.identifier) return date;
  let calendarDate = calendar.fromJulianDay(date.calendar.toJulianDay(date));
  let copy2 = date.copy();
  copy2.calendar = calendar;
  copy2.era = calendarDate.era;
  copy2.year = calendarDate.year;
  copy2.month = calendarDate.month;
  copy2.day = calendarDate.day;
  (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(copy2);
  return copy2;
}
function $11d87f3f76e88657$export$84c95a83c799e074(date, timeZone, disambiguation) {
  if (date instanceof (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)) {
    if (date.timeZone === timeZone) return date;
    return $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone);
  }
  let ms = $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation);
  return $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone);
}
function $11d87f3f76e88657$export$83aac07b4c37b25(date) {
  let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
  return new Date(ms);
}
function $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone) {
  let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
  return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone), date.calendar);
}

// node_modules/@internationalized/date/dist/manipulation.mjs
var $735220c2d4774dd3$var$ONE_HOUR = 36e5;
function $735220c2d4774dd3$export$e16d8520af44a096(date, duration) {
  let mutableDate = date.copy();
  let days = "hour" in mutableDate ? $735220c2d4774dd3$var$addTimeFields(mutableDate, duration) : 0;
  $735220c2d4774dd3$var$addYears(mutableDate, duration.years || 0);
  if (mutableDate.calendar.balanceYearMonth) mutableDate.calendar.balanceYearMonth(mutableDate, date);
  mutableDate.month += duration.months || 0;
  $735220c2d4774dd3$var$balanceYearMonth(mutableDate);
  $735220c2d4774dd3$var$constrainMonthDay(mutableDate);
  mutableDate.day += (duration.weeks || 0) * 7;
  mutableDate.day += duration.days || 0;
  mutableDate.day += days;
  $735220c2d4774dd3$var$balanceDay(mutableDate);
  if (mutableDate.calendar.balanceDate) mutableDate.calendar.balanceDate(mutableDate);
  if (mutableDate.year < 1) {
    mutableDate.year = 1;
    mutableDate.month = 1;
    mutableDate.day = 1;
  }
  let maxYear = mutableDate.calendar.getYearsInEra(mutableDate);
  if (mutableDate.year > maxYear) {
    var _mutableDate_calendar_isInverseEra, _mutableDate_calendar;
    let isInverseEra = (_mutableDate_calendar_isInverseEra = (_mutableDate_calendar = mutableDate.calendar).isInverseEra) === null || _mutableDate_calendar_isInverseEra === void 0 ? void 0 : _mutableDate_calendar_isInverseEra.call(_mutableDate_calendar, mutableDate);
    mutableDate.year = maxYear;
    mutableDate.month = isInverseEra ? 1 : mutableDate.calendar.getMonthsInYear(mutableDate);
    mutableDate.day = isInverseEra ? 1 : mutableDate.calendar.getDaysInMonth(mutableDate);
  }
  if (mutableDate.month < 1) {
    mutableDate.month = 1;
    mutableDate.day = 1;
  }
  let maxMonth = mutableDate.calendar.getMonthsInYear(mutableDate);
  if (mutableDate.month > maxMonth) {
    mutableDate.month = maxMonth;
    mutableDate.day = mutableDate.calendar.getDaysInMonth(mutableDate);
  }
  mutableDate.day = Math.max(1, Math.min(mutableDate.calendar.getDaysInMonth(mutableDate), mutableDate.day));
  return mutableDate;
}
function $735220c2d4774dd3$var$addYears(date, years) {
  var _date_calendar_isInverseEra, _date_calendar;
  if ((_date_calendar_isInverseEra = (_date_calendar = date.calendar).isInverseEra) === null || _date_calendar_isInverseEra === void 0 ? void 0 : _date_calendar_isInverseEra.call(_date_calendar, date)) years = -years;
  date.year += years;
}
function $735220c2d4774dd3$var$balanceYearMonth(date) {
  while (date.month < 1) {
    $735220c2d4774dd3$var$addYears(date, -1);
    date.month += date.calendar.getMonthsInYear(date);
  }
  let monthsInYear = 0;
  while (date.month > (monthsInYear = date.calendar.getMonthsInYear(date))) {
    date.month -= monthsInYear;
    $735220c2d4774dd3$var$addYears(date, 1);
  }
}
function $735220c2d4774dd3$var$balanceDay(date) {
  while (date.day < 1) {
    date.month--;
    $735220c2d4774dd3$var$balanceYearMonth(date);
    date.day += date.calendar.getDaysInMonth(date);
  }
  while (date.day > date.calendar.getDaysInMonth(date)) {
    date.day -= date.calendar.getDaysInMonth(date);
    date.month++;
    $735220c2d4774dd3$var$balanceYearMonth(date);
  }
}
function $735220c2d4774dd3$var$constrainMonthDay(date) {
  date.month = Math.max(1, Math.min(date.calendar.getMonthsInYear(date), date.month));
  date.day = Math.max(1, Math.min(date.calendar.getDaysInMonth(date), date.day));
}
function $735220c2d4774dd3$export$c4e2ecac49351ef2(date) {
  if (date.calendar.constrainDate) date.calendar.constrainDate(date);
  date.year = Math.max(1, Math.min(date.calendar.getYearsInEra(date), date.year));
  $735220c2d4774dd3$var$constrainMonthDay(date);
}
function $735220c2d4774dd3$export$3e2544e88a25bff8(duration) {
  let inverseDuration = {};
  for (let key in duration) if (typeof duration[key] === "number") inverseDuration[key] = -duration[key];
  return inverseDuration;
}
function $735220c2d4774dd3$export$4e2d2ead65e5f7e3(date, duration) {
  return $735220c2d4774dd3$export$e16d8520af44a096(date, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$adaa4cf7ef1b65be(date, fields) {
  let mutableDate = date.copy();
  if (fields.era != null) mutableDate.era = fields.era;
  if (fields.year != null) mutableDate.year = fields.year;
  if (fields.month != null) mutableDate.month = fields.month;
  if (fields.day != null) mutableDate.day = fields.day;
  $735220c2d4774dd3$export$c4e2ecac49351ef2(mutableDate);
  return mutableDate;
}
function $735220c2d4774dd3$export$e5d5e1c1822b6e56(value, fields) {
  let mutableValue = value.copy();
  if (fields.hour != null) mutableValue.hour = fields.hour;
  if (fields.minute != null) mutableValue.minute = fields.minute;
  if (fields.second != null) mutableValue.second = fields.second;
  if (fields.millisecond != null) mutableValue.millisecond = fields.millisecond;
  $735220c2d4774dd3$export$7555de1e070510cb(mutableValue);
  return mutableValue;
}
function $735220c2d4774dd3$var$balanceTime(time) {
  time.second += Math.floor(time.millisecond / 1e3);
  time.millisecond = $735220c2d4774dd3$var$nonNegativeMod(time.millisecond, 1e3);
  time.minute += Math.floor(time.second / 60);
  time.second = $735220c2d4774dd3$var$nonNegativeMod(time.second, 60);
  time.hour += Math.floor(time.minute / 60);
  time.minute = $735220c2d4774dd3$var$nonNegativeMod(time.minute, 60);
  let days = Math.floor(time.hour / 24);
  time.hour = $735220c2d4774dd3$var$nonNegativeMod(time.hour, 24);
  return days;
}
function $735220c2d4774dd3$export$7555de1e070510cb(time) {
  time.millisecond = Math.max(0, Math.min(time.millisecond, 1e3));
  time.second = Math.max(0, Math.min(time.second, 59));
  time.minute = Math.max(0, Math.min(time.minute, 59));
  time.hour = Math.max(0, Math.min(time.hour, 23));
}
function $735220c2d4774dd3$var$nonNegativeMod(a2, b2) {
  let result = a2 % b2;
  if (result < 0) result += b2;
  return result;
}
function $735220c2d4774dd3$var$addTimeFields(time, duration) {
  time.hour += duration.hours || 0;
  time.minute += duration.minutes || 0;
  time.second += duration.seconds || 0;
  time.millisecond += duration.milliseconds || 0;
  return $735220c2d4774dd3$var$balanceTime(time);
}
function $735220c2d4774dd3$export$7ed87b6bc2506470(time, duration) {
  let res = time.copy();
  $735220c2d4774dd3$var$addTimeFields(res, duration);
  return res;
}
function $735220c2d4774dd3$export$fe34d3a381cd7501(time, duration) {
  return $735220c2d4774dd3$export$7ed87b6bc2506470(time, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$d52ced6badfb9a4c(value, field, amount, options) {
  let mutable = value.copy();
  switch (field) {
    case "era": {
      let eras = value.calendar.getEras();
      let eraIndex = eras.indexOf(value.era);
      if (eraIndex < 0) throw new Error("Invalid era: " + value.era);
      eraIndex = $735220c2d4774dd3$var$cycleValue(eraIndex, amount, 0, eras.length - 1, options === null || options === void 0 ? void 0 : options.round);
      mutable.era = eras[eraIndex];
      $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);
      break;
    }
    case "year":
      var _mutable_calendar_isInverseEra, _mutable_calendar;
      if ((_mutable_calendar_isInverseEra = (_mutable_calendar = mutable.calendar).isInverseEra) === null || _mutable_calendar_isInverseEra === void 0 ? void 0 : _mutable_calendar_isInverseEra.call(_mutable_calendar, mutable)) amount = -amount;
      mutable.year = $735220c2d4774dd3$var$cycleValue(value.year, amount, -Infinity, 9999, options === null || options === void 0 ? void 0 : options.round);
      if (mutable.year === -Infinity) mutable.year = 1;
      if (mutable.calendar.balanceYearMonth) mutable.calendar.balanceYearMonth(mutable, value);
      break;
    case "month":
      mutable.month = $735220c2d4774dd3$var$cycleValue(value.month, amount, 1, value.calendar.getMonthsInYear(value), options === null || options === void 0 ? void 0 : options.round);
      break;
    case "day":
      mutable.day = $735220c2d4774dd3$var$cycleValue(value.day, amount, 1, value.calendar.getDaysInMonth(value), options === null || options === void 0 ? void 0 : options.round);
      break;
    default:
      throw new Error("Unsupported field " + field);
  }
  if (value.calendar.balanceDate) value.calendar.balanceDate(mutable);
  $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);
  return mutable;
}
function $735220c2d4774dd3$export$dd02b3e0007dfe28(value, field, amount, options) {
  let mutable = value.copy();
  switch (field) {
    case "hour": {
      let hours = value.hour;
      let min4 = 0;
      let max4 = 23;
      if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
        let isPM = hours >= 12;
        min4 = isPM ? 12 : 0;
        max4 = isPM ? 23 : 11;
      }
      mutable.hour = $735220c2d4774dd3$var$cycleValue(hours, amount, min4, max4, options === null || options === void 0 ? void 0 : options.round);
      break;
    }
    case "minute":
      mutable.minute = $735220c2d4774dd3$var$cycleValue(value.minute, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
      break;
    case "second":
      mutable.second = $735220c2d4774dd3$var$cycleValue(value.second, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
      break;
    case "millisecond":
      mutable.millisecond = $735220c2d4774dd3$var$cycleValue(value.millisecond, amount, 0, 999, options === null || options === void 0 ? void 0 : options.round);
      break;
    default:
      throw new Error("Unsupported field " + field);
  }
  return mutable;
}
function $735220c2d4774dd3$var$cycleValue(value, amount, min4, max4, round3 = false) {
  if (round3) {
    value += Math.sign(amount);
    if (value < min4) value = max4;
    let div = Math.abs(amount);
    if (amount > 0) value = Math.ceil(value / div) * div;
    else value = Math.floor(value / div) * div;
    if (value > max4) value = min4;
  } else {
    value += amount;
    if (value < min4) value = max4 - (min4 - value - 1);
    else if (value > max4) value = min4 + (value - max4 - 1);
  }
  return value;
}
function $735220c2d4774dd3$export$96b1d28349274637(dateTime, duration) {
  let ms;
  if (duration.years != null && duration.years !== 0 || duration.months != null && duration.months !== 0 || duration.weeks != null && duration.weeks !== 0 || duration.days != null && duration.days !== 0) {
    let res2 = $735220c2d4774dd3$export$e16d8520af44a096((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), {
      years: duration.years,
      months: duration.months,
      weeks: duration.weeks,
      days: duration.days
    });
    ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res2, dateTime.timeZone);
  } else
    ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;
  ms += duration.milliseconds || 0;
  ms += (duration.seconds || 0) * 1e3;
  ms += (duration.minutes || 0) * 6e4;
  ms += (duration.hours || 0) * 36e5;
  let res = (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone);
  return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(res, dateTime.calendar);
}
function $735220c2d4774dd3$export$6814caac34ca03c7(dateTime, duration) {
  return $735220c2d4774dd3$export$96b1d28349274637(dateTime, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$9a297d111fc86b79(dateTime, field, amount, options) {
  switch (field) {
    case "hour": {
      let min4 = 0;
      let max4 = 23;
      if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
        let isPM = dateTime.hour >= 12;
        min4 = isPM ? 12 : 0;
        max4 = isPM ? 23 : 11;
      }
      let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);
      let minDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {
        hour: min4
      }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
      let minAbsolute = [
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, "earlier"),
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, "later")
      ].filter((ms2) => (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms2, dateTime.timeZone).day === minDate.day)[0];
      let maxDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {
        hour: max4
      }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
      let maxAbsolute = [
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, "earlier"),
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, "later")
      ].filter((ms2) => (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms2, dateTime.timeZone).day === maxDate.day).pop();
      let ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;
      let hours = Math.floor(ms / $735220c2d4774dd3$var$ONE_HOUR);
      let remainder = ms % $735220c2d4774dd3$var$ONE_HOUR;
      ms = $735220c2d4774dd3$var$cycleValue(hours, amount, Math.floor(minAbsolute / $735220c2d4774dd3$var$ONE_HOUR), Math.floor(maxAbsolute / $735220c2d4774dd3$var$ONE_HOUR), options === null || options === void 0 ? void 0 : options.round) * $735220c2d4774dd3$var$ONE_HOUR + remainder;
      return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
    }
    case "minute":
    case "second":
    case "millisecond":
      return $735220c2d4774dd3$export$dd02b3e0007dfe28(dateTime, field, amount, options);
    case "era":
    case "year":
    case "month":
    case "day": {
      let res = $735220c2d4774dd3$export$d52ced6badfb9a4c((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), field, amount, options);
      let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone);
      return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
    }
    default:
      throw new Error("Unsupported field " + field);
  }
}
function $735220c2d4774dd3$export$31b5430eb18be4f8(dateTime, fields, disambiguation) {
  let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);
  let res = $735220c2d4774dd3$export$e5d5e1c1822b6e56($735220c2d4774dd3$export$adaa4cf7ef1b65be(plainDateTime, fields), fields);
  if (res.compare(plainDateTime) === 0) return dateTime;
  let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone, disambiguation);
  return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
}

// node_modules/@internationalized/date/dist/string.mjs
var $fae977aafc393c5c$var$requiredDurationTimeGroups = [
  "hours",
  "minutes",
  "seconds"
];
var $fae977aafc393c5c$var$requiredDurationGroups = [
  "years",
  "months",
  "weeks",
  "days",
  ...$fae977aafc393c5c$var$requiredDurationTimeGroups
];
function $fae977aafc393c5c$export$f59dee82248f5ad4(time) {
  return `${String(time.hour).padStart(2, "0")}:${String(time.minute).padStart(2, "0")}:${String(time.second).padStart(2, "0")}${time.millisecond ? String(time.millisecond / 1e3).slice(1) : ""}`;
}
function $fae977aafc393c5c$export$60dfd74aa96791bd(date) {
  let gregorianDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(date, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
  let year;
  if (gregorianDate.era === "BC") year = gregorianDate.year === 1 ? "0000" : "-" + String(Math.abs(1 - gregorianDate.year)).padStart(6, "00");
  else year = String(gregorianDate.year).padStart(4, "0");
  return `${year}-${String(gregorianDate.month).padStart(2, "0")}-${String(gregorianDate.day).padStart(2, "0")}`;
}
function $fae977aafc393c5c$export$4223de14708adc63(date) {
  return `${$fae977aafc393c5c$export$60dfd74aa96791bd(date)}T${$fae977aafc393c5c$export$f59dee82248f5ad4(date)}`;
}
function $fae977aafc393c5c$var$offsetToString(offset3) {
  let sign3 = Math.sign(offset3) < 0 ? "-" : "+";
  offset3 = Math.abs(offset3);
  let offsetHours = Math.floor(offset3 / 36e5);
  let offsetMinutes = offset3 % 36e5 / 6e4;
  return `${sign3}${String(offsetHours).padStart(2, "0")}:${String(offsetMinutes).padStart(2, "0")}`;
}
function $fae977aafc393c5c$export$bf79f1ebf4b18792(date) {
  return `${$fae977aafc393c5c$export$4223de14708adc63(date)}${$fae977aafc393c5c$var$offsetToString(date.offset)}[${date.timeZone}]`;
}

// node_modules/@swc/helpers/esm/_check_private_redeclaration.js
function _check_private_redeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

// node_modules/@swc/helpers/esm/_class_private_field_init.js
function _class_private_field_init(obj, privateMap, value) {
  _check_private_redeclaration(obj, privateMap);
  privateMap.set(obj, value);
}

// node_modules/@internationalized/date/dist/CalendarDate.mjs
function $35ea8db9cb2ccb90$var$shiftArgs(args) {
  let calendar = typeof args[0] === "object" ? args.shift() : new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)();
  let era;
  if (typeof args[0] === "string") era = args.shift();
  else {
    let eras = calendar.getEras();
    era = eras[eras.length - 1];
  }
  let year = args.shift();
  let month = args.shift();
  let day = args.shift();
  return [
    calendar,
    era,
    year,
    month,
    day
  ];
}
var $35ea8db9cb2ccb90$var$_type = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$99faa760c7908e4f = class _$35ea8db9cb2ccb90$export$99faa760c7908e4f {
  /** Returns a copy of this date. */
  copy() {
    if (this.era) return new _$35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.era, this.year, this.month, this.day);
    else return new _$35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.year, this.month, this.day);
  }
  /** Returns a new `CalendarDate` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$e16d8520af44a096)(this, duration);
  }
  /** Returns a new `CalendarDate` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);
  }
  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields) {
    return (0, $735220c2d4774dd3$export$adaa4cf7ef1b65be)(this, fields);
  }
  /**
  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    return (0, $735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);
  }
  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
  toDate(timeZone) {
    return (0, $11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return (0, $fae977aafc393c5c$export$60dfd74aa96791bd)(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b2) {
    return (0, $14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b2);
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};
var $35ea8db9cb2ccb90$var$_type1 = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$680ea196effce5f = class _$35ea8db9cb2ccb90$export$680ea196effce5f {
  /** Returns a copy of this time. */
  copy() {
    return new _$35ea8db9cb2ccb90$export$680ea196effce5f(this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `Time` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$7ed87b6bc2506470)(this, duration);
  }
  /** Returns a new `Time` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$fe34d3a381cd7501)(this, duration);
  }
  /** Returns a new `Time` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields) {
    return (0, $735220c2d4774dd3$export$e5d5e1c1822b6e56)(this, fields);
  }
  /**
  * Returns a new `Time` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    return (0, $735220c2d4774dd3$export$dd02b3e0007dfe28)(this, field, amount, options);
  }
  /** Converts the time to an ISO 8601 formatted string. */
  toString() {
    return (0, $fae977aafc393c5c$export$f59dee82248f5ad4)(this);
  }
  /** Compares this time with another. A negative result indicates that this time is before the given one, and a positive time indicates that it is after. */
  compare(b2) {
    return (0, $14e0f24ef4ac5c92$export$c19a80a9721b80f6)(this, b2);
  }
  constructor(hour = 0, minute = 0, second = 0, millisecond = 0) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type1, {
      writable: true,
      value: void 0
    });
    this.hour = hour;
    this.minute = minute;
    this.second = second;
    this.millisecond = millisecond;
    (0, $735220c2d4774dd3$export$7555de1e070510cb)(this);
  }
};
var $35ea8db9cb2ccb90$var$_type2 = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$ca871e8dbb80966f = class _$35ea8db9cb2ccb90$export$ca871e8dbb80966f {
  /** Returns a copy of this date. */
  copy() {
    if (this.era) return new _$35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
    else return new _$35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `CalendarDateTime` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$e16d8520af44a096)(this, duration);
  }
  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);
  }
  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields) {
    return (0, $735220c2d4774dd3$export$adaa4cf7ef1b65be)((0, $735220c2d4774dd3$export$e5d5e1c1822b6e56)(this, fields), fields);
  }
  /**
  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    switch (field) {
      case "era":
      case "year":
      case "month":
      case "day":
        return (0, $735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);
      default:
        return (0, $735220c2d4774dd3$export$dd02b3e0007dfe28)(this, field, amount, options);
    }
  }
  /** Converts the date to a native JavaScript Date object in the given time zone. */
  toDate(timeZone, disambiguation) {
    return (0, $11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone, disambiguation);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return (0, $fae977aafc393c5c$export$4223de14708adc63)(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b2) {
    let res = (0, $14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b2);
    if (res === 0) return (0, $14e0f24ef4ac5c92$export$c19a80a9721b80f6)(this, (0, $11d87f3f76e88657$export$b21e0b124e224484)(b2));
    return res;
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type2, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    this.hour = args.shift() || 0;
    this.minute = args.shift() || 0;
    this.second = args.shift() || 0;
    this.millisecond = args.shift() || 0;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};
var $35ea8db9cb2ccb90$var$_type3 = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$d3b7288e7994edea = class _$35ea8db9cb2ccb90$export$d3b7288e7994edea {
  /** Returns a copy of this date. */
  copy() {
    if (this.era) return new _$35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
    else return new _$35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `ZonedDateTime` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$96b1d28349274637)(this, duration);
  }
  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$6814caac34ca03c7)(this, duration);
  }
  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields, disambiguation) {
    return (0, $735220c2d4774dd3$export$31b5430eb18be4f8)(this, fields, disambiguation);
  }
  /**
  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    return (0, $735220c2d4774dd3$export$9a297d111fc86b79)(this, field, amount, options);
  }
  /** Converts the date to a native JavaScript Date object. */
  toDate() {
    return (0, $11d87f3f76e88657$export$83aac07b4c37b25)(this);
  }
  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
  toString() {
    return (0, $fae977aafc393c5c$export$bf79f1ebf4b18792)(this);
  }
  /** Converts the date to an ISO 8601 formatted string in UTC. */
  toAbsoluteString() {
    return this.toDate().toISOString();
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b2) {
    return this.toDate().getTime() - (0, $11d87f3f76e88657$export$84c95a83c799e074)(b2, this.timeZone).toDate().getTime();
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type3, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    let timeZone = args.shift();
    let offset3 = args.shift();
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    this.timeZone = timeZone;
    this.offset = offset3;
    this.hour = args.shift() || 0;
    this.minute = args.shift() || 0;
    this.second = args.shift() || 0;
    this.millisecond = args.shift() || 0;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};

// node_modules/@internationalized/date/dist/HebrewCalendar.mjs
var $7c5f6fbf42389787$var$HOUR_PARTS = 1080;
var $7c5f6fbf42389787$var$DAY_PARTS = 24 * $7c5f6fbf42389787$var$HOUR_PARTS;
var $7c5f6fbf42389787$var$MONTH_DAYS = 29;
var $7c5f6fbf42389787$var$MONTH_FRACT = 12 * $7c5f6fbf42389787$var$HOUR_PARTS + 793;
var $7c5f6fbf42389787$var$MONTH_PARTS = $7c5f6fbf42389787$var$MONTH_DAYS * $7c5f6fbf42389787$var$DAY_PARTS + $7c5f6fbf42389787$var$MONTH_FRACT;

// node_modules/@internationalized/date/dist/DateFormatter.mjs
var $fb18d541ea1ad717$var$formatterCache = /* @__PURE__ */ new Map();
var $fb18d541ea1ad717$export$ad991b66133851cf = class {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(value) {
    return this.formatter.format(value);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(value) {
    return this.formatter.formatToParts(value);
  }
  /** Formats a date range as a string. */
  formatRange(start, end) {
    if (typeof this.formatter.formatRange === "function")
      return this.formatter.formatRange(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(start)} – ${this.formatter.format(end)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(start, end) {
    if (typeof this.formatter.formatRangeToParts === "function")
      return this.formatter.formatRangeToParts(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    let startParts = this.formatter.formatToParts(start);
    let endParts = this.formatter.formatToParts(end);
    return [
      ...startParts.map((p) => ({
        ...p,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...endParts.map((p) => ({
        ...p,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let resolvedOptions = this.formatter.resolvedOptions();
    if ($fb18d541ea1ad717$var$hasBuggyResolvedHourCycle()) {
      if (!this.resolvedHourCycle) this.resolvedHourCycle = $fb18d541ea1ad717$var$getResolvedHourCycle(resolvedOptions.locale, this.options);
      resolvedOptions.hourCycle = this.resolvedHourCycle;
      resolvedOptions.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12";
    }
    if (resolvedOptions.calendar === "ethiopic-amete-alem") resolvedOptions.calendar = "ethioaa";
    return resolvedOptions;
  }
  constructor(locale, options = {}) {
    this.formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options);
    this.options = options;
  }
};
var $fb18d541ea1ad717$var$hour12Preferences = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options = {}) {
  if (typeof options.hour12 === "boolean" && $fb18d541ea1ad717$var$hasBuggyHour12Behavior()) {
    options = {
      ...options
    };
    let pref = $fb18d541ea1ad717$var$hour12Preferences[String(options.hour12)][locale.split("-")[0]];
    let defaultHourCycle = options.hour12 ? "h12" : "h23";
    options.hourCycle = pref !== null && pref !== void 0 ? pref : defaultHourCycle;
    delete options.hour12;
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a2, b2) => a2[0] < b2[0] ? -1 : 1).join() : "");
  if ($fb18d541ea1ad717$var$formatterCache.has(cacheKey)) return $fb18d541ea1ad717$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.DateTimeFormat(locale, options);
  $fb18d541ea1ad717$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
var $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = null;
function $fb18d541ea1ad717$var$hasBuggyHour12Behavior() {
  if ($fb18d541ea1ad717$var$_hasBuggyHour12Behavior == null) $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = new Intl.DateTimeFormat("en-US", {
    hour: "numeric",
    hour12: false
  }).format(new Date(2020, 2, 3, 0)) === "24";
  return $fb18d541ea1ad717$var$_hasBuggyHour12Behavior;
}
var $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = null;
function $fb18d541ea1ad717$var$hasBuggyResolvedHourCycle() {
  if ($fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle == null) $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = new Intl.DateTimeFormat("fr", {
    hour: "numeric",
    hour12: false
  }).resolvedOptions().hourCycle === "h12";
  return $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle;
}
function $fb18d541ea1ad717$var$getResolvedHourCycle(locale, options) {
  if (!options.timeStyle && !options.hour) return void 0;
  locale = locale.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, "");
  locale += (locale.includes("-u-") ? "" : "-u") + "-nu-latn";
  let formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, {
    ...options,
    timeZone: void 0
    // use local timezone
  });
  let min4 = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 0)).find((p) => p.type === "hour").value, 10);
  let max4 = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 23)).find((p) => p.type === "hour").value, 10);
  if (min4 === 0 && max4 === 23) return "h23";
  if (min4 === 24 && max4 === 23) return "h24";
  if (min4 === 0 && max4 === 11) return "h11";
  if (min4 === 12 && max4 === 11) return "h12";
  throw new Error("Unexpected hour cycle result");
}

// node_modules/@zag-js/date-utils/dist/index.mjs
function alignCenter(date, duration, locale, min4, max4) {
  const halfDuration = {};
  for (let prop in duration) {
    const key = prop;
    const value = duration[key];
    if (value == null) continue;
    halfDuration[key] = Math.floor(value / 2);
    if (halfDuration[key] > 0 && value % 2 === 0) {
      halfDuration[key]--;
    }
  }
  const aligned = alignStart(date, duration, locale).subtract(halfDuration);
  return constrainStart(date, aligned, duration, locale, min4, max4);
}
function alignStart(date, duration, locale, min4, max4) {
  let aligned = date;
  if (duration.years) {
    aligned = $14e0f24ef4ac5c92$export$f91e89d3d0406102(date);
  } else if (duration.months) {
    aligned = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date);
  } else if (duration.weeks) {
    aligned = $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale);
  }
  return constrainStart(date, aligned, duration, locale, min4, max4);
}
function alignEnd(date, duration, locale, min4, max4) {
  let d = { ...duration };
  if (d.days) {
    d.days--;
  } else if (d.weeks) {
    d.weeks--;
  } else if (d.months) {
    d.months--;
  } else if (d.years) {
    d.years--;
  }
  let aligned = alignStart(date, duration, locale).subtract(d);
  return constrainStart(date, aligned, duration, locale, min4, max4);
}
function constrainStart(date, aligned, duration, locale, min4, max4) {
  if (min4 && date.compare(min4) >= 0) {
    aligned = $14e0f24ef4ac5c92$export$a75f2bff57811055(aligned, alignStart($11d87f3f76e88657$export$93522d1a439f3617(min4), duration, locale));
  }
  if (max4 && date.compare(max4) <= 0) {
    aligned = $14e0f24ef4ac5c92$export$5c333a116e949cdd(aligned, alignEnd($11d87f3f76e88657$export$93522d1a439f3617(max4), duration, locale));
  }
  return aligned;
}
function constrainValue(date, minValue, maxValue2) {
  if (minValue) {
    date = $14e0f24ef4ac5c92$export$a75f2bff57811055(date, $11d87f3f76e88657$export$93522d1a439f3617(minValue));
  }
  if (maxValue2) {
    date = $14e0f24ef4ac5c92$export$5c333a116e949cdd(date, $11d87f3f76e88657$export$93522d1a439f3617(maxValue2));
  }
  return date;
}
function alignDate(date, alignment, duration, locale, min4, max4) {
  switch (alignment) {
    case "start":
      return alignStart(date, duration, locale, min4, max4);
    case "end":
      return alignEnd(date, duration, locale, min4, max4);
    case "center":
    default:
      return alignCenter(date, duration, locale, min4, max4);
  }
}
function isDateEqual(dateA, dateB) {
  return dateB != null && $14e0f24ef4ac5c92$export$ea39ec197993aef0(dateA, dateB);
}
function isDateInvalid(date, minValue, maxValue2) {
  return minValue != null && date.compare(minValue) < 0 || maxValue2 != null && date.compare(maxValue2) > 0;
}
function isDateDisabled(date, startDate, endDate, minValue, maxValue2) {
  return isDateOutsideVisibleRange(date, startDate, endDate) || isDateInvalid(date, minValue, maxValue2);
}
function isDateUnavailable(date, isUnavailable, locale, minValue, maxValue2) {
  if (!date) {
    return false;
  }
  if (isUnavailable == null ? void 0 : isUnavailable(date, locale)) {
    return true;
  }
  return isDateInvalid(date, minValue, maxValue2);
}
function isDateOutsideVisibleRange(date, startDate, endDate) {
  return date.compare(startDate) < 0 || date.compare(endDate) > 0;
}
function isPreviousVisibleRangeInvalid(startDate, minValue, maxValue2) {
  const prevDate = startDate.subtract({ days: 1 });
  return $14e0f24ef4ac5c92$export$ea39ec197993aef0(prevDate, startDate) || isDateInvalid(prevDate, minValue, maxValue2);
}
function isNextVisibleRangeInvalid(endDate, minValue, maxValue2) {
  const nextDate = endDate.add({ days: 1 });
  return $14e0f24ef4ac5c92$export$ea39ec197993aef0(nextDate, endDate) || isDateInvalid(nextDate, minValue, maxValue2);
}
function getUnitDuration(duration) {
  let clone3 = { ...duration };
  for (let key in clone3) clone3[key] = 1;
  return clone3;
}
function getEndDate(startDate, duration) {
  let clone3 = { ...duration };
  if (clone3.days) clone3.days--;
  else clone3.days = -1;
  return startDate.add(clone3);
}
function getEraFormat(date) {
  return (date == null ? void 0 : date.calendar.identifier) === "gregory" && date.era === "BC" ? "short" : void 0;
}
function getDayFormatter(locale, timeZone) {
  const date = $11d87f3f76e88657$export$b21e0b124e224484($14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone));
  return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
    weekday: "long",
    month: "long",
    year: "numeric",
    day: "numeric",
    era: getEraFormat(date),
    timeZone
  });
}
function getMonthFormatter(locale, timeZone) {
  const date = $11d87f3f76e88657$export$93522d1a439f3617($14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone));
  return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
    month: "long",
    year: "numeric",
    era: getEraFormat(date),
    calendar: date == null ? void 0 : date.calendar.identifier,
    timeZone
  });
}
function formatRange(startDate, endDate, formatter, toString, timeZone) {
  let parts42 = formatter.formatRangeToParts(startDate.toDate(timeZone), endDate.toDate(timeZone));
  let separatorIndex = -1;
  for (let i = 0; i < parts42.length; i++) {
    let part = parts42[i];
    if (part.source === "shared" && part.type === "literal") {
      separatorIndex = i;
    } else if (part.source === "endRange") {
      break;
    }
  }
  let start = "";
  let end = "";
  for (let i = 0; i < parts42.length; i++) {
    if (i < separatorIndex) {
      start += parts42[i].value;
    } else if (i > separatorIndex) {
      end += parts42[i].value;
    }
  }
  return toString(start, end);
}
function formatSelectedDate(startDate, endDate, locale, timeZone) {
  let start = startDate;
  let end = endDate ?? startDate;
  let formatter = getDayFormatter(locale, timeZone);
  if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(start, end)) {
    return formatter.format(start.toDate(timeZone));
  }
  return formatRange(start, end, formatter, (start2, end2) => `${start2} – ${end2}`, timeZone);
}
var daysOfTheWeek = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
function normalizeFirstDayOfWeek(firstDayOfWeek) {
  return firstDayOfWeek != null ? daysOfTheWeek[firstDayOfWeek] : void 0;
}
function getStartOfWeek(date, locale, firstDayOfWeek) {
  const firstDay = normalizeFirstDayOfWeek(firstDayOfWeek);
  return $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale, firstDay);
}
function getDaysInWeek(weekIndex, from2, locale, firstDayOfWeek) {
  const weekDate = from2.add({ weeks: weekIndex });
  const dates = [];
  let date = getStartOfWeek(weekDate, locale, firstDayOfWeek);
  while (dates.length < 7) {
    dates.push(date);
    let nextDate = date.add({ days: 1 });
    if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(date, nextDate)) break;
    date = nextDate;
  }
  return dates;
}
function getMonthDays(from2, locale, numOfWeeks, firstDayOfWeek) {
  const firstDay = normalizeFirstDayOfWeek(firstDayOfWeek);
  const monthWeeks = numOfWeeks ?? $14e0f24ef4ac5c92$export$ccc1b2479e7dd654(from2, locale, firstDay);
  const weeks = [...new Array(monthWeeks).keys()];
  return weeks.map((week) => getDaysInWeek(week, from2, locale, firstDayOfWeek));
}
function getWeekdayFormats(locale, timeZone) {
  const longFormat = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: "long", timeZone });
  const shortFormat = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: "short", timeZone });
  const narrowFormat = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: "narrow", timeZone });
  return (value) => {
    const date = value instanceof Date ? value : value.toDate(timeZone);
    return {
      value,
      short: shortFormat.format(date),
      long: longFormat.format(date),
      narrow: narrowFormat.format(date)
    };
  };
}
function getWeekDays(date, startOfWeekProp, timeZone, locale) {
  const firstDayOfWeek = getStartOfWeek(date, locale, startOfWeekProp);
  const weeks = [...new Array(7).keys()];
  const format = getWeekdayFormats(locale, timeZone);
  return weeks.map((index) => format(firstDayOfWeek.add({ days: index })));
}
function getMonthNames(locale, format = "long") {
  const date = new Date(2021, 0, 1);
  const monthNames = [];
  for (let i = 0; i < 12; i++) {
    monthNames.push(date.toLocaleString(locale, { month: format }));
    date.setMonth(date.getMonth() + 1);
  }
  return monthNames;
}
function getYearsRange(range2) {
  const years = [];
  for (let year = range2.from; year <= range2.to; year += 1) years.push(year);
  return years;
}
var FUTURE_YEAR_COERCION = 10;
function normalizeYear(year) {
  if (!year) return;
  if (year.length === 3) return year.padEnd(4, "0");
  if (year.length === 2) {
    const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    const currentCentury = Math.floor(currentYear / 100) * 100;
    const twoDigitYear = parseInt(year.slice(-2), 10);
    const fullYear = currentCentury + twoDigitYear;
    return fullYear > currentYear + FUTURE_YEAR_COERCION ? (fullYear - 100).toString() : fullYear.toString();
  }
  return year;
}
function getDecadeRange(year) {
  const computedYear = year - year % 10 - 1;
  const years = [];
  for (let i = 0; i < 12; i += 1) {
    const value = computedYear + i;
    years.push(value);
  }
  return years;
}
function getTodayDate(timeZone) {
  return $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone ?? $14e0f24ef4ac5c92$export$aa8b41735afcabd2());
}
function getAdjustedDateFn(visibleDuration, locale, minValue, maxValue2) {
  return function getDate(options) {
    const { startDate, focusedDate } = options;
    const endDate = getEndDate(startDate, visibleDuration);
    if (isDateInvalid(focusedDate, minValue, maxValue2)) {
      return {
        startDate,
        focusedDate: constrainValue(focusedDate, minValue, maxValue2),
        endDate
      };
    }
    if (focusedDate.compare(startDate) < 0) {
      return {
        startDate: alignEnd(focusedDate, visibleDuration, locale, minValue, maxValue2),
        focusedDate: constrainValue(focusedDate, minValue, maxValue2),
        endDate
      };
    }
    if (focusedDate.compare(endDate) > 0) {
      return {
        startDate: alignStart(focusedDate, visibleDuration, locale, minValue, maxValue2),
        endDate,
        focusedDate: constrainValue(focusedDate, minValue, maxValue2)
      };
    }
    return {
      startDate,
      endDate,
      focusedDate: constrainValue(focusedDate, minValue, maxValue2)
    };
  };
}
function getNextPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue2) {
  const adjust2 = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue2);
  const start = startDate.add(visibleDuration);
  return adjust2({
    focusedDate: focusedDate.add(visibleDuration),
    startDate: alignStart(
      constrainStart(focusedDate, start, visibleDuration, locale, minValue, maxValue2),
      visibleDuration,
      locale
    )
  });
}
function getPreviousPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue2) {
  const adjust2 = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue2);
  let start = startDate.subtract(visibleDuration);
  return adjust2({
    focusedDate: focusedDate.subtract(visibleDuration),
    startDate: alignStart(
      constrainStart(focusedDate, start, visibleDuration, locale, minValue, maxValue2),
      visibleDuration,
      locale
    )
  });
}
function getNextSection(focusedDate, startDate, larger, visibleDuration, locale, minValue, maxValue2) {
  const adjust2 = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue2);
  if (!larger && !visibleDuration.days) {
    return adjust2({
      focusedDate: focusedDate.add(getUnitDuration(visibleDuration)),
      startDate
    });
  }
  if (visibleDuration.days) {
    return getNextPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue2);
  }
  if (visibleDuration.weeks) {
    return adjust2({
      focusedDate: focusedDate.add({ months: 1 }),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust2({
      focusedDate: focusedDate.add({ years: 1 }),
      startDate
    });
  }
}
function getPreviousSection(focusedDate, startDate, larger, visibleDuration, locale, minValue, maxValue2) {
  const adjust2 = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue2);
  if (!larger && !visibleDuration.days) {
    return adjust2({
      focusedDate: focusedDate.subtract(getUnitDuration(visibleDuration)),
      startDate
    });
  }
  if (visibleDuration.days) {
    return getPreviousPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue2);
  }
  if (visibleDuration.weeks) {
    return adjust2({
      focusedDate: focusedDate.subtract({ months: 1 }),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust2({
      focusedDate: focusedDate.subtract({ years: 1 }),
      startDate
    });
  }
}
var isValidYear = (year) => year != null && year.length === 4;
var isValidMonth = (month) => month != null && parseFloat(month) <= 12;
var isValidDay = (day) => day != null && parseFloat(day) <= 31;
function parseDateString(date, locale, timeZone) {
  const regex = createRegex(locale, timeZone);
  let { year, month, day } = extract(regex, date) ?? {};
  const hasMatch = year != null || month != null || day != null;
  if (hasMatch) {
    const curr = /* @__PURE__ */ new Date();
    year || (year = curr.getFullYear().toString());
    month || (month = (curr.getMonth() + 1).toString());
    day || (day = curr.getDate().toString());
  }
  if (!isValidYear(year)) {
    year = normalizeYear(year);
  }
  if (isValidYear(year) && isValidMonth(month) && isValidDay(day)) {
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(+year, +month, +day);
  }
  const time = Date.parse(date);
  if (!isNaN(time)) {
    const date2 = new Date(time);
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(date2.getFullYear(), date2.getMonth() + 1, date2.getDate());
  }
}
function createRegex(locale, timeZone) {
  const formatter = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { day: "numeric", month: "numeric", year: "numeric", timeZone });
  const parts42 = formatter.formatToParts(new Date(2e3, 11, 25));
  return parts42.map(({ type, value }) => type === "literal" ? `${value}?` : `((?!=<${type}>)\\d+)?`).join("");
}
function extract(pattern, str) {
  var _a8;
  const matches = str.match(pattern);
  return (_a8 = pattern.toString().match(/<(.+?)>/g)) == null ? void 0 : _a8.map((group2) => {
    var _a9;
    const groupMatches = group2.match(/<(.+)>/);
    if (!groupMatches || groupMatches.length <= 0) {
      return null;
    }
    return (_a9 = group2.match(/<(.+)>/)) == null ? void 0 : _a9[1];
  }).reduce((acc, curr, index) => {
    if (!curr) return acc;
    if (matches && matches.length > index) {
      acc[curr] = matches[index + 1];
    } else {
      acc[curr] = null;
    }
    return acc;
  }, {});
}
function getDateRangePreset(preset, locale, timeZone) {
  const today3 = $14e0f24ef4ac5c92$export$461939dd4422153(timeZone);
  switch (preset) {
    case "thisWeek":
      return [$14e0f24ef4ac5c92$export$42c81a444fbfb5d4(today3, locale), $14e0f24ef4ac5c92$export$ef8b6d9133084f4e(today3, locale)];
    case "thisMonth":
      return [$14e0f24ef4ac5c92$export$a5a3b454ada2268e(today3), today3];
    case "thisQuarter":
      return [$14e0f24ef4ac5c92$export$a5a3b454ada2268e(today3).add({ months: -today3.month % 3 }), today3];
    case "thisYear":
      return [$14e0f24ef4ac5c92$export$f91e89d3d0406102(today3), today3];
    case "last3Days":
      return [today3.add({ days: -2 }), today3];
    case "last7Days":
      return [today3.add({ days: -6 }), today3];
    case "last14Days":
      return [today3.add({ days: -13 }), today3];
    case "last30Days":
      return [today3.add({ days: -29 }), today3];
    case "last90Days":
      return [today3.add({ days: -89 }), today3];
    case "lastMonth":
      return [$14e0f24ef4ac5c92$export$a5a3b454ada2268e(today3.add({ months: -1 })), $14e0f24ef4ac5c92$export$a2258d9c4118825c(today3.add({ months: -1 }))];
    case "lastQuarter":
      return [
        $14e0f24ef4ac5c92$export$a5a3b454ada2268e(today3.add({ months: -today3.month % 3 - 3 })),
        $14e0f24ef4ac5c92$export$a2258d9c4118825c(today3.add({ months: -today3.month % 3 - 1 }))
      ];
    case "lastWeek":
      return [$14e0f24ef4ac5c92$export$42c81a444fbfb5d4(today3, locale).add({ weeks: -1 }), $14e0f24ef4ac5c92$export$ef8b6d9133084f4e(today3, locale).add({ weeks: -1 })];
    case "lastYear":
      return [$14e0f24ef4ac5c92$export$f91e89d3d0406102(today3.add({ years: -1 })), $14e0f24ef4ac5c92$export$8b7aa55c66d5569e(today3.add({ years: -1 }))];
    default:
      throw new Error(`Invalid date range preset: ${preset}`);
  }
}

// node_modules/@zag-js/live-region/dist/index.mjs
var ID = "__live-region__";
function createLiveRegion(opts = {}) {
  const { level = "polite", document: doc = document, root, delay: _delay = 0 } = opts;
  const win = doc.defaultView ?? window;
  const parent = root ?? doc.body;
  function announce(message, delay2) {
    const oldRegion = doc.getElementById(ID);
    oldRegion == null ? void 0 : oldRegion.remove();
    delay2 = delay2 ?? _delay;
    const region = doc.createElement("span");
    region.id = ID;
    region.dataset.liveAnnouncer = "true";
    const role = level !== "assertive" ? "status" : "alert";
    region.setAttribute("aria-live", level);
    region.setAttribute("role", role);
    Object.assign(region.style, {
      border: "0",
      clip: "rect(0 0 0 0)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: "0",
      position: "absolute",
      width: "1px",
      whiteSpace: "nowrap",
      wordWrap: "normal"
    });
    parent.appendChild(region);
    win.setTimeout(() => {
      region.textContent = message;
    }, delay2);
  }
  function destroy() {
    const oldRegion = doc.getElementById(ID);
    oldRegion == null ? void 0 : oldRegion.remove();
  }
  return {
    announce,
    destroy,
    toJSON() {
      return ID;
    }
  };
}

// node_modules/@zag-js/date-picker/dist/index.mjs
var anatomy4 = createAnatomy("date-picker").parts(
  "root",
  "label",
  "clearTrigger",
  "content",
  "control",
  "input",
  "monthSelect",
  "nextTrigger",
  "positioner",
  "prevTrigger",
  "rangeText",
  "table",
  "tableBody",
  "tableCell",
  "tableCellTrigger",
  "tableHead",
  "tableHeader",
  "tableRow",
  "trigger",
  "viewTrigger",
  "viewControl",
  "yearSelect",
  "presetTrigger"
);
var parts4 = anatomy4.build();
var dom4 = createScope({
  getLabelId: (ctx, index) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.label) == null ? void 0 : _b7.call(_a8, index)) ?? `datepicker:${ctx.id}:label:${index}`;
  },
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `datepicker:${ctx.id}`;
  },
  getTableId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.table) == null ? void 0 : _b7.call(_a8, id)) ?? `datepicker:${ctx.id}:table:${id}`;
  },
  getTableHeaderId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.tableHeader) == null ? void 0 : _b7.call(_a8, id)) ?? `datepicker:${ctx.id}:thead`;
  },
  getTableBodyId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.tableBody) == null ? void 0 : _b7.call(_a8, id)) ?? `datepicker:${ctx.id}:tbody`;
  },
  getTableRowId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.tableRow) == null ? void 0 : _b7.call(_a8, id)) ?? `datepicker:${ctx.id}:tr:${id}`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `datepicker:${ctx.id}:content`;
  },
  getCellTriggerId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.cellTrigger) == null ? void 0 : _b7.call(_a8, id)) ?? `datepicker:${ctx.id}:cell-trigger:${id}`;
  },
  getPrevTriggerId: (ctx, view) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.prevTrigger) == null ? void 0 : _b7.call(_a8, view)) ?? `datepicker:${ctx.id}:prev:${view}`;
  },
  getNextTriggerId: (ctx, view) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.nextTrigger) == null ? void 0 : _b7.call(_a8, view)) ?? `datepicker:${ctx.id}:next:${view}`;
  },
  getViewTriggerId: (ctx, view) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.viewTrigger) == null ? void 0 : _b7.call(_a8, view)) ?? `datepicker:${ctx.id}:view:${view}`;
  },
  getClearTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.clearTrigger) ?? `datepicker:${ctx.id}:clear`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `datepicker:${ctx.id}:control`;
  },
  getInputId: (ctx, index) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.input) == null ? void 0 : _b7.call(_a8, index)) ?? `datepicker:${ctx.id}:input:${index}`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `datepicker:${ctx.id}:trigger`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `datepicker:${ctx.id}:positioner`;
  },
  getMonthSelectId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.monthSelect) ?? `datepicker:${ctx.id}:month-select`;
  },
  getYearSelectId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.yearSelect) ?? `datepicker:${ctx.id}:year-select`;
  },
  getFocusedCell: (ctx, view = ctx.view) => query(
    dom4.getContentEl(ctx),
    `[data-part=table-cell-trigger][data-view=${view}][data-focus]:not([data-outside-range])`
  ),
  getTriggerEl: (ctx) => dom4.getById(ctx, dom4.getTriggerId(ctx)),
  getContentEl: (ctx) => dom4.getById(ctx, dom4.getContentId(ctx)),
  getInputEls: (ctx) => queryAll(dom4.getControlEl(ctx), `[data-part=input]`),
  getYearSelectEl: (ctx) => dom4.getById(ctx, dom4.getYearSelectId(ctx)),
  getMonthSelectEl: (ctx) => dom4.getById(ctx, dom4.getMonthSelectId(ctx)),
  getClearTriggerEl: (ctx) => dom4.getById(ctx, dom4.getClearTriggerId(ctx)),
  getPositionerEl: (ctx) => dom4.getById(ctx, dom4.getPositionerId(ctx)),
  getControlEl: (ctx) => dom4.getById(ctx, dom4.getControlId(ctx))
});
function adjustStartAndEndDate(value) {
  const [startDate, endDate] = value;
  if (!startDate || !endDate) return value;
  return startDate.compare(endDate) <= 0 ? value : [endDate, startDate];
}
function isDateWithinRange(date, value) {
  const [startDate, endDate] = value;
  if (!startDate || !endDate) return false;
  return startDate.compare(date) <= 0 && endDate.compare(date) >= 0;
}
function sortDates(values) {
  return values.sort((a2, b2) => a2.compare(b2));
}
function getRoleDescription(view) {
  return match3(view, {
    year: "calendar decade",
    month: "calendar year",
    day: "calendar month"
  });
}
var PLACEHOLDERS = {
  day: "dd",
  month: "mm",
  year: "yyyy"
};
function getInputPlaceholder(locale) {
  return new $fb18d541ea1ad717$export$ad991b66133851cf(locale).formatToParts(/* @__PURE__ */ new Date()).map((item) => PLACEHOLDERS[item.type] ?? item.value).join("");
}
var isValidCharacter = (char2, separator) => {
  if (!char2) return true;
  return /\d/.test(char2) || char2 === separator || char2.length !== 1;
};
var isValidDate = (value) => {
  return !Number.isNaN(value.day) && !Number.isNaN(value.month) && !Number.isNaN(value.year);
};
var ensureValidCharacters = (value, separator) => {
  return value.split("").filter((char2) => isValidCharacter(char2, separator)).join("");
};
function getLocaleSeparator(locale) {
  const dateFormatter = new Intl.DateTimeFormat(locale);
  const parts210 = dateFormatter.formatToParts(/* @__PURE__ */ new Date());
  const literalPart = parts210.find((part) => part.type === "literal");
  return literalPart ? literalPart.value : "/";
}
var defaultTranslations = {
  dayCell(state2) {
    if (state2.unavailable) return `Not available. ${state2.formattedDate}`;
    if (state2.selected) return `Selected date. ${state2.formattedDate}`;
    return `Choose ${state2.formattedDate}`;
  },
  trigger(open) {
    return open ? "Close calendar" : "Open calendar";
  },
  viewTrigger(view) {
    return match3(view, {
      year: "Switch to month view",
      month: "Switch to day view",
      day: "Switch to year view"
    });
  },
  presetTrigger(value) {
    return Array.isArray(value) ? `select ${value[0].toString()} to ${value[1].toString()}` : `select ${value}`;
  },
  prevTrigger(view) {
    return match3(view, {
      year: "Switch to previous decade",
      month: "Switch to previous year",
      day: "Switch to previous month"
    });
  },
  nextTrigger(view) {
    return match3(view, {
      year: "Switch to next decade",
      month: "Switch to next year",
      day: "Switch to next month"
    });
  },
  // TODO: Revisit this
  placeholder() {
    return { day: "dd", month: "mm", year: "yyyy" };
  },
  content: "calendar",
  monthSelect: "Select month",
  yearSelect: "Select year",
  clearTrigger: "Clear selected dates"
};
function viewToNumber(view, fallback4) {
  if (!view) return fallback4 || 0;
  return view === "day" ? 0 : view === "month" ? 1 : 2;
}
function viewNumberToView(viewNumber) {
  return viewNumber === 0 ? "day" : viewNumber === 1 ? "month" : "year";
}
function clampView(view, minView, maxView) {
  return viewNumberToView(
    clampValue(viewToNumber(view, 0), viewToNumber(minView, 0), viewToNumber(maxView, 2))
  );
}
function isAboveMinView(view, minView) {
  return viewToNumber(view, 0) > viewToNumber(minView, 0);
}
function isBelowMinView(view, minView) {
  return viewToNumber(view, 0) < viewToNumber(minView, 0);
}
function getNextView(view, minView, maxView) {
  const nextViewNumber = viewToNumber(view, 0) + 1;
  return clampView(viewNumberToView(nextViewNumber), minView, maxView);
}
function getPreviousView(view, minView, maxView) {
  const prevViewNumber = viewToNumber(view, 0) - 1;
  return clampView(viewNumberToView(prevViewNumber), minView, maxView);
}
var views = ["day", "month", "year"];
function eachView(cb) {
  views.forEach((view) => cb(view));
}
function connect5(state2, send, normalize3) {
  const startValue = state2.context.startValue;
  const endValue = state2.context.endValue;
  const selectedValue = state2.context.value;
  const focusedValue = state2.context.focusedValue;
  const hoveredValue = state2.context.hoveredValue;
  const hoveredRangeValue = hoveredValue ? adjustStartAndEndDate([selectedValue[0], hoveredValue]) : [];
  const disabled = state2.context.disabled;
  const readOnly = state2.context.readOnly;
  const interactive = state2.context.isInteractive;
  const min4 = state2.context.min;
  const max4 = state2.context.max;
  const locale = state2.context.locale;
  const timeZone = state2.context.timeZone;
  const startOfWeek = state2.context.startOfWeek;
  const focused = state2.matches("focused");
  const open = state2.matches("open");
  const isRangePicker = state2.context.selectionMode === "range";
  const isDateUnavailableFn = state2.context.isDateUnavailable;
  const currentPlacement = state2.context.currentPlacement;
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: currentPlacement
  });
  const separator = getLocaleSeparator(locale);
  function getMonthWeeks(from2 = startValue) {
    const numOfWeeks = state2.context.fixedWeeks ? 6 : void 0;
    return getMonthDays(from2, locale, numOfWeeks, startOfWeek);
  }
  function getMonths(props210 = {}) {
    const { format } = props210;
    return getMonthNames(locale, format).map((label, index) => ({ label, value: index + 1 }));
  }
  function getYears() {
    const range2 = getYearsRange({ from: (min4 == null ? void 0 : min4.year) ?? 1900, to: (max4 == null ? void 0 : max4.year) ?? 2100 });
    return range2.map((year) => ({ label: year.toString(), value: year }));
  }
  function getDecadeYears(year) {
    const range2 = getDecadeRange(focusedValue.year);
    return range2.map((year2) => ({ label: year2.toString(), value: year2 }));
  }
  function isUnavailable(date) {
    return isDateUnavailable(date, isDateUnavailableFn, locale, min4, max4);
  }
  function focusMonth(month) {
    const date = startValue ?? getTodayDate(timeZone);
    send({ type: "FOCUS.SET", value: date.set({ month }) });
  }
  function focusYear(year) {
    const date = startValue ?? getTodayDate(timeZone);
    send({ type: "FOCUS.SET", value: date.set({ year }) });
  }
  function getYearTableCellState(props210) {
    const { value, disabled: disabled2 } = props210;
    const cellState = {
      focused: focusedValue.year === props210.value,
      selectable: isValueWithinRange(value, (min4 == null ? void 0 : min4.year) ?? 0, (max4 == null ? void 0 : max4.year) ?? 9999),
      selected: !!selectedValue.find((date) => date.year === value),
      valueText: value.toString(),
      get disabled() {
        return disabled2 || !cellState.selectable;
      }
    };
    return cellState;
  }
  function getMonthTableCellState(props210) {
    const { value, disabled: disabled2 } = props210;
    const normalized = focusedValue.set({ month: value });
    const formatter = getMonthFormatter(locale, timeZone);
    const cellState = {
      focused: focusedValue.month === props210.value,
      selectable: !isDateInvalid(normalized, min4, max4),
      selected: !!selectedValue.find((date) => date.month === value && date.year === focusedValue.year),
      valueText: formatter.format(normalized.toDate(timeZone)),
      get disabled() {
        return disabled2 || !cellState.selectable;
      }
    };
    return cellState;
  }
  const translations = state2.context.translations || defaultTranslations;
  function getDayTableCellState(props210) {
    const { value, disabled: disabled2, visibleRange = state2.context.visibleRange } = props210;
    const formatter = getDayFormatter(locale, timeZone);
    const unitDuration = getUnitDuration(state2.context.visibleDuration);
    const end = visibleRange.start.add(unitDuration).subtract({ days: 1 });
    const cellState = {
      invalid: isDateInvalid(value, min4, max4),
      disabled: disabled2 || isDateDisabled(value, visibleRange.start, end, min4, max4),
      selected: selectedValue.some((date) => isDateEqual(value, date)),
      unavailable: isDateUnavailable(value, isDateUnavailableFn, locale, min4, max4) && !disabled2,
      outsideRange: isDateOutsideVisibleRange(value, visibleRange.start, end),
      inRange: isRangePicker && (isDateWithinRange(value, selectedValue) || isDateWithinRange(value, hoveredRangeValue)),
      firstInRange: isRangePicker && isDateEqual(value, selectedValue[0]),
      lastInRange: isRangePicker && isDateEqual(value, selectedValue[1]),
      today: $14e0f24ef4ac5c92$export$629b0a497aa65267(value, timeZone),
      weekend: $14e0f24ef4ac5c92$export$618d60ea299da42(value, locale),
      formattedDate: formatter.format(value.toDate(timeZone)),
      get focused() {
        return isDateEqual(value, focusedValue) && !cellState.outsideRange;
      },
      get ariaLabel() {
        return translations.dayCell(cellState);
      },
      get selectable() {
        return !cellState.disabled && !cellState.unavailable;
      }
    };
    return cellState;
  }
  function getTableId(props210) {
    const { view = "day", id } = props210;
    return [view, id].filter(Boolean).join(" ");
  }
  return {
    focused,
    open,
    view: state2.context.view,
    getRangePresetValue(preset) {
      return getDateRangePreset(preset, locale, timeZone);
    },
    getDaysInWeek(week, from2 = startValue) {
      return getDaysInWeek(week, from2, locale, startOfWeek);
    },
    getOffset(duration) {
      const from2 = startValue.add(duration);
      return {
        visibleRange: { start: from2, end: endValue.add(duration) },
        weeks: getMonthWeeks(from2)
      };
    },
    getMonthWeeks,
    isUnavailable,
    weeks: getMonthWeeks(),
    weekDays: getWeekDays(getTodayDate(timeZone), startOfWeek, timeZone, locale),
    visibleRangeText: state2.context.visibleRangeText,
    value: selectedValue,
    valueAsDate: selectedValue.map((date) => date.toDate(timeZone)),
    valueAsString: state2.context.valueAsString,
    focusedValue,
    focusedValueAsDate: focusedValue == null ? void 0 : focusedValue.toDate(timeZone),
    focusedValueAsString: state2.context.format(focusedValue, { locale, timeZone }),
    visibleRange: state2.context.visibleRange,
    selectToday() {
      const value = constrainValue(getTodayDate(timeZone), min4, max4);
      send({ type: "VALUE.SET", value });
    },
    setValue(values) {
      const computedValue = values.map((date) => constrainValue(date, min4, max4));
      send({ type: "VALUE.SET", value: computedValue });
    },
    clearValue() {
      send("VALUE.CLEAR");
    },
    setFocusedValue(value) {
      send({ type: "FOCUS.SET", value });
    },
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    focusMonth,
    focusYear,
    getYears,
    getMonths,
    getYearsGrid(props210 = {}) {
      const { columns = 1 } = props210;
      return chunk(getDecadeYears(), columns);
    },
    getDecade() {
      const years = getDecadeRange(focusedValue.year);
      return { start: years.at(0), end: years.at(-1) };
    },
    getMonthsGrid(props210 = {}) {
      const { columns = 1, format } = props210;
      return chunk(getMonths({ format }), columns);
    },
    format(value, opts = { month: "long", year: "numeric" }) {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, opts).format(value.toDate(timeZone));
    },
    setView(view) {
      send({ type: "VIEW.SET", view });
    },
    goToNext() {
      send({ type: "GOTO.NEXT", view: state2.context.view });
    },
    goToPrev() {
      send({ type: "GOTO.PREV", view: state2.context.view });
    },
    getRootProps() {
      return normalize3.element({
        ...parts4.root.attrs,
        dir: state2.context.dir,
        id: dom4.getRootId(state2.context),
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getLabelProps(props210 = {}) {
      const { index = 0 } = props210;
      return normalize3.label({
        ...parts4.label.attrs,
        id: dom4.getLabelId(state2.context, index),
        dir: state2.context.dir,
        htmlFor: dom4.getInputId(state2.context, index),
        "data-state": open ? "open" : "closed",
        "data-index": index,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getControlProps() {
      return normalize3.element({
        ...parts4.control.attrs,
        dir: state2.context.dir,
        id: dom4.getControlId(state2.context),
        "data-disabled": dataAttr(disabled)
      });
    },
    getRangeTextProps() {
      return normalize3.element({
        ...parts4.rangeText.attrs,
        dir: state2.context.dir
      });
    },
    getContentProps() {
      return normalize3.element({
        ...parts4.content.attrs,
        hidden: !open,
        dir: state2.context.dir,
        "data-state": open ? "open" : "closed",
        "data-placement": currentPlacement,
        id: dom4.getContentId(state2.context),
        tabIndex: -1,
        role: "application",
        "aria-roledescription": "datepicker",
        "aria-label": translations.content
      });
    },
    getTableProps(props210 = {}) {
      const { view = "day", columns = view === "day" ? 7 : 4 } = props210;
      const uid = getTableId(props210);
      return normalize3.element({
        ...parts4.table.attrs,
        role: "grid",
        "data-columns": columns,
        "aria-roledescription": getRoleDescription(view),
        id: dom4.getTableId(state2.context, uid),
        "aria-readonly": ariaAttr(readOnly),
        "aria-disabled": ariaAttr(disabled),
        "aria-multiselectable": ariaAttr(state2.context.selectionMode !== "single"),
        "data-view": view,
        dir: state2.context.dir,
        tabIndex: -1,
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          const keyMap2 = {
            Enter() {
              if (isUnavailable(focusedValue)) return;
              send({ type: "TABLE.ENTER", view, columns, focus: true });
            },
            ArrowLeft() {
              send({ type: "TABLE.ARROW_LEFT", view, columns, focus: true });
            },
            ArrowRight() {
              send({ type: "TABLE.ARROW_RIGHT", view, columns, focus: true });
            },
            ArrowUp() {
              send({ type: "TABLE.ARROW_UP", view, columns, focus: true });
            },
            ArrowDown() {
              send({ type: "TABLE.ARROW_DOWN", view, columns, focus: true });
            },
            PageUp(event2) {
              send({ type: "TABLE.PAGE_UP", larger: event2.shiftKey, view, columns, focus: true });
            },
            PageDown(event2) {
              send({ type: "TABLE.PAGE_DOWN", larger: event2.shiftKey, view, columns, focus: true });
            },
            Home() {
              send({ type: "TABLE.HOME", view, columns, focus: true });
            },
            End() {
              send({ type: "TABLE.END", view, columns, focus: true });
            }
          };
          const exec2 = keyMap2[getEventKey(event, state2.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
            event.stopPropagation();
          }
        },
        onPointerLeave() {
          send({ type: "TABLE.POINTER_LEAVE" });
        },
        onPointerDown() {
          send({ type: "TABLE.POINTER_DOWN", view });
        },
        onPointerUp() {
          send({ type: "TABLE.POINTER_UP", view });
        }
      });
    },
    getTableHeadProps(props210 = {}) {
      const { view = "day" } = props210;
      return normalize3.element({
        ...parts4.tableHead.attrs,
        "aria-hidden": true,
        dir: state2.context.dir,
        "data-view": view,
        "data-disabled": dataAttr(disabled)
      });
    },
    getTableHeaderProps(props210 = {}) {
      const { view = "day" } = props210;
      return normalize3.element({
        ...parts4.tableHeader.attrs,
        dir: state2.context.dir,
        "data-view": view,
        "data-disabled": dataAttr(disabled)
      });
    },
    getTableBodyProps(props210 = {}) {
      const { view = "day" } = props210;
      return normalize3.element({
        ...parts4.tableBody.attrs,
        "data-view": view,
        "data-disabled": dataAttr(disabled)
      });
    },
    getTableRowProps(props210 = {}) {
      const { view = "day" } = props210;
      return normalize3.element({
        ...parts4.tableRow.attrs,
        "aria-disabled": ariaAttr(disabled),
        "data-disabled": dataAttr(disabled),
        "data-view": view
      });
    },
    getDayTableCellState,
    getDayTableCellProps(props210) {
      const { value } = props210;
      const cellState = getDayTableCellState(props210);
      return normalize3.element({
        ...parts4.tableCell.attrs,
        role: "gridcell",
        "aria-disabled": ariaAttr(!cellState.selectable),
        "aria-selected": cellState.selected || cellState.inRange,
        "aria-invalid": ariaAttr(cellState.invalid),
        "aria-current": cellState.today ? "date" : void 0,
        "data-value": value.toString()
      });
    },
    getDayTableCellTriggerProps(props210) {
      const { value } = props210;
      const cellState = getDayTableCellState(props210);
      return normalize3.element({
        ...parts4.tableCellTrigger.attrs,
        id: dom4.getCellTriggerId(state2.context, value.toString()),
        role: "button",
        dir: state2.context.dir,
        tabIndex: cellState.focused ? 0 : -1,
        "aria-label": cellState.ariaLabel,
        "aria-disabled": ariaAttr(!cellState.selectable),
        "aria-invalid": ariaAttr(cellState.invalid),
        "data-disabled": dataAttr(!cellState.selectable),
        "data-selected": dataAttr(cellState.selected),
        "data-value": value.toString(),
        "data-view": "day",
        "data-today": dataAttr(cellState.today),
        "data-focus": dataAttr(cellState.focused),
        "data-unavailable": dataAttr(cellState.unavailable),
        "data-range-start": dataAttr(cellState.firstInRange),
        "data-range-end": dataAttr(cellState.lastInRange),
        "data-in-range": dataAttr(cellState.inRange),
        "data-outside-range": dataAttr(cellState.outsideRange),
        "data-weekend": dataAttr(cellState.weekend),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!cellState.selectable) return;
          send({ type: "CELL.CLICK", cell: "day", value });
        },
        onPointerMove(event) {
          if (event.pointerType === "touch" || !cellState.selectable) return;
          const focus = event.currentTarget.ownerDocument.activeElement !== event.currentTarget;
          if (hoveredValue && $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(value, hoveredValue)) return;
          send({ type: "CELL.POINTER_MOVE", cell: "day", value, focus });
        }
      });
    },
    getMonthTableCellState,
    getMonthTableCellProps(props210) {
      const { value, columns } = props210;
      const cellState = getMonthTableCellState(props210);
      return normalize3.element({
        ...parts4.tableCell.attrs,
        dir: state2.context.dir,
        colSpan: columns,
        role: "gridcell",
        "aria-selected": ariaAttr(cellState.selected),
        "data-selected": dataAttr(cellState.selected),
        "aria-disabled": ariaAttr(!cellState.selectable),
        "data-value": value
      });
    },
    getMonthTableCellTriggerProps(props210) {
      const { value } = props210;
      const cellState = getMonthTableCellState(props210);
      return normalize3.element({
        ...parts4.tableCellTrigger.attrs,
        dir: state2.context.dir,
        role: "button",
        id: dom4.getCellTriggerId(state2.context, value.toString()),
        "data-selected": dataAttr(cellState.selected),
        "aria-disabled": ariaAttr(!cellState.selectable),
        "data-disabled": dataAttr(!cellState.selectable),
        "data-focus": dataAttr(cellState.focused),
        "aria-label": cellState.valueText,
        "data-view": "month",
        "data-value": value,
        tabIndex: cellState.focused ? 0 : -1,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!cellState.selectable) return;
          send({ type: "CELL.CLICK", cell: "month", value });
        }
      });
    },
    getYearTableCellState,
    getYearTableCellProps(props210) {
      const { value, columns } = props210;
      const cellState = getYearTableCellState(props210);
      return normalize3.element({
        ...parts4.tableCell.attrs,
        dir: state2.context.dir,
        colSpan: columns,
        role: "gridcell",
        "aria-selected": ariaAttr(cellState.selected),
        "data-selected": dataAttr(cellState.selected),
        "aria-disabled": ariaAttr(!cellState.selectable),
        "data-value": value
      });
    },
    getYearTableCellTriggerProps(props210) {
      const { value } = props210;
      const cellState = getYearTableCellState(props210);
      return normalize3.element({
        ...parts4.tableCellTrigger.attrs,
        dir: state2.context.dir,
        role: "button",
        id: dom4.getCellTriggerId(state2.context, value.toString()),
        "data-selected": dataAttr(cellState.selected),
        "data-focus": dataAttr(cellState.focused),
        "aria-disabled": ariaAttr(!cellState.selectable),
        "data-disabled": dataAttr(!cellState.selectable),
        "aria-label": cellState.valueText,
        "data-value": value,
        "data-view": "year",
        tabIndex: cellState.focused ? 0 : -1,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!cellState.selectable) return;
          send({ type: "CELL.CLICK", cell: "year", value });
        }
      });
    },
    getNextTriggerProps(props210 = {}) {
      const { view = "day" } = props210;
      const isDisabled = disabled || !state2.context.isNextVisibleRangeValid;
      return normalize3.button({
        ...parts4.nextTrigger.attrs,
        dir: state2.context.dir,
        id: dom4.getNextTriggerId(state2.context, view),
        type: "button",
        "aria-label": translations.nextTrigger(view),
        disabled: isDisabled,
        "data-disabled": dataAttr(isDisabled),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "GOTO.NEXT", view });
        }
      });
    },
    getPrevTriggerProps(props210 = {}) {
      const { view = "day" } = props210;
      const isDisabled = disabled || !state2.context.isPrevVisibleRangeValid;
      return normalize3.button({
        ...parts4.prevTrigger.attrs,
        dir: state2.context.dir,
        id: dom4.getPrevTriggerId(state2.context, view),
        type: "button",
        "aria-label": translations.prevTrigger(view),
        disabled: isDisabled,
        "data-disabled": dataAttr(isDisabled),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "GOTO.PREV", view });
        }
      });
    },
    getClearTriggerProps() {
      return normalize3.button({
        ...parts4.clearTrigger.attrs,
        id: dom4.getClearTriggerId(state2.context),
        dir: state2.context.dir,
        type: "button",
        "aria-label": translations.clearTrigger,
        hidden: !state2.context.value.length,
        onClick(event) {
          if (event.defaultPrevented) return;
          send("VALUE.CLEAR");
        }
      });
    },
    getTriggerProps() {
      return normalize3.button({
        ...parts4.trigger.attrs,
        id: dom4.getTriggerId(state2.context),
        dir: state2.context.dir,
        type: "button",
        "data-placement": currentPlacement,
        "aria-label": translations.trigger(open),
        "aria-controls": dom4.getContentId(state2.context),
        "data-state": open ? "open" : "closed",
        "aria-haspopup": "grid",
        disabled,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send("TRIGGER.CLICK");
        }
      });
    },
    getViewTriggerProps(props210 = {}) {
      const { view = "day" } = props210;
      return normalize3.button({
        ...parts4.viewTrigger.attrs,
        "data-view": view,
        dir: state2.context.dir,
        id: dom4.getViewTriggerId(state2.context, view),
        type: "button",
        disabled,
        "aria-label": translations.viewTrigger(view),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "VIEW.TOGGLE", src: "viewTrigger" });
        }
      });
    },
    getViewControlProps(props210 = {}) {
      const { view = "day" } = props210;
      return normalize3.element({
        ...parts4.viewControl.attrs,
        "data-view": view,
        dir: state2.context.dir
      });
    },
    getInputProps(props210 = {}) {
      const { index = 0, fixOnBlur = true } = props210;
      return normalize3.input({
        ...parts4.input.attrs,
        id: dom4.getInputId(state2.context, index),
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: "false",
        dir: state2.context.dir,
        name: state2.context.name,
        "data-index": index,
        "data-state": open ? "open" : "closed",
        readOnly,
        disabled,
        placeholder: state2.context.placeholder || getInputPlaceholder(locale),
        defaultValue: state2.context.valueAsString[index],
        onBeforeInput(event) {
          const { data } = getNativeEvent(event);
          if (!isValidCharacter(data, separator)) {
            event.preventDefault();
          }
        },
        onFocus() {
          send({ type: "INPUT.FOCUS", index });
        },
        onBlur(event) {
          const value = event.currentTarget.value.trim();
          send({ type: "INPUT.BLUR", value, index, fixOnBlur });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const keyMap2 = {
            Enter(event2) {
              if (isComposingEvent(event2)) return;
              if (isUnavailable(state2.context.focusedValue)) return;
              if (event2.currentTarget.value.trim() === "") return;
              send({ type: "INPUT.ENTER", value: event2.currentTarget.value, index });
            }
          };
          const exec2 = keyMap2[event.key];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        },
        onInput(event) {
          const value = event.currentTarget.value;
          send({ type: "INPUT.CHANGE", value: ensureValidCharacters(value, separator), index });
        }
      });
    },
    getMonthSelectProps() {
      return normalize3.select({
        ...parts4.monthSelect.attrs,
        id: dom4.getMonthSelectId(state2.context),
        "aria-label": translations.monthSelect,
        disabled,
        dir: state2.context.dir,
        defaultValue: startValue.month,
        onChange(event) {
          focusMonth(Number(event.currentTarget.value));
        }
      });
    },
    getYearSelectProps() {
      return normalize3.select({
        ...parts4.yearSelect.attrs,
        id: dom4.getYearSelectId(state2.context),
        disabled,
        "aria-label": translations.yearSelect,
        dir: state2.context.dir,
        defaultValue: startValue.year,
        onChange(event) {
          focusYear(Number(event.currentTarget.value));
        }
      });
    },
    getPositionerProps() {
      return normalize3.element({
        id: dom4.getPositionerId(state2.context),
        ...parts4.positioner.attrs,
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getPresetTriggerProps(props210) {
      const value = Array.isArray(props210.value) ? props210.value : getDateRangePreset(props210.value, locale, timeZone);
      const valueAsString = value.map((item) => item.toDate(timeZone).toDateString());
      return normalize3.button({
        ...parts4.presetTrigger.attrs,
        "aria-label": translations.presetTrigger(valueAsString),
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "PRESET.CLICK", value });
        }
      });
    }
  };
}
var { and: and4 } = guards;
var transformContext = (ctx) => {
  const locale = ctx.locale || "en-US";
  const timeZone = ctx.timeZone || "UTC";
  const selectionMode = ctx.selectionMode || "single";
  const numOfMonths = ctx.numOfMonths || 1;
  const value = sortDates(ctx.value || []).map((date) => constrainValue(date, ctx.min, ctx.max));
  let focusedValue = value[0] || ctx.focusedValue || getTodayDate(timeZone);
  focusedValue = constrainValue(focusedValue, ctx.min, ctx.max);
  const startValue = alignDate(focusedValue, "start", { months: numOfMonths }, locale);
  const minView = "day";
  const maxView = "year";
  const view = clampView(ctx.view || minView, minView, maxView);
  return {
    locale,
    numOfMonths,
    focusedValue,
    startValue,
    inputValue: "",
    timeZone,
    value,
    selectionMode,
    view,
    minView,
    maxView,
    activeIndex: 0,
    hoveredValue: null,
    closeOnSelect: true,
    disabled: false,
    readOnly: false,
    min: void 0,
    max: void 0,
    format(date, { locale: locale2, timeZone: timeZone2 }) {
      const formatter = new $fb18d541ea1ad717$export$ad991b66133851cf(locale2, { timeZone: timeZone2, day: "2-digit", month: "2-digit", year: "numeric" });
      return formatter.format(date.toDate(timeZone2));
    },
    parse(value2, { locale: locale2, timeZone: timeZone2 }) {
      return parseDateString(value2, locale2, timeZone2);
    },
    ...ctx,
    positioning: {
      placement: "bottom",
      ...ctx.positioning
    }
  };
};
function machine5(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "datepicker",
      initial: ctx.open ? "open" : "idle",
      context: transformContext(ctx),
      computed: {
        isInteractive: (ctx2) => !ctx2.disabled && !ctx2.readOnly,
        visibleDuration: (ctx2) => ({ months: ctx2.numOfMonths }),
        endValue: (ctx2) => getEndDate(ctx2.startValue, ctx2.visibleDuration),
        visibleRange: (ctx2) => ({ start: ctx2.startValue, end: ctx2.endValue }),
        visibleRangeText(ctx2) {
          const formatter = new $fb18d541ea1ad717$export$ad991b66133851cf(ctx2.locale, { month: "long", year: "numeric", timeZone: ctx2.timeZone });
          const start = formatter.format(ctx2.startValue.toDate(ctx2.timeZone));
          const end = formatter.format(ctx2.endValue.toDate(ctx2.timeZone));
          const formatted = ctx2.selectionMode === "range" ? `${start} - ${end}` : start;
          return { start, end, formatted };
        },
        isPrevVisibleRangeValid: (ctx2) => !isPreviousVisibleRangeInvalid(ctx2.startValue, ctx2.min, ctx2.max),
        isNextVisibleRangeValid: (ctx2) => !isNextVisibleRangeInvalid(ctx2.endValue, ctx2.min, ctx2.max),
        valueAsString(ctx2) {
          return ctx2.value.map((date) => ctx2.format(date, { locale: ctx2.locale, timeZone: ctx2.timeZone }));
        }
      },
      activities: ["setupLiveRegion"],
      created: ["setStartValue"],
      watch: {
        locale: ["setStartValue"],
        focusedValue: [
          "setStartValue",
          "syncMonthSelectElement",
          "syncYearSelectElement",
          "focusActiveCellIfNeeded",
          "setHoveredValueIfKeyboard"
        ],
        inputValue: ["syncInputValue"],
        value: ["syncInputElement"],
        valueAsString: ["announceValueText"],
        view: ["focusActiveCell"],
        open: ["toggleVisibility"]
      },
      on: {
        "VALUE.SET": {
          actions: ["setDateValue", "setFocusedDate"]
        },
        "VIEW.SET": {
          actions: ["setView"]
        },
        "FOCUS.SET": {
          actions: ["setFocusedDate"]
        },
        "VALUE.CLEAR": {
          actions: ["clearDateValue", "clearFocusedDate", "focusFirstInputElement"]
        },
        "INPUT.CHANGE": [
          {
            guard: "isInputValueEmpty",
            actions: ["setInputValue", "clearDateValue", "clearFocusedDate"]
          },
          {
            actions: ["setInputValue", "focusParsedDate"]
          }
        ],
        "INPUT.ENTER": {
          actions: ["focusParsedDate", "selectFocusedDate"]
        },
        "INPUT.FOCUS": {
          actions: ["setActiveIndex"]
        },
        "INPUT.BLUR": [
          {
            guard: "shouldFixOnBlur",
            actions: ["setActiveIndexToStart", "selectParsedDate"]
          },
          {
            actions: ["setActiveIndexToStart"]
          }
        ],
        "PRESET.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["setDateValue", "setFocusedDate", "invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["setDateValue", "setFocusedDate", "focusInputElement"]
          }
        ],
        "GOTO.NEXT": [
          {
            guard: "isYearView",
            actions: ["focusNextDecade", "announceVisibleRange"]
          },
          {
            guard: "isMonthView",
            actions: ["focusNextYear", "announceVisibleRange"]
          },
          {
            actions: ["focusNextPage"]
          }
        ],
        "GOTO.PREV": [
          {
            guard: "isYearView",
            actions: ["focusPreviousDecade", "announceVisibleRange"]
          },
          {
            guard: "isMonthView",
            actions: ["focusPreviousYear", "announceVisibleRange"]
          },
          {
            actions: ["focusPreviousPage"]
          }
        ]
      },
      states: {
        idle: {
          tags: "closed",
          on: {
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["focusFirstSelectedDate", "focusActiveCell"]
            },
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["focusFirstSelectedDate", "focusActiveCell", "invokeOnOpen"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["focusFirstSelectedDate", "focusActiveCell", "invokeOnOpen"]
              }
            ]
          }
        },
        focused: {
          tags: "closed",
          on: {
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["focusFirstSelectedDate", "focusActiveCell"]
            },
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["focusFirstSelectedDate", "focusActiveCell", "invokeOnOpen"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["focusFirstSelectedDate", "focusActiveCell", "invokeOnOpen"]
              }
            ]
          }
        },
        open: {
          tags: "open",
          activities: ["trackDismissableElement", "trackPositioning"],
          exit: ["clearHoveredDate", "resetView"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                guard: and4("shouldRestoreFocus", "isInteractOutsideEvent"),
                target: "focused",
                actions: ["focusTriggerElement"]
              },
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["focusInputElement"]
              },
              {
                target: "idle"
              }
            ],
            "CELL.CLICK": [
              {
                guard: "isAboveMinView",
                actions: ["setFocusedValueForView", "setPreviousView"]
              },
              {
                guard: and4("isRangePicker", "hasSelectedRange"),
                actions: [
                  "setActiveIndexToStart",
                  "clearDateValue",
                  "setFocusedDate",
                  "setSelectedDate",
                  "setActiveIndexToEnd"
                ]
              },
              // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===
              {
                guard: and4("isRangePicker", "isSelectingEndDate", "closeOnSelect", "isOpenControlled"),
                actions: [
                  "setFocusedDate",
                  "setSelectedDate",
                  "setActiveIndexToStart",
                  "invokeOnClose",
                  "setRestoreFocus"
                ]
              },
              {
                guard: and4("isRangePicker", "isSelectingEndDate", "closeOnSelect"),
                target: "focused",
                actions: [
                  "setFocusedDate",
                  "setSelectedDate",
                  "setActiveIndexToStart",
                  "invokeOnClose",
                  "focusInputElement"
                ]
              },
              {
                guard: and4("isRangePicker", "isSelectingEndDate"),
                actions: ["setFocusedDate", "setSelectedDate", "setActiveIndexToStart", "clearHoveredDate"]
              },
              // ===
              {
                guard: "isRangePicker",
                actions: ["setFocusedDate", "setSelectedDate", "setActiveIndexToEnd"]
              },
              {
                guard: "isMultiPicker",
                actions: ["setFocusedDate", "toggleSelectedDate"]
              },
              // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===
              {
                guard: and4("closeOnSelect", "isOpenControlled"),
                actions: ["setFocusedDate", "setSelectedDate", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["setFocusedDate", "setSelectedDate", "invokeOnClose", "focusInputElement"]
              },
              {
                actions: ["setFocusedDate", "setSelectedDate"]
              }
              // ===
            ],
            "CELL.POINTER_MOVE": {
              guard: and4("isRangePicker", "isSelectingEndDate"),
              actions: ["setHoveredDate", "setFocusedDate"]
            },
            "TABLE.POINTER_LEAVE": {
              guard: "isRangePicker",
              actions: ["clearHoveredDate"]
            },
            "TABLE.POINTER_DOWN": {
              actions: ["disableTextSelection"]
            },
            "TABLE.POINTER_UP": {
              actions: ["enableTextSelection"]
            },
            "TABLE.ESCAPE": [
              {
                guard: "isOpenControlled",
                actions: ["focusFirstSelectedDate", "invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["focusFirstSelectedDate", "invokeOnClose", "focusTriggerElement"]
              }
            ],
            "TABLE.ENTER": [
              {
                guard: "isAboveMinView",
                actions: ["setPreviousView"]
              },
              {
                guard: and4("isRangePicker", "hasSelectedRange"),
                actions: ["setActiveIndexToStart", "clearDateValue", "setSelectedDate", "setActiveIndexToEnd"]
              },
              // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===
              {
                guard: and4("isRangePicker", "isSelectingEndDate", "closeOnSelect", "isOpenControlled"),
                actions: ["setSelectedDate", "setActiveIndexToStart", "invokeOnClose"]
              },
              {
                guard: and4("isRangePicker", "isSelectingEndDate", "closeOnSelect"),
                target: "focused",
                actions: ["setSelectedDate", "setActiveIndexToStart", "invokeOnClose", "focusInputElement"]
              },
              {
                guard: and4("isRangePicker", "isSelectingEndDate"),
                actions: ["setSelectedDate", "setActiveIndexToStart"]
              },
              // ===
              {
                guard: "isRangePicker",
                actions: ["setSelectedDate", "setActiveIndexToEnd", "focusNextDay"]
              },
              {
                guard: "isMultiPicker",
                actions: ["toggleSelectedDate"]
              },
              // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===
              {
                guard: and4("closeOnSelect", "isOpenControlled"),
                actions: ["selectFocusedDate", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectFocusedDate", "invokeOnClose", "focusInputElement"]
              },
              {
                actions: ["selectFocusedDate"]
              }
              // ===
            ],
            "TABLE.ARROW_RIGHT": [
              {
                guard: "isMonthView",
                actions: "focusNextMonth"
              },
              {
                guard: "isYearView",
                actions: "focusNextYear"
              },
              {
                actions: ["focusNextDay", "setHoveredDate"]
              }
            ],
            "TABLE.ARROW_LEFT": [
              {
                guard: "isMonthView",
                actions: "focusPreviousMonth"
              },
              {
                guard: "isYearView",
                actions: "focusPreviousYear"
              },
              {
                actions: ["focusPreviousDay"]
              }
            ],
            "TABLE.ARROW_UP": [
              {
                guard: "isMonthView",
                actions: "focusPreviousMonthColumn"
              },
              {
                guard: "isYearView",
                actions: "focusPreviousYearColumn"
              },
              {
                actions: ["focusPreviousWeek"]
              }
            ],
            "TABLE.ARROW_DOWN": [
              {
                guard: "isMonthView",
                actions: "focusNextMonthColumn"
              },
              {
                guard: "isYearView",
                actions: "focusNextYearColumn"
              },
              {
                actions: ["focusNextWeek"]
              }
            ],
            "TABLE.PAGE_UP": {
              actions: ["focusPreviousSection"]
            },
            "TABLE.PAGE_DOWN": {
              actions: ["focusNextSection"]
            },
            "TABLE.HOME": [
              {
                guard: "isMonthView",
                actions: ["focusFirstMonth"]
              },
              {
                guard: "isYearView",
                actions: ["focusFirstYear"]
              },
              {
                actions: ["focusSectionStart"]
              }
            ],
            "TABLE.END": [
              {
                guard: "isMonthView",
                actions: ["focusLastMonth"]
              },
              {
                guard: "isYearView",
                actions: ["focusLastYear"]
              },
              {
                actions: ["focusSectionEnd"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose"]
              }
            ],
            "VIEW.TOGGLE": {
              actions: ["setNextView"]
            },
            INTERACT_OUTSIDE: [
              {
                guard: "isOpenControlled",
                actions: ["setActiveIndexToStart", "invokeOnClose"]
              },
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["setActiveIndexToStart", "invokeOnClose", "focusTriggerElement"]
              },
              {
                target: "idle",
                actions: ["setActiveIndexToStart", "invokeOnClose"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["setActiveIndexToStart", "invokeOnClose"]
              },
              {
                target: "idle",
                actions: ["setActiveIndexToStart", "invokeOnClose"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isAboveMinView: (ctx2) => isAboveMinView(ctx2.view, ctx2.minView),
        isDayView: (ctx2, evt) => (evt.view || ctx2.view) === "day",
        isMonthView: (ctx2, evt) => (evt.view || ctx2.view) === "month",
        isYearView: (ctx2, evt) => (evt.view || ctx2.view) === "year",
        isRangePicker: (ctx2) => ctx2.selectionMode === "range",
        hasSelectedRange: (ctx2) => ctx2.value.length === 2,
        isMultiPicker: (ctx2) => ctx2.selectionMode === "multiple",
        shouldRestoreFocus: (ctx2) => !!ctx2.restoreFocus,
        isSelectingEndDate: (ctx2) => ctx2.activeIndex === 1,
        closeOnSelect: (ctx2) => !!ctx2.closeOnSelect,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        isInteractOutsideEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "INTERACT_OUTSIDE";
        },
        isInputValueEmpty: (_ctx, evt) => evt.value.trim() === "",
        shouldFixOnBlur: (_ctx, evt) => !!evt.fixOnBlur
      },
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement || (ctx2.currentPlacement = ctx2.positioning.placement);
          const anchorEl = dom4.getControlEl(ctx2);
          const getPositionerEl = () => dom4.getPositionerEl(ctx2);
          return getPlacement(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        setupLiveRegion(ctx2) {
          const doc = dom4.getDoc(ctx2);
          ctx2.announcer = createLiveRegion({ level: "assertive", document: doc });
          return () => {
            var _a8, _b7;
            return (_b7 = (_a8 = ctx2.announcer) == null ? void 0 : _a8.destroy) == null ? void 0 : _b7.call(_a8);
          };
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom4.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            defer: true,
            exclude: [...dom4.getInputEls(ctx2), dom4.getTriggerEl(ctx2), dom4.getClearTriggerEl(ctx2)],
            onInteractOutside(event) {
              ctx2.restoreFocus = !event.detail.focusable;
            },
            onDismiss() {
              send({ type: "INTERACT_OUTSIDE" });
            },
            onEscapeKeyDown(event) {
              event.preventDefault();
              send({ type: "TABLE.ESCAPE", src: "dismissable" });
            }
          });
        }
      },
      actions: {
        setNextView(ctx2) {
          const nextView = getNextView(ctx2.view, ctx2.minView, ctx2.maxView);
          set5.view(ctx2, nextView);
        },
        setPreviousView(ctx2) {
          const prevView = getPreviousView(ctx2.view, ctx2.minView, ctx2.maxView);
          set5.view(ctx2, prevView);
        },
        setView(ctx2, evt) {
          set5.view(ctx2, evt.view);
        },
        setRestoreFocus(ctx2) {
          ctx2.restoreFocus = true;
        },
        announceValueText(ctx2) {
          var _a8;
          const announceText = ctx2.value.map((date) => formatSelectedDate(date, null, ctx2.locale, ctx2.timeZone));
          (_a8 = ctx2.announcer) == null ? void 0 : _a8.announce(announceText.join(","), 3e3);
        },
        announceVisibleRange(ctx2) {
          var _a8;
          const { formatted } = ctx2.visibleRangeText;
          (_a8 = ctx2.announcer) == null ? void 0 : _a8.announce(formatted);
        },
        disableTextSelection(ctx2) {
          disableTextSelection({ target: dom4.getContentEl(ctx2), doc: dom4.getDoc(ctx2) });
        },
        enableTextSelection(ctx2) {
          restoreTextSelection({ doc: dom4.getDoc(ctx2), target: dom4.getContentEl(ctx2) });
        },
        focusFirstSelectedDate(ctx2) {
          if (!ctx2.value.length) return;
          set5.focusedValue(ctx2, ctx2.value[0]);
        },
        syncInputElement(ctx2) {
          raf(() => {
            const inputEls = dom4.getInputEls(ctx2);
            inputEls.forEach((inputEl, index) => {
              dom4.setValue(inputEl, ctx2.valueAsString[index] || "");
            });
          });
        },
        setFocusedDate(ctx2, evt) {
          const value = Array.isArray(evt.value) ? evt.value[0] : evt.value;
          set5.focusedValue(ctx2, value);
        },
        setFocusedValueForView(ctx2, evt) {
          set5.focusedValue(ctx2, ctx2.focusedValue.set({ [ctx2.view]: evt.value }));
        },
        focusNextMonth(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.add({ months: 1 }));
        },
        focusPreviousMonth(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.subtract({ months: 1 }));
        },
        setDateValue(ctx2, evt) {
          if (!Array.isArray(evt.value)) return;
          const value = evt.value.map((date) => constrainValue(date, ctx2.min, ctx2.max));
          set5.value(ctx2, value);
        },
        clearDateValue(ctx2) {
          set5.value(ctx2, []);
        },
        setSelectedDate(ctx2, evt) {
          const values = Array.from(ctx2.value);
          values[ctx2.activeIndex] = normalizeValue(ctx2, evt.value ?? ctx2.focusedValue);
          set5.value(ctx2, adjustStartAndEndDate(values));
        },
        toggleSelectedDate(ctx2, evt) {
          const currentValue = normalizeValue(ctx2, evt.value ?? ctx2.focusedValue);
          const index = ctx2.value.findIndex((date) => isDateEqual(date, currentValue));
          if (index === -1) {
            const values = [...ctx2.value, currentValue];
            set5.value(ctx2, sortDates(values));
          } else {
            const values = Array.from(ctx2.value);
            values.splice(index, 1);
            set5.value(ctx2, sortDates(values));
          }
        },
        setHoveredDate(ctx2, evt) {
          ctx2.hoveredValue = evt.value;
        },
        clearHoveredDate(ctx2) {
          ctx2.hoveredValue = null;
        },
        selectFocusedDate(ctx2) {
          const values = Array.from(ctx2.value);
          values[ctx2.activeIndex] = ctx2.focusedValue.copy();
          set5.value(ctx2, adjustStartAndEndDate(values));
          set5.inputValue(ctx2, ctx2.activeIndex);
        },
        focusPreviousDay(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.subtract({ days: 1 }));
        },
        focusNextDay(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.add({ days: 1 }));
        },
        focusPreviousWeek(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.subtract({ weeks: 1 }));
        },
        focusNextWeek(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.add({ weeks: 1 }));
        },
        focusNextPage(ctx2) {
          const nextPage = getNextPage(
            ctx2.focusedValue,
            ctx2.startValue,
            ctx2.visibleDuration,
            ctx2.locale,
            ctx2.min,
            ctx2.max
          );
          set5.adjustedValue(ctx2, nextPage);
        },
        focusPreviousPage(ctx2) {
          const previousPage = getPreviousPage(
            ctx2.focusedValue,
            ctx2.startValue,
            ctx2.visibleDuration,
            ctx2.locale,
            ctx2.min,
            ctx2.max
          );
          set5.adjustedValue(ctx2, previousPage);
        },
        focusSectionStart(ctx2) {
          set5.focusedValue(ctx2, ctx2.startValue.copy());
        },
        focusSectionEnd(ctx2) {
          set5.focusedValue(ctx2, ctx2.endValue.copy());
        },
        focusNextSection(ctx2, evt) {
          const nextSection = getNextSection(
            ctx2.focusedValue,
            ctx2.startValue,
            evt.larger,
            ctx2.visibleDuration,
            ctx2.locale,
            ctx2.min,
            ctx2.max
          );
          if (!nextSection) return;
          set5.adjustedValue(ctx2, nextSection);
        },
        focusPreviousSection(ctx2, evt) {
          const previousSection = getPreviousSection(
            ctx2.focusedValue,
            ctx2.startValue,
            evt.larger,
            ctx2.visibleDuration,
            ctx2.locale,
            ctx2.min,
            ctx2.max
          );
          if (!previousSection) return;
          set5.adjustedValue(ctx2, previousSection);
        },
        focusNextYear(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.add({ years: 1 }));
        },
        focusPreviousYear(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.subtract({ years: 1 }));
        },
        focusNextDecade(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.add({ years: 10 }));
        },
        focusPreviousDecade(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.subtract({ years: 10 }));
        },
        clearFocusedDate(ctx2) {
          set5.focusedValue(ctx2, getTodayDate(ctx2.timeZone));
        },
        focusPreviousMonthColumn(ctx2, evt) {
          set5.focusedValue(ctx2, ctx2.focusedValue.subtract({ months: evt.columns }));
        },
        focusNextMonthColumn(ctx2, evt) {
          set5.focusedValue(ctx2, ctx2.focusedValue.add({ months: evt.columns }));
        },
        focusPreviousYearColumn(ctx2, evt) {
          set5.focusedValue(ctx2, ctx2.focusedValue.subtract({ years: evt.columns }));
        },
        focusNextYearColumn(ctx2, evt) {
          set5.focusedValue(ctx2, ctx2.focusedValue.add({ years: evt.columns }));
        },
        focusFirstMonth(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.set({ month: 0 }));
        },
        focusLastMonth(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.set({ month: 12 }));
        },
        focusFirstYear(ctx2) {
          const range2 = getDecadeRange(ctx2.focusedValue.year);
          set5.focusedValue(ctx2, ctx2.focusedValue.set({ year: range2[0] }));
        },
        focusLastYear(ctx2) {
          const range2 = getDecadeRange(ctx2.focusedValue.year);
          set5.focusedValue(ctx2, ctx2.focusedValue.set({ year: range2[range2.length - 1] }));
        },
        setActiveIndex(ctx2, evt) {
          ctx2.activeIndex = evt.index;
        },
        setActiveIndexToEnd(ctx2) {
          ctx2.activeIndex = 1;
        },
        setActiveIndexToStart(ctx2) {
          ctx2.activeIndex = 0;
        },
        focusActiveCell(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom4.getFocusedCell(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        focusActiveCellIfNeeded(ctx2, evt) {
          if (!evt.focus) return;
          raf(() => {
            var _a8;
            (_a8 = dom4.getFocusedCell(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        setHoveredValueIfKeyboard(ctx2, evt) {
          if (!evt.type.startsWith("TABLE.ARROW") || ctx2.selectionMode !== "range" || ctx2.activeIndex === 0) return;
          ctx2.hoveredValue = ctx2.focusedValue.copy();
        },
        focusTriggerElement(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom4.getTriggerEl(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        focusFirstInputElement(ctx2) {
          raf(() => {
            const [inputEl] = dom4.getInputEls(ctx2);
            inputEl == null ? void 0 : inputEl.focus({ preventScroll: true });
          });
        },
        focusInputElement(ctx2) {
          raf(() => {
            const inputEls = dom4.getInputEls(ctx2);
            const lastIndexWithValue = inputEls.findLastIndex((inputEl2) => inputEl2.value !== "");
            const indexToFocus = Math.max(lastIndexWithValue, 0);
            const inputEl = inputEls[indexToFocus];
            inputEl == null ? void 0 : inputEl.focus({ preventScroll: true });
            inputEl == null ? void 0 : inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
          });
        },
        syncMonthSelectElement(ctx2) {
          const monthSelectEl = dom4.getMonthSelectEl(ctx2);
          dom4.setValue(monthSelectEl, ctx2.startValue.month.toString());
        },
        syncYearSelectElement(ctx2) {
          const yearSelectEl = dom4.getYearSelectEl(ctx2);
          dom4.setValue(yearSelectEl, ctx2.startValue.year.toString());
        },
        setInputValue(ctx2, evt) {
          if (ctx2.activeIndex !== evt.index) return;
          ctx2.inputValue = evt.value;
        },
        syncInputValue(ctx2, evt) {
          queueMicrotask(() => {
            const inputEls = dom4.getInputEls(ctx2);
            const idx = evt.index ?? ctx2.activeIndex;
            dom4.setValue(inputEls[idx], ctx2.inputValue);
          });
        },
        focusParsedDate(ctx2, evt) {
          if (evt.index == null) return;
          const date = ctx2.parse(evt.value, { locale: ctx2.locale, timeZone: ctx2.timeZone });
          if (!date || !isValidDate(date)) return;
          set5.focusedValue(ctx2, date);
        },
        selectParsedDate(ctx2, evt) {
          if (evt.index == null) return;
          let date = ctx2.parse(evt.value, { locale: ctx2.locale, timeZone: ctx2.timeZone });
          if (!date || !isValidDate(date)) {
            if (evt.value) {
              date = ctx2.focusedValue.copy();
            }
          }
          if (!date) return;
          const values = Array.from(ctx2.value);
          values[evt.index] = date;
          set5.value(ctx2, values);
          set5.inputValue(ctx2, evt.index);
        },
        resetView(ctx2, _evt, { initialContext }) {
          set5.view(ctx2, initialContext.view);
        },
        setStartValue(ctx2) {
          const outside = isDateOutsideVisibleRange(ctx2.focusedValue, ctx2.startValue, ctx2.endValue);
          if (!outside) return;
          const startValue = alignDate(ctx2.focusedValue, "start", { months: ctx2.numOfMonths }, ctx2.locale);
          ctx2.startValue = startValue;
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      },
      compareFns: {
        startValue: isDateEqual,
        endValue: isDateEqual,
        focusedValue: isDateEqual,
        value: isDateEqualFn
      }
    }
  );
}
var invoke3 = {
  change(ctx) {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, {
      value: Array.from(ctx.value),
      valueAsString: Array.from(ctx.valueAsString),
      view: ctx.view
    });
  },
  focusChange(ctx) {
    var _a8;
    (_a8 = ctx.onFocusChange) == null ? void 0 : _a8.call(ctx, {
      focusedValue: ctx.focusedValue,
      value: Array.from(ctx.value),
      valueAsString: Array.from(ctx.valueAsString),
      view: ctx.view
    });
  },
  viewChange(ctx) {
    var _a8;
    (_a8 = ctx.onViewChange) == null ? void 0 : _a8.call(ctx, { view: ctx.view });
  }
};
var isDateEqualFn = (a2, b2) => {
  if (a2.length !== b2.length) return false;
  return a2.every((date, index) => isDateEqual(date, b2[index]));
};
var normalizeValue = (ctx, value) => {
  let dateValue = typeof value === "number" ? ctx.focusedValue.set({ [ctx.view]: value }) : value;
  eachView((view) => {
    if (isBelowMinView(view, ctx.minView)) {
      dateValue = dateValue.set({ [view]: view === "day" ? 1 : 0 });
    }
  });
  return dateValue;
};
var set5 = {
  value(ctx, value) {
    if (isDateEqualFn(ctx.value, value)) return;
    ctx.value = value;
    invoke3.change(ctx);
  },
  focusedValue(ctx, mixedValue) {
    if (!mixedValue) return;
    const value = normalizeValue(ctx, mixedValue);
    if (isDateEqual(ctx.focusedValue, value)) return;
    const adjustFn = getAdjustedDateFn(ctx.visibleDuration, ctx.locale, ctx.min, ctx.max);
    const adjustedValue = adjustFn({
      focusedDate: value,
      startDate: ctx.startValue
    });
    ctx.startValue = adjustedValue.startDate;
    ctx.focusedValue = adjustedValue.focusedDate;
    invoke3.focusChange(ctx);
  },
  adjustedValue(ctx, value) {
    ctx.startValue = value.startDate;
    if (isDateEqual(ctx.focusedValue, value.focusedDate)) return;
    ctx.focusedValue = value.focusedDate;
    invoke3.focusChange(ctx);
  },
  view(ctx, value) {
    if (isEqual(ctx.view, value)) return;
    ctx.view = value;
    invoke3.viewChange(ctx);
  },
  inputValue(ctx, index) {
    const value = ctx.valueAsString[index];
    if (ctx.inputValue === value) return;
    ctx.inputValue = value;
  }
};
var props4 = createProps()([
  "closeOnSelect",
  "dir",
  "disabled",
  "fixedWeeks",
  "focusedValue",
  "format",
  "parse",
  "placeholder",
  "getRootNode",
  "id",
  "ids",
  "isDateUnavailable",
  "isDateUnavailable",
  "locale",
  "max",
  "min",
  "name",
  "numOfMonths",
  "onFocusChange",
  "onOpenChange",
  "onValueChange",
  "onViewChange",
  "open",
  "open.controlled",
  "positioning",
  "readOnly",
  "selectionMode",
  "startOfWeek",
  "timeZone",
  "translations",
  "value",
  "view",
  "minView",
  "maxView"
]);
var splitProps5 = createSplitProps(props4);
var inputProps = createProps()(["index", "fixOnBlur"]);
var splitInputProps = createSplitProps(inputProps);
var presetTriggerProps = createProps()(["value"]);
var splitPresetTriggerProps = createSplitProps(presetTriggerProps);
var tableProps = createProps()(["columns", "id", "view"]);
var splitTableProps = createSplitProps(tableProps);
var tableCellProps = createProps()(["disabled", "value", "columns"]);
var splitTableCellProps = createSplitProps(tableCellProps);
var viewProps = createProps()(["view"]);
var splitViewProps = createSplitProps(viewProps);

// node_modules/@ark-ui/react/dist/utils/render-strategy.js
var [RenderStrategyPropsProvider, useRenderStrategyPropsContext] = createContext3({
  name: "RenderStrategyContext",
  hookName: "useRenderStrategyContext",
  providerName: "<RenderStrategyPropsProvider />"
});
var splitRenderStrategyProps = (props34) => createSplitProps2()(props34, ["lazyMount", "unmountOnExit"]);

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion-item-props-context.js
var [AccordionItemPropsProvider, useAccordionItemPropsContext] = createContext3({
  name: "AccordionItemPropsContext",
  hookName: "useAccordionItemPropsContext",
  providerName: "<AccordionItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item.js
var AccordionItem = (0, import_react30.forwardRef)((props34, ref2) => {
  const [itemProps12, localProps] = splitItemProps(props34);
  const accordion = useAccordionContext();
  const renderStrategy = useRenderStrategyPropsContext();
  const mergedProps = mergeProps2(accordion.getItemProps(itemProps12), localProps);
  const item = accordion.getItemState(itemProps12);
  const itemContentProps = accordion.getItemContentProps(itemProps12);
  return (0, import_jsx_runtime12.jsx)(AccordionItemPropsProvider, { value: itemProps12, children: (0, import_jsx_runtime12.jsx)(AccordionItemProvider, { value: item, children: (0, import_jsx_runtime12.jsx)(
    CollapsibleRoot,
    {
      ref: ref2,
      open: item.expanded,
      ids: { content: itemContentProps.id },
      ...renderStrategy,
      ...mergedProps
    }
  ) }) });
});
AccordionItem.displayName = "AccordionItem";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-content.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var import_react34 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-content.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_react32 = __toESM(require_react(), 1);
var CollapsibleContent = (0, import_react32.forwardRef)(
  (props34, ref2) => {
    const collapsible = useCollapsibleContext();
    if (collapsible.isUnmounted) {
      return null;
    }
    const mergedProps = mergeProps2(collapsible.getContentProps(), props34);
    return (0, import_jsx_runtime13.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
CollapsibleContent.displayName = "CollapsibleContent";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-content.js
var splitVisibilityProps = createSplitProps2();
var AccordionItemContent = (0, import_react34.forwardRef)(
  (props34, ref2) => {
    const accordion = useAccordionContext();
    const itemProps12 = useAccordionItemPropsContext();
    const contentProps2 = accordion.getItemContentProps(itemProps12);
    const [, itemContentProps] = splitVisibilityProps(contentProps2, ["hidden", "data-state"]);
    const mergedProps = mergeProps2(itemContentProps, props34);
    return (0, import_jsx_runtime14.jsx)(CollapsibleContent, { ref: ref2, ...mergedProps });
  }
);
AccordionItemContent.displayName = "AccordionItemContent";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-context.js
var AccordionItemContext = (props34) => props34.children(useAccordionItemContext());

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-indicator.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_react36 = __toESM(require_react(), 1);
var AccordionItemIndicator = (0, import_react36.forwardRef)(
  (props34, ref2) => {
    const accordion = useAccordionContext();
    const itemProps12 = useAccordionItemPropsContext();
    const mergedProps = mergeProps2(accordion.getItemIndicatorProps(itemProps12), props34);
    return (0, import_jsx_runtime15.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
AccordionItemIndicator.displayName = "AccordionItemIndicator";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-trigger.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_react38 = __toESM(require_react(), 1);
var AccordionItemTrigger = (0, import_react38.forwardRef)(
  (props34, ref2) => {
    const accordion = useAccordionContext();
    const itemProps12 = useAccordionItemPropsContext();
    const collapsible = useCollapsibleContext();
    const triggerProps2 = accordion.getItemTriggerProps(itemProps12);
    const mergedProps = mergeProps2(
      {
        ...triggerProps2,
        "aria-controls": collapsible.isUnmounted ? void 0 : triggerProps2["aria-controls"]
      },
      props34
    );
    return (0, import_jsx_runtime16.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
AccordionItemTrigger.displayName = "AccordionItemTrigger";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-root.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_react42 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion.js
var import_react40 = __toESM(require_react(), 1);
var useAccordion = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react40.useId)(),
    dir,
    getRootNode,
    value: props34.defaultValue,
    ...props34
  };
  const context = {
    ...initialContext,
    value: props34.value,
    onFocusChange: useEvent(props34.onFocusChange),
    onValueChange: useEvent(props34.onValueChange)
  };
  const [state2, send] = useMachine(machine2(initialContext), { context });
  return connect2(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/accordion/accordion-root.js
var AccordionRoot = (0, import_react42.forwardRef)((props34, ref2) => {
  const [renderStrategyProps, accordionProps] = splitRenderStrategyProps(props34);
  const [useAccordionProps, localProps] = createSplitProps2()(accordionProps, [
    "collapsible",
    "defaultValue",
    "disabled",
    "id",
    "ids",
    "multiple",
    "onFocusChange",
    "onValueChange",
    "orientation",
    "value"
  ]);
  const accordion = useAccordion(useAccordionProps);
  const mergedProps = mergeProps2(accordion.getRootProps(), localProps);
  return (0, import_jsx_runtime17.jsx)(AccordionProvider, { value: accordion, children: (0, import_jsx_runtime17.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime17.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
AccordionRoot.displayName = "AccordionRoot";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-root-provider.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_react44 = __toESM(require_react(), 1);
var AccordionRootProvider = (0, import_react44.forwardRef)(
  (props34, ref2) => {
    const [renderStrategyProps, accordionProps] = splitRenderStrategyProps(props34);
    const [{ value: accordion }, localProps] = createSplitProps2()(
      accordionProps,
      ["value"]
    );
    const mergedProps = mergeProps2(accordion.getRootProps(), localProps);
    return (0, import_jsx_runtime18.jsx)(AccordionProvider, { value: accordion, children: (0, import_jsx_runtime18.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime18.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
  }
);
AccordionRootProvider.displayName = "AccordionRootProvider";

// node_modules/@ark-ui/react/dist/components/accordion/accordion.js
var accordion_exports = {};
__export(accordion_exports, {
  Context: () => AccordionContext,
  Item: () => AccordionItem,
  ItemContent: () => AccordionItemContent,
  ItemContext: () => AccordionItemContext,
  ItemIndicator: () => AccordionItemIndicator,
  ItemTrigger: () => AccordionItemTrigger,
  Root: () => AccordionRoot,
  RootProvider: () => AccordionRootProvider
});

// node_modules/@ark-ui/react/dist/components/avatar/use-avatar-context.js
var [AvatarProvider, useAvatarContext] = createContext3({
  name: "AvatarContext",
  hookName: "useAvatarContext",
  providerName: "<AvatarProvider />"
});

// node_modules/@ark-ui/react/dist/components/avatar/avatar-context.js
var AvatarContext = (props34) => props34.children(useAvatarContext());

// node_modules/@ark-ui/react/dist/components/avatar/avatar-fallback.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_react46 = __toESM(require_react(), 1);
var AvatarFallback = (0, import_react46.forwardRef)((props34, ref2) => {
  const avatar = useAvatarContext();
  const mergedProps = mergeProps2(avatar.getFallbackProps(), props34);
  return (0, import_jsx_runtime19.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
AvatarFallback.displayName = "AvatarFallback";

// node_modules/@ark-ui/react/dist/components/avatar/avatar-image.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var import_react48 = __toESM(require_react(), 1);
var AvatarImage = (0, import_react48.forwardRef)((props34, ref2) => {
  const avatar = useAvatarContext();
  const mergedProps = mergeProps2(avatar.getImageProps(), props34);
  return (0, import_jsx_runtime20.jsx)(ark.img, { ...mergedProps, ref: ref2 });
});
AvatarImage.displayName = "AvatarImage";

// node_modules/@ark-ui/react/dist/components/avatar/avatar-root.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var import_react52 = __toESM(require_react(), 1);

// node_modules/@zag-js/avatar/dist/index.mjs
var anatomy5 = createAnatomy("avatar").parts("root", "image", "fallback");
var parts5 = anatomy5.build();
var dom5 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `avatar:${ctx.id}`;
  },
  getImageId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.image) ?? `avatar:${ctx.id}:image`;
  },
  getFallbackId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.fallback) ?? `avatar:${ctx.id}:fallback`;
  },
  getRootEl: (ctx) => dom5.getById(ctx, dom5.getRootId(ctx)),
  getImageEl: (ctx) => dom5.getById(ctx, dom5.getImageId(ctx))
});
function connect6(state2, send, normalize3) {
  const loaded = state2.matches("loaded");
  return {
    loaded,
    setSrc(src) {
      send({ type: "SRC.SET", src });
    },
    setLoaded() {
      send({ type: "IMG.LOADED", src: "api" });
    },
    setError() {
      send({ type: "IMG.ERROR", src: "api" });
    },
    getRootProps() {
      return normalize3.element({
        ...parts5.root.attrs,
        dir: state2.context.dir,
        id: dom5.getRootId(state2.context)
      });
    },
    getImageProps() {
      return normalize3.img({
        ...parts5.image.attrs,
        hidden: !loaded,
        dir: state2.context.dir,
        id: dom5.getImageId(state2.context),
        "data-state": loaded ? "visible" : "hidden",
        onLoad() {
          send({ type: "IMG.LOADED", src: "element" });
        },
        onError() {
          send({ type: "IMG.ERROR", src: "element" });
        }
      });
    },
    getFallbackProps() {
      return normalize3.element({
        ...parts5.fallback.attrs,
        dir: state2.context.dir,
        id: dom5.getFallbackId(state2.context),
        hidden: loaded,
        "data-state": loaded ? "hidden" : "visible"
      });
    }
  };
}
function machine6(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "avatar",
      initial: "loading",
      activities: ["trackImageRemoval"],
      context: ctx,
      on: {
        "SRC.CHANGE": {
          target: "loading"
        },
        "IMG.UNMOUNT": {
          target: "error"
        }
      },
      states: {
        loading: {
          activities: ["trackSrcChange"],
          entry: ["checkImageStatus"],
          on: {
            "IMG.LOADED": {
              target: "loaded",
              actions: ["invokeOnLoad"]
            },
            "IMG.ERROR": {
              target: "error",
              actions: ["invokeOnError"]
            }
          }
        },
        error: {
          activities: ["trackSrcChange"],
          on: {
            "IMG.LOADED": {
              target: "loaded",
              actions: ["invokeOnLoad"]
            }
          }
        },
        loaded: {
          activities: ["trackSrcChange"],
          on: {
            "IMG.ERROR": {
              target: "error",
              actions: ["invokeOnError"]
            }
          }
        }
      }
    },
    {
      activities: {
        trackSrcChange(ctx2, _evt, { send }) {
          const imageEl = dom5.getImageEl(ctx2);
          return observeAttributes(imageEl, {
            attributes: ["src", "srcset"],
            callback() {
              send({ type: "SRC.CHANGE" });
            }
          });
        },
        trackImageRemoval(ctx2, _evt, { send }) {
          const rootEl = dom5.getRootEl(ctx2);
          return observeChildren(rootEl, {
            callback(records) {
              const removedNodes = Array.from(records[0].removedNodes);
              const removed = removedNodes.find(
                (node2) => node2.nodeType === Node.ELEMENT_NODE && node2.matches("[data-scope=avatar][data-part=image]")
              );
              if (removed) {
                send({ type: "IMG.UNMOUNT" });
              }
            }
          });
        }
      },
      actions: {
        invokeOnLoad(ctx2) {
          var _a8;
          (_a8 = ctx2.onStatusChange) == null ? void 0 : _a8.call(ctx2, { status: "loaded" });
        },
        invokeOnError(ctx2) {
          var _a8;
          (_a8 = ctx2.onStatusChange) == null ? void 0 : _a8.call(ctx2, { status: "error" });
        },
        checkImageStatus(ctx2, _evt, { send }) {
          const imageEl = dom5.getImageEl(ctx2);
          if (imageEl == null ? void 0 : imageEl.complete) {
            const type = hasLoaded(imageEl) ? "IMG.LOADED" : "IMG.ERROR";
            send({ type, src: "ssr" });
          }
        }
      }
    }
  );
}
function hasLoaded(image) {
  return image.complete && image.naturalWidth !== 0 && image.naturalHeight !== 0;
}
var props5 = createProps()(["dir", "id", "ids", "onStatusChange", "getRootNode"]);
var splitProps6 = createSplitProps(props5);

// node_modules/@ark-ui/react/dist/components/avatar/use-avatar.js
var import_react50 = __toESM(require_react(), 1);
var useAvatar = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react50.useId)(),
    dir,
    getRootNode,
    ...props34
  };
  const context = {
    ...initialContext,
    onStatusChange: useEvent(props34.onStatusChange)
  };
  const [state2, send] = useMachine(machine6(initialContext), { context });
  return connect6(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/avatar/avatar-root.js
var AvatarRoot = (0, import_react52.forwardRef)((props34, ref2) => {
  const [useAvatarProps, localProps] = createSplitProps2()(props34, [
    "id",
    "ids",
    "onStatusChange"
  ]);
  const avatar = useAvatar(useAvatarProps);
  const mergedProps = mergeProps2(avatar.getRootProps(), localProps);
  return (0, import_jsx_runtime21.jsx)(AvatarProvider, { value: avatar, children: (0, import_jsx_runtime21.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
AvatarRoot.displayName = "AvatarRoot";

// node_modules/@ark-ui/react/dist/components/avatar/avatar-root-provider.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var import_react54 = __toESM(require_react(), 1);
var AvatarRootProvider = (0, import_react54.forwardRef)(
  (props34, ref2) => {
    const [{ value: avatar }, localProps] = createSplitProps2()(props34, ["value"]);
    const mergedProps = mergeProps2(avatar.getRootProps(), localProps);
    return (0, import_jsx_runtime22.jsx)(AvatarProvider, { value: avatar, children: (0, import_jsx_runtime22.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
AvatarRootProvider.displayName = "AvatarRootProvider";

// node_modules/@ark-ui/react/dist/components/avatar/avatar.js
var avatar_exports = {};
__export(avatar_exports, {
  Context: () => AvatarContext,
  Fallback: () => AvatarFallback,
  Image: () => AvatarImage,
  Root: () => AvatarRoot,
  RootProvider: () => AvatarRootProvider
});

// node_modules/@ark-ui/react/dist/components/carousel/carousel-autoplay-trigger.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var import_react56 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/carousel/use-carousel-context.js
var [CarouselProvider, useCarouselContext] = createContext3({
  name: "CarouselContext",
  hookName: "useCarouselContext",
  providerName: "<CarouselProvider />"
});

// node_modules/@ark-ui/react/dist/components/carousel/carousel-autoplay-trigger.js
var CarouselAutoplayTrigger = (0, import_react56.forwardRef)(
  (props34, ref2) => {
    const carousel = useCarouselContext();
    const mergedProps = mergeProps2(carousel.getAutoplayTriggerProps(), props34);
    return (0, import_jsx_runtime23.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
CarouselAutoplayTrigger.displayName = "CarouselAutoplayTrigger";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-control.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var import_react58 = __toESM(require_react(), 1);
var CarouselControl = (0, import_react58.forwardRef)((props34, ref2) => {
  const carousel = useCarouselContext();
  const mergedProps = mergeProps2(carousel.getControlProps(), props34);
  return (0, import_jsx_runtime24.jsx)(ark.div, { ...mergedProps, ...props34, ref: ref2 });
});
CarouselControl.displayName = "CarouselControl";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-indicator.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var import_react60 = __toESM(require_react(), 1);
var CarouselIndicator = (0, import_react60.forwardRef)(
  (props34, ref2) => {
    const [indicatorProps3, localProps] = createSplitProps2()(props34, [
      "readOnly",
      "index"
    ]);
    const carousel = useCarouselContext();
    const mergedProps = mergeProps2(carousel.getIndicatorProps(indicatorProps3), localProps);
    return (0, import_jsx_runtime25.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
CarouselIndicator.displayName = "CarouselIndicator";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-indicator-group.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var import_react62 = __toESM(require_react(), 1);
var CarouselIndicatorGroup = (0, import_react62.forwardRef)(
  (props34, ref2) => {
    const carousel = useCarouselContext();
    const mergedProps = mergeProps2(carousel.getIndicatorGroupProps(), props34);
    return (0, import_jsx_runtime26.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
CarouselIndicatorGroup.displayName = "CarouselIndicatorGroup";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-item.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var import_react64 = __toESM(require_react(), 1);
var CarouselItem = (0, import_react64.forwardRef)((props34, ref2) => {
  const [itemProps12, localProps] = createSplitProps2()(props34, ["index", "snapAlign"]);
  const carousel = useCarouselContext();
  const mergedProps = mergeProps2(carousel.getItemProps(itemProps12), localProps);
  return (0, import_jsx_runtime27.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
CarouselItem.displayName = "CarouselItem";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-item-group.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var import_react66 = __toESM(require_react(), 1);
var CarouselItemGroup = (0, import_react66.forwardRef)(
  (props34, ref2) => {
    const carousel = useCarouselContext();
    const mergedProps = mergeProps2(carousel.getItemGroupProps(), props34);
    return (0, import_jsx_runtime28.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
CarouselItemGroup.displayName = "CarouselItemGroup";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-next-trigger.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var import_react68 = __toESM(require_react(), 1);
var CarouselNextTrigger = (0, import_react68.forwardRef)(
  (props34, ref2) => {
    const carousel = useCarouselContext();
    const mergedProps = mergeProps2(carousel.getNextTriggerProps(), props34);
    return (0, import_jsx_runtime29.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
CarouselNextTrigger.displayName = "CarouselNextTrigger";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-prev-trigger.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var import_react70 = __toESM(require_react(), 1);
var CarouselPrevTrigger = (0, import_react70.forwardRef)(
  (props34, ref2) => {
    const carousel = useCarouselContext();
    const mergedProps = mergeProps2(carousel.getPrevTriggerProps(), props34);
    return (0, import_jsx_runtime30.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
CarouselPrevTrigger.displayName = "CarouselPrevTrigger";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-root.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var import_react74 = __toESM(require_react(), 1);

// node_modules/@zag-js/scroll-snap/dist/index.mjs
function getScrollPadding(element) {
  const style = getComputedStyle2(element);
  const rect = element.getBoundingClientRect();
  let xBeforeRaw = style.getPropertyValue("scroll-padding-left").replace("auto", "0px");
  let yBeforeRaw = style.getPropertyValue("scroll-padding-top").replace("auto", "0px");
  let xAfterRaw = style.getPropertyValue("scroll-padding-right").replace("auto", "0px");
  let yAfterRaw = style.getPropertyValue("scroll-padding-bottom").replace("auto", "0px");
  function convert(raw, size3) {
    let n = parseFloat(raw);
    if (/%/.test(raw)) {
      n /= 100;
      n *= size3;
    }
    return n;
  }
  let xBefore = convert(xBeforeRaw, rect.width);
  let yBefore = convert(yBeforeRaw, rect.height);
  let xAfter = convert(xAfterRaw, rect.width);
  let yAfter = convert(yAfterRaw, rect.height);
  return {
    x: { before: xBefore, after: xAfter },
    y: { before: yBefore, after: yAfter }
  };
}
function isRectIntersecting(a2, b2, axis = "both") {
  return axis === "x" && a2.right >= b2.left && a2.left <= b2.right || axis === "y" && a2.bottom >= b2.top && a2.top <= b2.bottom || axis === "both" && a2.right >= b2.left && a2.left <= b2.right && a2.bottom >= b2.top && a2.top <= b2.bottom;
}
function getDescendants(parent) {
  let children = [];
  for (const child of parent.children) {
    children = children.concat(child, getDescendants(child));
  }
  return children;
}
function getSnapPositions(parent, subtree = false) {
  const parentRect = parent.getBoundingClientRect();
  const positions = {
    x: { start: [], center: [], end: [] },
    y: { start: [], center: [], end: [] }
  };
  const children = subtree ? getDescendants(parent) : parent.children;
  for (const axis of ["x", "y"]) {
    const orthogonalAxis = axis === "x" ? "y" : "x";
    const axisStart = axis === "x" ? "left" : "top";
    const axisSize = axis === "x" ? "width" : "height";
    const axisScroll = axis === "x" ? "scrollLeft" : "scrollTop";
    for (const child of children) {
      const childRect = child.getBoundingClientRect();
      if (!isRectIntersecting(parentRect, childRect, orthogonalAxis)) {
        continue;
      }
      const childStyle = getComputedStyle2(child);
      let [childAlignY, childAlignX] = childStyle.getPropertyValue("scroll-snap-align").split(" ");
      if (typeof childAlignX === "undefined") {
        childAlignX = childAlignY;
      }
      const childAlign = axis === "x" ? childAlignX : childAlignY;
      const childOffsetStart = childRect[axisStart] - parentRect[axisStart] + parent[axisScroll];
      switch (childAlign) {
        case "none":
          break;
        case "start":
          positions[axis].start.push({ node: child, position: childOffsetStart });
          break;
        case "center":
          positions[axis].center.push({ node: child, position: childOffsetStart + childRect[axisSize] / 2 });
          break;
        case "end":
          positions[axis].end.push({ node: child, position: childOffsetStart + childRect[axisSize] });
          break;
      }
    }
  }
  return positions;
}
function getScrollSnapPositions(element) {
  const rect = element.getBoundingClientRect();
  const scrollPadding = getScrollPadding(element);
  const snapPositions = getSnapPositions(element);
  const maxScroll = {
    x: element.scrollWidth - element.offsetWidth,
    y: element.scrollHeight - element.offsetHeight
  };
  return {
    x: uniq2(
      [
        ...snapPositions.x.start.map((v) => v.position - scrollPadding.x.before),
        ...snapPositions.x.center.map((v) => v.position - rect.width / 2),
        ...snapPositions.x.end.map((v) => v.position - rect.width + scrollPadding.x.after)
      ].map(clamp3(0, maxScroll.x))
    ),
    y: uniq2(
      [
        ...snapPositions.y.start.map((v) => v.position - scrollPadding.y.before),
        ...snapPositions.y.center.map((v) => v.position - rect.height / 2),
        ...snapPositions.y.end.map((v) => v.position - rect.height + scrollPadding.y.after)
      ].map(clamp3(0, maxScroll.y))
    )
  };
}
function findSnapPoint(parent, axis, predicate) {
  const snapPositions = getSnapPositions(parent);
  const items = [...snapPositions[axis].start, ...snapPositions[axis].center, ...snapPositions[axis].end];
  for (const item of items) {
    if (predicate(item.node)) {
      return item.position;
    }
  }
}
var uniq2 = (arr) => [...new Set(arr)];
var clamp3 = (min4, max4) => (value) => Math.max(min4, Math.min(max4, value));

// node_modules/@zag-js/carousel/dist/index.mjs
var anatomy6 = createAnatomy("carousel").parts(
  "root",
  "itemGroup",
  "item",
  "control",
  "nextTrigger",
  "prevTrigger",
  "indicatorGroup",
  "indicator",
  "autoplayTrigger"
);
var parts6 = anatomy6.build();
var dom6 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `carousel:${ctx.id}`;
  },
  getItemId: (ctx, index) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, index)) ?? `carousel:${ctx.id}:item:${index}`;
  },
  getItemGroupId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.itemGroup) ?? `carousel:${ctx.id}:item-group`;
  },
  getNextTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.nextTrigger) ?? `carousel:${ctx.id}:next-trigger`;
  },
  getPrevTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.prevTrigger) ?? `carousel:${ctx.id}:prev-trigger`;
  },
  getIndicatorGroupId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.indicatorGroup) ?? `carousel:${ctx.id}:indicator-group`;
  },
  getIndicatorId: (ctx, index) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.indicator) == null ? void 0 : _b7.call(_a8, index)) ?? `carousel:${ctx.id}:indicator:${index}`;
  },
  getRootEl: (ctx) => dom6.getById(ctx, dom6.getRootId(ctx)),
  getItemGroupEl: (ctx) => dom6.getById(ctx, dom6.getItemGroupId(ctx)),
  getItemEl: (ctx, index) => dom6.getById(ctx, dom6.getItemId(ctx, index)),
  getItemEls: (ctx) => queryAll(dom6.getItemGroupEl(ctx), `[data-part=item]`),
  getActiveIndicatorEl: (ctx) => dom6.getById(ctx, dom6.getIndicatorId(ctx, ctx.page)),
  syncTabIndex(ctx) {
    const el = dom6.getItemGroupEl(ctx);
    if (!el) return;
    const tabbables = getTabbables(el);
    if (tabbables.length > 0) {
      el.removeAttribute("tabindex");
    } else {
      el.setAttribute("tabindex", "0");
    }
  }
});
function connect7(state2, send, normalize3) {
  const isPlaying = state2.matches("autoplay");
  const isDragging = state2.matches("dragging");
  const canScrollNext = state2.context.canScrollNext;
  const canScrollPrev = state2.context.canScrollPrev;
  const horizontal = state2.context.isHorizontal;
  const pageSnapPoints = Array.from(state2.context.pageSnapPoints);
  const page = state2.context.page;
  const slidesPerPage = state2.context.slidesPerPage;
  const padding = state2.context.padding;
  const translations = state2.context.translations;
  return {
    isPlaying,
    isDragging,
    page,
    pageSnapPoints,
    canScrollNext,
    canScrollPrev,
    getProgress() {
      return page / pageSnapPoints.length;
    },
    scrollToIndex(index, instant) {
      send({ type: "INDEX.SET", index, instant });
    },
    scrollTo(index, instant) {
      send({ type: "PAGE.SET", index, instant });
    },
    scrollNext(instant) {
      send({ type: "PAGE.NEXT", instant });
    },
    scrollPrev(instant) {
      send({ type: "PAGE.PREV", instant });
    },
    play() {
      send("AUTOPLAY.START");
    },
    pause() {
      send("AUTOPLAY.PAUSE");
    },
    isInView(index) {
      return Array.from(state2.context.slidesInView).includes(index);
    },
    refresh() {
      send({ type: "SNAP.REFRESH" });
    },
    getRootProps() {
      return normalize3.element({
        ...parts6.root.attrs,
        id: dom6.getRootId(state2.context),
        role: "region",
        "aria-roledescription": "carousel",
        "data-orientation": state2.context.orientation,
        dir: state2.context.dir,
        style: {
          "--slides-per-page": slidesPerPage,
          "--slide-spacing": state2.context.spacing,
          "--slide-item-size": "calc(100% / var(--slides-per-page) - var(--slide-spacing) * (var(--slides-per-page) - 1) / var(--slides-per-page))"
        }
      });
    },
    getItemGroupProps() {
      return normalize3.element({
        ...parts6.itemGroup.attrs,
        id: dom6.getItemGroupId(state2.context),
        "data-orientation": state2.context.orientation,
        "data-dragging": dataAttr(isDragging),
        dir: state2.context.dir,
        "aria-live": isPlaying ? "off" : "polite",
        onMouseDown(event) {
          if (!state2.context.allowMouseDrag) return;
          if (event.button !== 0) return;
          if (event.defaultPrevented) return;
          const target = getEventTarget(event);
          if (isFocusable(target) && target !== event.currentTarget) return;
          event.preventDefault();
          send({ type: "DRAGGING.START" });
        },
        style: {
          display: "grid",
          gap: "var(--slide-spacing)",
          scrollSnapType: [horizontal ? "x" : "y", state2.context.snapType].join(" "),
          gridAutoFlow: horizontal ? "column" : "row",
          scrollbarWidth: "none",
          overscrollBehavior: "contain",
          [horizontal ? "gridAutoColumns" : "gridAutoRows"]: "var(--slide-item-size)",
          [horizontal ? "scrollPaddingInline" : "scrollPaddingBlock"]: padding,
          [horizontal ? "paddingInline" : "paddingBlock"]: padding,
          [horizontal ? "overflowX" : "overflowY"]: "auto"
        }
      });
    },
    getItemProps(props210) {
      const isInView = state2.context.slidesInView.includes(props210.index);
      return normalize3.element({
        ...parts6.item.attrs,
        id: dom6.getItemId(state2.context, props210.index),
        dir: state2.context.dir,
        role: "group",
        "data-index": props210.index,
        "data-inview": dataAttr(isInView),
        "aria-roledescription": "slide",
        "data-orientation": state2.context.orientation,
        "aria-label": state2.context.slideCount ? translations.item(props210.index, state2.context.slideCount) : void 0,
        "aria-hidden": ariaAttr(!isInView),
        style: {
          scrollSnapAlign: getSnapAlign(state2.context, props210)
        }
      });
    },
    getControlProps() {
      return normalize3.element({
        ...parts6.control.attrs,
        "data-orientation": state2.context.orientation
      });
    },
    getPrevTriggerProps() {
      return normalize3.button({
        ...parts6.prevTrigger.attrs,
        id: dom6.getPrevTriggerId(state2.context),
        type: "button",
        disabled: !canScrollPrev,
        dir: state2.context.dir,
        "aria-label": translations.prevTrigger,
        "data-orientation": state2.context.orientation,
        "aria-controls": dom6.getItemGroupId(state2.context),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "PAGE.PREV", src: "trigger" });
        }
      });
    },
    getNextTriggerProps() {
      return normalize3.button({
        ...parts6.nextTrigger.attrs,
        dir: state2.context.dir,
        id: dom6.getNextTriggerId(state2.context),
        type: "button",
        "aria-label": translations.nextTrigger,
        "data-orientation": state2.context.orientation,
        "aria-controls": dom6.getItemGroupId(state2.context),
        disabled: !canScrollNext,
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "PAGE.NEXT", src: "trigger" });
        }
      });
    },
    getIndicatorGroupProps() {
      return normalize3.element({
        ...parts6.indicatorGroup.attrs,
        dir: state2.context.dir,
        id: dom6.getIndicatorGroupId(state2.context),
        "data-orientation": state2.context.orientation,
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          const src = "indicator";
          const keyMap2 = {
            ArrowDown(event2) {
              if (horizontal) return;
              send({ type: "PAGE.NEXT", src });
              event2.preventDefault();
            },
            ArrowUp(event2) {
              if (horizontal) return;
              send({ type: "PAGE.PREV", src });
              event2.preventDefault();
            },
            ArrowRight(event2) {
              if (!horizontal) return;
              send({ type: "PAGE.NEXT", src });
              event2.preventDefault();
            },
            ArrowLeft(event2) {
              if (!horizontal) return;
              send({ type: "PAGE.PREV", src });
              event2.preventDefault();
            },
            Home(event2) {
              send({ type: "PAGE.SET", index: 0, src });
              event2.preventDefault();
            },
            End(event2) {
              send({ type: "PAGE.SET", index: pageSnapPoints.length - 1, src });
              event2.preventDefault();
            }
          };
          const key = getEventKey(event, {
            dir: state2.context.dir,
            orientation: state2.context.orientation
          });
          const exec2 = keyMap2[key];
          exec2 == null ? void 0 : exec2(event);
        }
      });
    },
    getIndicatorProps(props210) {
      return normalize3.button({
        ...parts6.indicator.attrs,
        dir: state2.context.dir,
        id: dom6.getIndicatorId(state2.context, props210.index),
        type: "button",
        "data-orientation": state2.context.orientation,
        "data-index": props210.index,
        "data-readonly": dataAttr(props210.readOnly),
        "data-current": dataAttr(props210.index === state2.context.page),
        "aria-label": translations.indicator(props210.index),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (props210.readOnly) return;
          send({ type: "PAGE.SET", index: props210.index, src: "indicator" });
        }
      });
    },
    getAutoplayTriggerProps() {
      return normalize3.button({
        ...parts6.autoplayTrigger.attrs,
        type: "button",
        "data-orientation": state2.context.orientation,
        "data-pressed": dataAttr(isPlaying),
        "aria-label": isPlaying ? translations.autoplayStop : translations.autoplayStart,
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: isPlaying ? "AUTOPLAY.PAUSE" : "AUTOPLAY.START" });
        }
      });
    }
  };
}
function getSnapAlign(ctx, props210) {
  const { snapAlign = "start", index } = props210;
  const perMove = ctx.slidesPerMove === "auto" ? Math.floor(ctx.slidesPerPage) : ctx.slidesPerMove;
  const shouldSnap = (index + perMove) % perMove === 0;
  return shouldSnap ? snapAlign : void 0;
}
var DEFAULT_SLIDES_PER_PAGE = 1;
var DEFAULT_SLIDES_PER_MOVE = "auto";
function machine7(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "carousel",
      initial: ctx.autoplay ? "autoplay" : "idle",
      context: {
        dir: "ltr",
        page: 0,
        orientation: "horizontal",
        snapType: "mandatory",
        loop: false,
        slidesPerPage: DEFAULT_SLIDES_PER_PAGE,
        slidesPerMove: DEFAULT_SLIDES_PER_MOVE,
        spacing: "0px",
        autoplay: false,
        allowMouseDrag: false,
        inViewThreshold: 0.6,
        ...ctx,
        timeoutRef: ref({ current: void 0 }),
        translations: {
          nextTrigger: "Next slide",
          prevTrigger: "Previous slide",
          indicator: (index) => `Go to slide ${index + 1}`,
          item: (index, count) => `${index + 1} of ${count}`,
          autoplayStart: "Start slide rotation",
          autoplayStop: "Stop slide rotation",
          ...ctx.translations
        },
        pageSnapPoints: getPageSnapPoints(
          ctx.slideCount,
          ctx.slidesPerMove ?? DEFAULT_SLIDES_PER_MOVE,
          ctx.slidesPerPage ?? DEFAULT_SLIDES_PER_PAGE
        ),
        slidesInView: []
      },
      computed: {
        isRtl: (ctx2) => ctx2.dir === "rtl",
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        canScrollNext: (ctx2) => ctx2.loop || ctx2.page < ctx2.pageSnapPoints.length - 1,
        canScrollPrev: (ctx2) => ctx2.loop || ctx2.page > 0,
        autoplayInterval: (ctx2) => isObject5(ctx2.autoplay) ? ctx2.autoplay.delay : 4e3
      },
      watch: {
        slidesPerPage: ["setSnapPoints"],
        slidesPerMove: ["setSnapPoints"],
        page: ["scrollToPage", "focusIndicatorEl"],
        orientation: ["setSnapPoints", "scrollToPage"]
      },
      on: {
        "PAGE.NEXT": {
          target: "idle",
          actions: ["clearScrollEndTimer", "setNextPage"]
        },
        "PAGE.PREV": {
          target: "idle",
          actions: ["clearScrollEndTimer", "setPrevPage"]
        },
        "PAGE.SET": {
          target: "idle",
          actions: ["clearScrollEndTimer", "setPage"]
        },
        "INDEX.SET": {
          target: "idle",
          actions: ["clearScrollEndTimer", "setMatchingPage"]
        },
        "SNAP.REFRESH": {
          actions: ["setSnapPoints", "clampPage"]
        }
      },
      activities: ["trackSlideMutation", "trackSlideIntersections", "trackSlideResize"],
      entry: ["resetScrollPosition", "setSnapPoints", "setPage"],
      exit: ["clearScrollEndTimer"],
      states: {
        idle: {
          activities: ["trackScroll"],
          on: {
            "DRAGGING.START": {
              target: "dragging",
              actions: ["invokeDragStart"]
            },
            "AUTOPLAY.START": {
              target: "autoplay",
              actions: ["invokeAutoplayStart"]
            }
          }
        },
        dragging: {
          activities: ["trackPointerMove"],
          entry: ["disableScrollSnap"],
          on: {
            DRAGGING: {
              actions: ["scrollSlides", "invokeDragging"]
            },
            "DRAGGING.END": {
              target: "idle",
              actions: ["endDragging", "invokeDraggingEnd"]
            }
          }
        },
        autoplay: {
          activities: ["trackDocumentVisibility", "trackScroll"],
          exit: ["invokeAutoplayEnd"],
          every: {
            AUTOPLAY_INTERVAL: ["setNextPage", "invokeAutoplay"]
          },
          on: {
            "DRAGGING.START": {
              target: "dragging",
              actions: ["invokeDragStart"]
            },
            "AUTOPLAY.PAUSE": "idle"
          }
        }
      }
    },
    {
      activities: {
        trackSlideMutation(ctx2, _evt, { send }) {
          const el = dom6.getItemGroupEl(ctx2);
          if (!el) return;
          const win = dom6.getWin(ctx2);
          const observer = new win.MutationObserver(() => {
            send({ type: "SNAP.REFRESH", src: "slide.mutation" });
            dom6.syncTabIndex(ctx2);
          });
          dom6.syncTabIndex(ctx2);
          observer.observe(el, { childList: true, subtree: true });
          return () => observer.disconnect();
        },
        trackSlideResize(ctx2, _evt, { send }) {
          const el = dom6.getItemGroupEl(ctx2);
          if (!el) return;
          const win = dom6.getWin(ctx2);
          const observer = new win.ResizeObserver(() => {
            send({ type: "SNAP.REFRESH", src: "slide.resize" });
          });
          dom6.getItemEls(ctx2).forEach((slide) => observer.observe(slide));
          return () => observer.disconnect();
        },
        trackSlideIntersections(ctx2) {
          const el = dom6.getItemGroupEl(ctx2);
          const win = dom6.getWin(ctx2);
          const observer = new win.IntersectionObserver(
            (entries) => {
              const slidesInView = entries.reduce((acc, entry) => {
                const target = entry.target;
                const index = Number(target.dataset.index ?? "-1");
                if (index == null || Number.isNaN(index) || index === -1) return acc;
                return entry.isIntersecting ? add(acc, index) : remove(acc, index);
              }, ctx2.slidesInView);
              ctx2.slidesInView = uniq(slidesInView);
            },
            {
              root: el,
              threshold: ctx2.inViewThreshold
            }
          );
          dom6.getItemEls(ctx2).forEach((slide) => observer.observe(slide));
          return () => observer.disconnect();
        },
        trackScroll(ctx2) {
          const el = dom6.getItemGroupEl(ctx2);
          if (!el) return;
          const onScrollEnd = () => {
            if (ctx2.slidesInView.length === 0) return;
            const scrollPosition = ctx2.isHorizontal ? el.scrollLeft : el.scrollTop;
            const page = ctx2.pageSnapPoints.findIndex((point) => Math.abs(point - scrollPosition) < 1);
            if (page === -1) return;
            set6.page(ctx2, page);
          };
          const onScroll = () => {
            clearTimeout(ctx2.timeoutRef.current);
            ctx2.timeoutRef.current = setTimeout(() => {
              onScrollEnd == null ? void 0 : onScrollEnd();
            }, 150);
          };
          return addDomEvent(el, "scroll", onScroll, { passive: true });
        },
        trackDocumentVisibility(ctx2, _evt, { send }) {
          const doc = dom6.getDoc(ctx2);
          const onVisibilityChange = () => {
            if (doc.visibilityState === "visible") return;
            send({ type: "AUTOPLAY.PAUSE", src: "doc.hidden" });
          };
          return addDomEvent(doc, "visibilitychange", onVisibilityChange);
        },
        trackPointerMove(ctx2, _evt, { send }) {
          const doc = dom6.getDoc(ctx2);
          return trackPointerMove(doc, {
            onPointerMove({ event }) {
              send({ type: "DRAGGING", left: -event.movementX, top: -event.movementY });
            },
            onPointerUp() {
              send({ type: "DRAGGING.END" });
            }
          });
        }
      },
      actions: {
        resetScrollPosition(ctx2) {
          const el = dom6.getItemGroupEl(ctx2);
          el.scrollTo(0, 0);
        },
        clearScrollEndTimer(ctx2) {
          if (ctx2.timeoutRef.current == null) return;
          clearTimeout(ctx2.timeoutRef.current);
          ctx2.timeoutRef.current = void 0;
        },
        scrollToPage(ctx2, evt) {
          const behavior = evt.instant ? "instant" : "smooth";
          const index = clamp4(evt.index ?? ctx2.page, 0, ctx2.pageSnapPoints.length - 1);
          const el = dom6.getItemGroupEl(ctx2);
          const axis = ctx2.isHorizontal ? "left" : "top";
          el.scrollTo({ [axis]: ctx2.pageSnapPoints[index], behavior });
        },
        setNextPage(ctx2) {
          const page = nextIndex(ctx2.pageSnapPoints, ctx2.page, { loop: ctx2.loop });
          set6.page(ctx2, page);
        },
        setPrevPage(ctx2) {
          const page = prevIndex(ctx2.pageSnapPoints, ctx2.page, { loop: ctx2.loop });
          set6.page(ctx2, page);
        },
        setMatchingPage(ctx2, evt) {
          const snapPoint = findSnapPoint(
            dom6.getItemGroupEl(ctx2),
            ctx2.isHorizontal ? "x" : "y",
            (node2) => node2.dataset.index === evt.index.toString()
          );
          if (snapPoint == null) return;
          const page = ctx2.pageSnapPoints.indexOf(snapPoint);
          set6.page(ctx2, page);
        },
        setPage(ctx2, evt) {
          set6.page(ctx2, evt.index ?? ctx2.page);
        },
        clampPage(ctx2) {
          const index = clamp4(ctx2.page, 0, ctx2.pageSnapPoints.length - 1);
          set6.page(ctx2, index);
        },
        setSnapPoints(ctx2) {
          queueMicrotask(() => {
            const el = dom6.getItemGroupEl(ctx2);
            const scrollSnapPoints = getScrollSnapPositions(el);
            ctx2.pageSnapPoints = ctx2.isHorizontal ? scrollSnapPoints.x : scrollSnapPoints.y;
          });
        },
        disableScrollSnap(ctx2) {
          const el = dom6.getItemGroupEl(ctx2);
          const styles = getComputedStyle(el);
          el.dataset.scrollSnapType = styles.getPropertyValue("scroll-snap-type");
          el.style.setProperty("scroll-snap-type", "none");
        },
        scrollSlides(ctx2, evt) {
          const el = dom6.getItemGroupEl(ctx2);
          el.scrollBy({ left: evt.left, top: evt.top, behavior: "instant" });
        },
        endDragging(ctx2) {
          const el = dom6.getItemGroupEl(ctx2);
          const startX = el.scrollLeft;
          const startY = el.scrollTop;
          const snapPositions = getScrollSnapPositions(el);
          const closestX = snapPositions.x.reduce((closest, curr) => {
            return Math.abs(curr - startX) < Math.abs(closest - startX) ? curr : closest;
          }, snapPositions.x[0]);
          const closestY = snapPositions.y.reduce((closest, curr) => {
            return Math.abs(curr - startY) < Math.abs(closest - startY) ? curr : closest;
          }, snapPositions.y[0]);
          raf(() => {
            el.scrollTo({ left: closestX, top: closestY, behavior: "smooth" });
            const scrollSnapType = el.dataset.scrollSnapType;
            if (scrollSnapType) {
              el.style.removeProperty("scroll-snap-type");
              delete el.dataset.scrollSnapType;
            }
          });
        },
        focusIndicatorEl(ctx2, evt) {
          if (evt.src !== "indicator") return;
          const el = dom6.getActiveIndicatorEl(ctx2);
          raf(() => el.focus({ preventScroll: true }));
        },
        invokeDragStart(ctx2) {
          var _a8;
          (_a8 = ctx2.onDragStatusChange) == null ? void 0 : _a8.call(ctx2, { type: "dragging.start", isDragging: true, page: ctx2.page });
        },
        invokeDragging(ctx2) {
          var _a8;
          (_a8 = ctx2.onDragStatusChange) == null ? void 0 : _a8.call(ctx2, { type: "dragging", isDragging: true, page: ctx2.page });
        },
        invokeDraggingEnd(ctx2) {
          var _a8;
          (_a8 = ctx2.onDragStatusChange) == null ? void 0 : _a8.call(ctx2, { type: "dragging.end", isDragging: false, page: ctx2.page });
        },
        invokeAutoplay(ctx2) {
          var _a8;
          (_a8 = ctx2.onAutoplayStatusChange) == null ? void 0 : _a8.call(ctx2, { type: "autoplay", isPlaying: true, page: ctx2.page });
        },
        invokeAutoplayStart(ctx2) {
          var _a8;
          (_a8 = ctx2.onAutoplayStatusChange) == null ? void 0 : _a8.call(ctx2, { type: "autoplay.start", isPlaying: true, page: ctx2.page });
        },
        invokeAutoplayEnd(ctx2) {
          var _a8;
          (_a8 = ctx2.onAutoplayStatusChange) == null ? void 0 : _a8.call(ctx2, { type: "autoplay.stop", isPlaying: false, page: ctx2.page });
        }
      },
      delays: {
        AUTOPLAY_INTERVAL: (ctx2) => ctx2.autoplayInterval
      }
    }
  );
}
var invoke4 = {
  pageChange: (ctx) => {
    var _a8;
    (_a8 = ctx.onPageChange) == null ? void 0 : _a8.call(ctx, {
      page: ctx.page,
      pageSnapPoint: ctx.pageSnapPoints[ctx.page]
    });
  }
};
var set6 = {
  page: (ctx, value) => {
    const page = clamp4(value, 0, ctx.pageSnapPoints.length - 1);
    if (isEqual(ctx.page, page)) return;
    ctx.page = page;
    invoke4.pageChange(ctx);
  }
};
function clamp4(value, min4, max4) {
  return Math.min(Math.max(value, min4), max4);
}
function getPageSnapPoints(totalSlides, slidesPerMove, slidesPerPage) {
  if (totalSlides == null) return [];
  const snapPoints = [];
  const perMove = slidesPerMove === "auto" ? Math.floor(slidesPerPage) : slidesPerMove;
  for (let i = 0; i < totalSlides - 1; i += perMove) snapPoints.push(i);
  return snapPoints;
}
var props6 = createProps()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "loop",
  "page",
  "onPageChange",
  "orientation",
  "slideCount",
  "slidesPerPage",
  "slidesPerMove",
  "spacing",
  "padding",
  "autoplay",
  "allowMouseDrag",
  "inViewThreshold",
  "translations",
  "snapType",
  "onDragStatusChange",
  "onAutoplayStatusChange"
]);
var splitProps7 = createSplitProps(props6);
var indicatorProps = createProps()(["index", "readOnly"]);
var splitIndicatorProps = createSplitProps(indicatorProps);
var itemProps2 = createProps()(["index", "snapAlign"]);
var splitItemProps2 = createSplitProps(itemProps2);

// node_modules/@ark-ui/react/dist/components/carousel/use-carousel.js
var import_react72 = __toESM(require_react(), 1);
var useCarousel = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react72.useId)(),
    dir,
    getRootNode,
    page: props34.defaultPage,
    ...props34
  };
  const context = {
    ...initialContext,
    page: props34.page,
    onPageChange: useEvent(props34.onPageChange, { sync: true })
  };
  const [state2, send] = useMachine(machine7(initialContext), { context });
  return connect7(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/carousel/carousel-root.js
var CarouselRoot = (0, import_react74.forwardRef)((props34, ref2) => {
  const [useCarouselProps, localProps] = createSplitProps2()(props34, [
    "allowMouseDrag",
    "autoplay",
    "defaultPage",
    "id",
    "ids",
    "inViewThreshold",
    "loop",
    "onAutoplayStatusChange",
    "onDragStatusChange",
    "onPageChange",
    "orientation",
    "padding",
    "page",
    "slideCount",
    "slidesPerMove",
    "slidesPerPage",
    "snapType",
    "spacing",
    "translations"
  ]);
  const carousel = useCarousel(useCarouselProps);
  const mergedProps = mergeProps2(carousel.getRootProps(), localProps);
  return (0, import_jsx_runtime31.jsx)(CarouselProvider, { value: carousel, children: (0, import_jsx_runtime31.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
CarouselRoot.displayName = "CarouselRoot";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-root-provider.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var import_react76 = __toESM(require_react(), 1);
var CarouselRootProvider = (0, import_react76.forwardRef)(
  (props34, ref2) => {
    const [{ value: carousel }, localProps] = createSplitProps2()(props34, [
      "value"
    ]);
    const mergedProps = mergeProps2(carousel.getRootProps(), localProps);
    return (0, import_jsx_runtime32.jsx)(CarouselProvider, { value: carousel, children: (0, import_jsx_runtime32.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
CarouselRootProvider.displayName = "CarouselRootProvider";

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-context.js
var [CheckboxProvider, useCheckboxContext] = createContext3({
  name: "CheckboxContext",
  hookName: "useCheckboxContext",
  providerName: "<CheckboxProvider />"
});

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-context.js
var CheckboxContext = (props34) => props34.children(useCheckboxContext());

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-control.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var import_react78 = __toESM(require_react(), 1);
var CheckboxControl = (0, import_react78.forwardRef)((props34, ref2) => {
  const checkbox = useCheckboxContext();
  const mergedProps = mergeProps2(checkbox.getControlProps(), props34);
  return (0, import_jsx_runtime33.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
CheckboxControl.displayName = "CheckboxControl";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-group.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var import_react80 = __toESM(require_react(), 1);

// node_modules/@zag-js/focus-visible/dist/index.mjs
function isVirtualClick(event) {
  if (event.mozInputSource === 0 && event.isTrusted) return true;
  return event.detail === 0 && !event.pointerType;
}
function isValidKey(e) {
  return !(e.metaKey || !isMac() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
var nonTextInputTypes = /* @__PURE__ */ new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);
function isKeyboardFocusEvent(isTextInput, modality, e) {
  const target = e ? getEventTarget(e) : null;
  const win = getWindow(target);
  isTextInput = isTextInput || target instanceof win.HTMLInputElement && !nonTextInputTypes.has(target == null ? void 0 : target.type) || target instanceof win.HTMLTextAreaElement || target instanceof win.HTMLElement && target.isContentEditable;
  return !(isTextInput && modality === "keyboard" && e instanceof win.KeyboardEvent && !Reflect.has(FOCUS_VISIBLE_INPUT_KEYS, e.key));
}
var currentModality = null;
var changeHandlers = /* @__PURE__ */ new Set();
var listenerMap = /* @__PURE__ */ new Map();
var hasEventBeforeFocus = false;
var hasBlurredWindowRecently = false;
var FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};
function triggerChangeHandlers(modality, e) {
  for (let handler of changeHandlers) {
    handler(modality, e);
  }
}
function handleKeyboardEvent(e) {
  hasEventBeforeFocus = true;
  if (isValidKey(e)) {
    currentModality = "keyboard";
    triggerChangeHandlers("keyboard", e);
  }
}
function handlePointerEvent(e) {
  currentModality = "pointer";
  if (e.type === "mousedown" || e.type === "pointerdown") {
    hasEventBeforeFocus = true;
    triggerChangeHandlers("pointer", e);
  }
}
function handleClickEvent(e) {
  if (isVirtualClick(e)) {
    hasEventBeforeFocus = true;
    currentModality = "virtual";
  }
}
function handleFocusEvent(e) {
  const target = getEventTarget(e);
  if (target === getWindow(target) || target === getDocument(target)) {
    return;
  }
  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", e);
  }
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = false;
}
function handleWindowBlur() {
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = true;
}
function setupGlobalFocusEvents(root) {
  if (typeof window === "undefined" || listenerMap.get(getWindow(root))) {
    return;
  }
  const win = getWindow(root);
  const doc = getDocument(root);
  let focus = win.HTMLElement.prototype.focus;
  win.HTMLElement.prototype.focus = function() {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", null);
    hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  };
  doc.addEventListener("keydown", handleKeyboardEvent, true);
  doc.addEventListener("keyup", handleKeyboardEvent, true);
  doc.addEventListener("click", handleClickEvent, true);
  win.addEventListener("focus", handleFocusEvent, true);
  win.addEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.addEventListener("pointerdown", handlePointerEvent, true);
    doc.addEventListener("pointermove", handlePointerEvent, true);
    doc.addEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.addEventListener("mousedown", handlePointerEvent, true);
    doc.addEventListener("mousemove", handlePointerEvent, true);
    doc.addEventListener("mouseup", handlePointerEvent, true);
  }
  win.addEventListener(
    "beforeunload",
    () => {
      tearDownWindowFocusTracking(root);
    },
    { once: true }
  );
  listenerMap.set(win, { focus });
}
var tearDownWindowFocusTracking = (root, loadListener) => {
  const win = getWindow(root);
  const doc = getDocument(root);
  if (!listenerMap.has(win)) {
    return;
  }
  win.HTMLElement.prototype.focus = listenerMap.get(win).focus;
  doc.removeEventListener("keydown", handleKeyboardEvent, true);
  doc.removeEventListener("keyup", handleKeyboardEvent, true);
  doc.removeEventListener("click", handleClickEvent, true);
  win.removeEventListener("focus", handleFocusEvent, true);
  win.removeEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.removeEventListener("pointerdown", handlePointerEvent, true);
    doc.removeEventListener("pointermove", handlePointerEvent, true);
    doc.removeEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.removeEventListener("mousedown", handlePointerEvent, true);
    doc.removeEventListener("mousemove", handlePointerEvent, true);
    doc.removeEventListener("mouseup", handlePointerEvent, true);
  }
  listenerMap.delete(win);
};
function isFocusVisible() {
  return currentModality === "keyboard";
}
function trackFocusVisible(props34 = {}) {
  const { isTextInput, autoFocus, onChange, root } = props34;
  setupGlobalFocusEvents(root);
  onChange == null ? void 0 : onChange({ isFocusVisible: autoFocus || isFocusVisible(), modality: currentModality });
  const handler = (modality, e) => {
    if (!isKeyboardFocusEvent(!!isTextInput, modality, e)) return;
    onChange == null ? void 0 : onChange({ isFocusVisible: isFocusVisible(), modality });
  };
  changeHandlers.add(handler);
  return () => {
    changeHandlers.delete(handler);
  };
}

// node_modules/@zag-js/checkbox/dist/index.mjs
var anatomy7 = createAnatomy("checkbox").parts("root", "label", "control", "indicator");
var parts7 = anatomy7.build();
var dom7 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `checkbox:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `checkbox:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `checkbox:${ctx.id}:control`;
  },
  getHiddenInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `checkbox:${ctx.id}:input`;
  },
  getRootEl: (ctx) => dom7.getById(ctx, dom7.getRootId(ctx)),
  getHiddenInputEl: (ctx) => dom7.getById(ctx, dom7.getHiddenInputId(ctx))
});
function connect8(state2, send, normalize3) {
  const disabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  const focused = !disabled && state2.context.focused;
  const focusVisible = !disabled && state2.context.focusVisible;
  const checked = state2.context.isChecked;
  const indeterminate = state2.context.isIndeterminate;
  const dataAttrs = {
    "data-active": dataAttr(state2.context.active),
    "data-focus": dataAttr(focused),
    "data-focus-visible": dataAttr(focusVisible),
    "data-readonly": dataAttr(readOnly),
    "data-hover": dataAttr(state2.context.hovered),
    "data-disabled": dataAttr(disabled),
    "data-state": indeterminate ? "indeterminate" : state2.context.checked ? "checked" : "unchecked",
    "data-invalid": dataAttr(state2.context.invalid)
  };
  return {
    checked,
    disabled,
    indeterminate,
    focused,
    checkedState: state2.context.checked,
    setChecked(checked2) {
      send({ type: "CHECKED.SET", checked: checked2, isTrusted: false });
    },
    toggleChecked() {
      send({ type: "CHECKED.TOGGLE", checked, isTrusted: false });
    },
    getRootProps() {
      return normalize3.label({
        ...parts7.root.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom7.getRootId(state2.context),
        htmlFor: dom7.getHiddenInputId(state2.context),
        onPointerMove() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: true } });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: false } });
        },
        onClick(event) {
          const target = getEventTarget(event);
          if (target === dom7.getHiddenInputEl(state2.context)) {
            event.stopPropagation();
          }
        }
      });
    },
    getLabelProps() {
      return normalize3.element({
        ...parts7.label.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom7.getLabelId(state2.context)
      });
    },
    getControlProps() {
      return normalize3.element({
        ...parts7.control.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom7.getControlId(state2.context),
        "aria-hidden": true
      });
    },
    getIndicatorProps() {
      return normalize3.element({
        ...parts7.indicator.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        hidden: !indeterminate && !state2.context.checked
      });
    },
    getHiddenInputProps() {
      return normalize3.input({
        id: dom7.getHiddenInputId(state2.context),
        type: "checkbox",
        required: state2.context.required,
        defaultChecked: checked,
        disabled,
        "aria-labelledby": dom7.getLabelId(state2.context),
        "aria-invalid": state2.context.invalid,
        name: state2.context.name,
        form: state2.context.form,
        value: state2.context.value,
        style: visuallyHiddenStyle,
        onFocus() {
          const focusVisible2 = isFocusVisible();
          send({ type: "CONTEXT.SET", context: { focused: true, focusVisible: focusVisible2 } });
        },
        onBlur() {
          send({ type: "CONTEXT.SET", context: { focused: false, focusVisible: false } });
        },
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          const checked2 = event.currentTarget.checked;
          send({ type: "CHECKED.SET", checked: checked2, isTrusted: true });
        }
      });
    }
  };
}
var { not: not3 } = guards;
function machine8(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "checkbox",
      initial: "ready",
      context: {
        checked: false,
        value: "on",
        disabled: false,
        ...ctx,
        fieldsetDisabled: false,
        focusVisible: false
      },
      watch: {
        disabled: "removeFocusIfNeeded",
        checked: "syncInputElement"
      },
      activities: ["trackFormControlState", "trackPressEvent", "trackFocusVisible"],
      on: {
        "CHECKED.TOGGLE": [
          {
            guard: not3("isTrusted"),
            actions: ["toggleChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["toggleChecked"]
          }
        ],
        "CHECKED.SET": [
          {
            guard: not3("isTrusted"),
            actions: ["setChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["setChecked"]
          }
        ],
        "CONTEXT.SET": {
          actions: ["setContext"]
        }
      },
      computed: {
        isIndeterminate: (ctx2) => isIndeterminate(ctx2.checked),
        isChecked: (ctx2) => isChecked(ctx2.checked),
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled
      },
      states: {
        ready: {}
      }
    },
    {
      guards: {
        isTrusted: (_ctx, evt) => !!evt.isTrusted
      },
      activities: {
        trackPressEvent(ctx2) {
          if (ctx2.isDisabled) return;
          return trackPress({
            pointerNode: dom7.getRootEl(ctx2),
            keyboardNode: dom7.getHiddenInputEl(ctx2),
            isValidKey: (event) => event.key === " ",
            onPress: () => ctx2.active = false,
            onPressStart: () => ctx2.active = true,
            onPressEnd: () => ctx2.active = false
          });
        },
        trackFocusVisible(ctx2) {
          if (ctx2.isDisabled) return;
          return trackFocusVisible({ root: dom7.getRootNode(ctx2) });
        },
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl(dom7.getHiddenInputEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "CHECKED.SET", checked: !!initialContext.checked });
            }
          });
        }
      },
      actions: {
        setContext(ctx2, evt) {
          Object.assign(ctx2, evt.context);
        },
        syncInputElement(ctx2) {
          const inputEl = dom7.getHiddenInputEl(ctx2);
          if (!inputEl) return;
          setElementChecked(inputEl, ctx2.isChecked);
          inputEl.indeterminate = ctx2.isIndeterminate;
        },
        removeFocusIfNeeded(ctx2) {
          if (ctx2.disabled && ctx2.focused) {
            ctx2.focused = false;
            ctx2.focusVisible = false;
          }
        },
        setChecked(ctx2, evt) {
          set7.checked(ctx2, evt.checked);
        },
        toggleChecked(ctx2) {
          const checked = isIndeterminate(ctx2.checked) ? true : !ctx2.checked;
          set7.checked(ctx2, checked);
        },
        dispatchChangeEvent(ctx2) {
          const inputEl = dom7.getHiddenInputEl(ctx2);
          dispatchInputCheckedEvent(inputEl, { checked: isChecked(ctx2.checked) });
        }
      }
    }
  );
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function isChecked(checked) {
  return isIndeterminate(checked) ? false : !!checked;
}
var invoke5 = {
  change: (ctx) => {
    var _a8;
    (_a8 = ctx.onCheckedChange) == null ? void 0 : _a8.call(ctx, { checked: ctx.checked });
  }
};
var set7 = {
  checked: (ctx, checked) => {
    if (isEqual(ctx.checked, checked)) return;
    ctx.checked = checked;
    invoke5.change(ctx);
  }
};
var props7 = createProps()([
  "checked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
var splitProps8 = createSplitProps(props7);

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox.anatomy.js
var checkboxAnatomy = anatomy7.extendWith("group");

// node_modules/@ark-ui/react/dist/utils/use-controllable-state.js
var import_react79 = __toESM(require_react(), 1);
function useControllableState2(props34) {
  const { value, onChange, defaultValue } = props34;
  const [uncontrolledValue, setUncontrolledValue] = (0, import_react79.useState)(defaultValue);
  const controlled = value !== void 0;
  const currentValue = controlled ? value : uncontrolledValue;
  const setValue = (0, import_react79.useCallback)(
    (value2) => {
      if (controlled) {
        return onChange == null ? void 0 : onChange(value2);
      }
      setUncontrolledValue(value2);
      return onChange == null ? void 0 : onChange(value2);
    },
    [controlled, onChange]
  );
  return [currentValue, setValue];
}

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-group.js
function useCheckboxGroup(props34 = {}) {
  const {
    defaultValue,
    value: controlledValue,
    onValueChange,
    disabled,
    readOnly,
    name,
    invalid
  } = props34;
  const interactive = !(disabled || readOnly);
  const onChangeProp = useEvent(onValueChange, { sync: true });
  const [value, setValue] = useControllableState2({
    value: controlledValue,
    defaultValue: defaultValue || [],
    onChange: onChangeProp
  });
  const isChecked2 = (val) => {
    return value.some((v) => String(v) === String(val));
  };
  const toggleValue = (val) => {
    isChecked2(val) ? removeValue(val) : addValue(val);
  };
  const addValue = (val) => {
    if (!interactive) return;
    if (isChecked2(val)) return;
    setValue(value.concat(val));
  };
  const removeValue = (val) => {
    if (!interactive) return;
    setValue(value.filter((v) => String(v) !== String(val)));
  };
  const getItemProps = (props210) => {
    return {
      checked: props210.value != null ? isChecked2(props210.value) : void 0,
      onCheckedChange() {
        if (props210.value != null) {
          toggleValue(props210.value);
        }
      },
      name,
      disabled,
      readOnly,
      invalid
    };
  };
  return {
    isChecked: isChecked2,
    value,
    name,
    disabled: !!disabled,
    readOnly: !!readOnly,
    invalid: !!invalid,
    setValue,
    addValue,
    toggleValue,
    getItemProps
  };
}

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-group-context.js
var [CheckboxGroupContextProvider, useCheckboxGroupContext] = createContext3({
  name: "CheckboxGroupContext",
  hookName: "useCheckboxGroupContext",
  providerName: "<CheckboxGroupProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-group.js
var CheckboxGroup = (0, import_react80.forwardRef)((props34, ref2) => {
  const [checkboxGroupProps, localProps] = createSplitProps2()(props34, [
    "defaultValue",
    "value",
    "onValueChange",
    "disabled",
    "invalid",
    "readOnly",
    "name"
  ]);
  const checkboxGroup = useCheckboxGroup(checkboxGroupProps);
  return (0, import_jsx_runtime34.jsx)(CheckboxGroupContextProvider, { value: checkboxGroup, children: (0, import_jsx_runtime34.jsx)(ark.div, { ref: ref2, role: "group", ...localProps, ...checkboxAnatomy.build().group.attrs }) });
});
CheckboxGroup.displayName = "CheckboxGroup";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-hidden-input.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var import_react82 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/field/use-field-context.js
var [FieldProvider, useFieldContext] = createContext3({
  name: "FieldContext",
  hookName: "useFieldContext",
  providerName: "<FieldProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-hidden-input.js
var CheckboxHiddenInput = (0, import_react82.forwardRef)(
  (props34, ref2) => {
    const checkbox = useCheckboxContext();
    const mergedProps = mergeProps2(checkbox.getHiddenInputProps(), props34);
    const field = useFieldContext();
    return (0, import_jsx_runtime35.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
CheckboxHiddenInput.displayName = "CheckboxHiddenInput";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-indicator.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var import_react84 = __toESM(require_react(), 1);
var CheckboxIndicator = (0, import_react84.forwardRef)(
  (props34, ref2) => {
    const { indeterminate, ...rest } = props34;
    const checkbox = useCheckboxContext();
    const mergedProps = mergeProps2(checkbox.getIndicatorProps(), rest);
    const isVisible = indeterminate ? checkbox.indeterminate : checkbox.checked;
    return (0, import_jsx_runtime36.jsx)(ark.div, { ...mergedProps, hidden: !isVisible, ref: ref2 });
  }
);
CheckboxIndicator.displayName = "CheckboxIndicator";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-label.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var import_react86 = __toESM(require_react(), 1);
var CheckboxLabel = (0, import_react86.forwardRef)((props34, ref2) => {
  const checkbox = useCheckboxContext();
  const mergedProps = mergeProps2(checkbox.getLabelProps(), props34);
  return (0, import_jsx_runtime37.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
CheckboxLabel.displayName = "CheckboxLabel";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var import_react90 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox.js
var import_react88 = __toESM(require_react(), 1);
var useCheckbox = (ownProps = {}) => {
  const checkboxGroup = useCheckboxGroupContext();
  const field = useFieldContext();
  const props34 = (0, import_react88.useMemo)(() => {
    return mergeProps2(ownProps, (checkboxGroup == null ? void 0 : checkboxGroup.getItemProps({ value: ownProps.value })) ?? {});
  }, [ownProps, checkboxGroup]);
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react88.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    invalid: field == null ? void 0 : field.invalid,
    required: field == null ? void 0 : field.required,
    getRootNode,
    checked: props34.defaultChecked,
    ...props34
  };
  const context = {
    ...initialContext,
    checked: props34.checked,
    onCheckedChange: useEvent(props34.onCheckedChange, { sync: true })
  };
  const [state2, send] = useMachine(machine8(initialContext), { context });
  return connect8(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root.js
var CheckboxRoot = (0, import_react90.forwardRef)((props34, ref2) => {
  const [useCheckboxProps, localProps] = createSplitProps2()(props34, [
    "checked",
    "defaultChecked",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "name",
    "onCheckedChange",
    "readOnly",
    "required",
    "value"
  ]);
  const checkbox = useCheckbox(useCheckboxProps);
  const mergedProps = mergeProps2(checkbox.getRootProps(), localProps);
  return (0, import_jsx_runtime38.jsx)(CheckboxProvider, { value: checkbox, children: (0, import_jsx_runtime38.jsx)(ark.label, { ...mergedProps, ref: ref2 }) });
});
CheckboxRoot.displayName = "CheckboxRoot";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root-provider.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var import_react92 = __toESM(require_react(), 1);
var CheckboxRootProvider = (0, import_react92.forwardRef)(
  (props34, ref2) => {
    const [{ value: checkbox }, localProps] = createSplitProps2()(props34, [
      "value"
    ]);
    const mergedProps = mergeProps2(checkbox.getRootProps(), localProps);
    return (0, import_jsx_runtime39.jsx)(CheckboxProvider, { value: checkbox, children: (0, import_jsx_runtime39.jsx)(ark.label, { ...mergedProps, ref: ref2 }) });
  }
);
CheckboxRootProvider.displayName = "CheckboxRootProvider";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox.js
var checkbox_exports = {};
__export(checkbox_exports, {
  Context: () => CheckboxContext,
  Control: () => CheckboxControl,
  Group: () => CheckboxGroup,
  HiddenInput: () => CheckboxHiddenInput,
  Indicator: () => CheckboxIndicator,
  Label: () => CheckboxLabel,
  Root: () => CheckboxRoot,
  RootProvider: () => CheckboxRootProvider
});

// node_modules/@ark-ui/react/dist/components/client-only/client-only.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var import_react93 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/clipboard/use-clipboard-context.js
var [ClipboardProvider, useClipboardContext] = createContext3({
  name: "ClipboardContext",
  hookName: "useClipboardContext",
  providerName: "<ClipboardProvider />"
});

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-context.js
var ClipboardContext = (props34) => props34.children(useClipboardContext());

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-control.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var import_react95 = __toESM(require_react(), 1);
var ClipboardControl = (0, import_react95.forwardRef)((props34, ref2) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps2(clipboard.getControlProps(), props34);
  return (0, import_jsx_runtime41.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ClipboardControl.displayName = "ClipboardControl";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-indicator.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var import_react97 = __toESM(require_react(), 1);
var ClipboardIndicator = (0, import_react97.forwardRef)(
  (props34, ref2) => {
    const { children, copied, ...localProps } = props34;
    const clipboard = useClipboardContext();
    const mergedProps = mergeProps2(
      clipboard.getIndicatorProps({ copied: clipboard.copied }),
      localProps
    );
    return (0, import_jsx_runtime42.jsx)(ark.div, { ...mergedProps, ref: ref2, children: clipboard.copied ? copied : children });
  }
);
ClipboardIndicator.displayName = "ClipboardIndicator";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-input.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var import_react99 = __toESM(require_react(), 1);
var ClipboardInput = (0, import_react99.forwardRef)((props34, ref2) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps2(clipboard.getInputProps(), props34);
  return (0, import_jsx_runtime43.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
ClipboardInput.displayName = "ClipboardInput";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-label.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var import_react101 = __toESM(require_react(), 1);
var ClipboardLabel = (0, import_react101.forwardRef)((props34, ref2) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps2(clipboard.getLabelProps(), props34);
  return (0, import_jsx_runtime44.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
ClipboardLabel.displayName = "ClipboardLabel";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-root.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
var import_react105 = __toESM(require_react(), 1);

// node_modules/@zag-js/clipboard/dist/index.mjs
var anatomy8 = createAnatomy("clipboard").parts("root", "control", "trigger", "indicator", "input", "label");
var parts8 = anatomy8.build();
var dom8 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `clip:${ctx.id}`;
  },
  getInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.input) ?? `clip:${ctx.id}:input`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `clip:${ctx.id}:label`;
  },
  getInputEl: (ctx) => dom8.getById(ctx, dom8.getInputId(ctx)),
  writeToClipboard: (ctx) => copyText(dom8.getDoc(ctx), ctx.value)
});
function createNode(doc, text) {
  const node2 = doc.createElement("pre");
  Object.assign(node2.style, {
    width: "1px",
    height: "1px",
    position: "fixed",
    top: "5px"
  });
  node2.textContent = text;
  return node2;
}
function copyNode(node2) {
  const win = getWindow(node2);
  const selection = win.getSelection();
  if (selection == null) {
    return Promise.reject(new Error());
  }
  selection.removeAllRanges();
  const doc = node2.ownerDocument;
  const range2 = doc.createRange();
  range2.selectNodeContents(node2);
  selection.addRange(range2);
  doc.execCommand("copy");
  selection.removeAllRanges();
  return Promise.resolve();
}
function copyText(doc, text) {
  var _a8;
  const win = doc.defaultView || window;
  if (((_a8 = win.navigator.clipboard) == null ? void 0 : _a8.writeText) !== void 0) {
    return win.navigator.clipboard.writeText(text);
  }
  if (!doc.body) {
    return Promise.reject(new Error());
  }
  const node2 = createNode(doc, text);
  doc.body.appendChild(node2);
  copyNode(node2);
  doc.body.removeChild(node2);
  return Promise.resolve();
}
function connect9(state2, send, normalize3) {
  const copied = state2.matches("copied");
  return {
    copied,
    value: state2.context.value,
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    copy() {
      send({ type: "COPY" });
    },
    getRootProps() {
      return normalize3.element({
        ...parts8.root.attrs,
        "data-copied": dataAttr(copied),
        id: dom8.getRootId(state2.context)
      });
    },
    getLabelProps() {
      return normalize3.label({
        ...parts8.label.attrs,
        htmlFor: dom8.getInputId(state2.context),
        "data-copied": dataAttr(copied),
        id: dom8.getLabelId(state2.context)
      });
    },
    getControlProps() {
      return normalize3.element({
        ...parts8.control.attrs,
        "data-copied": dataAttr(copied)
      });
    },
    getInputProps() {
      return normalize3.input({
        ...parts8.input.attrs,
        defaultValue: state2.context.value,
        "data-copied": dataAttr(copied),
        readOnly: true,
        "data-readonly": "true",
        id: dom8.getInputId(state2.context),
        onFocus(event) {
          event.currentTarget.select();
        },
        onCopy() {
          send({ type: "INPUT.COPY" });
        }
      });
    },
    getTriggerProps() {
      return normalize3.button({
        ...parts8.trigger.attrs,
        type: "button",
        "aria-label": copied ? "Copied to clipboard" : "Copy to clipboard",
        "data-copied": dataAttr(copied),
        onClick() {
          send({ type: "COPY" });
        }
      });
    },
    getIndicatorProps(props210) {
      return normalize3.element({
        ...parts8.indicator.attrs,
        hidden: props210.copied !== copied
      });
    }
  };
}
function machine9(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "clipboard",
      initial: "idle",
      context: {
        value: "",
        timeout: 3e3,
        ...ctx
      },
      watch: {
        value: ["syncInputElement"]
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        },
        COPY: {
          target: "copied",
          actions: ["copyToClipboard", "invokeOnCopy"]
        }
      },
      states: {
        idle: {
          on: {
            "INPUT.COPY": {
              target: "copied",
              actions: ["invokeOnCopy"]
            }
          }
        },
        copied: {
          after: {
            COPY_TIMEOUT: "idle"
          },
          on: {
            COPY: {
              target: "copied",
              actions: ["copyToClipboard", "invokeOnCopy"]
            },
            "INPUT.COPY": {
              actions: ["invokeOnCopy"]
            }
          }
        }
      }
    },
    {
      actions: {
        setValue(ctx2, evt) {
          ctx2.value = evt.value;
        },
        copyToClipboard(ctx2) {
          dom8.writeToClipboard(ctx2);
        },
        invokeOnCopy(ctx2) {
          var _a8;
          (_a8 = ctx2.onStatusChange) == null ? void 0 : _a8.call(ctx2, { copied: true });
        },
        syncInputElement(ctx2) {
          dom8.setValue(dom8.getInputEl(ctx2), ctx2.value);
        }
      },
      delays: {
        COPY_TIMEOUT: (ctx2) => ctx2.timeout
      }
    }
  );
}
var props8 = createProps()([
  "getRootNode",
  "id",
  "ids",
  "value",
  "timeout",
  "onStatusChange"
]);
var contextProps = createSplitProps(props8);
var indicatorProps2 = createProps()(["copied"]);
var splitIndicatorProps2 = createSplitProps(indicatorProps2);

// node_modules/@ark-ui/react/dist/components/clipboard/use-clipboard.js
var import_react103 = __toESM(require_react(), 1);
var useClipboard = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const initialContext = {
    id: (0, import_react103.useId)(),
    getRootNode,
    ...props34
  };
  const context = {
    ...initialContext
  };
  const [state2, send] = useMachine(machine9(initialContext), { context });
  return connect9(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-root.js
var ClipboardRoot = (0, import_react105.forwardRef)((props34, ref2) => {
  const [useClipboardProps, localProps] = createSplitProps2()(props34, [
    "id",
    "ids",
    "onStatusChange",
    "timeout",
    "value"
  ]);
  const clipboard = useClipboard(useClipboardProps);
  const mergedProps = mergeProps2(clipboard.getRootProps(), localProps);
  return (0, import_jsx_runtime45.jsx)(ClipboardProvider, { value: clipboard, children: (0, import_jsx_runtime45.jsx)(ark.div, { ref: ref2, ...mergedProps }) });
});
ClipboardRoot.displayName = "ClipboardRoot";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-root-provider.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var import_react107 = __toESM(require_react(), 1);
var ClipboardRootProvider = (0, import_react107.forwardRef)(
  (props34, ref2) => {
    const [{ value: clipboard }, localProps] = createSplitProps2()(props34, [
      "value"
    ]);
    const mergedProps = mergeProps2(clipboard.getRootProps(), localProps);
    return (0, import_jsx_runtime46.jsx)(ClipboardProvider, { value: clipboard, children: (0, import_jsx_runtime46.jsx)(ark.div, { ref: ref2, ...mergedProps }) });
  }
);
ClipboardRootProvider.displayName = "ClipboardRootProvider";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-trigger.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var import_react109 = __toESM(require_react(), 1);
var ClipboardTrigger = (0, import_react109.forwardRef)(
  (props34, ref2) => {
    const clipboard = useClipboardContext();
    const mergedProps = mergeProps2(clipboard.getTriggerProps(), props34);
    return (0, import_jsx_runtime47.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
ClipboardTrigger.displayName = "ClipboardTrigger";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-value-text.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
var import_react110 = __toESM(require_react(), 1);
var ClipboardValueText = (0, import_react110.forwardRef)(
  (props34, ref2) => {
    const clipboard = useClipboardContext();
    return (0, import_jsx_runtime48.jsx)(ark.span, { ...props34, ref: ref2, children: props34.children || clipboard.value });
  }
);
ClipboardValueText.displayName = "ClipboardValueText";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard.js
var clipboard_exports = {};
__export(clipboard_exports, {
  Context: () => ClipboardContext,
  Control: () => ClipboardControl,
  Indicator: () => ClipboardIndicator,
  Input: () => ClipboardInput,
  Label: () => ClipboardLabel,
  Root: () => ClipboardRoot,
  RootProvider: () => ClipboardRootProvider,
  Trigger: () => ClipboardTrigger,
  ValueText: () => ClipboardValueText
});

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-context.js
var CollapsibleContext = (props34) => props34.children(useCollapsibleContext());

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-root-provider.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var import_react112 = __toESM(require_react(), 1);
var CollapsibleRootProvider = (0, import_react112.forwardRef)(
  (props34, ref2) => {
    const [{ value: collapsible }, localProps] = createSplitProps2()(props34, [
      "value"
    ]);
    const mergedProps = mergeProps2(collapsible.getRootProps(), localProps);
    return (0, import_jsx_runtime49.jsx)(CollapsibleProvider, { value: collapsible, children: (0, import_jsx_runtime49.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
CollapsibleRootProvider.displayName = "CollapsibleRootProvider";

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-trigger.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
var import_react114 = __toESM(require_react(), 1);
var CollapsibleTrigger = (0, import_react114.forwardRef)(
  (props34, ref2) => {
    const collapsible = useCollapsibleContext();
    const mergedProps = mergeProps2(collapsible.getTriggerProps(), props34);
    return (0, import_jsx_runtime50.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
CollapsibleTrigger.displayName = "CollapsibleTrigger";

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible.js
var collapsible_exports = {};
__export(collapsible_exports, {
  Content: () => CollapsibleContent,
  Context: () => CollapsibleContext,
  Root: () => CollapsibleRoot,
  RootProvider: () => CollapsibleRootProvider,
  Trigger: () => CollapsibleTrigger
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-area.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
var import_react116 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-area-props-context.js
var [ColorPickerAreaPropsProvider, useColorPickerAreaPropsContext] = createContext3({
  name: "ColorPickerAreaContext",
  hookName: "useColorPickerAreaContext",
  providerName: "<ColorPickerAreaProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-context.js
var [ColorPickerProvider, useColorPickerContext] = createContext3({
  name: "ColorPickerContext",
  hookName: "useColorPickerContext",
  providerName: "<ColorPickerProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-area.js
var ColorPickerArea = (0, import_react116.forwardRef)((props34, ref2) => {
  const [areaProps, localProps] = createSplitProps2()(props34, ["xChannel", "yChannel"]);
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getAreaProps(areaProps), localProps);
  return (0, import_jsx_runtime51.jsx)(ColorPickerAreaPropsProvider, { value: areaProps, children: (0, import_jsx_runtime51.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
ColorPickerArea.displayName = "ColorPickerArea";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-area-background.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var import_react118 = __toESM(require_react(), 1);
var ColorPickerAreaBackground = (0, import_react118.forwardRef)(
  (props34, ref2) => {
    const colorPicker = useColorPickerContext();
    const areaProps = useColorPickerAreaPropsContext();
    const mergedProps = mergeProps2(colorPicker.getAreaBackgroundProps(areaProps), props34);
    return (0, import_jsx_runtime52.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerAreaBackground.displayName = "ColorPickerAreaBackground";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-area-thumb.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var import_react120 = __toESM(require_react(), 1);
var ColorPickerAreaThumb = (0, import_react120.forwardRef)(
  (props34, ref2) => {
    const colorPicker = useColorPickerContext();
    const areaProps = useColorPickerAreaPropsContext();
    const mergedProps = mergeProps2(colorPicker.getAreaThumbProps(areaProps), props34);
    return (0, import_jsx_runtime53.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerAreaThumb.displayName = "ColorPickerAreaThumb";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-input.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
var import_react122 = __toESM(require_react(), 1);
var ColorPickerChannelInput = (0, import_react122.forwardRef)(
  (props34, ref2) => {
    const [channelProps, localProps] = createSplitProps2()(props34, [
      "channel",
      "orientation"
    ]);
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getChannelInputProps(channelProps), localProps);
    return (0, import_jsx_runtime54.jsx)(ark.input, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerChannelInput.displayName = "ColorPickerChannelInput";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
var import_react124 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-channel-props-context.js
var [ColorPickerChannelPropsProvider, useColorPickerChannelPropsContext] = createContext3({
  name: "ColorPickerChannelSliderContext",
  hookName: "useColorPickerChannelSliderContext",
  providerName: "<ColorPickerChannelSliderProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-format-context.js
var [ColorPickerFormatPropsProvider, useColorPickerFormatPropsContext] = createContext3({
  name: "ColorPickerFormatContext",
  hookName: "useColorPickerFormatPropsContext",
  providerName: "<ColorPickerFormatPropsProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider.js
var ColorPickerChannelSlider = (0, import_react124.forwardRef)(
  (props34, ref2) => {
    const [channelProps, localProps] = createSplitProps2()(props34, [
      "channel",
      "orientation"
    ]);
    const colorPicker = useColorPickerContext();
    const formatProps = useColorPickerFormatPropsContext();
    const channelSliderProps = { ...channelProps, ...formatProps };
    const mergedProps = mergeProps2(
      colorPicker.getChannelSliderProps(channelSliderProps),
      localProps
    );
    return (0, import_jsx_runtime55.jsx)(ColorPickerChannelPropsProvider, { value: channelProps, children: (0, import_jsx_runtime55.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
ColorPickerChannelSlider.displayName = "ColorPickerChannelSlider";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider-label.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var import_react126 = __toESM(require_react(), 1);
var ColorPickerChannelSliderLabel = (0, import_react126.forwardRef)((props34, ref2) => {
  const colorPicker = useColorPickerContext();
  const channelProps = useColorPickerChannelPropsContext();
  const mergedProps = mergeProps2(colorPicker.getChannelSliderLabelProps(channelProps), props34);
  return (0, import_jsx_runtime56.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
ColorPickerChannelSliderLabel.displayName = "ColorPickerChannelSliderLabel";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider-thumb.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
var import_react128 = __toESM(require_react(), 1);
var ColorPickerChannelSliderThumb = (0, import_react128.forwardRef)((props34, ref2) => {
  const colorPicker = useColorPickerContext();
  const channelProps = useColorPickerChannelPropsContext();
  const formatProps = useColorPickerFormatPropsContext();
  const channelSliderProps = { ...channelProps, ...formatProps };
  const mergedProps = mergeProps2(colorPicker.getChannelSliderThumbProps(channelSliderProps), props34);
  return (0, import_jsx_runtime57.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ColorPickerChannelSliderThumb.displayName = "ColorPickerChannelSliderThumb";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider-track.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var import_react130 = __toESM(require_react(), 1);
var ColorPickerChannelSliderTrack = (0, import_react130.forwardRef)((props34, ref2) => {
  const colorPicker = useColorPickerContext();
  const channelProps = useColorPickerChannelPropsContext();
  const formatProps = useColorPickerFormatPropsContext();
  const channelSliderProps = { ...channelProps, ...formatProps };
  const mergedProps = mergeProps2(colorPicker.getChannelSliderTrackProps(channelSliderProps), props34);
  return (0, import_jsx_runtime58.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ColorPickerChannelSliderTrack.displayName = "ColorPickerChannelSliderTrack";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider-value-text.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
var import_react132 = __toESM(require_react(), 1);
var ColorPickerChannelSliderValueText = (0, import_react132.forwardRef)((props34, ref2) => {
  const { locale } = useLocaleContext();
  const colorPicker = useColorPickerContext();
  const channelProps = useColorPickerChannelPropsContext();
  const mergedProps = mergeProps2(colorPicker.getChannelSliderValueTextProps(channelProps), props34);
  return (0, import_jsx_runtime59.jsx)(ark.span, { ...mergedProps, ref: ref2, children: props34.children || colorPicker.getChannelValueText(channelProps.channel, locale) });
});
ColorPickerChannelSliderValueText.displayName = "ColorPickerChannelSliderValueText";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-content.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
var import_react134 = __toESM(require_react(), 1);
var ColorPickerContent = (0, import_react134.forwardRef)(
  (props34, ref2) => {
    const colorPicker = useColorPickerContext();
    const presence = usePresenceContext();
    const mergedProps = mergeProps2(
      colorPicker.getContentProps(),
      presence.getPresenceProps(),
      props34
    );
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime60.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
  }
);
ColorPickerContent.displayName = "ColorPickerContent";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-context.js
var ColorPickerContext = (props34) => props34.children(useColorPickerContext());

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-control.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);
var import_react136 = __toESM(require_react(), 1);
var ColorPickerControl = (0, import_react136.forwardRef)(
  (props34, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getControlProps(), props34);
    return (0, import_jsx_runtime61.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerControl.displayName = "ColorPickerControl";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-eye-dropper-trigger.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var import_react138 = __toESM(require_react(), 1);
var ColorPickerEyeDropperTrigger = (0, import_react138.forwardRef)((props34, ref2) => {
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getEyeDropperTriggerProps(), props34);
  return (0, import_jsx_runtime62.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
ColorPickerEyeDropperTrigger.displayName = "ColorPickerEyeDropperTrigger";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-format-select.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);
var import_react140 = __toESM(require_react(), 1);
var ColorPickerFormatSelect = (0, import_react140.forwardRef)(
  (props34, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getFormatSelectProps(), props34);
    return (0, import_jsx_runtime63.jsx)(ark.select, { ...mergedProps, ref: ref2, children: ["rgba", "hsla", "hsba"].map((format) => (0, import_jsx_runtime63.jsx)(ark.option, { value: format, children: format }, format)) });
  }
);
ColorPickerFormatSelect.displayName = "ColorPickerFormatSelect";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-format-trigger.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);
var import_react142 = __toESM(require_react(), 1);
var ColorPickerFormatTrigger = (0, import_react142.forwardRef)((props34, ref2) => {
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getFormatTriggerProps(), props34);
  return (0, import_jsx_runtime64.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
ColorPickerFormatTrigger.displayName = "ColorPickerFormatTrigger";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-hidden-input.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
var import_react144 = __toESM(require_react(), 1);
var ColorPickerHiddenInput = (0, import_react144.forwardRef)(
  (props34, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getHiddenInputProps(), props34);
    const field = useFieldContext();
    return (0, import_jsx_runtime65.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
ColorPickerHiddenInput.displayName = "ColorPickerHiddenInput";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-label.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);
var import_react146 = __toESM(require_react(), 1);
var ColorPickerLabel = (0, import_react146.forwardRef)(
  (props34, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getLabelProps(), props34);
    return (0, import_jsx_runtime66.jsx)(ark.label, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerLabel.displayName = "ColorPickerLabel";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-positioner.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
var import_react148 = __toESM(require_react(), 1);
var ColorPickerPositioner = (0, import_react148.forwardRef)(
  (props34, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getPositionerProps(), props34);
    const presence = usePresenceContext();
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime67.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerPositioner.displayName = "ColorPickerPositioner";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-root.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime(), 1);
var import_react152 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker.js
var import_react150 = __toESM(require_react(), 1);
var useColorPicker = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react150.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      input: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    invalid: field == null ? void 0 : field.invalid,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    getRootNode,
    open: props34.defaultOpen,
    "open.controlled": props34.open !== void 0,
    value: props34.defaultValue,
    ...props34
  };
  const context = {
    ...initialContext,
    value: props34.value,
    onValueChange: useEvent(props34.onValueChange, { sync: true }),
    onValueChangeEnd: useEvent(props34.onValueChangeEnd)
  };
  const [state2, send] = useMachine(machine4(initialContext), { context });
  return connect4(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-root.js
var ColorPickerRoot = (0, import_react152.forwardRef)((props34, ref2) => {
  const [presenceProps, colorPickerProps] = splitPresenceProps(props34);
  const [useColorPickerProps, localProps] = createSplitProps2()(
    colorPickerProps,
    [
      "closeOnSelect",
      "defaultOpen",
      "defaultValue",
      "disabled",
      "format",
      "id",
      "ids",
      "initialFocusEl",
      "invalid",
      "name",
      "name",
      "onFocusOutside",
      "onFormatChange",
      "onInteractOutside",
      "onOpenChange",
      "onPointerDownOutside",
      "onValueChange",
      "onValueChangeEnd",
      "open",
      "openAutoFocus",
      "positioning",
      "readOnly",
      "required",
      "value"
    ]
  );
  const colorPicker = useColorPicker(useColorPickerProps);
  const presence = usePresence(mergeProps2({ present: colorPicker.open }, presenceProps));
  const mergedProps = mergeProps2(colorPicker.getRootProps(), localProps);
  return (0, import_jsx_runtime68.jsx)(ColorPickerProvider, { value: colorPicker, children: (0, import_jsx_runtime68.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime68.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
ColorPickerRoot.displayName = "ColorPickerRoot";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-root-provider.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime(), 1);
var import_react154 = __toESM(require_react(), 1);
var ColorPickerRootProvider = (0, import_react154.forwardRef)(
  (props34, ref2) => {
    const [presenceProps, colorPickerProps] = splitPresenceProps(props34);
    const [{ value: colorPicker }, localProps] = createSplitProps2()(
      colorPickerProps,
      ["value"]
    );
    const presence = usePresence(mergeProps2({ present: colorPicker.open }, presenceProps));
    const mergedProps = mergeProps2(colorPicker.getRootProps(), localProps);
    return (0, import_jsx_runtime69.jsx)(ColorPickerProvider, { value: colorPicker, children: (0, import_jsx_runtime69.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime69.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
  }
);
ColorPickerRootProvider.displayName = "ColorPickerRootProvider";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch.js
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);
var import_react156 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-swatch-props-context.js
var [ColorPickerSwatchPropsProvider, useColorPickerSwatchPropsContext] = createContext3({
  name: "ColorPickerSwatchContext",
  hookName: "useColorPickerSwatchContext",
  providerName: "<ColorPickerSwatchProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch.js
var ColorPickerSwatch = (0, import_react156.forwardRef)(
  (props34, ref2) => {
    const [swatwchProps, localProps] = createSplitProps2()(props34, [
      "respectAlpha",
      "value"
    ]);
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getSwatchProps(swatwchProps), localProps);
    return (0, import_jsx_runtime70.jsx)(ColorPickerSwatchPropsProvider, { value: swatwchProps, children: (0, import_jsx_runtime70.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
ColorPickerSwatch.displayName = "ColorPickerSwatch";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch-group.js
var import_jsx_runtime71 = __toESM(require_jsx_runtime(), 1);
var import_react158 = __toESM(require_react(), 1);
var ColorPickerSwatchGroup = (0, import_react158.forwardRef)(
  (props34, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getSwatchGroupProps(), props34);
    return (0, import_jsx_runtime71.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerSwatchGroup.displayName = "ColorPickerSwatchGroup";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch-indicator.js
var import_jsx_runtime72 = __toESM(require_jsx_runtime(), 1);
var import_react160 = __toESM(require_react(), 1);
var ColorPickerSwatchIndicator = (0, import_react160.forwardRef)((props34, ref2) => {
  const colorPicker = useColorPickerContext();
  const swatchProps = useColorPickerSwatchPropsContext();
  const mergedProps = mergeProps2(colorPicker.getSwatchIndicatorProps(swatchProps), props34);
  return (0, import_jsx_runtime72.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ColorPickerSwatchIndicator.displayName = "ColorPickerSwatchIndicator";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch-trigger.js
var import_jsx_runtime73 = __toESM(require_jsx_runtime(), 1);
var import_react162 = __toESM(require_react(), 1);
var ColorPickerSwatchTrigger = (0, import_react162.forwardRef)((props34, ref2) => {
  const [triggerProps2, localProps] = createSplitProps2()(props34, [
    "value",
    "disabled"
  ]);
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getSwatchTriggerProps(triggerProps2), localProps);
  return (0, import_jsx_runtime73.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
ColorPickerSwatchTrigger.displayName = "ColorPickerSwatchTrigger";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-transparency-grid.js
var import_jsx_runtime74 = __toESM(require_jsx_runtime(), 1);
var import_react164 = __toESM(require_react(), 1);
var ColorPickerTransparencyGrid = (0, import_react164.forwardRef)((props34, ref2) => {
  const [gridProps, localProps] = createSplitProps2()(props34, ["size"]);
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getTransparencyGridProps(gridProps), localProps);
  return (0, import_jsx_runtime74.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ColorPickerTransparencyGrid.displayName = "ColorPickerTransparencyGrid";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-trigger.js
var import_jsx_runtime75 = __toESM(require_jsx_runtime(), 1);
var import_react166 = __toESM(require_react(), 1);
var ColorPickerTrigger = (0, import_react166.forwardRef)(
  (props34, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getTriggerProps(), props34);
    return (0, import_jsx_runtime75.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerTrigger.displayName = "ColorPickerTrigger";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-value-swatch.js
var import_jsx_runtime76 = __toESM(require_jsx_runtime(), 1);
var import_react168 = __toESM(require_react(), 1);
var ColorPickerValueSwatch = (0, import_react168.forwardRef)(
  (props34, ref2) => {
    const [{ respectAlpha }, localProps] = createSplitProps2()(props34, [
      "respectAlpha"
    ]);
    const colorPicker = useColorPickerContext();
    const swatchProps = {
      respectAlpha,
      value: colorPicker.valueAsString
    };
    const mergedProps = mergeProps2(colorPicker.getSwatchProps(swatchProps), localProps);
    return (0, import_jsx_runtime76.jsx)(ColorPickerSwatchPropsProvider, { value: swatchProps, children: (0, import_jsx_runtime76.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
ColorPickerValueSwatch.displayName = "ColorPickerValueSwatch";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-value-text.js
var import_jsx_runtime77 = __toESM(require_jsx_runtime(), 1);
var import_react170 = __toESM(require_react(), 1);
var ColorPickerValueText = (0, import_react170.forwardRef)(
  (props34, ref2) => {
    const { children, ...localprops } = props34;
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getValueTextProps(), localprops);
    return (0, import_jsx_runtime77.jsx)(ark.span, { ...mergedProps, ref: ref2, children: props34.children || colorPicker.valueAsString });
  }
);
ColorPickerValueText.displayName = "ColorPickerValueText";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-view.js
var import_jsx_runtime78 = __toESM(require_jsx_runtime(), 1);
var import_react171 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker.anatomy.js
var colorPickerAnatomy = anatomy3.extendWith("view");

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-view.js
var ColorPickerView = (0, import_react171.forwardRef)((props34, ref2) => {
  const colorPicker = useColorPickerContext();
  const [formatProps, restProps] = createSplitProps2()(props34, ["format"]);
  if (colorPicker.format !== formatProps.format) {
    return null;
  }
  return (0, import_jsx_runtime78.jsx)(ColorPickerFormatPropsProvider, { value: formatProps, children: (0, import_jsx_runtime78.jsx)(
    ark.div,
    {
      ref: ref2,
      "data-format": props34.format,
      ...colorPickerAnatomy.build().view.attrs,
      ...restProps
    }
  ) });
});
ColorPickerView.displayName = "ColorPickerView";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker.js
var color_picker_exports = {};
__export(color_picker_exports, {
  Area: () => ColorPickerArea,
  AreaBackground: () => ColorPickerAreaBackground,
  AreaThumb: () => ColorPickerAreaThumb,
  ChannelInput: () => ColorPickerChannelInput,
  ChannelSlider: () => ColorPickerChannelSlider,
  ChannelSliderLabel: () => ColorPickerChannelSliderLabel,
  ChannelSliderThumb: () => ColorPickerChannelSliderThumb,
  ChannelSliderTrack: () => ColorPickerChannelSliderTrack,
  ChannelSliderValueText: () => ColorPickerChannelSliderValueText,
  Content: () => ColorPickerContent,
  Context: () => ColorPickerContext,
  Control: () => ColorPickerControl,
  EyeDropperTrigger: () => ColorPickerEyeDropperTrigger,
  FormatSelect: () => ColorPickerFormatSelect,
  FormatTrigger: () => ColorPickerFormatTrigger,
  HiddenInput: () => ColorPickerHiddenInput,
  Label: () => ColorPickerLabel,
  Positioner: () => ColorPickerPositioner,
  Root: () => ColorPickerRoot,
  RootProvider: () => ColorPickerRootProvider,
  Swatch: () => ColorPickerSwatch,
  SwatchGroup: () => ColorPickerSwatchGroup,
  SwatchIndicator: () => ColorPickerSwatchIndicator,
  SwatchTrigger: () => ColorPickerSwatchTrigger,
  TransparencyGrid: () => ColorPickerTransparencyGrid,
  Trigger: () => ColorPickerTrigger,
  ValueSwatch: () => ColorPickerValueSwatch,
  ValueText: () => ColorPickerValueText,
  View: () => ColorPickerView
});

// node_modules/@zag-js/collection/dist/index.mjs
var __defProp3 = Object.defineProperty;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField3 = (obj, key, value) => __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
var fallback = {
  itemToValue(item) {
    if (typeof item === "string") return item;
    if (isObject5(item) && hasProp(item, "value")) return item.value;
    return "";
  },
  itemToString(item) {
    if (typeof item === "string") return item;
    if (isObject5(item) && hasProp(item, "label")) return item.label;
    return fallback.itemToValue(item);
  },
  isItemDisabled(item) {
    if (isObject5(item) && hasProp(item, "disabled")) return !!item.disabled;
    return false;
  }
};
var ListCollection = class {
  constructor(options) {
    this.options = options;
    __publicField3(this, "items");
    this.items = [...options.items];
  }
  isEqual(other) {
    return isEqual(this.items, other.items);
  }
  /**
   * Function to update the collection items
   */
  setItems(items) {
    this.items = Array.from(items);
  }
  /**
   * Returns all the values in the collection
   */
  getValues(items = this.items) {
    return Array.from(items).map((item) => this.getItemValue(item)).filter(Boolean);
  }
  /**
   * Get the item based on its value
   */
  find(value) {
    if (value == null) return null;
    const index = this.items.findIndex((item) => this.getItemValue(item) === value);
    return index != null ? this.items[index] : null;
  }
  /**
   * Get the items based on its values
   */
  findMany(values) {
    return Array.from(values).map((value) => this.find(value)).filter(Boolean);
  }
  /**
   * Get the item based on its index
   */
  at(index) {
    return this.items[index] ?? null;
  }
  sortFn(valueA, valueB) {
    const indexA = this.indexOf(valueA);
    const indexB = this.indexOf(valueB);
    return (indexA ?? 0) - (indexB ?? 0);
  }
  /**
   * Sort the values based on their index
   */
  sort(values) {
    return [...values].sort(this.sortFn.bind(this));
  }
  /**
   * Convert an item to a value
   */
  getItemValue(item) {
    var _a8, _b7;
    if (item == null) return null;
    return ((_b7 = (_a8 = this.options).itemToValue) == null ? void 0 : _b7.call(_a8, item)) ?? fallback.itemToValue(item);
  }
  /**
   * Whether an item is disabled
   */
  getItemDisabled(item) {
    var _a8, _b7;
    if (item == null) return false;
    return ((_b7 = (_a8 = this.options).isItemDisabled) == null ? void 0 : _b7.call(_a8, item)) ?? fallback.isItemDisabled(item);
  }
  /**
   * Convert an item to a string
   */
  stringifyItem(item) {
    var _a8, _b7;
    if (item == null) return null;
    return ((_b7 = (_a8 = this.options).itemToString) == null ? void 0 : _b7.call(_a8, item)) ?? fallback.itemToString(item);
  }
  /**
   * Convert a value to a string
   */
  stringify(value) {
    if (value == null) return null;
    return this.stringifyItem(this.find(value));
  }
  /**
   * Convert an array of items to a string
   */
  stringifyItems(items, separator = ", ") {
    return Array.from(items).map((item) => this.stringifyItem(item)).filter(Boolean).join(separator);
  }
  /**
   * Convert an array of items to a string
   */
  stringifyMany(value, separator) {
    return this.stringifyItems(this.findMany(value), separator);
  }
  /**
   * Whether the collection has a value
   */
  has(value) {
    return this.indexOf(value) !== -1;
  }
  /**
   * Whether the collection has an item
   */
  hasItem(item) {
    if (item == null) return false;
    return this.has(this.getItemValue(item));
  }
  /**
   * Returns the number of items in the collection
   */
  get size() {
    return this.items.length;
  }
  /**
   * Returns the first value in the collection
   */
  get firstValue() {
    let index = 0;
    while (this.getItemDisabled(this.at(index))) index++;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the last value in the collection
   */
  get lastValue() {
    let index = this.size - 1;
    while (this.getItemDisabled(this.at(index))) index--;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the next value in the collection
   */
  getNextValue(value, step = 1, clamp6 = false) {
    let index = this.indexOf(value);
    if (index === -1) return null;
    index = clamp6 ? Math.min(index + step, this.size - 1) : index + step;
    while (index <= this.size && this.getItemDisabled(this.at(index))) index++;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the previous value in the collection
   */
  getPreviousValue(value, step = 1, clamp6 = false) {
    let index = this.indexOf(value);
    if (index === -1) return null;
    index = clamp6 ? Math.max(index - step, 0) : index - step;
    while (index >= 0 && this.getItemDisabled(this.at(index))) index--;
    return this.getItemValue(this.at(index));
  }
  /**
   * Get the index of an item based on its key
   */
  indexOf(value) {
    if (value == null) return -1;
    return this.items.findIndex((item) => this.getItemValue(item) === value);
  }
  getByText(text, current) {
    let items = current != null ? wrap3(this.items, this.indexOf(current)) : this.items;
    const isSingleKey = text.length === 1;
    if (isSingleKey) items = items.filter((item) => this.getItemValue(item) !== current);
    return items.find((item) => match4(this.stringifyItem(item), text));
  }
  /**
   * Search for a value based on a query
   */
  search(queryString, options) {
    const { state: state2, currentValue, timeout = 350 } = options;
    const search = state2.keysSoFar + queryString;
    const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
    const query2 = isRepeated ? search[0] : search;
    const item = this.getByText(query2, currentValue);
    const value = this.getItemValue(item);
    function cleanup() {
      clearTimeout(state2.timer);
      state2.timer = -1;
    }
    function update(value2) {
      state2.keysSoFar = value2;
      cleanup();
      if (value2 !== "") {
        state2.timer = +setTimeout(() => {
          update("");
          cleanup();
        }, timeout);
      }
    }
    update(search);
    return value;
  }
  *[Symbol.iterator]() {
    yield* this.items;
  }
  insertBefore(value, item) {
    const index = this.indexOf(value);
    if (index === -1) return;
    this.items.splice(index, 0, item);
  }
  insertAfter(value, item) {
    const index = this.indexOf(value);
    if (index === -1) return;
    this.items.splice(index + 1, 0, item);
  }
  reorder(fromIndex, toIndex) {
    if (fromIndex === -1 || toIndex === -1) return;
    if (fromIndex === toIndex) return;
    const [removed] = this.items.splice(fromIndex, 1);
    this.items.splice(toIndex, 0, removed);
  }
  json() {
    return {
      size: this.size,
      first: this.firstValue,
      last: this.lastValue
    };
  }
};
var match4 = (label, query2) => {
  return !!(label == null ? void 0 : label.toLowerCase().startsWith(query2.toLowerCase()));
};
var wrap3 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function access(node2, indexPath, options) {
  for (let i = 0; i < indexPath.length; i++) node2 = options.getChildren(node2, indexPath.slice(i + 1))[indexPath[i]];
  return node2;
}
function ancestorIndexPaths(indexPaths) {
  const sortedPaths = sortIndexPaths(indexPaths);
  const result = [];
  const seen = /* @__PURE__ */ new Set();
  for (const indexPath of sortedPaths) {
    const key = indexPath.join();
    if (!seen.has(key)) {
      seen.add(key);
      result.push(indexPath);
    }
  }
  return result;
}
function compareIndexPaths(a2, b2) {
  for (let i = 0; i < Math.min(a2.length, b2.length); i++) {
    if (a2[i] < b2[i]) return -1;
    if (a2[i] > b2[i]) return 1;
  }
  return a2.length - b2.length;
}
function sortIndexPaths(indexPaths) {
  return indexPaths.sort(compareIndexPaths);
}
function find(node2, options) {
  let found;
  visit(node2, {
    ...options,
    onEnter: (child, indexPath) => {
      if (options.predicate(child, indexPath)) {
        found = child;
        return "stop";
      }
    }
  });
  return found;
}
function findIndexPath(node2, options) {
  let found;
  visit(node2, {
    onEnter: (child, indexPath) => {
      if (options.predicate(child, indexPath)) {
        found = [...indexPath];
        return "stop";
      }
    },
    getChildren: options.getChildren
  });
  return found;
}
function reduce(node2, options) {
  let result = options.initialResult;
  visit(node2, {
    ...options,
    onEnter: (child, indexPath) => {
      result = options.nextResult(result, child, indexPath);
    }
  });
  return result;
}
function flatMap(node2, options) {
  return reduce(node2, {
    ...options,
    initialResult: [],
    nextResult: (result, child, indexPath) => {
      result.push(...options.transform(child, indexPath));
      return result;
    }
  });
}
function insertOperation(index, nodes) {
  return { type: "insert", index, nodes };
}
function removeOperation(indexes) {
  return { type: "remove", indexes };
}
function replaceOperation() {
  return { type: "replace" };
}
function splitIndexPath(indexPath) {
  return [indexPath.slice(0, -1), indexPath[indexPath.length - 1]];
}
function getInsertionOperations(indexPath, nodes, operations = /* @__PURE__ */ new Map()) {
  var _a8;
  const [parentIndexPath, index] = splitIndexPath(indexPath);
  for (let i = parentIndexPath.length - 1; i >= 0; i--) {
    const parentKey = parentIndexPath.slice(0, i).join();
    switch ((_a8 = operations.get(parentKey)) == null ? void 0 : _a8.type) {
      case "remove":
        continue;
    }
    operations.set(parentKey, replaceOperation());
  }
  const operation = operations.get(parentIndexPath.join());
  switch (operation == null ? void 0 : operation.type) {
    case "remove":
      operations.set(parentIndexPath.join(), {
        type: "removeThenInsert",
        removeIndexes: operation.indexes,
        insertIndex: index,
        insertNodes: nodes
      });
      break;
    default:
      operations.set(parentIndexPath.join(), insertOperation(index, nodes));
  }
  return operations;
}
function getRemovalOperations(indexPaths) {
  const operations = /* @__PURE__ */ new Map();
  const indexesToRemove = /* @__PURE__ */ new Map();
  for (const indexPath of indexPaths) {
    const parentKey = indexPath.slice(0, -1).join();
    const value = indexesToRemove.get(parentKey) ?? [];
    value.push(indexPath[indexPath.length - 1]);
    indexesToRemove.set(
      parentKey,
      value.sort((a2, b2) => a2 - b2)
    );
  }
  for (const indexPath of indexPaths) {
    for (let i = indexPath.length - 2; i >= 0; i--) {
      const parentKey = indexPath.slice(0, i).join();
      if (!operations.has(parentKey)) {
        operations.set(parentKey, replaceOperation());
      }
    }
  }
  for (const [parentKey, indexes] of indexesToRemove) {
    operations.set(parentKey, removeOperation(indexes));
  }
  return operations;
}
function getReplaceOperations(indexPath, node2) {
  const operations = /* @__PURE__ */ new Map();
  const [parentIndexPath, index] = splitIndexPath(indexPath);
  for (let i = parentIndexPath.length - 1; i >= 0; i--) {
    const parentKey = parentIndexPath.slice(0, i).join();
    operations.set(parentKey, replaceOperation());
  }
  operations.set(parentIndexPath.join(), {
    type: "removeThenInsert",
    removeIndexes: [index],
    insertIndex: index,
    insertNodes: [node2]
  });
  return operations;
}
function mutate(node2, operations, options) {
  return map(node2, {
    ...options,
    getChildren: (node22, indexPath) => {
      const key = indexPath.join();
      const operation = operations.get(key);
      switch (operation == null ? void 0 : operation.type) {
        case "replace":
        case "remove":
        case "removeThenInsert":
        case "insert":
          return options.getChildren(node22, indexPath);
        default:
          return [];
      }
    },
    transform: (node22, children, indexPath) => {
      const key = indexPath.join();
      const operation = operations.get(key);
      switch (operation == null ? void 0 : operation.type) {
        case "remove":
          return options.create(
            node22,
            children.filter((_, index) => !operation.indexes.includes(index)),
            indexPath
          );
        case "removeThenInsert":
          const updatedChildren = children.filter((_, index) => !operation.removeIndexes.includes(index));
          const adjustedIndex = operation.removeIndexes.reduce(
            (index, removedIndex) => removedIndex < index ? index - 1 : index,
            operation.insertIndex
          );
          return options.create(node22, splice(updatedChildren, adjustedIndex, 0, ...operation.insertNodes), indexPath);
        case "insert":
          return options.create(node22, splice(children, operation.index, 0, ...operation.nodes), indexPath);
        case "replace":
          return options.create(node22, children, indexPath);
        default:
          return node22;
      }
    }
  });
}
function splice(array, start, deleteCount, ...items) {
  return [...array.slice(0, start), ...items, ...array.slice(start + deleteCount)];
}
function map(node2, options) {
  const childrenMap = {};
  visit(node2, {
    ...options,
    onLeave: (child, indexPath) => {
      const keyIndexPath = [0, ...indexPath];
      const key = keyIndexPath.join();
      const transformed = options.transform(child, childrenMap[key] ?? [], indexPath);
      const parentKey = keyIndexPath.slice(0, -1).join();
      const parentChildren = childrenMap[parentKey] ?? [];
      parentChildren.push(transformed);
      childrenMap[parentKey] = parentChildren;
    }
  });
  return childrenMap[""][0];
}
function insert(node2, options) {
  const { nodes, at } = options;
  if (at.length === 0) throw new Error(`Can't insert nodes at the root`);
  const state2 = getInsertionOperations(at, nodes);
  return mutate(node2, state2, options);
}
function replace2(node2, options) {
  if (options.at.length === 0) return options.node;
  const operations = getReplaceOperations(options.at, options.node);
  return mutate(node2, operations, options);
}
function remove2(node2, options) {
  if (options.indexPaths.length === 0) return node2;
  for (const indexPath of options.indexPaths) {
    if (indexPath.length === 0) throw new Error(`Can't remove the root node`);
  }
  const operations = getRemovalOperations(options.indexPaths);
  return mutate(node2, operations, options);
}
function move(node2, options) {
  if (options.indexPaths.length === 0) return node2;
  for (const indexPath of options.indexPaths) {
    if (indexPath.length === 0) throw new Error(`Can't move the root node`);
  }
  if (options.to.length === 0) throw new Error(`Can't move nodes to the root`);
  const _ancestorIndexPaths = ancestorIndexPaths(options.indexPaths);
  const nodesToInsert = _ancestorIndexPaths.map((indexPath) => access(node2, indexPath, options));
  const operations = getInsertionOperations(options.to, nodesToInsert, getRemovalOperations(_ancestorIndexPaths));
  return mutate(node2, operations, options);
}
function visit(node2, options) {
  const { onEnter, onLeave, getChildren } = options;
  let indexPath = [];
  let stack = [{ node: node2 }];
  const getIndexPath = options.reuseIndexPath ? () => indexPath : () => indexPath.slice();
  while (stack.length > 0) {
    let wrapper = stack[stack.length - 1];
    if (wrapper.state === void 0) {
      const enterResult = onEnter == null ? void 0 : onEnter(wrapper.node, getIndexPath());
      if (enterResult === "stop") return;
      wrapper.state = enterResult === "skip" ? -1 : 0;
    }
    const children = wrapper.children || getChildren(wrapper.node, getIndexPath());
    wrapper.children || (wrapper.children = children);
    if (wrapper.state !== -1) {
      if (wrapper.state < children.length) {
        let currentIndex = wrapper.state;
        indexPath.push(currentIndex);
        stack.push({ node: children[currentIndex] });
        wrapper.state = currentIndex + 1;
        continue;
      }
      const leaveResult = onLeave == null ? void 0 : onLeave(wrapper.node, getIndexPath());
      if (leaveResult === "stop") return;
    }
    indexPath.pop();
    stack.pop();
  }
}
var TreeCollection = class {
  constructor(options) {
    this.options = options;
    __publicField3(this, "rootNode");
    __publicField3(this, "isEqual", (other) => {
      return isEqual(this.rootNode, other.rootNode);
    });
    __publicField3(this, "getNodeChildren", (node2) => {
      var _a8, _b7;
      return ((_b7 = (_a8 = this.options).nodeToChildren) == null ? void 0 : _b7.call(_a8, node2)) ?? fallback2.nodeToChildren(node2) ?? [];
    });
    __publicField3(this, "getNodeValue", (node2) => {
      var _a8, _b7;
      return ((_b7 = (_a8 = this.options).nodeToValue) == null ? void 0 : _b7.call(_a8, node2)) ?? fallback2.nodeToValue(node2);
    });
    __publicField3(this, "getNodeDisabled", (node2) => {
      var _a8, _b7;
      return ((_b7 = (_a8 = this.options).isNodeDisabled) == null ? void 0 : _b7.call(_a8, node2)) ?? fallback2.isNodeDisabled(node2);
    });
    __publicField3(this, "stringify", (value) => {
      const node2 = this.findNode(value);
      if (!node2) return null;
      return this.stringifyNode(node2);
    });
    __publicField3(this, "stringifyNode", (node2) => {
      var _a8, _b7;
      return ((_b7 = (_a8 = this.options).nodeToString) == null ? void 0 : _b7.call(_a8, node2)) ?? fallback2.nodeToString(node2);
    });
    __publicField3(this, "getFirstNode", (rootNode = this.rootNode) => {
      let firstChild;
      visit(rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node2, indexPath) => {
          if (!firstChild && indexPath.length > 0 && !this.getNodeDisabled(node2)) {
            firstChild = node2;
            return "stop";
          }
        }
      });
      return firstChild;
    });
    __publicField3(this, "getLastNode", (rootNode = this.rootNode, opts = {}) => {
      let lastChild;
      visit(rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node2, indexPath) => {
          var _a8;
          const nodeValue = this.getNodeValue(node2);
          if ((_a8 = opts.skip) == null ? void 0 : _a8.call(opts, { value: nodeValue, node: node2, indexPath })) return "skip";
          if (indexPath.length > 1) return "skip";
          if (!this.getNodeDisabled(node2)) {
            lastChild = node2;
          }
        }
      });
      return lastChild;
    });
    __publicField3(this, "at", (indexPath) => {
      return access(this.rootNode, indexPath, {
        getChildren: this.getNodeChildren
      });
    });
    __publicField3(this, "findNode", (value, rootNode = this.rootNode) => {
      return find(rootNode, {
        getChildren: this.getNodeChildren,
        predicate: (node2) => this.getNodeValue(node2) === value
      });
    });
    __publicField3(this, "sort", (values) => {
      return values.reduce(
        (acc, value) => {
          const indexPath = this.getIndexPath(value);
          if (indexPath != null) acc.push({ value, indexPath });
          return acc;
        },
        []
      ).sort((a2, b2) => compareIndexPaths(a2.indexPath, b2.indexPath)).map(({ value }) => value);
    });
    __publicField3(this, "getIndexPath", (value) => {
      return findIndexPath(this.rootNode, {
        getChildren: this.getNodeChildren,
        predicate: (node2) => this.getNodeValue(node2) === value
      });
    });
    __publicField3(this, "getValue", (indexPath) => {
      const node2 = this.at(indexPath);
      return node2 ? this.getNodeValue(node2) : void 0;
    });
    __publicField3(this, "getValuePath", (indexPath) => {
      if (!indexPath) return [];
      const valuePath = [];
      let currentPath = [...indexPath];
      while (currentPath.length > 0) {
        const node2 = this.at(currentPath);
        if (node2) valuePath.unshift(this.getNodeValue(node2));
        currentPath.pop();
      }
      return valuePath;
    });
    __publicField3(this, "getDepth", (value) => {
      const indexPath = findIndexPath(this.rootNode, {
        getChildren: this.getNodeChildren,
        predicate: (node2) => this.getNodeValue(node2) === value
      });
      return (indexPath == null ? void 0 : indexPath.length) ?? 0;
    });
    __publicField3(this, "isRootNode", (node2) => {
      return this.getNodeValue(node2) === this.getNodeValue(this.rootNode);
    });
    __publicField3(this, "contains", (parentIndexPath, valueIndexPath) => {
      if (!parentIndexPath || !valueIndexPath) return false;
      return valueIndexPath.slice(0, parentIndexPath.length).every((_, i) => parentIndexPath[i] === valueIndexPath[i]);
    });
    __publicField3(this, "getNextNode", (value, opts = {}) => {
      let found = false;
      let nextNode;
      visit(this.rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node2, indexPath) => {
          var _a8;
          if (this.isRootNode(node2)) return;
          const nodeValue = this.getNodeValue(node2);
          if ((_a8 = opts.skip) == null ? void 0 : _a8.call(opts, { value: nodeValue, node: node2, indexPath })) {
            if (nodeValue === value) {
              found = true;
            }
            return "skip";
          }
          if (found && !this.getNodeDisabled(node2)) {
            nextNode = node2;
            return "stop";
          }
          if (nodeValue === value) {
            found = true;
          }
        }
      });
      return nextNode;
    });
    __publicField3(this, "getPreviousNode", (value, opts = {}) => {
      let previousNode;
      let found = false;
      visit(this.rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node2, indexPath) => {
          var _a8;
          if (this.isRootNode(node2)) return;
          const nodeValue = this.getNodeValue(node2);
          if ((_a8 = opts.skip) == null ? void 0 : _a8.call(opts, { value: nodeValue, node: node2, indexPath })) {
            return "skip";
          }
          if (nodeValue === value) {
            found = true;
            return "stop";
          }
          if (!this.getNodeDisabled(node2)) {
            previousNode = node2;
          }
        }
      });
      return found ? previousNode : void 0;
    });
    __publicField3(this, "getParentNodes", (values) => {
      const result = [];
      let indexPath = this.getIndexPath(values);
      while (indexPath && indexPath.length > 0) {
        indexPath.pop();
        const parentNode = this.at(indexPath);
        if (parentNode && !this.isRootNode(parentNode)) {
          result.unshift(parentNode);
        }
      }
      return result;
    });
    __publicField3(this, "getParentIndexPath", (indexPath) => {
      return indexPath.slice(0, -1);
    });
    __publicField3(this, "getParentNode", (valueOrIndexPath) => {
      const indexPath = typeof valueOrIndexPath === "string" ? this.getIndexPath(valueOrIndexPath) : valueOrIndexPath;
      return indexPath ? this.at(this.getParentIndexPath(indexPath)) : void 0;
    });
    __publicField3(this, "visit", (opts) => {
      const { skip, ...rest } = opts;
      visit(this.rootNode, {
        ...rest,
        getChildren: this.getNodeChildren,
        onEnter: (node2, indexPath) => {
          var _a8;
          if (this.isRootNode(node2)) return;
          if (skip == null ? void 0 : skip({ value: this.getNodeValue(node2), node: node2, indexPath })) return "skip";
          return (_a8 = rest.onEnter) == null ? void 0 : _a8.call(rest, node2, indexPath);
        }
      });
    });
    __publicField3(this, "getPreviousSibling", (indexPath) => {
      const parentNode = this.getParentNode(indexPath);
      if (!parentNode) return;
      const siblings = this.getNodeChildren(parentNode);
      let idx = siblings.findIndex((sibling) => this.getValue(indexPath) === this.getNodeValue(sibling));
      while (--idx >= 0) {
        const sibling = siblings[idx];
        if (!this.getNodeDisabled(sibling)) return sibling;
      }
      return;
    });
    __publicField3(this, "getNextSibling", (indexPath) => {
      const parentNode = this.getParentNode(indexPath);
      if (!parentNode) return;
      const siblings = this.getNodeChildren(parentNode);
      let idx = siblings.findIndex((sibling) => this.getValue(indexPath) === this.getNodeValue(sibling));
      while (++idx < siblings.length) {
        const sibling = siblings[idx];
        if (!this.getNodeDisabled(sibling)) return sibling;
      }
      return;
    });
    __publicField3(this, "getSiblingNodes", (indexPath) => {
      const parentNode = this.getParentNode(indexPath);
      return parentNode ? this.getNodeChildren(parentNode) : [];
    });
    __publicField3(this, "getValues", (rootNode = this.rootNode) => {
      const values = flatMap(rootNode, {
        getChildren: this.getNodeChildren,
        transform: (node2) => [this.getNodeValue(node2)]
      });
      return values.slice(1);
    });
    __publicField3(this, "isSameDepth", (indexPath, depth) => {
      if (depth == null) return true;
      return indexPath.length === depth;
    });
    __publicField3(this, "isBranchNode", (node2) => {
      return this.getNodeChildren(node2).length > 0;
    });
    __publicField3(this, "getBranchValues", (rootNode = this.rootNode, opts = {}) => {
      let values = [];
      visit(rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node2, indexPath) => {
          var _a8;
          const nodeValue = this.getNodeValue(node2);
          if ((_a8 = opts.skip) == null ? void 0 : _a8.call(opts, { value: nodeValue, node: node2, indexPath })) return "skip";
          if (this.getNodeChildren(node2).length > 0 && this.isSameDepth(indexPath, opts.depth)) {
            values.push(this.getNodeValue(node2));
          }
        }
      });
      return values.slice(1);
    });
    __publicField3(this, "flatten", (rootNode = this.rootNode) => {
      const nodes = flatMap(rootNode, {
        getChildren: this.getNodeChildren,
        transform: (node2, indexPath) => {
          const children = this.getNodeChildren(node2).map((child) => this.getNodeValue(child));
          return [
            compact2({
              label: this.stringifyNode(node2),
              value: this.getNodeValue(node2),
              indexPath,
              children: children.length > 0 ? children : void 0
            })
          ];
        }
      });
      return nodes.slice(1);
    });
    __publicField3(this, "_create", (node2, children) => {
      return compact2({ ...node2, children });
    });
    __publicField3(this, "_insert", (rootNode, indexPath, nodes) => {
      return insert(rootNode, { at: indexPath, nodes, getChildren: this.getNodeChildren, create: this._create });
    });
    __publicField3(this, "_replace", (rootNode, indexPath, node2) => {
      return replace2(rootNode, { at: indexPath, node: node2, getChildren: this.getNodeChildren, create: this._create });
    });
    __publicField3(this, "_move", (rootNode, indexPaths, to) => {
      return move(rootNode, { indexPaths, to, getChildren: this.getNodeChildren, create: this._create });
    });
    __publicField3(this, "_remove", (rootNode, indexPaths) => {
      return remove2(rootNode, { indexPaths, getChildren: this.getNodeChildren, create: this._create });
    });
    __publicField3(this, "replace", (indexPath, node2) => {
      return this._replace(this.rootNode, indexPath, node2);
    });
    __publicField3(this, "remove", (indexPaths) => {
      return this._remove(this.rootNode, indexPaths);
    });
    __publicField3(this, "insertBefore", (indexPath, nodes) => {
      const parentNode = this.getParentNode(indexPath);
      return parentNode ? this._insert(this.rootNode, indexPath, nodes) : void 0;
    });
    __publicField3(this, "insertAfter", (indexPath, nodes) => {
      const parentNode = this.getParentNode(indexPath);
      if (!parentNode) return;
      const nextIndex2 = [...indexPath.slice(0, -1), indexPath[indexPath.length - 1] + 1];
      return this._insert(this.rootNode, nextIndex2, nodes);
    });
    __publicField3(this, "move", (fromIndexPaths, toIndexPath) => {
      return this._move(this.rootNode, fromIndexPaths, toIndexPath);
    });
    __publicField3(this, "json", () => {
      return this.getValues(this.rootNode);
    });
    this.rootNode = options.rootNode;
  }
};
var fallback2 = {
  nodeToValue(node2) {
    if (typeof node2 === "string") return node2;
    if (isObject5(node2) && hasProp(node2, "value")) return node2.value;
    return "";
  },
  nodeToString(node2) {
    if (typeof node2 === "string") return node2;
    if (isObject5(node2) && hasProp(node2, "label")) return node2.label;
    return fallback2.nodeToValue(node2);
  },
  isNodeDisabled(node2) {
    if (isObject5(node2) && hasProp(node2, "disabled")) return !!node2.disabled;
    return false;
  },
  nodeToChildren(node2) {
    return node2.children;
  }
};

// node_modules/@ark-ui/react/dist/components/collection.js
var createListCollection = (options) => ref(new ListCollection(options));

// node_modules/@ark-ui/react/dist/components/combobox/combobox-clear-trigger.js
var import_jsx_runtime79 = __toESM(require_jsx_runtime(), 1);
var import_react173 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/combobox/use-combobox-context.js
var [ComboboxProvider, useComboboxContext] = createContext3({
  name: "ComboboxContext",
  hookName: "useComboboxContext",
  providerName: "<ComboboxProvider />"
});

// node_modules/@ark-ui/react/dist/components/combobox/combobox-clear-trigger.js
var ComboboxClearTrigger = (0, import_react173.forwardRef)(
  (props34, ref2) => {
    const combobox = useComboboxContext();
    const mergedProps = mergeProps2(combobox.getClearTriggerProps(), props34);
    return (0, import_jsx_runtime79.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
ComboboxClearTrigger.displayName = "ComboboxClearTrigger";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-content.js
var import_jsx_runtime80 = __toESM(require_jsx_runtime(), 1);
var import_react175 = __toESM(require_react(), 1);
var ComboboxContent = (0, import_react175.forwardRef)((props34, ref2) => {
  const combobox = useComboboxContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(combobox.getContentProps(), presence.getPresenceProps(), props34);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime80.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
ComboboxContent.displayName = "ComboboxContent";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-control.js
var import_jsx_runtime81 = __toESM(require_jsx_runtime(), 1);
var import_react177 = __toESM(require_react(), 1);
var ComboboxControl = (0, import_react177.forwardRef)((props34, ref2) => {
  const combobox = useComboboxContext();
  const mergedProps = mergeProps2(combobox.getControlProps(), props34);
  return (0, import_jsx_runtime81.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ComboboxControl.displayName = "ComboboxControl";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-input.js
var import_jsx_runtime82 = __toESM(require_jsx_runtime(), 1);
var import_react179 = __toESM(require_react(), 1);
var ComboboxInput = (0, import_react179.forwardRef)((props34, ref2) => {
  const combobox = useComboboxContext();
  const mergedProps = mergeProps2(combobox.getInputProps(), props34);
  const field = useFieldContext();
  return (0, import_jsx_runtime82.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
});
ComboboxInput.displayName = "ComboboxInput";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item.js
var import_jsx_runtime83 = __toESM(require_jsx_runtime(), 1);
var import_react181 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/combobox/use-combobox-item-context.js
var [ComboboxItemProvider, useComboboxItemContext] = createContext3(
  {
    name: "ComboboxItemContext",
    hookName: "useComboboxItemContext",
    providerName: "<ComboboxItemProvider />"
  }
);

// node_modules/@ark-ui/react/dist/components/combobox/use-combobox-item-props-context.js
var [ComboboxItemPropsProvider, useComboboxItemPropsContext] = createContext3({
  name: "ComboboxItemPropsContext",
  hookName: "useComboboxItemPropsContext",
  providerName: "<ComboboxItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item.js
var ComboboxItem = (0, import_react181.forwardRef)((props34, ref2) => {
  const [itemProps12, localProps] = createSplitProps2()(props34, ["item", "persistFocus"]);
  const combobox = useComboboxContext();
  const mergedProps = mergeProps2(combobox.getItemProps(itemProps12), localProps);
  const itemState = combobox.getItemState(itemProps12);
  return (0, import_jsx_runtime83.jsx)(ComboboxItemPropsProvider, { value: itemProps12, children: (0, import_jsx_runtime83.jsx)(ComboboxItemProvider, { value: itemState, children: (0, import_jsx_runtime83.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
ComboboxItem.displayName = "ComboboxItem";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item-group.js
var import_jsx_runtime84 = __toESM(require_jsx_runtime(), 1);
var import_react183 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/combobox/use-combobox-item-group-props-context.js
var [ComboboxItemGroupPropsProvider, useComboboxItemGroupPropsContext] = createContext3({
  name: "ComboboxItemGroupPropsContext",
  hookName: "useComboboxItemGroupPropsContext",
  providerName: "<ComboboxItemGroupPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item-group.js
var ComboboxItemGroup = (0, import_react183.forwardRef)(
  (props34, ref2) => {
    const id = (0, import_react183.useId)();
    const [_itemGroupProps, localProps] = createSplitProps2()(props34, ["id"]);
    const itemGroupProps3 = { id, ..._itemGroupProps };
    const combobox = useComboboxContext();
    const mergedProps = mergeProps2(combobox.getItemGroupProps(itemGroupProps3), localProps);
    return (0, import_jsx_runtime84.jsx)(ComboboxItemGroupPropsProvider, { value: itemGroupProps3, children: (0, import_jsx_runtime84.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
ComboboxItemGroup.displayName = "ComboboxItemGroup";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item-group-label.js
var import_jsx_runtime85 = __toESM(require_jsx_runtime(), 1);
var import_react185 = __toESM(require_react(), 1);
var ComboboxItemGroupLabel = (0, import_react185.forwardRef)(
  (props34, ref2) => {
    const combobox = useComboboxContext();
    const itemGroupProps3 = useComboboxItemGroupPropsContext();
    const mergedProps = mergeProps2(
      combobox.getItemGroupLabelProps({ htmlFor: itemGroupProps3.id }),
      props34
    );
    return (0, import_jsx_runtime85.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ComboboxItemGroupLabel.displayName = "ComboboxItemGroupLabel";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item-indicator.js
var import_jsx_runtime86 = __toESM(require_jsx_runtime(), 1);
var import_react187 = __toESM(require_react(), 1);
var ComboboxItemIndicator = (0, import_react187.forwardRef)(
  (props34, ref2) => {
    const combobox = useComboboxContext();
    const itemProps12 = useComboboxItemPropsContext();
    const mergedProps = mergeProps2(combobox.getItemIndicatorProps(itemProps12), props34);
    return (0, import_jsx_runtime86.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ComboboxItemIndicator.displayName = "ComboboxItemIndicator";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item-text.js
var import_jsx_runtime87 = __toESM(require_jsx_runtime(), 1);
var import_react189 = __toESM(require_react(), 1);
var ComboboxItemText = (0, import_react189.forwardRef)((props34, ref2) => {
  const combobox = useComboboxContext();
  const itemProps12 = useComboboxItemPropsContext();
  const mergedProps = mergeProps2(combobox.getItemTextProps(itemProps12), props34);
  return (0, import_jsx_runtime87.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
ComboboxItemText.displayName = "ComboboxItemText";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-label.js
var import_jsx_runtime88 = __toESM(require_jsx_runtime(), 1);
var import_react191 = __toESM(require_react(), 1);
var ComboboxLabel = (0, import_react191.forwardRef)((props34, ref2) => {
  const combobox = useComboboxContext();
  const mergedProps = mergeProps2(combobox.getLabelProps(), props34);
  return (0, import_jsx_runtime88.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
ComboboxLabel.displayName = "ComboboxLabel";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-list.js
var import_jsx_runtime89 = __toESM(require_jsx_runtime(), 1);
var import_react193 = __toESM(require_react(), 1);
var ComboboxList = (0, import_react193.forwardRef)((props34, ref2) => {
  const combobox = useComboboxContext();
  const mergedProps = mergeProps2(combobox.getListProps(), props34);
  return (0, import_jsx_runtime89.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ComboboxList.displayName = "ComboboxList";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-positioner.js
var import_jsx_runtime90 = __toESM(require_jsx_runtime(), 1);
var import_react195 = __toESM(require_react(), 1);
var ComboboxPositioner = (0, import_react195.forwardRef)(
  (props34, ref2) => {
    const combobox = useComboboxContext();
    const presence = usePresenceContext();
    const mergedProps = mergeProps2(combobox.getPositionerProps(), props34);
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime90.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ComboboxPositioner.displayName = "ComboboxPositioner";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-root.js
var import_jsx_runtime91 = __toESM(require_jsx_runtime(), 1);
var import_react199 = __toESM(require_react(), 1);

// node_modules/@zag-js/aria-hidden/dist/index.mjs
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = (node2) => node2 && (node2.host || unwrapHost(node2.parentNode));
var correctTargets = (parent, targets) => targets.map((target) => {
  if (parent.contains(target)) return target;
  const correctedTarget = unwrapHost(target);
  if (correctedTarget && parent.contains(correctedTarget)) {
    return correctedTarget;
  }
  console.error("[zag-js > ariaHidden] target", target, "in not contained inside", parent, ". Doing nothing");
  return null;
}).filter((x) => Boolean(x));
var isIgnoredNode = (node2) => {
  if (node2.localName === "next-route-announcer") return true;
  if (node2.localName === "script") return true;
  if (node2.hasAttribute("aria-live")) return true;
  return node2.matches("[data-live-announcer]");
};
var walkTreeOutside = (originalTarget, props34) => {
  const { parentNode, markerName, controlAttribute, explicitBooleanValue } = props34;
  const targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  markerMap[markerName] || (markerMap[markerName] = /* @__PURE__ */ new WeakMap());
  const markerCounter = markerMap[markerName];
  const hiddenNodes = [];
  const elementsToKeep = /* @__PURE__ */ new Set();
  const elementsToStop = new Set(targets);
  const keep = (el) => {
    if (!el || elementsToKeep.has(el)) return;
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  const deep = (parent) => {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, (node2) => {
      if (elementsToKeep.has(node2)) {
        deep(node2);
      } else {
        try {
          if (isIgnoredNode(node2)) return;
          const attr = node2.getAttribute(controlAttribute);
          const alreadyHidden = explicitBooleanValue ? attr === "true" : attr !== null && attr !== "false";
          const counterValue = (counterMap.get(node2) || 0) + 1;
          const markerValue = (markerCounter.get(node2) || 0) + 1;
          counterMap.set(node2, counterValue);
          markerCounter.set(node2, markerValue);
          hiddenNodes.push(node2);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node2, true);
          }
          if (markerValue === 1) {
            node2.setAttribute(markerName, "");
          }
          if (!alreadyHidden) {
            node2.setAttribute(controlAttribute, explicitBooleanValue ? "true" : "");
          }
        } catch (e) {
          console.error("[zag-js > ariaHidden] cannot operate on ", node2, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return () => {
    hiddenNodes.forEach((node2) => {
      const counterValue = counterMap.get(node2) - 1;
      const markerValue = markerCounter.get(node2) - 1;
      counterMap.set(node2, counterValue);
      markerCounter.set(node2, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node2)) {
          node2.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node2);
      }
      if (!markerValue) {
        node2.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var getParentNode3 = (originalTarget) => {
  const target = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return target.ownerDocument.body;
};
var hideOthers = (originalTarget, parentNode = getParentNode3(originalTarget), markerName = "data-aria-hidden") => {
  if (!parentNode) return;
  return walkTreeOutside(originalTarget, {
    parentNode,
    markerName,
    controlAttribute: "aria-hidden",
    explicitBooleanValue: true
  });
};
var raf2 = (fn) => {
  const frameId = requestAnimationFrame(() => fn());
  return () => cancelAnimationFrame(frameId);
};
function ariaHidden(targetsOrFn, options = {}) {
  const { defer = true } = options;
  const func = defer ? raf2 : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const targets = typeof targetsOrFn === "function" ? targetsOrFn() : targetsOrFn;
      const elements = targets.filter(Boolean);
      if (elements.length === 0) return;
      cleanups2.push(hideOthers(elements));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}

// node_modules/@zag-js/combobox/dist/index.mjs
var anatomy9 = createAnatomy("combobox").parts(
  "root",
  "clearTrigger",
  "content",
  "control",
  "input",
  "item",
  "itemGroup",
  "itemGroupLabel",
  "itemIndicator",
  "itemText",
  "label",
  "list",
  "positioner",
  "trigger"
);
var parts9 = anatomy9.build();
var collection = (options) => {
  return ref(new ListCollection(options));
};
collection.empty = () => {
  return ref(new ListCollection({ items: [] }));
};
var dom9 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `combobox:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `combobox:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `combobox:${ctx.id}:control`;
  },
  getInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.input) ?? `combobox:${ctx.id}:input`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `combobox:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `combobox:${ctx.id}:popper`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `combobox:${ctx.id}:toggle-btn`;
  },
  getClearTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.clearTrigger) ?? `combobox:${ctx.id}:clear-btn`;
  },
  getItemGroupId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemGroup) == null ? void 0 : _b7.call(_a8, id)) ?? `combobox:${ctx.id}:optgroup:${id}`;
  },
  getItemGroupLabelId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemGroupLabel) == null ? void 0 : _b7.call(_a8, id)) ?? `combobox:${ctx.id}:optgroup-label:${id}`;
  },
  getItemId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, id)) ?? `combobox:${ctx.id}:option:${id}`;
  },
  getContentEl: (ctx) => dom9.getById(ctx, dom9.getContentId(ctx)),
  getInputEl: (ctx) => dom9.getById(ctx, dom9.getInputId(ctx)),
  getPositionerEl: (ctx) => dom9.getById(ctx, dom9.getPositionerId(ctx)),
  getControlEl: (ctx) => dom9.getById(ctx, dom9.getControlId(ctx)),
  getTriggerEl: (ctx) => dom9.getById(ctx, dom9.getTriggerId(ctx)),
  getClearTriggerEl: (ctx) => dom9.getById(ctx, dom9.getClearTriggerId(ctx)),
  getHighlightedItemEl: (ctx) => {
    const value = ctx.highlightedValue;
    if (value == null) return;
    const selector = `[role=option][data-value="${CSS.escape(value)}"`;
    return query(dom9.getContentEl(ctx), selector);
  },
  focusInputEl: (ctx) => {
    const inputEl = dom9.getInputEl(ctx);
    if (dom9.isActiveElement(ctx, inputEl)) return;
    inputEl == null ? void 0 : inputEl.focus({ preventScroll: true });
  },
  focusTriggerEl: (ctx) => {
    const triggerEl = dom9.getTriggerEl(ctx);
    if (dom9.isActiveElement(ctx, triggerEl)) return;
    triggerEl == null ? void 0 : triggerEl.focus({ preventScroll: true });
  }
});
function connect10(state2, send, normalize3) {
  const translations = state2.context.translations;
  const collection22 = state2.context.collection;
  const disabled = state2.context.disabled;
  const interactive = state2.context.isInteractive;
  const invalid = state2.context.invalid;
  const readOnly = state2.context.readOnly;
  const open = state2.hasTag("open");
  const focused = state2.hasTag("focused");
  const composite = state2.context.composite;
  const highlightedValue = state2.context.highlightedValue;
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: state2.context.currentPlacement
  });
  function getItemState(props34) {
    const disabled2 = collection22.getItemDisabled(props34.item);
    const value = collection22.getItemValue(props34.item);
    return {
      value,
      disabled: Boolean(disabled2 || disabled2),
      highlighted: highlightedValue === value,
      selected: state2.context.value.includes(value)
    };
  }
  return {
    focused,
    open,
    inputValue: state2.context.inputValue,
    highlightedValue,
    highlightedItem: state2.context.highlightedItem,
    value: state2.context.value,
    valueAsString: state2.context.valueAsString,
    hasSelectedItems: state2.context.hasSelectedItems,
    selectedItems: state2.context.selectedItems,
    collection: state2.context.collection,
    multiple: !!state2.context.multiple,
    disabled: !!disabled,
    syncSelectedItems() {
      send({ type: "SELECTED_ITEMS.SYNC" });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    setCollection(collection32) {
      send({ type: "COLLECTION.SET", value: collection32 });
    },
    setHighlightValue(value) {
      send({ type: "HIGHLIGHTED_VALUE.SET", value });
    },
    selectValue(value) {
      send({ type: "ITEM.SELECT", value });
    },
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    setInputValue(value) {
      send({ type: "INPUT_VALUE.SET", value });
    },
    clearValue(value) {
      if (value != null) {
        send({ type: "ITEM.CLEAR", value });
      } else {
        send("VALUE.CLEAR");
      }
    },
    focus() {
      var _a8;
      (_a8 = dom9.getInputEl(state2.context)) == null ? void 0 : _a8.focus();
    },
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    getRootProps() {
      return normalize3.element({
        ...parts9.root.attrs,
        dir: state2.context.dir,
        id: dom9.getRootId(state2.context),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getLabelProps() {
      return normalize3.label({
        ...parts9.label.attrs,
        dir: state2.context.dir,
        htmlFor: dom9.getInputId(state2.context),
        id: dom9.getLabelId(state2.context),
        "data-readonly": dataAttr(readOnly),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        onClick(event) {
          var _a8;
          if (composite) return;
          event.preventDefault();
          (_a8 = dom9.getTriggerEl(state2.context)) == null ? void 0 : _a8.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize3.element({
        ...parts9.control.attrs,
        dir: state2.context.dir,
        id: dom9.getControlId(state2.context),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr(focused),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid)
      });
    },
    getPositionerProps() {
      return normalize3.element({
        ...parts9.positioner.attrs,
        dir: state2.context.dir,
        id: dom9.getPositionerId(state2.context),
        style: popperStyles.floating
      });
    },
    getInputProps() {
      return normalize3.input({
        ...parts9.input.attrs,
        dir: state2.context.dir,
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        name: state2.context.name,
        form: state2.context.form,
        disabled,
        autoFocus: state2.context.autoFocus,
        required: state2.context.required,
        autoComplete: "off",
        autoCorrect: "off",
        autoCapitalize: "none",
        spellCheck: "false",
        readOnly,
        placeholder: state2.context.placeholder,
        id: dom9.getInputId(state2.context),
        type: "text",
        role: "combobox",
        defaultValue: state2.context.inputValue,
        "aria-autocomplete": state2.context.autoComplete ? "both" : "list",
        "aria-controls": dom9.getContentId(state2.context),
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-activedescendant": highlightedValue ? dom9.getItemId(state2.context, highlightedValue) : void 0,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!state2.context.openOnClick) return;
          if (!interactive) return;
          send("INPUT.CLICK");
        },
        onFocus() {
          if (disabled) return;
          send("INPUT.FOCUS");
        },
        onBlur() {
          if (disabled) return;
          send("INPUT.BLUR");
        },
        onChange(event) {
          send({ type: "INPUT.CHANGE", value: event.currentTarget.value });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          if (event.ctrlKey || event.shiftKey || isComposingEvent(event)) return;
          const openOnKeyPress = state2.context.openOnKeyPress;
          const isModifierKey2 = event.ctrlKey || event.metaKey || event.shiftKey;
          const keypress = true;
          const keymap = {
            ArrowDown(event2) {
              if (!openOnKeyPress && !open) return;
              send({ type: event2.altKey ? "OPEN" : "INPUT.ARROW_DOWN", keypress });
              event2.preventDefault();
            },
            ArrowUp() {
              if (!openOnKeyPress && !open) return;
              send({ type: event.altKey ? "CLOSE" : "INPUT.ARROW_UP", keypress });
              event.preventDefault();
            },
            Home(event2) {
              if (isModifierKey2) return;
              send({ type: "INPUT.HOME", keypress });
              if (open) {
                event2.preventDefault();
              }
            },
            End(event2) {
              if (isModifierKey2) return;
              send({ type: "INPUT.END", keypress });
              if (open) {
                event2.preventDefault();
              }
            },
            Enter(event2) {
              send({ type: "INPUT.ENTER", keypress });
              if (open) {
                event2.preventDefault();
              }
              const itemEl = dom9.getHighlightedItemEl(state2.context);
              if (isAnchorElement(itemEl)) {
                state2.context.navigate({
                  value: state2.context.highlightedValue,
                  node: itemEl
                });
              }
            },
            Escape() {
              send({ type: "INPUT.ESCAPE", keypress });
              event.preventDefault();
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keymap[key];
          exec2 == null ? void 0 : exec2(event);
        }
      });
    },
    getTriggerProps(props34 = {}) {
      return normalize3.button({
        ...parts9.trigger.attrs,
        dir: state2.context.dir,
        id: dom9.getTriggerId(state2.context),
        "aria-haspopup": composite ? "listbox" : "dialog",
        type: "button",
        tabIndex: props34.focusable ? void 0 : -1,
        "aria-label": translations.triggerLabel,
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": open ? dom9.getContentId(state2.context) : void 0,
        disabled,
        "data-invalid": dataAttr(invalid),
        "data-focusable": dataAttr(props34.focusable),
        "data-readonly": dataAttr(readOnly),
        "data-disabled": dataAttr(disabled),
        onFocus() {
          if (!props34.focusable) return;
          send({ type: "INPUT.FOCUS", src: "trigger" });
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          if (!isLeftClick(event)) return;
          send("TRIGGER.CLICK");
        },
        onPointerDown(event) {
          if (!interactive) return;
          if (event.pointerType === "touch") return;
          event.preventDefault();
          queueMicrotask(() => {
            var _a8;
            (_a8 = dom9.getInputEl(state2.context)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (composite) return;
          const keyMap2 = {
            ArrowDown() {
              send({ type: "INPUT.ARROW_DOWN", src: "trigger" });
            },
            ArrowUp() {
              send({ type: "INPUT.ARROW_UP", src: "trigger" });
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        }
      });
    },
    getContentProps() {
      return normalize3.element({
        ...parts9.content.attrs,
        dir: state2.context.dir,
        id: dom9.getContentId(state2.context),
        role: !composite ? "dialog" : "listbox",
        tabIndex: -1,
        hidden: !open,
        "data-state": open ? "open" : "closed",
        "data-placement": state2.context.currentPlacement,
        "aria-labelledby": dom9.getLabelId(state2.context),
        "aria-multiselectable": state2.context.multiple && composite ? true : void 0,
        onPointerDown(event) {
          event.preventDefault();
        }
      });
    },
    getListProps() {
      return normalize3.element({
        ...parts9.list.attrs,
        role: !composite ? "listbox" : void 0,
        "aria-labelledby": dom9.getLabelId(state2.context),
        "aria-multiselectable": state2.context.multiple && !composite ? true : void 0
      });
    },
    getClearTriggerProps() {
      return normalize3.button({
        ...parts9.clearTrigger.attrs,
        dir: state2.context.dir,
        id: dom9.getClearTriggerId(state2.context),
        type: "button",
        tabIndex: -1,
        disabled,
        "data-invalid": dataAttr(invalid),
        "aria-label": translations.clearTriggerLabel,
        "aria-controls": dom9.getInputId(state2.context),
        hidden: !state2.context.value.length,
        onPointerDown(event) {
          event.preventDefault();
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "VALUE.CLEAR", src: "clear-trigger" });
        }
      });
    },
    getItemState,
    getItemProps(props34) {
      const itemState = getItemState(props34);
      const value = itemState.value;
      return normalize3.element({
        ...parts9.item.attrs,
        dir: state2.context.dir,
        id: dom9.getItemId(state2.context, value),
        role: "option",
        tabIndex: -1,
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-state": itemState.selected ? "checked" : "unchecked",
        "aria-selected": ariaAttr(itemState.highlighted),
        "aria-disabled": ariaAttr(itemState.disabled),
        "data-disabled": dataAttr(itemState.disabled),
        "data-value": itemState.value,
        onPointerMove() {
          if (itemState.disabled) return;
          if (itemState.highlighted) return;
          send({ type: "ITEM.POINTER_MOVE", value });
        },
        onPointerLeave() {
          if (props34.persistFocus) return;
          if (itemState.disabled) return;
          const mouseMoved = state2.previousEvent.type.includes("POINTER");
          if (!mouseMoved) return;
          send({ type: "ITEM.POINTER_LEAVE", value });
        },
        onClick(event) {
          if (isDownloadingEvent(event)) return;
          if (isOpeningInNewTab(event)) return;
          if (isContextMenuEvent(event)) return;
          if (itemState.disabled) return;
          send({ type: "ITEM.CLICK", src: "click", value });
        }
      });
    },
    getItemTextProps(props34) {
      const itemState = getItemState(props34);
      return normalize3.element({
        ...parts9.itemText.attrs,
        dir: state2.context.dir,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted)
      });
    },
    getItemIndicatorProps(props34) {
      const itemState = getItemState(props34);
      return normalize3.element({
        "aria-hidden": true,
        ...parts9.itemIndicator.attrs,
        dir: state2.context.dir,
        "data-state": itemState.selected ? "checked" : "unchecked",
        hidden: !itemState.selected
      });
    },
    getItemGroupProps(props34) {
      const { id } = props34;
      return normalize3.element({
        ...parts9.itemGroup.attrs,
        dir: state2.context.dir,
        id: dom9.getItemGroupId(state2.context, id),
        "aria-labelledby": dom9.getItemGroupLabelId(state2.context, id)
      });
    },
    getItemGroupLabelProps(props34) {
      const { htmlFor } = props34;
      return normalize3.element({
        ...parts9.itemGroupLabel.attrs,
        dir: state2.context.dir,
        id: dom9.getItemGroupLabelId(state2.context, htmlFor),
        role: "group"
      });
    }
  };
}
var { and: and5, not: not4 } = guards;
function machine10(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "combobox",
      initial: ctx.open ? "suggesting" : "idle",
      context: {
        loopFocus: true,
        openOnClick: false,
        value: [],
        highlightedValue: null,
        inputValue: "",
        allowCustomValue: false,
        closeOnSelect: !ctx.multiple,
        inputBehavior: "none",
        selectionBehavior: "replace",
        openOnKeyPress: true,
        openOnChange: true,
        composite: true,
        readOnly: false,
        disabled: false,
        navigate({ node: node2 }) {
          clickIfLink(node2);
        },
        ...ctx,
        highlightedItem: null,
        selectedItems: [],
        valueAsString: "",
        collection: ctx.collection ?? collection.empty(),
        positioning: {
          placement: "bottom",
          sameWidth: true,
          ...ctx.positioning
        },
        translations: {
          triggerLabel: "Toggle suggestions",
          clearTriggerLabel: "Clear value",
          ...ctx.translations
        }
      },
      created: ["syncInitialValues", "syncSelectionBehavior"],
      computed: {
        isInputValueEmpty: (ctx2) => ctx2.inputValue.length === 0,
        isInteractive: (ctx2) => !(ctx2.readOnly || ctx2.disabled),
        autoComplete: (ctx2) => ctx2.inputBehavior === "autocomplete",
        autoHighlight: (ctx2) => ctx2.inputBehavior === "autohighlight",
        hasSelectedItems: (ctx2) => ctx2.value.length > 0
      },
      watch: {
        value: ["syncSelectedItems"],
        inputValue: ["syncInputValue"],
        highlightedValue: ["syncHighlightedItem", "autofillInputValue"],
        multiple: ["syncSelectionBehavior"],
        open: ["toggleVisibility"]
      },
      on: {
        "SELECTED_ITEMS.SYNC": {
          actions: ["syncSelectedItems"]
        },
        "HIGHLIGHTED_VALUE.SET": {
          actions: ["setHighlightedItem"]
        },
        "ITEM.SELECT": {
          actions: ["selectItem"]
        },
        "ITEM.CLEAR": {
          actions: ["clearItem"]
        },
        "VALUE.SET": {
          actions: ["setSelectedItems"]
        },
        "INPUT_VALUE.SET": {
          actions: "setInputValue"
        },
        "COLLECTION.SET": {
          actions: ["setCollection"]
        },
        "POSITIONING.SET": {
          actions: ["reposition"]
        }
      },
      states: {
        idle: {
          tags: ["idle", "closed"],
          entry: ["scrollContentToTop", "clearHighlightedItem"],
          on: {
            "CONTROLLED.OPEN": {
              target: "interacting"
            },
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["setInitialFocus", "highlightFirstSelectedItem", "invokeOnOpen"]
              },
              {
                target: "interacting",
                actions: ["setInitialFocus", "highlightFirstSelectedItem", "invokeOnOpen"]
              }
            ],
            "INPUT.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
              },
              {
                target: "interacting",
                actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
              }
            ],
            "INPUT.FOCUS": {
              target: "focused"
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "interacting",
                actions: ["invokeOnOpen"]
              }
            ],
            "VALUE.CLEAR": {
              target: "focused",
              actions: ["clearInputValue", "clearSelectedItems", "setInitialFocus"]
            }
          }
        },
        focused: {
          tags: ["focused", "closed"],
          entry: ["scrollContentToTop", "clearHighlightedItem"],
          on: {
            "CONTROLLED.OPEN": [
              {
                guard: "isChangeEvent",
                target: "suggesting"
              },
              {
                target: "interacting"
              }
            ],
            "INPUT.CHANGE": [
              {
                guard: and5("isOpenControlled", "openOnChange"),
                actions: ["setInputValue", "invokeOnOpen", "highlightFirstItemIfNeeded"]
              },
              {
                guard: "openOnChange",
                target: "suggesting",
                actions: ["setInputValue", "invokeOnOpen", "highlightFirstItemIfNeeded"]
              },
              {
                actions: "setInputValue"
              }
            ],
            "LAYER.INTERACT_OUTSIDE": {
              target: "idle"
            },
            "INPUT.ESCAPE": {
              guard: and5("isCustomValue", not4("allowCustomValue")),
              actions: "revertInputValue"
            },
            "INPUT.BLUR": {
              target: "idle"
            },
            "INPUT.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
              },
              {
                target: "interacting",
                actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["setInitialFocus", "highlightFirstSelectedItem", "invokeOnOpen"]
              },
              {
                target: "interacting",
                actions: ["setInitialFocus", "highlightFirstSelectedItem", "invokeOnOpen"]
              }
            ],
            "INPUT.ARROW_DOWN": [
              // == group 1 ==
              {
                guard: and5("isOpenControlled", "autoComplete"),
                actions: ["invokeOnOpen"]
              },
              {
                guard: "autoComplete",
                target: "interacting",
                actions: ["invokeOnOpen"]
              },
              // == group 2 ==
              {
                guard: "isOpenControlled",
                actions: ["highlightFirstOrSelectedItem", "invokeOnOpen"]
              },
              {
                target: "interacting",
                actions: ["highlightFirstOrSelectedItem", "invokeOnOpen"]
              }
            ],
            "INPUT.ARROW_UP": [
              // == group 1 ==
              {
                guard: "autoComplete",
                target: "interacting",
                actions: "invokeOnOpen"
              },
              {
                guard: "autoComplete",
                target: "interacting",
                actions: "invokeOnOpen"
              },
              // == group 2 ==
              {
                target: "interacting",
                actions: ["highlightLastOrSelectedItem", "invokeOnOpen"]
              },
              {
                target: "interacting",
                actions: ["highlightLastOrSelectedItem", "invokeOnOpen"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "interacting",
                actions: ["invokeOnOpen"]
              }
            ],
            "VALUE.CLEAR": {
              actions: ["clearInputValue", "clearSelectedItems"]
            }
          }
        },
        interacting: {
          tags: ["open", "focused"],
          entry: ["setInitialFocus"],
          activities: ["scrollToHighlightedItem", "trackDismissableLayer", "computePlacement", "hideOtherElements"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                guard: "restoreFocus",
                target: "focused",
                actions: ["setFinalFocus"]
              },
              {
                target: "idle"
              }
            ],
            "INPUT.HOME": {
              actions: ["highlightFirstItem"]
            },
            "INPUT.END": {
              actions: ["highlightLastItem"]
            },
            "INPUT.ARROW_DOWN": [
              {
                guard: and5("autoComplete", "isLastItemHighlighted"),
                actions: ["clearHighlightedItem", "scrollContentToTop"]
              },
              {
                actions: ["highlightNextItem"]
              }
            ],
            "INPUT.ARROW_UP": [
              {
                guard: and5("autoComplete", "isFirstItemHighlighted"),
                actions: "clearHighlightedItem"
              },
              {
                actions: "highlightPrevItem"
              }
            ],
            "INPUT.ENTER": [
              // == group 1 ==
              {
                guard: and5("isOpenControlled", "isCustomValue", not4("hasHighlightedItem"), not4("allowCustomValue")),
                actions: ["revertInputValue", "invokeOnClose"]
              },
              {
                guard: and5("isCustomValue", not4("hasHighlightedItem"), not4("allowCustomValue")),
                target: "focused",
                actions: ["revertInputValue", "invokeOnClose"]
              },
              // == group 2 ==
              {
                guard: and5("isOpenControlled", "closeOnSelect"),
                actions: ["selectHighlightedItem", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectHighlightedItem", "invokeOnClose", "setFinalFocus"]
              },
              {
                actions: ["selectHighlightedItem"]
              }
            ],
            "INPUT.CHANGE": [
              {
                guard: "autoComplete",
                target: "suggesting",
                actions: ["setInputValue", "invokeOnOpen"]
              },
              {
                target: "suggesting",
                actions: ["clearHighlightedItem", "setInputValue", "invokeOnOpen"]
              }
            ],
            "ITEM.POINTER_MOVE": {
              actions: ["setHighlightedItem"]
            },
            "ITEM.POINTER_LEAVE": {
              actions: ["clearHighlightedItem"]
            },
            "ITEM.CLICK": [
              {
                guard: and5("isOpenControlled", "closeOnSelect"),
                actions: ["selectItem", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectItem", "invokeOnClose", "setFinalFocus"]
              },
              {
                actions: ["selectItem"]
              }
            ],
            "LAYER.ESCAPE": [
              {
                guard: and5("isOpenControlled", "autoComplete"),
                actions: ["syncInputValue", "invokeOnClose"]
              },
              {
                guard: "autoComplete",
                target: "focused",
                actions: ["syncInputValue", "invokeOnClose"]
              },
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "focused",
                actions: ["invokeOnClose", "setFinalFocus"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "focused",
                actions: "invokeOnClose"
              }
            ],
            "LAYER.INTERACT_OUTSIDE": [
              // == group 1 ==
              {
                guard: and5("isOpenControlled", "isCustomValue", not4("allowCustomValue")),
                actions: ["revertInputValue", "invokeOnClose"]
              },
              {
                guard: and5("isCustomValue", not4("allowCustomValue")),
                target: "idle",
                actions: ["revertInputValue", "invokeOnClose"]
              },
              // == group 2 ==
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "idle",
                actions: "invokeOnClose"
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose", "setFinalFocus"]
              }
            ],
            "VALUE.CLEAR": [
              {
                guard: "isOpenControlled",
                actions: ["clearInputValue", "clearSelectedItems", "invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["clearInputValue", "clearSelectedItems", "invokeOnClose", "setFinalFocus"]
              }
            ]
          }
        },
        suggesting: {
          tags: ["open", "focused"],
          activities: [
            "trackDismissableLayer",
            "scrollToHighlightedItem",
            "computePlacement",
            "trackChildNodes",
            "hideOtherElements"
          ],
          entry: ["setInitialFocus"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                guard: "restoreFocus",
                target: "focused",
                actions: ["setFinalFocus"]
              },
              {
                target: "idle"
              }
            ],
            CHILDREN_CHANGE: {
              actions: ["highlightFirstItem"]
            },
            "INPUT.ARROW_DOWN": {
              target: "interacting",
              actions: ["highlightNextItem"]
            },
            "INPUT.ARROW_UP": {
              target: "interacting",
              actions: ["highlightPrevItem"]
            },
            "INPUT.HOME": {
              target: "interacting",
              actions: ["highlightFirstItem"]
            },
            "INPUT.END": {
              target: "interacting",
              actions: ["highlightLastItem"]
            },
            "INPUT.ENTER": [
              // == group 1 ==
              {
                guard: and5("isOpenControlled", "isCustomValue", not4("hasHighlightedItem"), not4("allowCustomValue")),
                actions: ["revertInputValue", "invokeOnClose"]
              },
              {
                guard: and5("isCustomValue", not4("hasHighlightedItem"), not4("allowCustomValue")),
                target: "focused",
                actions: ["revertInputValue", "invokeOnClose"]
              },
              // == group 2 ==
              {
                guard: and5("isOpenControlled", "closeOnSelect"),
                actions: ["selectHighlightedItem", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectHighlightedItem", "invokeOnClose", "setFinalFocus"]
              },
              {
                actions: ["selectHighlightedItem"]
              }
            ],
            "INPUT.CHANGE": [
              {
                guard: "autoHighlight",
                actions: ["setInputValue"]
              },
              {
                actions: ["setInputValue"]
              }
            ],
            "LAYER.ESCAPE": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose"]
              }
            ],
            "ITEM.POINTER_MOVE": {
              target: "interacting",
              actions: ["setHighlightedItem"]
            },
            "ITEM.POINTER_LEAVE": {
              actions: ["clearHighlightedItem"]
            },
            "LAYER.INTERACT_OUTSIDE": [
              // == group 1 ==
              {
                guard: and5("isOpenControlled", "isCustomValue", not4("allowCustomValue")),
                actions: ["revertInputValue", "invokeOnClose"]
              },
              {
                guard: and5("isCustomValue", not4("allowCustomValue")),
                target: "idle",
                actions: ["revertInputValue", "invokeOnClose"]
              },
              // == group 2 ==
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose"]
              }
            ],
            "ITEM.CLICK": [
              {
                guard: and5("isOpenControlled", "closeOnSelect"),
                actions: ["selectItem", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectItem", "invokeOnClose", "setFinalFocus"]
              },
              {
                actions: ["selectItem"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose", "setFinalFocus"]
              }
            ],
            "VALUE.CLEAR": [
              {
                guard: "isOpenControlled",
                actions: ["clearInputValue", "clearSelectedItems", "invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["clearInputValue", "clearSelectedItems", "invokeOnClose", "setFinalFocus"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isInputValueEmpty: (ctx2) => ctx2.isInputValueEmpty,
        autoComplete: (ctx2) => ctx2.autoComplete && !ctx2.multiple,
        autoHighlight: (ctx2) => ctx2.autoHighlight,
        isFirstItemHighlighted: (ctx2) => ctx2.collection.firstValue === ctx2.highlightedValue,
        isLastItemHighlighted: (ctx2) => ctx2.collection.lastValue === ctx2.highlightedValue,
        isCustomValue: (ctx2) => ctx2.inputValue !== ctx2.valueAsString,
        allowCustomValue: (ctx2) => !!ctx2.allowCustomValue,
        hasHighlightedItem: (ctx2) => ctx2.highlightedValue != null,
        closeOnSelect: (ctx2) => !!ctx2.closeOnSelect,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        openOnChange: (ctx2, evt) => {
          var _a8;
          if (isBoolean(ctx2.openOnChange)) return ctx2.openOnChange;
          return !!((_a8 = ctx2.openOnChange) == null ? void 0 : _a8.call(ctx2, { inputValue: evt.value }));
        },
        restoreFocus: (_ctx, evt) => evt.restoreFocus == null ? true : !!evt.restoreFocus,
        isChangeEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "INPUT.CHANGE";
        }
      },
      activities: {
        trackDismissableLayer(ctx2, _evt, { send }) {
          if (ctx2.disableLayer) return;
          const contentEl = () => dom9.getContentEl(ctx2);
          return trackDismissableElement(contentEl, {
            defer: true,
            exclude: () => [dom9.getInputEl(ctx2), dom9.getTriggerEl(ctx2), dom9.getClearTriggerEl(ctx2)],
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onInteractOutside: ctx2.onInteractOutside,
            onEscapeKeyDown(event) {
              event.preventDefault();
              event.stopPropagation();
              send("LAYER.ESCAPE");
            },
            onDismiss() {
              send({ type: "LAYER.INTERACT_OUTSIDE", restoreFocus: false });
            }
          });
        },
        hideOtherElements(ctx2) {
          return ariaHidden([
            dom9.getInputEl(ctx2),
            dom9.getContentEl(ctx2),
            dom9.getTriggerEl(ctx2),
            dom9.getClearTriggerEl(ctx2)
          ]);
        },
        computePlacement(ctx2) {
          const controlEl = () => dom9.getControlEl(ctx2);
          const positionerEl = () => dom9.getPositionerEl(ctx2);
          ctx2.currentPlacement = ctx2.positioning.placement;
          return getPlacement(controlEl, positionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        // in event the options are fetched (async), we still want to auto-highlight the first option
        trackChildNodes(ctx2, _evt, { send }) {
          if (!ctx2.autoHighlight) return;
          const exec2 = () => send("CHILDREN_CHANGE");
          const contentEl = () => dom9.getContentEl(ctx2);
          return observeChildren(contentEl, {
            callback: exec2,
            defer: true
          });
        },
        scrollToHighlightedItem(ctx2, _evt, { getState }) {
          const inputEl = dom9.getInputEl(ctx2);
          let cleanups2 = [];
          const exec2 = (immediate) => {
            const state2 = getState();
            const pointer = state2.event.type.includes("POINTER");
            if (pointer || !ctx2.highlightedValue) return;
            const itemEl = dom9.getHighlightedItemEl(ctx2);
            const contentEl = dom9.getContentEl(ctx2);
            if (ctx2.scrollToIndexFn) {
              const highlightedIndex = ctx2.collection.indexOf(ctx2.highlightedValue);
              ctx2.scrollToIndexFn({ index: highlightedIndex, immediate });
              return;
            }
            const rafCleanup2 = raf(() => {
              scrollIntoView(itemEl, { rootEl: contentEl, block: "nearest" });
            });
            cleanups2.push(rafCleanup2);
          };
          const rafCleanup = raf(() => exec2(true));
          cleanups2.push(rafCleanup);
          const observerCleanup = observeAttributes(inputEl, {
            attributes: ["aria-activedescendant"],
            callback: () => exec2(false)
          });
          cleanups2.push(observerCleanup);
          return () => {
            cleanups2.forEach((cleanup) => cleanup());
          };
        }
      },
      actions: {
        reposition(ctx2, evt) {
          const controlEl = () => dom9.getControlEl(ctx2);
          const positionerEl = () => dom9.getPositionerEl(ctx2);
          getPlacement(controlEl, positionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        setHighlightedItem(ctx2, evt) {
          if (evt.value == null) return;
          set8.highlightedValue(ctx2, evt.value);
        },
        clearHighlightedItem(ctx2) {
          set8.highlightedValue(ctx2, null, true);
        },
        selectHighlightedItem(ctx2) {
          set8.value(ctx2, ctx2.highlightedValue);
          set8.inputValue(ctx2, getInputValue(ctx2));
        },
        selectItem(ctx2, evt) {
          if (evt.value == null) return;
          set8.value(ctx2, evt.value);
          set8.inputValue(ctx2, getInputValue(ctx2));
        },
        clearItem(ctx2, evt) {
          if (evt.value == null) return;
          const value = ctx2.value.filter((v) => v !== evt.value);
          set8.value(ctx2, value);
          set8.inputValue(ctx2, getInputValue(ctx2));
        },
        setInitialFocus(ctx2) {
          raf(() => {
            dom9.focusInputEl(ctx2);
          });
        },
        setFinalFocus(ctx2) {
          raf(() => {
            const triggerEl = dom9.getTriggerEl(ctx2);
            if ((triggerEl == null ? void 0 : triggerEl.dataset.focusable) == null) {
              dom9.focusInputEl(ctx2);
            } else {
              dom9.focusTriggerEl(ctx2);
            }
          });
        },
        syncInputValue(ctx2) {
          const inputEl = dom9.getInputEl(ctx2);
          if (!inputEl) return;
          inputEl.value = ctx2.inputValue;
          queueMicrotask(() => {
            const { selectionStart, selectionEnd } = inputEl;
            if (Math.abs((selectionEnd ?? 0) - (selectionStart ?? 0)) !== 0) return;
            if (selectionStart !== 0) return;
            inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
          });
        },
        setInputValue(ctx2, evt) {
          set8.inputValue(ctx2, evt.value);
        },
        clearInputValue(ctx2) {
          set8.inputValue(ctx2, "");
        },
        revertInputValue(ctx2) {
          const inputValue = match3(ctx2.selectionBehavior, {
            replace: ctx2.hasSelectedItems ? ctx2.valueAsString : "",
            preserve: ctx2.inputValue,
            clear: ""
          });
          set8.inputValue(ctx2, inputValue);
        },
        syncInitialValues(ctx2) {
          const selectedItems = ctx2.collection.findMany(ctx2.value);
          const valueAsString = ctx2.collection.stringifyMany(ctx2.value);
          ctx2.highlightedItem = ctx2.collection.find(ctx2.highlightedValue);
          ctx2.selectedItems = selectedItems;
          ctx2.valueAsString = valueAsString;
          if (ctx2.inputValue.trim() || ctx2.multiple) return;
          ctx2.inputValue = match3(ctx2.selectionBehavior, {
            preserve: ctx2.inputValue || valueAsString,
            replace: valueAsString,
            clear: ""
          });
        },
        syncSelectionBehavior(ctx2) {
          if (ctx2.multiple) {
            ctx2.selectionBehavior = "clear";
          }
        },
        setSelectedItems(ctx2, evt) {
          if (!isArray(evt.value)) return;
          set8.value(ctx2, evt.value);
          set8.inputValue(ctx2, getInputValue(ctx2));
        },
        clearSelectedItems(ctx2) {
          set8.value(ctx2, []);
          set8.inputValue(ctx2, getInputValue(ctx2));
        },
        scrollContentToTop(ctx2) {
          if (ctx2.scrollToIndexFn) {
            ctx2.scrollToIndexFn({ index: 0, immediate: true });
          } else {
            const contentEl = dom9.getContentEl(ctx2);
            if (!contentEl) return;
            contentEl.scrollTop = 0;
          }
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        highlightFirstItem(ctx2) {
          raf(() => {
            const value = ctx2.collection.firstValue;
            set8.highlightedValue(ctx2, value, true);
          });
        },
        highlightFirstItemIfNeeded(ctx2) {
          if (!ctx2.autoHighlight) return;
          raf(() => {
            const value = ctx2.collection.firstValue;
            set8.highlightedValue(ctx2, value);
          });
        },
        highlightLastItem(ctx2) {
          raf(() => {
            const value = ctx2.collection.lastValue;
            set8.highlightedValue(ctx2, value);
          });
        },
        highlightNextItem(ctx2) {
          let value = null;
          if (ctx2.highlightedValue) {
            value = ctx2.collection.getNextValue(ctx2.highlightedValue);
            if (!value && ctx2.loopFocus) value = ctx2.collection.firstValue;
          } else {
            value = ctx2.collection.firstValue;
          }
          set8.highlightedValue(ctx2, value);
        },
        highlightPrevItem(ctx2) {
          let value = null;
          if (ctx2.highlightedValue) {
            value = ctx2.collection.getPreviousValue(ctx2.highlightedValue);
            if (!value && ctx2.loopFocus) value = ctx2.collection.lastValue;
          } else {
            value = ctx2.collection.lastValue;
          }
          set8.highlightedValue(ctx2, value);
        },
        highlightFirstSelectedItem(ctx2) {
          raf(() => {
            const [value] = ctx2.collection.sort(ctx2.value);
            set8.highlightedValue(ctx2, value);
          });
        },
        highlightFirstOrSelectedItem(ctx2) {
          raf(() => {
            let value = null;
            if (ctx2.hasSelectedItems) {
              value = ctx2.collection.sort(ctx2.value)[0];
            } else {
              value = ctx2.collection.firstValue;
            }
            set8.highlightedValue(ctx2, value);
          });
        },
        highlightLastOrSelectedItem(ctx2) {
          raf(() => {
            let value = null;
            if (ctx2.hasSelectedItems) {
              value = ctx2.collection.sort(ctx2.value)[0];
            } else {
              value = ctx2.collection.lastValue;
            }
            set8.highlightedValue(ctx2, value);
          });
        },
        autofillInputValue(ctx2, evt) {
          const inputEl = dom9.getInputEl(ctx2);
          if (!ctx2.autoComplete || !inputEl || !evt.keypress) return;
          const valueText = ctx2.collection.stringify(ctx2.highlightedValue);
          raf(() => {
            inputEl.value = valueText || ctx2.inputValue;
          });
        },
        setCollection(ctx2, evt) {
          ctx2.collection = evt.value;
        },
        syncSelectedItems(ctx2) {
          sync2.valueChange(ctx2);
          set8.inputValue(ctx2, getInputValue(ctx2));
        },
        syncHighlightedItem(ctx2) {
          sync2.highlightChange(ctx2);
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      }
    }
  );
}
function getInputValue(ctx) {
  return match3(ctx.selectionBehavior, {
    preserve: ctx.inputValue,
    replace: ctx.valueAsString,
    clear: ""
  });
}
var sync2 = {
  valueChange: (ctx) => {
    const prevSelectedItems = ctx.selectedItems;
    ctx.selectedItems = ctx.value.map((v) => {
      const foundItem = prevSelectedItems.find((item) => ctx.collection.getItemValue(item) === v);
      if (foundItem) return foundItem;
      return ctx.collection.find(v);
    });
    ctx.valueAsString = ctx.collection.stringifyItems(ctx.selectedItems);
  },
  highlightChange: (ctx) => {
    ctx.highlightedItem = ctx.collection.find(ctx.highlightedValue);
  }
};
var invoke6 = {
  valueChange: (ctx) => {
    var _a8;
    sync2.valueChange(ctx);
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, {
      value: Array.from(ctx.value),
      items: Array.from(ctx.selectedItems)
    });
  },
  highlightChange: (ctx) => {
    var _a8;
    sync2.highlightChange(ctx);
    (_a8 = ctx.onHighlightChange) == null ? void 0 : _a8.call(ctx, {
      highlightedValue: ctx.highlightedValue,
      highlightedItem: ctx.highlightedItem
    });
  },
  inputChange: (ctx) => {
    var _a8;
    (_a8 = ctx.onInputValueChange) == null ? void 0 : _a8.call(ctx, { inputValue: ctx.inputValue });
  }
};
var set8 = {
  value: (ctx, value, force = false) => {
    if (isEqual(ctx.value, value)) return;
    if (value == null && !force) return;
    if (value == null && force) {
      ctx.value = [];
      invoke6.valueChange(ctx);
      return;
    }
    if (isArray(value)) {
      ctx.value = value;
    } else if (value != null) {
      ctx.value = ctx.multiple ? addOrRemove(ctx.value, value) : [value];
    }
    invoke6.valueChange(ctx);
  },
  highlightedValue: (ctx, value, force = false) => {
    if (isEqual(ctx.highlightedValue, value)) return;
    if (!value && !force) return;
    ctx.highlightedValue = value || null;
    invoke6.highlightChange(ctx);
  },
  inputValue: (ctx, value) => {
    if (isEqual(ctx.inputValue, value)) return;
    ctx.inputValue = value;
    invoke6.inputChange(ctx);
  }
};

// node_modules/@ark-ui/react/dist/components/combobox/use-combobox.js
var import_react197 = __toESM(require_react(), 1);
var useCombobox = (props34) => {
  const { collection: collection4, ...comboboxProps } = props34;
  const { dir } = useLocaleContext();
  const { getRootNode } = useEnvironmentContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react197.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      input: field == null ? void 0 : field.ids.control
    },
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    invalid: field == null ? void 0 : field.invalid,
    dir,
    getRootNode,
    collection: collection4,
    open: props34.defaultOpen,
    value: props34.defaultValue,
    "open.controlled": props34.open !== void 0,
    ...comboboxProps
  };
  const context = (() => {
    const { collection: _, ...restProps } = initialContext;
    return {
      ...restProps,
      value: props34.value,
      onValueChange: useEvent(props34.onValueChange),
      onInputValueChange: useEvent(props34.onInputValueChange, { sync: true }),
      onHighlightChange: useEvent(props34.onHighlightChange),
      onOpenChange: useEvent(props34.onOpenChange)
    };
  })();
  const [state2, send, service] = useMachine(machine10(initialContext), {
    context
  });
  (0, import_react197.useEffect)(() => {
    service.setContext({ collection: collection4 });
  }, [collection4]);
  return connect10(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/combobox/combobox-root.js
var ComboboxImpl = (props34, ref2) => {
  const [presenceProps, comboboxProps] = splitPresenceProps(props34);
  const [useComboboxProps, localProps] = createSplitProps2()(comboboxProps, [
    "allowCustomValue",
    "autoFocus",
    "closeOnSelect",
    "composite",
    "collection",
    "defaultOpen",
    "defaultValue",
    "disabled",
    "disableLayer",
    "form",
    "highlightedValue",
    "id",
    "ids",
    "inputBehavior",
    "inputValue",
    "invalid",
    "loopFocus",
    "multiple",
    "name",
    "navigate",
    "onFocusOutside",
    "onHighlightChange",
    "onInputValueChange",
    "onInteractOutside",
    "onOpenChange",
    "onOpenChange",
    "onPointerDownOutside",
    "onValueChange",
    "open",
    "openOnChange",
    "openOnClick",
    "openOnKeyPress",
    "placeholder",
    "positioning",
    "readOnly",
    "required",
    "scrollToIndexFn",
    "selectionBehavior",
    "translations",
    "value"
  ]);
  const combobox = useCombobox(useComboboxProps);
  const presence = usePresence(mergeProps2({ present: combobox.open }, presenceProps));
  const mergedProps = mergeProps2(combobox.getRootProps(), localProps);
  return (0, import_jsx_runtime91.jsx)(ComboboxProvider, { value: combobox, children: (0, import_jsx_runtime91.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime91.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
};
var ComboboxRoot = (0, import_react199.forwardRef)(ComboboxImpl);

// node_modules/@ark-ui/react/dist/components/combobox/combobox-root-provider.js
var import_jsx_runtime92 = __toESM(require_jsx_runtime(), 1);
var import_react201 = __toESM(require_react(), 1);
var ComboboxImpl2 = (props34, ref2) => {
  const [presenceProps, comboboxProps] = splitPresenceProps(props34);
  const [{ value: combobox }, localProps] = createSplitProps2()(
    comboboxProps,
    ["value"]
  );
  const presence = usePresence(mergeProps2({ present: combobox.open }, presenceProps));
  const mergedProps = mergeProps2(combobox.getRootProps(), localProps);
  return (0, import_jsx_runtime92.jsx)(ComboboxProvider, { value: combobox, children: (0, import_jsx_runtime92.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime92.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
};
var ComboboxRootProvider = (0, import_react201.forwardRef)(ComboboxImpl2);

// node_modules/@ark-ui/react/dist/components/combobox/combobox-trigger.js
var import_jsx_runtime93 = __toESM(require_jsx_runtime(), 1);
var import_react203 = __toESM(require_react(), 1);
var ComboboxTrigger = (0, import_react203.forwardRef)((props34, ref2) => {
  const combobox = useComboboxContext();
  const mergedProps = mergeProps2(combobox.getTriggerProps(), props34);
  return (0, import_jsx_runtime93.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
ComboboxTrigger.displayName = "ComboboxTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-clear-trigger.js
var import_jsx_runtime94 = __toESM(require_jsx_runtime(), 1);
var import_react205 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/date-picker/use-date-picker-context.js
var [DatePickerProvider, useDatePickerContext] = createContext3({
  name: "DatePickerContext",
  hookName: "useDatePickerContext",
  providerName: "<DatePickerProvider />"
});

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-clear-trigger.js
var DatePickerClearTrigger = (0, import_react205.forwardRef)(
  (props34, ref2) => {
    const datePicker = useDatePickerContext();
    const mergedProps = mergeProps2(datePicker.getClearTriggerProps(), props34);
    return (0, import_jsx_runtime94.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
DatePickerClearTrigger.displayName = "DatePickerClearTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-content.js
var import_jsx_runtime95 = __toESM(require_jsx_runtime(), 1);
var import_react207 = __toESM(require_react(), 1);
var DatePickerContent = (0, import_react207.forwardRef)(
  (props34, ref2) => {
    const datePicker = useDatePickerContext();
    const presence = usePresenceContext();
    const mergedProps = mergeProps2(datePicker.getContentProps(), presence.getPresenceProps(), props34);
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime95.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
  }
);
DatePickerContent.displayName = "DatePickerContent";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-control.js
var import_jsx_runtime96 = __toESM(require_jsx_runtime(), 1);
var import_react209 = __toESM(require_react(), 1);
var DatePickerControl = (0, import_react209.forwardRef)(
  (props34, ref2) => {
    const datePicker = useDatePickerContext();
    const mergedProps = mergeProps2(datePicker.getControlProps(), props34);
    return (0, import_jsx_runtime96.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
DatePickerControl.displayName = "DatePickerControl";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-input.js
var import_jsx_runtime97 = __toESM(require_jsx_runtime(), 1);
var import_react211 = __toESM(require_react(), 1);
var DatePickerInput = (0, import_react211.forwardRef)((props34, ref2) => {
  const [inputProps2, localProps] = createSplitProps2()(props34, ["index", "fixOnBlur"]);
  const datePicker = useDatePickerContext();
  const mergedProps = mergeProps2(datePicker.getInputProps(inputProps2), localProps);
  return (0, import_jsx_runtime97.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
DatePickerInput.displayName = "DatePickerInput";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-label.js
var import_jsx_runtime98 = __toESM(require_jsx_runtime(), 1);
var import_react213 = __toESM(require_react(), 1);
var DatePickerLabel = (0, import_react213.forwardRef)((props34, ref2) => {
  const datePicker = useDatePickerContext();
  const mergedProps = mergeProps2(datePicker.getLabelProps(), props34);
  return (0, import_jsx_runtime98.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
DatePickerLabel.displayName = "DatePickerLabel";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-month-select.js
var import_jsx_runtime99 = __toESM(require_jsx_runtime(), 1);
var import_react215 = __toESM(require_react(), 1);
var DatePickerMonthSelect = (0, import_react215.forwardRef)(
  (props34, ref2) => {
    const datePicker = useDatePickerContext();
    const mergedProps = mergeProps2(datePicker.getMonthSelectProps(), props34);
    return (0, import_jsx_runtime99.jsx)(ark.select, { ...mergedProps, ref: ref2, children: datePicker.getMonths().map((month, i) => (0, import_jsx_runtime99.jsx)("option", { value: month.value, children: month.label }, i)) });
  }
);
DatePickerMonthSelect.displayName = "DatePickerMonthSelect";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-next-trigger.js
var import_jsx_runtime100 = __toESM(require_jsx_runtime(), 1);
var import_react217 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/date-picker/use-date-picker-view-props-context.js
var [DatePickerViewPropsProvider, useDatePickerViewPropsContext] = createContext3({
  name: "DatePickerViewContext",
  hookName: "useDatePickerViewContext",
  providerName: "<DatePickerViewProvider />",
  strict: false,
  defaultValue: { view: "day" }
});

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-next-trigger.js
var DatePickerNextTrigger = (0, import_react217.forwardRef)(
  (props34, ref2) => {
    const datePicker = useDatePickerContext();
    const viewProps2 = useDatePickerViewPropsContext();
    const mergedProps = mergeProps2(datePicker.getNextTriggerProps(viewProps2), props34);
    return (0, import_jsx_runtime100.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
DatePickerNextTrigger.displayName = "DatePickerNextTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-positioner.js
var import_jsx_runtime101 = __toESM(require_jsx_runtime(), 1);
var import_react219 = __toESM(require_react(), 1);
var DatePickerPositioner = (0, import_react219.forwardRef)(
  (props34, ref2) => {
    const datePicker = useDatePickerContext();
    const mergedProps = mergeProps2(datePicker.getPositionerProps(), props34);
    const presence = usePresenceContext();
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime101.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
DatePickerPositioner.displayName = "DatePickerPositioner";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-preset-trigger.js
var import_jsx_runtime102 = __toESM(require_jsx_runtime(), 1);
var import_react221 = __toESM(require_react(), 1);
var DatePickerPresetTrigger = (0, import_react221.forwardRef)(
  (props34, ref2) => {
    const [presetTriggerProps2, localProps] = createSplitProps2()(props34, [
      "value"
    ]);
    const datePicker = useDatePickerContext();
    const mergedProps = mergeProps2(datePicker.getPresetTriggerProps(presetTriggerProps2), localProps);
    return (0, import_jsx_runtime102.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
DatePickerPresetTrigger.displayName = "DatePickerPresetTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-prev-trigger.js
var import_jsx_runtime103 = __toESM(require_jsx_runtime(), 1);
var import_react223 = __toESM(require_react(), 1);
var DatePickerPrevTrigger = (0, import_react223.forwardRef)(
  (props34, ref2) => {
    const datePicker = useDatePickerContext();
    const viewProps2 = useDatePickerViewPropsContext();
    const mergedProps = mergeProps2(datePicker.getPrevTriggerProps(viewProps2), props34);
    return (0, import_jsx_runtime103.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
DatePickerPrevTrigger.displayName = "DatePickerPrevTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-range-text.js
var import_jsx_runtime104 = __toESM(require_jsx_runtime(), 1);
var import_react225 = __toESM(require_react(), 1);
var DatePickerRangeText = (0, import_react225.forwardRef)(
  (props34, ref2) => {
    const datePicker = useDatePickerContext();
    const mergedProps = mergeProps2(datePicker.getRangeTextProps(), props34);
    return (0, import_jsx_runtime104.jsx)(ark.div, { ...mergedProps, ref: ref2, children: datePicker.visibleRangeText.start });
  }
);
DatePickerRangeText.displayName = "DatePickerRangeText";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-root.js
var import_jsx_runtime105 = __toESM(require_jsx_runtime(), 1);
var import_react229 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/date-picker/use-date-picker.js
var import_react227 = __toESM(require_react(), 1);
var useDatePicker = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react227.useId)(),
    dir,
    getRootNode,
    open: props34.defaultOpen,
    "open.controlled": props34.open !== void 0,
    value: props34.defaultValue,
    view: props34.defaultView,
    ...props34
  };
  const context = {
    ...initialContext,
    value: props34.value,
    view: props34.view,
    onValueChange: useEvent(props34.onValueChange, { sync: true }),
    onFocusChange: useEvent(props34.onFocusChange),
    onViewChange: useEvent(props34.onViewChange),
    onOpenChange: useEvent(props34.onOpenChange)
  };
  const [state2, send] = useMachine(machine5(initialContext), {
    context
  });
  return connect5(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-root.js
var DatePickerRoot = (0, import_react229.forwardRef)((props34, ref2) => {
  const [presenceProps, datePickerProps] = splitPresenceProps(props34);
  const [useDatePickerProps, localProps] = createSplitProps2()(datePickerProps, [
    "closeOnSelect",
    "defaultOpen",
    "defaultValue",
    "defaultView",
    "disabled",
    "fixedWeeks",
    "focusedValue",
    "format",
    "id",
    "ids",
    "isDateUnavailable",
    "isDateUnavailable",
    "locale",
    "max",
    "maxView",
    "min",
    "minView",
    "name",
    "numOfMonths",
    "onFocusChange",
    "onOpenChange",
    "onValueChange",
    "onViewChange",
    "open",
    "parse",
    "placeholder",
    "positioning",
    "readOnly",
    "selectionMode",
    "startOfWeek",
    "timeZone",
    "translations",
    "value",
    "view"
  ]);
  const datePicker = useDatePicker(useDatePickerProps);
  const presence = usePresence(mergeProps2({ present: datePicker.open }, presenceProps));
  const mergedProps = mergeProps2(datePicker.getRootProps(), localProps);
  return (0, import_jsx_runtime105.jsx)(DatePickerProvider, { value: datePicker, children: (0, import_jsx_runtime105.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime105.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
DatePickerRoot.displayName = "DatePickerRoot";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-root-provider.js
var import_jsx_runtime106 = __toESM(require_jsx_runtime(), 1);
var import_react231 = __toESM(require_react(), 1);
var DatePickerRootProvider = (0, import_react231.forwardRef)(
  (props34, ref2) => {
    const [presenceProps, datePickerProps] = splitPresenceProps(props34);
    const [{ value: datePicker }, localProps] = createSplitProps2()(
      datePickerProps,
      ["value"]
    );
    const presence = usePresence(mergeProps2({ present: datePicker.open }, presenceProps));
    const mergedProps = mergeProps2(datePicker.getRootProps(), localProps);
    return (0, import_jsx_runtime106.jsx)(DatePickerProvider, { value: datePicker, children: (0, import_jsx_runtime106.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime106.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
  }
);
DatePickerRootProvider.displayName = "DatePickerRootProvider";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table.js
var import_jsx_runtime107 = __toESM(require_jsx_runtime(), 1);
var import_react233 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/date-picker/use-date-picker-table-props-context.js
var [DatePickerTablePropsProvider, useDatePickerTablePropsContext] = createContext3({
  name: "DatePickerTableContext",
  hookName: "useDatePickerTableContext",
  providerName: "<DatePickerTableProvider />"
});

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table.js
var DatePickerTable = (0, import_react233.forwardRef)((props34, ref2) => {
  const [{ columns }, localProps] = createSplitProps2()(props34, [
    "columns"
  ]);
  const datePicker = useDatePickerContext();
  const viewProps2 = useDatePickerViewPropsContext();
  const tableProps2 = { columns, id: (0, import_react233.useId)(), ...viewProps2 };
  const mergedProps = mergeProps2(datePicker.getTableProps(tableProps2), localProps);
  return (0, import_jsx_runtime107.jsx)(DatePickerTablePropsProvider, { value: tableProps2, children: (0, import_jsx_runtime107.jsx)(ark.table, { ...mergedProps, ref: ref2 }) });
});
DatePickerTable.displayName = "DatePickerTable";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-body.js
var import_jsx_runtime108 = __toESM(require_jsx_runtime(), 1);
var import_react235 = __toESM(require_react(), 1);
var DatePickerTableBody = (0, import_react235.forwardRef)(
  (props34, ref2) => {
    const datePicker = useDatePickerContext();
    const tableProps2 = useDatePickerTablePropsContext();
    const mergedProps = mergeProps2(datePicker.getTableBodyProps(tableProps2), props34);
    return (0, import_jsx_runtime108.jsx)(ark.tbody, { ...mergedProps, ref: ref2 });
  }
);
DatePickerTableBody.displayName = "DatePickerTableBody";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-cell.js
var import_jsx_runtime109 = __toESM(require_jsx_runtime(), 1);
var import_react237 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/date-picker/use-date-picker-table-cell-props-context.js
var [DatePickerTableCellPropsProvider, useDatePickerTableCellPropsContext] = createContext3({
  name: "DatePickerTableCellContext",
  hookName: "useDatePickerTableCellContext",
  providerName: "<DatePickerTableCellProvider />"
});

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-cell.js
var DatePickerTableCell = (0, import_react237.forwardRef)(
  (props34, ref2) => {
    const [cellProps, localProps] = createSplitProps2()(props34, [
      "disabled",
      "value",
      "visibleRange",
      "columns"
    ]);
    const datePicker = useDatePickerContext();
    const viewProps2 = useDatePickerViewPropsContext();
    const tableCellProps2 = {
      day: datePicker.getDayTableCellProps,
      month: datePicker.getMonthTableCellProps,
      year: datePicker.getYearTableCellProps
      // @ts-expect-error value is number filter
    }[viewProps2.view](cellProps);
    const mergedProps = mergeProps2(tableCellProps2, localProps);
    return (0, import_jsx_runtime109.jsx)(DatePickerTableCellPropsProvider, { value: cellProps, children: (0, import_jsx_runtime109.jsx)(ark.td, { ref: ref2, ...mergedProps }) });
  }
);
DatePickerTableCell.displayName = "DatePickerTableCell";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-cell-trigger.js
var import_jsx_runtime110 = __toESM(require_jsx_runtime(), 1);
var import_react239 = __toESM(require_react(), 1);
var DatePickerTableCellTrigger = (0, import_react239.forwardRef)((props34, ref2) => {
  const datePicker = useDatePickerContext();
  const tableCellProps2 = useDatePickerTableCellPropsContext();
  const viewProps2 = useDatePickerViewPropsContext();
  const viewMap = {
    day: datePicker.getDayTableCellTriggerProps,
    month: datePicker.getMonthTableCellTriggerProps,
    year: datePicker.getYearTableCellTriggerProps
  };
  const viewFn = viewMap[viewProps2.view];
  const triggerProps2 = viewFn(tableCellProps2);
  const mergedProps = mergeProps2(triggerProps2, props34);
  return (0, import_jsx_runtime110.jsx)(ark.div, { ref: ref2, ...mergedProps });
});
DatePickerTableCellTrigger.displayName = "DatePickerTableCellTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-head.js
var import_jsx_runtime111 = __toESM(require_jsx_runtime(), 1);
var import_react241 = __toESM(require_react(), 1);
var DatePickerTableHead = (0, import_react241.forwardRef)(
  (props34, ref2) => {
    const datePicker = useDatePickerContext();
    const tableProps2 = useDatePickerTablePropsContext();
    const mergedProps = mergeProps2(datePicker.getTableHeadProps(tableProps2), props34);
    return (0, import_jsx_runtime111.jsx)(ark.thead, { ...mergedProps, ref: ref2 });
  }
);
DatePickerTableHead.displayName = "DatePickerTableHead";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-header.js
var import_jsx_runtime112 = __toESM(require_jsx_runtime(), 1);
var import_react243 = __toESM(require_react(), 1);
var DatePickerTableHeader = (0, import_react243.forwardRef)(
  (props34, ref2) => {
    const datePicker = useDatePickerContext();
    const tableProps2 = useDatePickerTablePropsContext();
    const mergedProps = mergeProps2(datePicker.getTableHeaderProps(tableProps2), props34);
    return (0, import_jsx_runtime112.jsx)(ark.th, { ...mergedProps, ref: ref2 });
  }
);
DatePickerTableHeader.displayName = "DatePickerTableHeader";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-row.js
var import_jsx_runtime113 = __toESM(require_jsx_runtime(), 1);
var import_react245 = __toESM(require_react(), 1);
var DatePickerTableRow = (0, import_react245.forwardRef)(
  (props34, ref2) => {
    const datePicker = useDatePickerContext();
    const tableProps2 = useDatePickerTablePropsContext();
    const mergedProps = mergeProps2(datePicker.getTableRowProps(tableProps2), props34);
    return (0, import_jsx_runtime113.jsx)(ark.tr, { ...mergedProps, ref: ref2 });
  }
);
DatePickerTableRow.displayName = "DatePickerTableRow";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-trigger.js
var import_jsx_runtime114 = __toESM(require_jsx_runtime(), 1);
var import_react247 = __toESM(require_react(), 1);
var DatePickerTrigger = (0, import_react247.forwardRef)(
  (props34, ref2) => {
    const datePicker = useDatePickerContext();
    const mergedProps = mergeProps2(datePicker.getTriggerProps(), props34);
    return (0, import_jsx_runtime114.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
DatePickerTrigger.displayName = "DatePickerTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-view.js
var import_jsx_runtime115 = __toESM(require_jsx_runtime(), 1);
var import_react248 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker.anatomy.js
var datePickerAnatomy = anatomy4.extendWith("view");

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-view.js
var DatePickerView = (0, import_react248.forwardRef)((props34, ref2) => {
  const [viewProps2, localProps] = createSplitProps2()(props34, ["view"]);
  const datePicker = useDatePickerContext();
  return (0, import_jsx_runtime115.jsx)(DatePickerViewPropsProvider, { value: viewProps2, children: (0, import_jsx_runtime115.jsx)(
    ark.div,
    {
      hidden: datePicker.view !== viewProps2.view,
      ...datePickerAnatomy.build().view.attrs,
      ...localProps,
      ref: ref2
    }
  ) });
});
DatePickerView.displayName = "DatePickerView";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-view-control.js
var import_jsx_runtime116 = __toESM(require_jsx_runtime(), 1);
var import_react250 = __toESM(require_react(), 1);
var DatePickerViewControl = (0, import_react250.forwardRef)(
  (props34, ref2) => {
    const datePicker = useDatePickerContext();
    const viewProps2 = useDatePickerViewPropsContext();
    const mergedProps = mergeProps2(datePicker.getViewControlProps(viewProps2), props34);
    return (0, import_jsx_runtime116.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
DatePickerViewControl.displayName = "DatePickerViewControl";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-view-trigger.js
var import_jsx_runtime117 = __toESM(require_jsx_runtime(), 1);
var import_react252 = __toESM(require_react(), 1);
var DatePickerViewTrigger = (0, import_react252.forwardRef)(
  (props34, ref2) => {
    const datePicker = useDatePickerContext();
    const viewProps2 = useDatePickerViewPropsContext();
    const mergedProps = mergeProps2(datePicker.getViewTriggerProps(viewProps2), props34);
    return (0, import_jsx_runtime117.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
DatePickerViewTrigger.displayName = "DatePickerViewTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-year-select.js
var import_jsx_runtime118 = __toESM(require_jsx_runtime(), 1);
var import_react254 = __toESM(require_react(), 1);
var DatePickerYearSelect = (0, import_react254.forwardRef)(
  (props34, ref2) => {
    const datePicker = useDatePickerContext();
    const mergedProps = mergeProps2(datePicker.getYearSelectProps(), props34);
    return (0, import_jsx_runtime118.jsx)(ark.select, { ...mergedProps, ref: ref2, children: datePicker.getYears().map((year, i) => (0, import_jsx_runtime118.jsx)("option", { value: year.value, children: year.label }, i)) });
  }
);
DatePickerYearSelect.displayName = "DatePickerYearSelect";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-backdrop.js
var import_jsx_runtime119 = __toESM(require_jsx_runtime(), 1);
var import_react256 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/dialog/use-dialog-context.js
var [DialogProvider, useDialogContext] = createContext3({
  name: "DialogContext",
  hookName: "useDialogContext",
  providerName: "<DialogProvider />"
});

// node_modules/@ark-ui/react/dist/components/dialog/dialog-backdrop.js
var DialogBackdrop = (0, import_react256.forwardRef)((props34, ref2) => {
  const dialog = useDialogContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const presence = usePresence({ ...renderStrategyProps, present: dialog.open });
  const mergedProps = mergeProps2(dialog.getBackdropProps(), presence.getPresenceProps(), props34);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime119.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
DialogBackdrop.displayName = "DialogBackdrop";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-close-trigger.js
var import_jsx_runtime120 = __toESM(require_jsx_runtime(), 1);
var import_react258 = __toESM(require_react(), 1);
var DialogCloseTrigger = (0, import_react258.forwardRef)(
  (props34, ref2) => {
    const dialog = useDialogContext();
    const mergedProps = mergeProps2(dialog.getCloseTriggerProps(), props34);
    return (0, import_jsx_runtime120.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
DialogCloseTrigger.displayName = "DialogCloseTrigger";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-content.js
var import_jsx_runtime121 = __toESM(require_jsx_runtime(), 1);
var import_react260 = __toESM(require_react(), 1);
var DialogContent = (0, import_react260.forwardRef)((props34, ref2) => {
  const dialog = useDialogContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(dialog.getContentProps(), presence.getPresenceProps(), props34);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime121.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
DialogContent.displayName = "DialogContent";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-context.js
var DialogContext = (props34) => props34.children(useDialogContext());

// node_modules/@ark-ui/react/dist/components/dialog/dialog-description.js
var import_jsx_runtime122 = __toESM(require_jsx_runtime(), 1);
var import_react262 = __toESM(require_react(), 1);
var DialogDescription = (0, import_react262.forwardRef)(
  (props34, ref2) => {
    const dialog = useDialogContext();
    const mergedProps = mergeProps2(dialog.getDescriptionProps(), props34);
    return (0, import_jsx_runtime122.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
DialogDescription.displayName = "DialogDescription";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-positioner.js
var import_jsx_runtime123 = __toESM(require_jsx_runtime(), 1);
var import_react264 = __toESM(require_react(), 1);
var DialogPositioner = (0, import_react264.forwardRef)((props34, ref2) => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps2(dialog.getPositionerProps(), props34);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime123.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
DialogPositioner.displayName = "DialogPositioner";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-root.js
var import_jsx_runtime124 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/focus-trap/dist/index.mjs
var __defProp4 = Object.defineProperty;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField4 = (obj, key, value) => __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
var activeFocusTraps = {
  activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      const activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap.pause();
      }
    }
    const trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap(trapStack, trap) {
    const trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0) {
      trapStack[trapStack.length - 1].unpause();
    }
  }
};
var sharedTrapStack = [];
var FocusTrap = class {
  constructor(elements, options) {
    __publicField4(this, "trapStack");
    __publicField4(this, "config");
    __publicField4(this, "doc");
    __publicField4(this, "state", {
      containers: [],
      containerGroups: [],
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      delayInitialFocusTimer: void 0,
      recentNavEvent: void 0
    });
    __publicField4(this, "listenerCleanups", []);
    __publicField4(this, "handleFocus", (event) => {
      const target = getEventTarget(event);
      const targetContained = this.findContainerIndex(target, event) >= 0;
      if (targetContained || isDocument(target)) {
        if (targetContained) {
          this.state.mostRecentlyFocusedNode = target;
        }
      } else {
        event.stopImmediatePropagation();
        let nextNode;
        let navAcrossContainers = true;
        if (this.state.mostRecentlyFocusedNode) {
          if (getTabIndex(this.state.mostRecentlyFocusedNode) > 0) {
            const mruContainerIdx = this.findContainerIndex(this.state.mostRecentlyFocusedNode);
            const { tabbableNodes } = this.state.containerGroups[mruContainerIdx];
            if (tabbableNodes.length > 0) {
              const mruTabIdx = tabbableNodes.findIndex((node2) => node2 === this.state.mostRecentlyFocusedNode);
              if (mruTabIdx >= 0) {
                if (this.config.isKeyForward(this.state.recentNavEvent)) {
                  if (mruTabIdx + 1 < tabbableNodes.length) {
                    nextNode = tabbableNodes[mruTabIdx + 1];
                    navAcrossContainers = false;
                  }
                } else {
                  if (mruTabIdx - 1 >= 0) {
                    nextNode = tabbableNodes[mruTabIdx - 1];
                    navAcrossContainers = false;
                  }
                }
              }
            }
          } else {
            if (!this.state.containerGroups.some((g) => g.tabbableNodes.some((n) => getTabIndex(n) > 0))) {
              navAcrossContainers = false;
            }
          }
        } else {
          navAcrossContainers = false;
        }
        if (navAcrossContainers) {
          nextNode = this.findNextNavNode({
            // move FROM the MRU node, not event-related node (which will be the node that is
            //  outside the trap causing the focus escape we're trying to fix)
            target: this.state.mostRecentlyFocusedNode,
            isBackward: this.config.isKeyBackward(this.state.recentNavEvent)
          });
        }
        if (nextNode) {
          this.tryFocus(nextNode);
        } else {
          this.tryFocus(this.state.mostRecentlyFocusedNode || this.getInitialFocusNode());
        }
      }
      this.state.recentNavEvent = void 0;
    });
    __publicField4(this, "handlePointerDown", (event) => {
      const target = getEventTarget(event);
      if (this.findContainerIndex(target, event) >= 0) {
        return;
      }
      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {
        this.deactivate({ returnFocus: this.config.returnFocusOnDeactivate });
        return;
      }
      if (valueOrHandler(this.config.allowOutsideClick, event)) {
        return;
      }
      event.preventDefault();
    });
    __publicField4(this, "handleClick", (event) => {
      const target = getEventTarget(event);
      if (this.findContainerIndex(target, event) >= 0) {
        return;
      }
      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {
        return;
      }
      if (valueOrHandler(this.config.allowOutsideClick, event)) {
        return;
      }
      event.preventDefault();
      event.stopImmediatePropagation();
    });
    __publicField4(this, "handleTabKey", (event) => {
      if (this.config.isKeyForward(event) || this.config.isKeyBackward(event)) {
        this.state.recentNavEvent = event;
        const isBackward = this.config.isKeyBackward(event);
        const destinationNode = this.findNextNavNode({ event, isBackward });
        if (!destinationNode) return;
        if (isTabEvent(event)) {
          event.preventDefault();
        }
        this.tryFocus(destinationNode);
      }
    });
    __publicField4(this, "handleEscapeKey", (event) => {
      if (isEscapeEvent(event) && valueOrHandler(this.config.escapeDeactivates, event) !== false) {
        event.preventDefault();
        this.deactivate();
      }
    });
    __publicField4(this, "_mutationObserver");
    __publicField4(this, "setupMutationObserver", () => {
      const win = this.doc.defaultView || window;
      this._mutationObserver = new win.MutationObserver((mutations) => {
        const isFocusedNodeRemoved = mutations.some((mutation) => {
          const removedNodes = Array.from(mutation.removedNodes);
          return removedNodes.some((node2) => node2 === this.state.mostRecentlyFocusedNode);
        });
        if (isFocusedNodeRemoved) {
          this.tryFocus(this.getInitialFocusNode());
        }
      });
    });
    __publicField4(this, "updateObservedNodes", () => {
      var _a8;
      (_a8 = this._mutationObserver) == null ? void 0 : _a8.disconnect();
      if (this.state.active && !this.state.paused) {
        this.state.containers.map((container) => {
          var _a9;
          (_a9 = this._mutationObserver) == null ? void 0 : _a9.observe(container, { subtree: true, childList: true });
        });
      }
    });
    __publicField4(this, "getInitialFocusNode", () => {
      let node2 = this.getNodeForOption("initialFocus", { hasFallback: true });
      if (node2 === false) {
        return false;
      }
      if (node2 === void 0 || node2 && !isFocusable(node2)) {
        if (this.findContainerIndex(this.doc.activeElement) >= 0) {
          node2 = this.doc.activeElement;
        } else {
          const firstTabbableGroup = this.state.tabbableGroups[0];
          const firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
          node2 = firstTabbableNode || this.getNodeForOption("fallbackFocus");
        }
      } else if (node2 === null) {
        node2 = this.getNodeForOption("fallbackFocus");
      }
      if (!node2) {
        throw new Error("Your focus-trap needs to have at least one focusable element");
      }
      if (!node2.isConnected) {
        node2 = this.getNodeForOption("fallbackFocus");
      }
      return node2;
    });
    __publicField4(this, "tryFocus", (node2) => {
      if (node2 === false) return;
      if (node2 === getActiveElement(this.doc)) return;
      if (!node2 || !node2.focus) {
        this.tryFocus(this.getInitialFocusNode());
        return;
      }
      node2.focus({ preventScroll: !!this.config.preventScroll });
      this.state.mostRecentlyFocusedNode = node2;
      if (isSelectableInput(node2)) {
        node2.select();
      }
    });
    __publicField4(this, "deactivate", (deactivateOptions) => {
      if (!this.state.active) return this;
      const options2 = {
        onDeactivate: this.config.onDeactivate,
        onPostDeactivate: this.config.onPostDeactivate,
        checkCanReturnFocus: this.config.checkCanReturnFocus,
        ...deactivateOptions
      };
      clearTimeout(this.state.delayInitialFocusTimer);
      this.state.delayInitialFocusTimer = void 0;
      this.removeListeners();
      this.state.active = false;
      this.state.paused = false;
      this.updateObservedNodes();
      activeFocusTraps.deactivateTrap(this.trapStack, this);
      const onDeactivate = this.getOption(options2, "onDeactivate");
      const onPostDeactivate = this.getOption(options2, "onPostDeactivate");
      const checkCanReturnFocus = this.getOption(options2, "checkCanReturnFocus");
      const returnFocus = this.getOption(options2, "returnFocus", "returnFocusOnDeactivate");
      onDeactivate == null ? void 0 : onDeactivate();
      const finishDeactivation = () => {
        delay(() => {
          if (returnFocus) {
            const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);
            this.tryFocus(returnFocusNode);
          }
          onPostDeactivate == null ? void 0 : onPostDeactivate();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);
        checkCanReturnFocus(returnFocusNode).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    });
    __publicField4(this, "pause", (pauseOptions) => {
      if (this.state.paused || !this.state.active) {
        return this;
      }
      const onPause = this.getOption(pauseOptions, "onPause");
      const onPostPause = this.getOption(pauseOptions, "onPostPause");
      this.state.paused = true;
      onPause == null ? void 0 : onPause();
      this.removeListeners();
      this.updateObservedNodes();
      onPostPause == null ? void 0 : onPostPause();
      return this;
    });
    __publicField4(this, "unpause", (unpauseOptions) => {
      if (!this.state.paused || !this.state.active) {
        return this;
      }
      const onUnpause = this.getOption(unpauseOptions, "onUnpause");
      const onPostUnpause = this.getOption(unpauseOptions, "onPostUnpause");
      this.state.paused = false;
      onUnpause == null ? void 0 : onUnpause();
      this.updateTabbableNodes();
      this.addListeners();
      this.updateObservedNodes();
      onPostUnpause == null ? void 0 : onPostUnpause();
      return this;
    });
    __publicField4(this, "updateContainerElements", (containerElements) => {
      this.state.containers = Array.isArray(containerElements) ? containerElements.filter(Boolean) : [containerElements].filter(Boolean);
      if (this.state.active) {
        this.updateTabbableNodes();
      }
      this.updateObservedNodes();
      return this;
    });
    __publicField4(this, "getReturnFocusNode", (previousActiveElement) => {
      const node2 = this.getNodeForOption("setReturnFocus", {
        params: [previousActiveElement]
      });
      return node2 ? node2 : node2 === false ? false : previousActiveElement;
    });
    __publicField4(this, "getOption", (configOverrideOptions, optionName, configOptionName) => {
      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : (
        // @ts-expect-error
        this.config[configOptionName || optionName]
      );
    });
    __publicField4(this, "getNodeForOption", (optionName, { hasFallback = false, params = [] } = {}) => {
      let optionValue = this.config[optionName];
      if (typeof optionValue === "function") optionValue = optionValue(...params);
      if (optionValue === true) optionValue = void 0;
      if (!optionValue) {
        if (optionValue === void 0 || optionValue === false) {
          return optionValue;
        }
        throw new Error(`\`${optionName}\` was specified but was not a node, or did not return a node`);
      }
      let node2 = optionValue;
      if (typeof optionValue === "string") {
        try {
          node2 = this.doc.querySelector(optionValue);
        } catch (err) {
          throw new Error(`\`${optionName}\` appears to be an invalid selector; error="${err.message}"`);
        }
        if (!node2) {
          if (!hasFallback) {
            throw new Error(`\`${optionName}\` as selector refers to no known node`);
          }
        }
      }
      return node2;
    });
    __publicField4(this, "findNextNavNode", (opts) => {
      const { event, isBackward = false } = opts;
      const target = opts.target || getEventTarget(event);
      this.updateTabbableNodes();
      let destinationNode = null;
      if (this.state.tabbableGroups.length > 0) {
        const containerIndex = this.findContainerIndex(target, event);
        const containerGroup = containerIndex >= 0 ? this.state.containerGroups[containerIndex] : void 0;
        if (containerIndex < 0) {
          if (isBackward) {
            destinationNode = this.state.tabbableGroups[this.state.tabbableGroups.length - 1].lastTabbableNode;
          } else {
            destinationNode = this.state.tabbableGroups[0].firstTabbableNode;
          }
        } else if (isBackward) {
          let startOfGroupIndex = this.state.tabbableGroups.findIndex(
            ({ firstTabbableNode }) => target === firstTabbableNode
          );
          if (startOfGroupIndex < 0 && ((containerGroup == null ? void 0 : containerGroup.container) === target || isFocusable(target) && !isTabbable(target) && !(containerGroup == null ? void 0 : containerGroup.nextTabbableNode(target, false)))) {
            startOfGroupIndex = containerIndex;
          }
          if (startOfGroupIndex >= 0) {
            const destinationGroupIndex = startOfGroupIndex === 0 ? this.state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
          } else if (!isTabEvent(event)) {
            destinationNode = containerGroup == null ? void 0 : containerGroup.nextTabbableNode(target, false);
          }
        } else {
          let lastOfGroupIndex = this.state.tabbableGroups.findIndex(
            ({ lastTabbableNode }) => target === lastTabbableNode
          );
          if (lastOfGroupIndex < 0 && ((containerGroup == null ? void 0 : containerGroup.container) === target || isFocusable(target) && !isTabbable(target) && !(containerGroup == null ? void 0 : containerGroup.nextTabbableNode(target)))) {
            lastOfGroupIndex = containerIndex;
          }
          if (lastOfGroupIndex >= 0) {
            const destinationGroupIndex = lastOfGroupIndex === this.state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.firstTabbableNode : destinationGroup.firstDomTabbableNode;
          } else if (!isTabEvent(event)) {
            destinationNode = containerGroup == null ? void 0 : containerGroup.nextTabbableNode(target);
          }
        }
      } else {
        destinationNode = this.getNodeForOption("fallbackFocus");
      }
      return destinationNode;
    });
    this.trapStack = options.trapStack || sharedTrapStack;
    const config = {
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true,
      isKeyForward(e) {
        return isTabEvent(e) && !e.shiftKey;
      },
      isKeyBackward(e) {
        return isTabEvent(e) && e.shiftKey;
      },
      ...options
    };
    this.doc = config.document || getDocument(Array.isArray(elements) ? elements[0] : elements);
    this.config = config;
    this.updateContainerElements(elements);
    this.setupMutationObserver();
  }
  get active() {
    return this.state.active;
  }
  get paused() {
    return this.state.paused;
  }
  findContainerIndex(element, event) {
    const composedPath = typeof (event == null ? void 0 : event.composedPath) === "function" ? event.composedPath() : void 0;
    return this.state.containerGroups.findIndex(
      ({ container, tabbableNodes }) => container.contains(element) || (composedPath == null ? void 0 : composedPath.includes(container)) || tabbableNodes.find((node2) => node2 === element)
    );
  }
  updateTabbableNodes() {
    this.state.containerGroups = this.state.containers.map((container) => {
      const tabbableNodes = getTabbables(container);
      const focusableNodes = getFocusables(container);
      const firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
      const lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
      const firstDomTabbableNode = focusableNodes.find((node2) => isTabbable(node2));
      const lastDomTabbableNode = focusableNodes.slice().reverse().find((node2) => isTabbable(node2));
      const posTabIndexesFound = !!tabbableNodes.find((node2) => getTabIndex(node2) > 0);
      function nextTabbableNode(node2, forward = true) {
        const nodeIdx = tabbableNodes.indexOf(node2);
        if (nodeIdx < 0) {
          if (forward) {
            return focusableNodes.slice(focusableNodes.indexOf(node2) + 1).find((el) => isTabbable(el));
          }
          return focusableNodes.slice(0, focusableNodes.indexOf(node2)).reverse().find((el) => isTabbable(el));
        }
        return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
      }
      return {
        container,
        tabbableNodes,
        focusableNodes,
        posTabIndexesFound,
        firstTabbableNode,
        lastTabbableNode,
        firstDomTabbableNode,
        lastDomTabbableNode,
        nextTabbableNode
      };
    });
    this.state.tabbableGroups = this.state.containerGroups.filter((group2) => group2.tabbableNodes.length > 0);
    if (this.state.tabbableGroups.length <= 0 && !this.getNodeForOption("fallbackFocus")) {
      throw new Error(
        "Your focus-trap must have at least one container with at least one tabbable node in it at all times"
      );
    }
    if (this.state.containerGroups.find((g) => g.posTabIndexesFound) && this.state.containerGroups.length > 1) {
      throw new Error(
        "At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps."
      );
    }
  }
  addListeners() {
    if (!this.state.active) return;
    activeFocusTraps.activateTrap(this.trapStack, this);
    this.state.delayInitialFocusTimer = this.config.delayInitialFocus ? delay(() => {
      this.tryFocus(this.getInitialFocusNode());
    }) : this.tryFocus(this.getInitialFocusNode());
    this.listenerCleanups.push(
      addDomEvent(this.doc, "focusin", this.handleFocus, true),
      addDomEvent(this.doc, "mousedown", this.handlePointerDown, { capture: true, passive: false }),
      addDomEvent(this.doc, "touchstart", this.handlePointerDown, { capture: true, passive: false }),
      addDomEvent(this.doc, "click", this.handleClick, { capture: true, passive: false }),
      addDomEvent(this.doc, "keydown", this.handleTabKey, { capture: true, passive: false }),
      addDomEvent(this.doc, "keydown", this.handleEscapeKey)
    );
    return this;
  }
  removeListeners() {
    if (!this.state.active) return;
    this.listenerCleanups.forEach((cleanup) => cleanup());
    this.listenerCleanups = [];
    return this;
  }
  activate(activateOptions) {
    if (this.state.active) {
      return this;
    }
    const onActivate = this.getOption(activateOptions, "onActivate");
    const onPostActivate = this.getOption(activateOptions, "onPostActivate");
    const checkCanFocusTrap = this.getOption(activateOptions, "checkCanFocusTrap");
    if (!checkCanFocusTrap) {
      this.updateTabbableNodes();
    }
    this.state.active = true;
    this.state.paused = false;
    this.state.nodeFocusedBeforeActivation = this.doc.activeElement || null;
    onActivate == null ? void 0 : onActivate();
    const finishActivation = () => {
      if (checkCanFocusTrap) {
        this.updateTabbableNodes();
      }
      this.addListeners();
      this.updateObservedNodes();
      onPostActivate == null ? void 0 : onPostActivate();
    };
    if (checkCanFocusTrap) {
      checkCanFocusTrap(this.state.containers.concat()).then(finishActivation, finishActivation);
      return this;
    }
    finishActivation();
    return this;
  }
};
var isTabEvent = (event) => event.key === "Tab";
var valueOrHandler = (value, ...params) => typeof value === "function" ? value(...params) : value;
var isEscapeEvent = (event) => !event.isComposing && event.key === "Escape";
var delay = (fn) => setTimeout(fn, 0);
var isSelectableInput = (node2) => node2.localName === "input" && "select" in node2 && typeof node2.select === "function";
function trapFocus(el, options = {}) {
  let trap;
  const cleanup = raf(() => {
    const contentEl = typeof el === "function" ? el() : el;
    if (!contentEl) return;
    trap = new FocusTrap(contentEl, {
      escapeDeactivates: false,
      allowOutsideClick: true,
      preventScroll: true,
      returnFocusOnDeactivate: true,
      delayInitialFocus: false,
      fallbackFocus: contentEl,
      ...options,
      document: getDocument(contentEl)
    });
    try {
      trap.activate();
    } catch {
    }
  });
  return function destroy() {
    trap == null ? void 0 : trap.deactivate();
    cleanup();
  };
}

// node_modules/@zag-js/remove-scroll/dist/index.mjs
var LOCK_CLASSNAME = "data-scroll-lock";
function assignStyle(el, style) {
  if (!el) return;
  const previousStyle = Object.keys(style).reduce(
    (acc, key) => {
      acc[key] = el.style.getPropertyValue(key);
      return acc;
    },
    {}
  );
  Object.assign(el.style, style);
  return () => {
    Object.assign(el.style, previousStyle);
  };
}
function setCSSProperty(el, property, value) {
  if (!el) return;
  const previousValue = el.style.getPropertyValue(property);
  el.style.setProperty(property, value);
  return () => {
    if (previousValue) {
      el.style.setProperty(property, previousValue);
    } else {
      el.style.removeProperty(property);
    }
  };
}
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
function preventBodyScroll(_document) {
  const doc = _document ?? document;
  const win = doc.defaultView ?? window;
  const { documentElement, body } = doc;
  const locked = body.hasAttribute(LOCK_CLASSNAME);
  if (locked) return;
  body.setAttribute(LOCK_CLASSNAME, "");
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  const setScrollbarWidthProperty = () => setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
  const paddingProperty = getPaddingProperty(documentElement);
  const setStyle2 = () => assignStyle(body, {
    overflow: "hidden",
    [paddingProperty]: `${scrollbarWidth}px`
  });
  const setIOSStyle = () => {
    const { scrollX, scrollY, visualViewport: visualViewport2 } = win;
    const offsetLeft = (visualViewport2 == null ? void 0 : visualViewport2.offsetLeft) ?? 0;
    const offsetTop = (visualViewport2 == null ? void 0 : visualViewport2.offsetTop) ?? 0;
    const restoreStyle = assignStyle(body, {
      position: "fixed",
      overflow: "hidden",
      top: `${-(scrollY - Math.floor(offsetTop))}px`,
      left: `${-(scrollX - Math.floor(offsetLeft))}px`,
      right: "0",
      [paddingProperty]: `${scrollbarWidth}px`
    });
    return () => {
      restoreStyle == null ? void 0 : restoreStyle();
      win.scrollTo({ left: scrollX, top: scrollY, behavior: "instant" });
    };
  };
  const cleanups2 = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle2()];
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
    body.removeAttribute(LOCK_CLASSNAME);
  };
}

// node_modules/@zag-js/dialog/dist/index.mjs
var anatomy10 = createAnatomy("dialog").parts(
  "trigger",
  "backdrop",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts10 = anatomy10.build();
var dom10 = createScope({
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `dialog:${ctx.id}:positioner`;
  },
  getBackdropId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.backdrop) ?? `dialog:${ctx.id}:backdrop`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `dialog:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `dialog:${ctx.id}:trigger`;
  },
  getTitleId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.title) ?? `dialog:${ctx.id}:title`;
  },
  getDescriptionId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.description) ?? `dialog:${ctx.id}:description`;
  },
  getCloseTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.closeTrigger) ?? `dialog:${ctx.id}:close`;
  },
  getContentEl: (ctx) => dom10.getById(ctx, dom10.getContentId(ctx)),
  getPositionerEl: (ctx) => dom10.getById(ctx, dom10.getPositionerId(ctx)),
  getBackdropEl: (ctx) => dom10.getById(ctx, dom10.getBackdropId(ctx)),
  getTriggerEl: (ctx) => dom10.getById(ctx, dom10.getTriggerId(ctx)),
  getTitleEl: (ctx) => dom10.getById(ctx, dom10.getTitleId(ctx)),
  getDescriptionEl: (ctx) => dom10.getById(ctx, dom10.getDescriptionId(ctx)),
  getCloseTriggerEl: (ctx) => dom10.getById(ctx, dom10.getCloseTriggerId(ctx))
});
function connect11(state2, send, normalize3) {
  const ariaLabel = state2.context["aria-label"];
  const open = state2.matches("open");
  const rendered = state2.context.renderedElements;
  return {
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    getTriggerProps() {
      return normalize3.button({
        ...parts10.trigger.attrs,
        dir: state2.context.dir,
        id: dom10.getTriggerId(state2.context),
        "aria-haspopup": "dialog",
        type: "button",
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": dom10.getContentId(state2.context),
        onClick(event) {
          if (event.defaultPrevented) return;
          send("TOGGLE");
        }
      });
    },
    getBackdropProps() {
      return normalize3.element({
        ...parts10.backdrop.attrs,
        dir: state2.context.dir,
        hidden: !open,
        id: dom10.getBackdropId(state2.context),
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize3.element({
        ...parts10.positioner.attrs,
        dir: state2.context.dir,
        id: dom10.getPositionerId(state2.context),
        style: {
          pointerEvents: open ? void 0 : "none"
        }
      });
    },
    getContentProps() {
      return normalize3.element({
        ...parts10.content.attrs,
        dir: state2.context.dir,
        role: state2.context.role,
        hidden: !open,
        id: dom10.getContentId(state2.context),
        tabIndex: -1,
        "data-state": open ? "open" : "closed",
        "aria-modal": true,
        "aria-label": ariaLabel || void 0,
        "aria-labelledby": ariaLabel || !rendered.title ? void 0 : dom10.getTitleId(state2.context),
        "aria-describedby": rendered.description ? dom10.getDescriptionId(state2.context) : void 0
      });
    },
    getTitleProps() {
      return normalize3.element({
        ...parts10.title.attrs,
        dir: state2.context.dir,
        id: dom10.getTitleId(state2.context)
      });
    },
    getDescriptionProps() {
      return normalize3.element({
        ...parts10.description.attrs,
        dir: state2.context.dir,
        id: dom10.getDescriptionId(state2.context)
      });
    },
    getCloseTriggerProps() {
      return normalize3.button({
        ...parts10.closeTrigger.attrs,
        dir: state2.context.dir,
        id: dom10.getCloseTriggerId(state2.context),
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          event.stopPropagation();
          send("CLOSE");
        }
      });
    }
  };
}
function machine11(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "dialog",
      initial: ctx.open ? "open" : "closed",
      context: {
        role: "dialog",
        renderedElements: {
          title: true,
          description: true
        },
        modal: true,
        trapFocus: true,
        preventScroll: true,
        closeOnInteractOutside: true,
        closeOnEscape: true,
        restoreFocus: true,
        ...ctx
      },
      created: ["setAlertDialogProps"],
      watch: {
        open: ["toggleVisibility"]
      },
      states: {
        open: {
          entry: ["checkRenderedElements", "syncZIndex"],
          activities: ["trackDismissableElement", "trapFocus", "preventScroll", "hideContentBelow"],
          on: {
            "CONTROLLED.CLOSE": {
              target: "closed"
            },
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          }
        },
        closed: {
          on: {
            "CONTROLLED.OPEN": {
              target: "open"
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom10.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            defer: true,
            pointerBlocking: ctx2.modal,
            exclude: [dom10.getTriggerEl(ctx2)],
            onInteractOutside(event) {
              var _a8;
              (_a8 = ctx2.onInteractOutside) == null ? void 0 : _a8.call(ctx2, event);
              if (!ctx2.closeOnInteractOutside) {
                event.preventDefault();
              }
            },
            persistentElements: ctx2.persistentElements,
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onEscapeKeyDown(event) {
              var _a8;
              (_a8 = ctx2.onEscapeKeyDown) == null ? void 0 : _a8.call(ctx2, event);
              if (!ctx2.closeOnEscape) {
                event.preventDefault();
              }
            },
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside" });
            }
          });
        },
        preventScroll(ctx2) {
          if (!ctx2.preventScroll) return;
          return preventBodyScroll(dom10.getDoc(ctx2));
        },
        trapFocus(ctx2) {
          if (!ctx2.trapFocus || !ctx2.modal) return;
          const contentEl = () => dom10.getContentEl(ctx2);
          return trapFocus(contentEl, {
            preventScroll: true,
            returnFocusOnDeactivate: !!ctx2.restoreFocus,
            initialFocus: ctx2.initialFocusEl,
            setReturnFocus: (el) => {
              var _a8;
              return ((_a8 = ctx2.finalFocusEl) == null ? void 0 : _a8.call(ctx2)) ?? el;
            }
          });
        },
        hideContentBelow(ctx2) {
          if (!ctx2.modal) return;
          const getElements = () => [dom10.getContentEl(ctx2)];
          return ariaHidden(getElements, { defer: true });
        }
      },
      actions: {
        setAlertDialogProps(ctx2) {
          if (ctx2.role !== "alertdialog") return;
          ctx2.initialFocusEl || (ctx2.initialFocusEl = () => dom10.getCloseTriggerEl(ctx2));
          ctx2.closeOnInteractOutside = false;
        },
        checkRenderedElements(ctx2) {
          raf(() => {
            ctx2.renderedElements.title = !!dom10.getTitleEl(ctx2);
            ctx2.renderedElements.description = !!dom10.getDescriptionEl(ctx2);
          });
        },
        syncZIndex(ctx2) {
          raf(() => {
            const contentEl = dom10.getContentEl(ctx2);
            if (!contentEl) return;
            const styles = getComputedStyle2(contentEl);
            const elems = [dom10.getPositionerEl(ctx2), dom10.getBackdropEl(ctx2)];
            elems.forEach((node2) => {
              node2 == null ? void 0 : node2.style.setProperty("--z-index", styles.zIndex);
            });
          });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      }
    }
  );
}
var props9 = createProps()([
  "aria-label",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "finalFocusEl",
  "getRootNode",
  "getRootNode",
  "id",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "open.controlled",
  "open",
  "persistentElements",
  "preventScroll",
  "restoreFocus",
  "role",
  "trapFocus"
]);
var splitProps9 = createSplitProps(props9);

// node_modules/@ark-ui/react/dist/components/dialog/use-dialog.js
var import_react266 = __toESM(require_react(), 1);
var useDialog = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react266.useId)(),
    getRootNode,
    dir,
    open: props34.defaultOpen,
    "open.controlled": props34.open !== void 0,
    ...props34
  };
  const context = {
    ...initialContext,
    open: props34.open,
    onOpenChange: useEvent(props34.onOpenChange, { sync: true }),
    onEscapeKeyDown: useEvent(props34.onEscapeKeyDown),
    onInteractOutside: useEvent(props34.onInteractOutside)
  };
  const [state2, send] = useMachine(machine11(initialContext), { context });
  return connect11(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/dialog/dialog-root.js
var DialogRoot = (props34) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props34);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const dialog = useDialog(localProps);
  const presence = usePresence(mergeProps2({ present: dialog.open }, presenceProps));
  return (0, import_jsx_runtime124.jsx)(DialogProvider, { value: dialog, children: (0, import_jsx_runtime124.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime124.jsx)(PresenceProvider, { value: presence, children }) }) });
};

// node_modules/@ark-ui/react/dist/components/dialog/dialog-root-provider.js
var import_jsx_runtime125 = __toESM(require_jsx_runtime(), 1);
var DialogRootProvider = (props34) => {
  const [presenceProps, { value: dialog, children }] = splitPresenceProps(props34);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const presence = usePresence(mergeProps2({ present: dialog.open }, presenceProps));
  return (0, import_jsx_runtime125.jsx)(DialogProvider, { value: dialog, children: (0, import_jsx_runtime125.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime125.jsx)(PresenceProvider, { value: presence, children }) }) });
};

// node_modules/@ark-ui/react/dist/components/dialog/dialog-title.js
var import_jsx_runtime126 = __toESM(require_jsx_runtime(), 1);
var import_react270 = __toESM(require_react(), 1);
var DialogTitle = (0, import_react270.forwardRef)((props34, ref2) => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps2(dialog.getTitleProps(), props34);
  return (0, import_jsx_runtime126.jsx)(ark.h2, { ...mergedProps, ref: ref2 });
});
DialogTitle.displayName = "DialogTitle";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-trigger.js
var import_jsx_runtime127 = __toESM(require_jsx_runtime(), 1);
var import_react272 = __toESM(require_react(), 1);
var DialogTrigger = (0, import_react272.forwardRef)((props34, ref2) => {
  const dialog = useDialogContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(
    {
      ...dialog.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : dialog.getTriggerProps()["aria-controls"]
    },
    props34
  );
  return (0, import_jsx_runtime127.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
DialogTrigger.displayName = "DialogTrigger";

// node_modules/@ark-ui/react/dist/components/dialog/dialog.js
var dialog_exports = {};
__export(dialog_exports, {
  Backdrop: () => DialogBackdrop,
  CloseTrigger: () => DialogCloseTrigger,
  Content: () => DialogContent,
  Context: () => DialogContext,
  Description: () => DialogDescription,
  Positioner: () => DialogPositioner,
  Root: () => DialogRoot,
  RootProvider: () => DialogRootProvider,
  Title: () => DialogTitle,
  Trigger: () => DialogTrigger
});

// node_modules/@ark-ui/react/dist/components/editable/editable-area.js
var import_jsx_runtime128 = __toESM(require_jsx_runtime(), 1);
var import_react274 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/editable/use-editable-context.js
var [EditableProvider, useEditableContext] = createContext3({
  name: "EditableContext",
  hookName: "useEditableContext",
  providerName: "<EditableProvider />"
});

// node_modules/@ark-ui/react/dist/components/editable/editable-area.js
var EditableArea = (0, import_react274.forwardRef)((props34, ref2) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps2(editable.getAreaProps(), props34);
  return (0, import_jsx_runtime128.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
EditableArea.displayName = "EditableArea";

// node_modules/@ark-ui/react/dist/components/editable/editable-cancel-trigger.js
var import_jsx_runtime129 = __toESM(require_jsx_runtime(), 1);
var import_react276 = __toESM(require_react(), 1);
var EditableCancelTrigger = (0, import_react276.forwardRef)(
  (props34, ref2) => {
    const editable = useEditableContext();
    const mergedProps = mergeProps2(editable.getCancelTriggerProps(), props34);
    return (0, import_jsx_runtime129.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
EditableCancelTrigger.displayName = "EditableCancelTrigger";

// node_modules/@ark-ui/react/dist/components/editable/editable-context.js
var EditableContext = (props34) => props34.children(useEditableContext());

// node_modules/@ark-ui/react/dist/components/editable/editable-control.js
var import_jsx_runtime130 = __toESM(require_jsx_runtime(), 1);
var import_react278 = __toESM(require_react(), 1);
var EditableControl = (0, import_react278.forwardRef)((props34, ref2) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps2(editable.getControlProps(), props34);
  return (0, import_jsx_runtime130.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
EditableControl.displayName = "EditableControl";

// node_modules/@ark-ui/react/dist/components/editable/editable-edit-trigger.js
var import_jsx_runtime131 = __toESM(require_jsx_runtime(), 1);
var import_react280 = __toESM(require_react(), 1);
var EditableEditTrigger = (0, import_react280.forwardRef)(
  (props34, ref2) => {
    const editable = useEditableContext();
    const mergedProps = mergeProps2(editable.getEditTriggerProps(), props34);
    return (0, import_jsx_runtime131.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
EditableEditTrigger.displayName = "EditableEditTrigger";

// node_modules/@ark-ui/react/dist/components/editable/editable-input.js
var import_jsx_runtime132 = __toESM(require_jsx_runtime(), 1);
var import_react282 = __toESM(require_react(), 1);
var EditableInput = (0, import_react282.forwardRef)((props34, ref2) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps2(editable.getInputProps(), props34);
  const field = useFieldContext();
  return (0, import_jsx_runtime132.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
});
EditableInput.displayName = "EditableInput";

// node_modules/@ark-ui/react/dist/components/editable/editable-label.js
var import_jsx_runtime133 = __toESM(require_jsx_runtime(), 1);
var import_react284 = __toESM(require_react(), 1);
var EditableLabel = (0, import_react284.forwardRef)((props34, ref2) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps2(editable.getLabelProps(), props34);
  return (0, import_jsx_runtime133.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
EditableLabel.displayName = "EditableLabel";

// node_modules/@ark-ui/react/dist/components/editable/editable-preview.js
var import_jsx_runtime134 = __toESM(require_jsx_runtime(), 1);
var import_react286 = __toESM(require_react(), 1);
var EditablePreview = (0, import_react286.forwardRef)((props34, ref2) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps2(editable.getPreviewProps(), props34);
  return (0, import_jsx_runtime134.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
EditablePreview.displayName = "EditablePreview";

// node_modules/@ark-ui/react/dist/components/editable/editable-root.js
var import_jsx_runtime135 = __toESM(require_jsx_runtime(), 1);
var import_react290 = __toESM(require_react(), 1);

// node_modules/@zag-js/editable/dist/index.mjs
var anatomy11 = createAnatomy("editable").parts(
  "root",
  "area",
  "label",
  "preview",
  "input",
  "editTrigger",
  "submitTrigger",
  "cancelTrigger",
  "control"
);
var parts11 = anatomy11.build();
var dom11 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `editable:${ctx.id}`;
  },
  getAreaId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.area) ?? `editable:${ctx.id}:area`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `editable:${ctx.id}:label`;
  },
  getPreviewId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.preview) ?? `editable:${ctx.id}:preview`;
  },
  getInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.input) ?? `editable:${ctx.id}:input`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `editable:${ctx.id}:control`;
  },
  getSubmitTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.submitTrigger) ?? `editable:${ctx.id}:submit`;
  },
  getCancelTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.cancelTrigger) ?? `editable:${ctx.id}:cancel`;
  },
  getEditTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.editTrigger) ?? `editable:${ctx.id}:edit`;
  },
  getInputEl: (ctx) => dom11.getById(ctx, dom11.getInputId(ctx)),
  getPreviewEl: (ctx) => dom11.getById(ctx, dom11.getPreviewId(ctx)),
  getSubmitTriggerEl: (ctx) => dom11.getById(ctx, dom11.getSubmitTriggerId(ctx)),
  getCancelTriggerEl: (ctx) => dom11.getById(ctx, dom11.getCancelTriggerId(ctx)),
  getEditTriggerEl: (ctx) => dom11.getById(ctx, dom11.getEditTriggerId(ctx))
});
function connect12(state2, send, normalize3) {
  const disabled = state2.context.disabled;
  const interactive = state2.context.isInteractive;
  const readOnly = state2.context.readOnly;
  const invalid = state2.context.invalid;
  const autoResize = state2.context.autoResize;
  const translations = state2.context.translations;
  const editing = state2.matches("edit");
  const placeholderProp = state2.context.placeholder;
  const placeholder = typeof placeholderProp === "string" ? { edit: placeholderProp, preview: placeholderProp } : placeholderProp;
  const value = state2.context.value;
  const empty2 = value.trim() === "";
  const valueText = empty2 ? (placeholder == null ? void 0 : placeholder.preview) ?? "" : value;
  return {
    editing,
    empty: empty2,
    value,
    valueText,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2, src: "setValue" });
    },
    clearValue() {
      send({ type: "VALUE.SET", value: "", src: "clearValue" });
    },
    edit() {
      if (!interactive) return;
      send("EDIT");
    },
    cancel() {
      if (!interactive) return;
      send("CANCEL");
    },
    submit() {
      if (!interactive) return;
      send("SUBMIT");
    },
    getRootProps() {
      return normalize3.element({
        ...parts11.root.attrs,
        id: dom11.getRootId(state2.context),
        dir: state2.context.dir
      });
    },
    getAreaProps() {
      return normalize3.element({
        ...parts11.area.attrs,
        id: dom11.getAreaId(state2.context),
        dir: state2.context.dir,
        style: autoResize ? { display: "inline-grid" } : void 0,
        "data-focus": dataAttr(editing),
        "data-disabled": dataAttr(disabled),
        "data-placeholder-shown": dataAttr(empty2)
      });
    },
    getLabelProps() {
      return normalize3.label({
        ...parts11.label.attrs,
        id: dom11.getLabelId(state2.context),
        dir: state2.context.dir,
        htmlFor: dom11.getInputId(state2.context),
        "data-focus": dataAttr(editing),
        "data-invalid": dataAttr(invalid),
        onClick() {
          if (editing) return;
          const previewEl = dom11.getPreviewEl(state2.context);
          previewEl == null ? void 0 : previewEl.focus({ preventScroll: true });
        }
      });
    },
    getInputProps() {
      return normalize3.input({
        ...parts11.input.attrs,
        dir: state2.context.dir,
        "aria-label": translations.input,
        name: state2.context.name,
        form: state2.context.form,
        id: dom11.getInputId(state2.context),
        hidden: autoResize ? void 0 : !editing,
        placeholder: placeholder == null ? void 0 : placeholder.edit,
        maxLength: state2.context.maxLength,
        required: state2.context.required,
        disabled,
        "data-disabled": dataAttr(disabled),
        readOnly,
        "data-readonly": dataAttr(readOnly),
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        "data-autoresize": dataAttr(autoResize),
        defaultValue: value,
        size: autoResize ? 1 : void 0,
        onChange(event) {
          send({ type: "VALUE.SET", src: "input.change", value: event.currentTarget.value });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          const keyMap2 = {
            Escape() {
              send("CANCEL");
              event.preventDefault();
            },
            Enter(event2) {
              if (!state2.context.submitOnEnter) return;
              const { localName } = event2.currentTarget;
              if (localName === "textarea") {
                const submitMod = isApple() ? event2.metaKey : event2.ctrlKey;
                if (!submitMod) return;
                send({ type: "SUBMIT", src: "keydown.enter" });
                return;
              }
              if (localName === "input" && !event2.shiftKey && !event2.metaKey) {
                send({ type: "SUBMIT", src: "keydown.enter" });
                event2.preventDefault();
              }
            }
          };
          const exec2 = keyMap2[event.key];
          if (exec2) {
            exec2(event);
          }
        },
        style: autoResize ? {
          gridArea: "1 / 1 / auto / auto",
          visibility: !editing ? "hidden" : void 0
        } : void 0
      });
    },
    getPreviewProps() {
      return normalize3.element({
        id: dom11.getPreviewId(state2.context),
        ...parts11.preview.attrs,
        dir: state2.context.dir,
        "data-placeholder-shown": dataAttr(empty2),
        "aria-readonly": ariaAttr(readOnly),
        "data-readonly": dataAttr(disabled),
        "data-disabled": dataAttr(disabled),
        "aria-disabled": ariaAttr(disabled),
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        "aria-label": translations.edit,
        "data-autoresize": dataAttr(autoResize),
        children: valueText,
        hidden: autoResize ? void 0 : editing,
        tabIndex: interactive ? 0 : void 0,
        onClick() {
          if (!interactive) return;
          if (state2.context.activationMode !== "click") return;
          send({ type: "EDIT", src: "click" });
        },
        onFocus() {
          if (!interactive) return;
          if (state2.context.activationMode !== "focus") return;
          send({ type: "EDIT", src: "focus" });
        },
        onDoubleClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          if (state2.context.activationMode !== "dblclick") return;
          send({ type: "EDIT", src: "dblclick" });
        },
        style: autoResize ? {
          whiteSpace: "pre",
          userSelect: "none",
          gridArea: "1 / 1 / auto / auto",
          visibility: editing ? "hidden" : void 0,
          // in event the preview overflow's the parent element
          overflow: "hidden",
          textOverflow: "ellipsis"
        } : void 0
      });
    },
    getEditTriggerProps() {
      return normalize3.button({
        ...parts11.editTrigger.attrs,
        id: dom11.getEditTriggerId(state2.context),
        dir: state2.context.dir,
        "aria-label": translations.edit,
        hidden: editing,
        type: "button",
        disabled,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "EDIT", src: "edit.click" });
        }
      });
    },
    getControlProps() {
      return normalize3.element({
        id: dom11.getControlId(state2.context),
        ...parts11.control.attrs,
        dir: state2.context.dir
      });
    },
    getSubmitTriggerProps() {
      return normalize3.button({
        ...parts11.submitTrigger.attrs,
        dir: state2.context.dir,
        id: dom11.getSubmitTriggerId(state2.context),
        "aria-label": translations.submit,
        hidden: !editing,
        disabled,
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "SUBMIT", src: "submit.click" });
        }
      });
    },
    getCancelTriggerProps() {
      return normalize3.button({
        ...parts11.cancelTrigger.attrs,
        dir: state2.context.dir,
        "aria-label": translations.cancel,
        id: dom11.getCancelTriggerId(state2.context),
        hidden: !editing,
        type: "button",
        disabled,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "CANCEL", src: "cancel.click" });
        }
      });
    }
  };
}
var submitOnEnter = (ctx) => ["both", "enter"].includes(ctx.submitMode);
var submitOnBlur = (ctx) => ["both", "blur"].includes(ctx.submitMode);
function machine12(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "editable",
      initial: ctx.edit ? "edit" : "preview",
      entry: ctx.edit ? ["focusInput"] : void 0,
      context: {
        activationMode: "focus",
        submitMode: "both",
        value: "",
        previousValue: "",
        selectOnFocus: true,
        disabled: false,
        readOnly: false,
        ...ctx,
        translations: {
          input: "editable input",
          edit: "edit",
          submit: "submit",
          cancel: "cancel",
          ...ctx.translations
        }
      },
      watch: {
        value: ["syncInputValue"],
        edit: ["toggleEditing"]
      },
      computed: {
        submitOnEnter,
        submitOnBlur,
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly)
      },
      on: {
        "VALUE.SET": {
          actions: "setValue"
        }
      },
      states: {
        preview: {
          // https://bugzilla.mozilla.org/show_bug.cgi?id=559561
          entry: ["blurInputIfNeeded"],
          on: {
            "CONTROLLED.EDIT": {
              target: "edit",
              actions: ["setPreviousValue", "focusInput"]
            },
            EDIT: [
              {
                guard: "isEditControlled",
                actions: ["invokeOnEdit"]
              },
              {
                target: "edit",
                actions: ["setPreviousValue", "focusInput", "invokeOnEdit"]
              }
            ]
          }
        },
        edit: {
          activities: ["trackInteractOutside"],
          on: {
            "CONTROLLED.PREVIEW": [
              {
                guard: "isSubmitEvent",
                target: "preview",
                actions: ["setPreviousValue", "restoreFocus", "invokeOnSubmit"]
              },
              {
                target: "preview",
                actions: ["revertValue", "restoreFocus", "invokeOnCancel"]
              }
            ],
            CANCEL: [
              {
                guard: "isEditControlled",
                actions: ["invokeOnPreview"]
              },
              {
                target: "preview",
                actions: ["revertValue", "restoreFocus", "invokeOnCancel", "invokeOnPreview"]
              }
            ],
            SUBMIT: [
              {
                guard: "isEditControlled",
                actions: ["invokeOnPreview"]
              },
              {
                target: "preview",
                actions: ["setPreviousValue", "restoreFocus", "invokeOnSubmit", "invokeOnPreview"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isEditControlled: (ctx2) => !!ctx2["edit.controlled"],
        isSubmitEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "SUBMIT";
        }
      },
      activities: {
        trackInteractOutside(ctx2, _evt, { send }) {
          return trackInteractOutside(dom11.getInputEl(ctx2), {
            exclude(target) {
              const ignore = [dom11.getCancelTriggerEl(ctx2), dom11.getSubmitTriggerEl(ctx2)];
              return ignore.some((el) => contains(el, target));
            },
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onInteractOutside(event) {
              var _a8;
              (_a8 = ctx2.onInteractOutside) == null ? void 0 : _a8.call(ctx2, event);
              if (event.defaultPrevented) return;
              const { focusable } = event.detail;
              send({ type: submitOnBlur(ctx2) ? "SUBMIT" : "CANCEL", src: "interact-outside", focusable });
            }
          });
        }
      },
      actions: {
        restoreFocus(ctx2, evt) {
          if (evt.focusable) return;
          raf(() => {
            var _a8;
            const finalEl = ((_a8 = ctx2.finalFocusEl) == null ? void 0 : _a8.call(ctx2)) ?? dom11.getEditTriggerEl(ctx2);
            finalEl == null ? void 0 : finalEl.focus({ preventScroll: true });
          });
        },
        focusInput(ctx2) {
          raf(() => {
            const inputEl = dom11.getInputEl(ctx2);
            if (!inputEl) return;
            if (ctx2.selectOnFocus) {
              inputEl.select();
            } else {
              inputEl.focus({ preventScroll: true });
            }
          });
        },
        invokeOnCancel(ctx2) {
          var _a8;
          (_a8 = ctx2.onValueRevert) == null ? void 0 : _a8.call(ctx2, { value: ctx2.previousValue });
        },
        invokeOnSubmit(ctx2) {
          var _a8;
          (_a8 = ctx2.onValueCommit) == null ? void 0 : _a8.call(ctx2, { value: ctx2.value });
        },
        invokeOnEdit(ctx2) {
          var _a8;
          (_a8 = ctx2.onEditChange) == null ? void 0 : _a8.call(ctx2, { edit: true });
        },
        invokeOnPreview(ctx2) {
          var _a8;
          (_a8 = ctx2.onEditChange) == null ? void 0 : _a8.call(ctx2, { edit: false });
        },
        toggleEditing(ctx2, evt, { send }) {
          send({ type: ctx2.edit ? "CONTROLLED.EDIT" : "CONTROLLED.PREVIEW", previousEvent: evt });
        },
        syncInputValue(ctx2) {
          sync3.value(ctx2);
        },
        setValue(ctx2, evt) {
          const value = ctx2.maxLength != null ? evt.value.slice(0, ctx2.maxLength) : evt.value;
          set9.value(ctx2, value);
        },
        setPreviousValue(ctx2) {
          ctx2.previousValue = ctx2.value;
        },
        revertValue(ctx2) {
          set9.value(ctx2, ctx2.previousValue);
        },
        blurInputIfNeeded(ctx2) {
          var _a8;
          (_a8 = dom11.getInputEl(ctx2)) == null ? void 0 : _a8.blur();
        }
      }
    }
  );
}
var sync3 = {
  value: (ctx) => {
    const inputEl = dom11.getInputEl(ctx);
    dom11.setValue(inputEl, ctx.value);
  }
};
var invoke7 = {
  change(ctx) {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value: ctx.value });
    sync3.value(ctx);
  }
};
var set9 = {
  value(ctx, value) {
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke7.change(ctx);
  }
};
var props10 = createProps()([
  "activationMode",
  "autoResize",
  "dir",
  "disabled",
  "finalFocusEl",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "maxLength",
  "name",
  "onEditChange",
  "onFocusOutside",
  "onInteractOutside",
  "onPointerDownOutside",
  "onValueChange",
  "onValueCommit",
  "onValueRevert",
  "placeholder",
  "readOnly",
  "required",
  "selectOnFocus",
  "edit",
  "edit.controlled",
  "submitMode",
  "translations",
  "value"
]);
var splitProps10 = createSplitProps(props10);

// node_modules/@ark-ui/react/dist/components/editable/use-editable.js
var import_react288 = __toESM(require_react(), 1);
var useEditable = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react288.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      input: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    invalid: field == null ? void 0 : field.invalid,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    getRootNode,
    edit: props34.defaultEdit,
    value: props34.defaultValue,
    "edit.controlled": props34.edit !== void 0,
    ...props34
  };
  const context = {
    ...initialContext,
    value: props34.value,
    onValueChange: useEvent(props34.onValueChange, { sync: true }),
    onEditChange: useEvent(props34.onEditChange),
    onValueCommit: useEvent(props34.onValueCommit),
    onValueRevert: useEvent(props34.onValueRevert)
  };
  const [state2, send] = useMachine(machine12(initialContext), { context });
  return connect12(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/editable/editable-root.js
var EditableRoot = (0, import_react290.forwardRef)((props34, ref2) => {
  const [useEditableProps, localProps] = createSplitProps2()(props34, [
    "activationMode",
    "autoResize",
    "defaultEdit",
    "defaultValue",
    "disabled",
    "edit",
    "finalFocusEl",
    "form",
    "id",
    "ids",
    "invalid",
    "maxLength",
    "name",
    "onEditChange",
    "onFocusOutside",
    "onInteractOutside",
    "onPointerDownOutside",
    "onValueChange",
    "onValueCommit",
    "onValueRevert",
    "placeholder",
    "readOnly",
    "required",
    "selectOnFocus",
    "submitMode",
    "translations",
    "value"
  ]);
  const editable = useEditable(useEditableProps);
  const mergedProps = mergeProps2(editable.getRootProps(), localProps);
  return (0, import_jsx_runtime135.jsx)(EditableProvider, { value: editable, children: (0, import_jsx_runtime135.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
EditableRoot.displayName = "EditableRoot";

// node_modules/@ark-ui/react/dist/components/editable/editable-root-provider.js
var import_jsx_runtime136 = __toESM(require_jsx_runtime(), 1);
var import_react292 = __toESM(require_react(), 1);
var EditableRootProvider = (0, import_react292.forwardRef)(
  (props34, ref2) => {
    const [{ value: editable }, localProps] = createSplitProps2()(props34, [
      "value"
    ]);
    const mergedProps = mergeProps2(editable.getRootProps(), localProps);
    return (0, import_jsx_runtime136.jsx)(EditableProvider, { value: editable, children: (0, import_jsx_runtime136.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
EditableRootProvider.displayName = "EditableRootProvider";

// node_modules/@ark-ui/react/dist/components/editable/editable-submit-trigger.js
var import_jsx_runtime137 = __toESM(require_jsx_runtime(), 1);
var import_react294 = __toESM(require_react(), 1);
var EditableSubmitTrigger = (0, import_react294.forwardRef)(
  (props34, ref2) => {
    const editable = useEditableContext();
    const mergedProps = mergeProps2(editable.getSubmitTriggerProps(), props34);
    return (0, import_jsx_runtime137.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
EditableSubmitTrigger.displayName = "EditableSubmitTrigger";

// node_modules/@ark-ui/react/dist/components/editable/editable.js
var editable_exports = {};
__export(editable_exports, {
  Area: () => EditableArea,
  CancelTrigger: () => EditableCancelTrigger,
  Context: () => EditableContext,
  Control: () => EditableControl,
  EditTrigger: () => EditableEditTrigger,
  Input: () => EditableInput,
  Label: () => EditableLabel,
  Preview: () => EditablePreview,
  Root: () => EditableRoot,
  RootProvider: () => EditableRootProvider,
  SubmitTrigger: () => EditableSubmitTrigger
});

// node_modules/@ark-ui/react/dist/components/field/field-context.js
var FieldContext = (props34) => props34.children(useFieldContext());

// node_modules/@ark-ui/react/dist/components/field/field-error-text.js
var import_jsx_runtime138 = __toESM(require_jsx_runtime(), 1);
var import_react296 = __toESM(require_react(), 1);
var FieldErrorText = (0, import_react296.forwardRef)((props34, ref2) => {
  const field = useFieldContext();
  const mergedProps = mergeProps2(field.getErrorTextProps(), props34);
  if (field == null ? void 0 : field.invalid) {
    return (0, import_jsx_runtime138.jsx)(ark.span, { ...mergedProps, ref: ref2 });
  }
  return null;
});
FieldErrorText.displayName = "FieldErrorText";

// node_modules/@ark-ui/react/dist/components/field/field-helper-text.js
var import_jsx_runtime139 = __toESM(require_jsx_runtime(), 1);
var import_react298 = __toESM(require_react(), 1);
var FieldHelperText = (0, import_react298.forwardRef)((props34, ref2) => {
  const field = useFieldContext();
  const mergedProps = mergeProps2(field == null ? void 0 : field.getHelperTextProps(), props34);
  return (0, import_jsx_runtime139.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
FieldHelperText.displayName = "FieldHelperText";

// node_modules/@ark-ui/react/dist/components/field/field-input.js
var import_jsx_runtime140 = __toESM(require_jsx_runtime(), 1);
var import_react300 = __toESM(require_react(), 1);
var FieldInput = (0, import_react300.forwardRef)((props34, ref2) => {
  const field = useFieldContext();
  const mergedProps = mergeProps2(field == null ? void 0 : field.getInputProps(), props34);
  return (0, import_jsx_runtime140.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
FieldInput.displayName = "FieldInput";

// node_modules/@ark-ui/react/dist/components/field/field-label.js
var import_jsx_runtime141 = __toESM(require_jsx_runtime(), 1);
var import_react302 = __toESM(require_react(), 1);
var FieldLabel = (0, import_react302.forwardRef)((props34, ref2) => {
  const field = useFieldContext();
  const mergedProps = mergeProps2(field == null ? void 0 : field.getLabelProps(), props34);
  return (0, import_jsx_runtime141.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
FieldLabel.displayName = "FieldLabel";

// node_modules/@ark-ui/react/dist/components/field/field-required-indicator.js
var import_jsx_runtime142 = __toESM(require_jsx_runtime(), 1);
var import_react303 = __toESM(require_react(), 1);
var FieldRequiredIndicator = (0, import_react303.forwardRef)(
  ({ fallback: fallback4, ...props34 }, ref2) => {
    const field = useFieldContext();
    if (!field.required) {
      return fallback4;
    }
    const mergedProps = mergeProps2(field.getRequiredIndicatorProps(), props34);
    return (0, import_jsx_runtime142.jsx)(ark.span, { ...mergedProps, ref: ref2, children: props34.children ?? "*" });
  }
);
FieldRequiredIndicator.displayName = "FieldRequiredIndicator";

// node_modules/@ark-ui/react/dist/components/field/field-root.js
var import_jsx_runtime143 = __toESM(require_jsx_runtime(), 1);
var import_react307 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/field/use-field.js
var import_react305 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/use-safe-layout-effect.js
var import_react304 = __toESM(require_react(), 1);
var useSafeLayoutEffect2 = typeof window !== "undefined" ? import_react304.useLayoutEffect : import_react304.useEffect;

// node_modules/@ark-ui/react/dist/components/fieldset/use-fieldset-context.js
var [FieldsetProvider, useFieldsetContext] = createContext3({
  name: "FieldsetContext",
  hookName: "useFieldsetContext",
  providerName: "<FieldsetProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/field/field.anatomy.js
var fieldAnatomy = createAnatomy("field").parts(
  "root",
  "errorText",
  "helperText",
  "input",
  "label",
  "select",
  "textarea",
  "requiredIndicator"
);
var parts12 = fieldAnatomy.build();

// node_modules/@ark-ui/react/dist/components/field/use-field.js
var useField = (props34) => {
  const fieldset = useFieldsetContext();
  const {
    ids,
    disabled = Boolean(fieldset == null ? void 0 : fieldset.disabled),
    invalid = false,
    readOnly = false,
    required = false
  } = props34;
  const hasErrorText = (0, import_react305.useRef)(false);
  const hasHelperText = (0, import_react305.useRef)(false);
  const id = props34.id ?? (0, import_react305.useId)();
  const rootRef = (0, import_react305.useRef)(null);
  const rootId = (ids == null ? void 0 : ids.control) ?? `field::${id}`;
  const errorTextId = (ids == null ? void 0 : ids.errorText) ?? `field::${id}::error-text`;
  const helperTextId = (ids == null ? void 0 : ids.helperText) ?? `field::${id}::helper-text`;
  const labelId = (ids == null ? void 0 : ids.label) ?? `field::${id}::label`;
  useSafeLayoutEffect2(() => {
    const rootNode = rootRef.current;
    if (!rootNode) return;
    const win = getWindow(rootNode);
    const doc = win.document;
    const checkTextElements = () => {
      hasErrorText.current = !!doc.getElementById(errorTextId);
      hasHelperText.current = !!doc.getElementById(helperTextId);
    };
    checkTextElements();
    const observer = new win.MutationObserver(checkTextElements);
    observer.observe(rootNode, { childList: true, subtree: true });
    return () => observer.disconnect();
  }, [errorTextId, helperTextId]);
  const labelIds = (0, import_react305.useMemo)(() => {
    const ids2 = [];
    if (hasErrorText.current && invalid) ids2.push(errorTextId);
    if (hasHelperText.current) ids2.push(helperTextId);
    return ids2.join(" ") || void 0;
  }, [invalid, errorTextId, helperTextId]);
  const getRootProps = (0, import_react305.useMemo)(
    () => () => ({
      ...parts12.root.attrs,
      id: rootId,
      ref: rootRef,
      role: "group",
      "data-disabled": dataAttr(disabled),
      "data-invalid": dataAttr(invalid),
      "data-readonly": dataAttr(readOnly)
    }),
    [disabled, invalid, readOnly, rootId]
  );
  const getLabelProps = (0, import_react305.useMemo)(
    () => () => ({
      ...parts12.label.attrs,
      id: labelId,
      "data-disabled": dataAttr(disabled),
      "data-invalid": dataAttr(invalid),
      "data-readonly": dataAttr(readOnly),
      htmlFor: id
    }),
    [disabled, invalid, readOnly, id, labelId]
  );
  const getControlProps = (0, import_react305.useMemo)(
    () => () => ({
      "aria-describedby": labelIds,
      "aria-invalid": ariaAttr(invalid),
      "data-invalid": dataAttr(invalid),
      "data-required": dataAttr(required),
      "data-readonly": dataAttr(readOnly),
      id,
      required,
      disabled,
      readOnly
    }),
    [labelIds, invalid, required, readOnly, id, disabled]
  );
  const getInputProps = (0, import_react305.useMemo)(
    () => () => ({
      ...getControlProps(),
      ...parts12.input.attrs
    }),
    [getControlProps]
  );
  const getTextareaProps = (0, import_react305.useMemo)(
    () => () => ({
      ...getControlProps(),
      ...parts12.textarea.attrs
    }),
    [getControlProps]
  );
  const getSelectProps = (0, import_react305.useMemo)(
    () => () => ({
      ...getControlProps(),
      ...parts12.select.attrs
    }),
    [getControlProps]
  );
  const getHelperTextProps = (0, import_react305.useMemo)(
    () => () => ({
      id: helperTextId,
      ...parts12.helperText.attrs,
      "data-disabled": dataAttr(disabled)
    }),
    [disabled, helperTextId]
  );
  const getErrorTextProps = (0, import_react305.useMemo)(
    () => () => ({
      id: errorTextId,
      ...parts12.errorText.attrs,
      "aria-live": "polite"
    }),
    [errorTextId]
  );
  const getRequiredIndicatorProps = (0, import_react305.useMemo)(
    () => () => ({
      "aria-hidden": true,
      ...parts12.requiredIndicator.attrs
    }),
    []
  );
  return {
    ariaDescribedby: labelIds,
    ids: {
      root: rootId,
      control: id,
      label: labelId,
      errorText: errorTextId,
      helperText: helperTextId
    },
    refs: {
      rootRef
    },
    disabled,
    invalid,
    readOnly,
    required,
    getLabelProps,
    getRootProps,
    getInputProps,
    getTextareaProps,
    getSelectProps,
    getHelperTextProps,
    getErrorTextProps,
    getRequiredIndicatorProps
  };
};

// node_modules/@ark-ui/react/dist/components/field/field-root.js
var FieldRoot = (0, import_react307.forwardRef)((props34, ref2) => {
  const [useFieldProps, localProps] = createSplitProps2()(props34, [
    "id",
    "ids",
    "disabled",
    "invalid",
    "readOnly",
    "required"
  ]);
  const field = useField(useFieldProps);
  const mergedProps = mergeProps2(field.getRootProps(), localProps);
  return (0, import_jsx_runtime143.jsx)(FieldProvider, { value: field, children: (0, import_jsx_runtime143.jsx)(ark.div, { ...mergedProps, ref: composeRefs(ref2, field.refs.rootRef) }) });
});
FieldRoot.displayName = "FieldRoot";

// node_modules/@ark-ui/react/dist/components/field/field-root-provider.js
var import_jsx_runtime144 = __toESM(require_jsx_runtime(), 1);
var import_react309 = __toESM(require_react(), 1);
var FieldRootProvider = (0, import_react309.forwardRef)(
  (props34, ref2) => {
    const [{ value: field }, localProps] = createSplitProps2()(props34, ["value"]);
    const mergedProps = mergeProps2(field.getRootProps(), localProps);
    return (0, import_jsx_runtime144.jsx)(FieldProvider, { value: field, children: (0, import_jsx_runtime144.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
FieldRootProvider.displayName = "FieldRootProvider";

// node_modules/@ark-ui/react/dist/components/field/field-select.js
var import_jsx_runtime145 = __toESM(require_jsx_runtime(), 1);
var import_react311 = __toESM(require_react(), 1);
var FieldSelect = (0, import_react311.forwardRef)((props34, ref2) => {
  const field = useFieldContext();
  const mergedProps = mergeProps2(field == null ? void 0 : field.getSelectProps(), props34);
  return (0, import_jsx_runtime145.jsx)(ark.select, { ...mergedProps, ref: ref2 });
});
FieldSelect.displayName = "FieldSelect";

// node_modules/@ark-ui/react/dist/components/field/field-textarea.js
var import_jsx_runtime146 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/auto-resize/dist/index.mjs
function getVisualStyles(node2) {
  if (!node2) return;
  const style = getComputedStyle2(node2);
  return "box-sizing:" + style.boxSizing + ";border-left:" + style.borderLeftWidth + " solid red;border-right:" + style.borderRightWidth + " solid red;font-family:" + style.fontFamily + ";font-feature-settings:" + style.fontFeatureSettings + ";font-kerning:" + style.fontKerning + ";font-size:" + style.fontSize + ";font-stretch:" + style.fontStretch + ";font-style:" + style.fontStyle + ";font-variant:" + style.fontVariant + ";font-variant-caps:" + style.fontVariantCaps + ";font-variant-ligatures:" + style.fontVariantLigatures + ";font-variant-numeric:" + style.fontVariantNumeric + ";font-weight:" + style.fontWeight + ";letter-spacing:" + style.letterSpacing + ";margin-left:" + style.marginLeft + ";margin-right:" + style.marginRight + ";padding-left:" + style.paddingLeft + ";padding-right:" + style.paddingRight + ";text-indent:" + style.textIndent + ";text-transform:" + style.textTransform;
}
function createGhostElement(doc) {
  var el = doc.createElement("div");
  el.id = "ghost";
  el.style.cssText = "display:inline-block;height:0;overflow:hidden;position:absolute;top:0;visibility:hidden;white-space:nowrap;";
  doc.body.appendChild(el);
  return el;
}
function autoResizeInput(input) {
  if (!input) return;
  const doc = getDocument(input);
  const win = getWindow(input);
  const ghost = createGhostElement(doc);
  const cssText = getVisualStyles(input);
  if (cssText) ghost.style.cssText += cssText;
  function resize() {
    win.requestAnimationFrame(() => {
      ghost.innerHTML = input.value;
      const rect = win.getComputedStyle(ghost);
      input == null ? void 0 : input.style.setProperty("width", rect.width);
    });
  }
  resize();
  input == null ? void 0 : input.addEventListener("input", resize);
  input == null ? void 0 : input.addEventListener("change", resize);
  return () => {
    doc.body.removeChild(ghost);
    input == null ? void 0 : input.removeEventListener("input", resize);
    input == null ? void 0 : input.removeEventListener("change", resize);
  };
}
var autoresizeTextarea = (el) => {
  var _a8;
  if (!el) return;
  const style = getComputedStyle2(el);
  const win = getWindow(el);
  const doc = getDocument(el);
  const resize = () => {
    el.style.height = "auto";
    const borderTopWidth = parseInt(style.borderTopWidth, 10);
    const borderBottomWidth = parseInt(style.borderBottomWidth, 10);
    el.style.height = `${el.scrollHeight + borderTopWidth + borderBottomWidth}px`;
  };
  el.addEventListener("input", resize);
  const elementPrototype = Object.getPrototypeOf(el);
  const descriptor = Object.getOwnPropertyDescriptor(elementPrototype, "value");
  Object.defineProperty(el, "value", {
    ...descriptor,
    set() {
      var _a9;
      (_a9 = descriptor == null ? void 0 : descriptor.set) == null ? void 0 : _a9.apply(this, arguments);
      resize();
    }
  });
  const resizeObserver = new win.ResizeObserver(() => resize());
  resizeObserver.observe(el);
  const attrObserver = new win.MutationObserver(() => resize());
  attrObserver.observe(el, { attributes: true, attributeFilter: ["rows", "placeholder"] });
  (_a8 = doc.fonts) == null ? void 0 : _a8.addEventListener("loadingdone", resize);
  return () => {
    var _a9;
    el.removeEventListener("input", resize);
    (_a9 = doc.fonts) == null ? void 0 : _a9.removeEventListener("loadingdone", resize);
    resizeObserver.disconnect();
    attrObserver.disconnect();
  };
};

// node_modules/@ark-ui/react/dist/components/field/field-textarea.js
var import_react313 = __toESM(require_react(), 1);
var FieldTextarea = (0, import_react313.forwardRef)((props34, ref2) => {
  const { autoresize, ...textareaProps } = props34;
  const textareaRef = (0, import_react313.useRef)(null);
  const field = useFieldContext();
  const mergedProps = mergeProps2(
    field == null ? void 0 : field.getTextareaProps(),
    { style: { resize: autoresize ? "none" : void 0 } },
    textareaProps
  );
  (0, import_react313.useEffect)(() => {
    if (!autoresize) return;
    return autoresizeTextarea(textareaRef.current);
  }, [autoresize]);
  return (0, import_jsx_runtime146.jsx)(ark.textarea, { ...mergedProps, ref: composeRefs(ref2, textareaRef) });
});
FieldTextarea.displayName = "FieldTextarea";

// node_modules/@ark-ui/react/dist/components/field/field.js
var field_exports = {};
__export(field_exports, {
  Context: () => FieldContext,
  ErrorText: () => FieldErrorText,
  HelperText: () => FieldHelperText,
  Input: () => FieldInput,
  Label: () => FieldLabel,
  RequiredIndicator: () => FieldRequiredIndicator,
  Root: () => FieldRoot,
  RootProvider: () => FieldRootProvider,
  Select: () => FieldSelect,
  Textarea: () => FieldTextarea
});

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-context.js
var FieldsetContext = (props34) => props34.children(useFieldsetContext());

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-error-text.js
var import_jsx_runtime147 = __toESM(require_jsx_runtime(), 1);
var import_react315 = __toESM(require_react(), 1);
var FieldsetErrorText = (0, import_react315.forwardRef)(
  (props34, ref2) => {
    const fieldset = useFieldsetContext();
    const mergedProps = mergeProps2(fieldset.getErrorTextProps(), props34);
    return fieldset.invalid ? (0, import_jsx_runtime147.jsx)(ark.span, { ...mergedProps, ref: ref2 }) : null;
  }
);
FieldsetErrorText.displayName = "FieldsetErrorText";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-helper-text.js
var import_jsx_runtime148 = __toESM(require_jsx_runtime(), 1);
var import_react317 = __toESM(require_react(), 1);
var FieldsetHelperText = (0, import_react317.forwardRef)(
  (props34, ref2) => {
    const fieldset = useFieldsetContext();
    const mergedProps = mergeProps2(fieldset.getHelperTextProps(), props34);
    return (0, import_jsx_runtime148.jsx)(ark.span, { ...mergedProps, ref: ref2 });
  }
);
FieldsetHelperText.displayName = "FieldsetHelperText";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-legend.js
var import_jsx_runtime149 = __toESM(require_jsx_runtime(), 1);
var import_react319 = __toESM(require_react(), 1);
var FieldsetLegend = (0, import_react319.forwardRef)((props34, ref2) => {
  const fieldset = useFieldsetContext();
  const mergedProps = mergeProps2(fieldset.getLegendProps(), props34);
  return (0, import_jsx_runtime149.jsx)(ark.legend, { ...mergedProps, ref: ref2 });
});
FieldsetLegend.displayName = "FieldsetLegend";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-root.js
var import_jsx_runtime150 = __toESM(require_jsx_runtime(), 1);
var import_react322 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/fieldset/use-fieldset.js
var import_react320 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset.anatomy.js
var fieldsetAnatomy = createAnatomy("fieldset").parts(
  "root",
  "errorText",
  "helperText",
  "legend"
);
var parts13 = fieldsetAnatomy.build();

// node_modules/@ark-ui/react/dist/components/fieldset/use-fieldset.js
var useFieldset = (props34) => {
  const { disabled = false, invalid = false } = props34;
  const hasErrorText = (0, import_react320.useRef)(false);
  const hasHelperText = (0, import_react320.useRef)(false);
  const id = props34.id ?? (0, import_react320.useId)();
  const rootRef = (0, import_react320.useRef)(null);
  const errorTextId = `fieldset::${id}::error-text`;
  const helperTextId = `fieldset::${id}::helper-text`;
  useSafeLayoutEffect2(() => {
    const rootNode = rootRef.current;
    if (!rootNode) return;
    const win = getWindow(rootNode);
    const doc = win.document;
    const checkTextElements = () => {
      hasErrorText.current = !!doc.getElementById(errorTextId);
      hasHelperText.current = !!doc.getElementById(helperTextId);
    };
    checkTextElements();
    const observer = new win.MutationObserver(checkTextElements);
    observer.observe(rootNode, { childList: true, subtree: true });
    return () => observer.disconnect();
  }, [errorTextId, helperTextId]);
  const labelIds = (0, import_react320.useMemo)(() => {
    const ids = [];
    if (hasErrorText.current && invalid) ids.push(errorTextId);
    if (hasHelperText.current) ids.push(helperTextId);
    return ids.join(" ") || void 0;
  }, [invalid, errorTextId, helperTextId]);
  const getRootProps = (0, import_react320.useMemo)(
    () => () => ({
      ...parts13.root.attrs,
      ref: rootRef,
      disabled,
      "data-disabled": disabled ? "true" : void 0,
      "data-invalid": invalid ? "true" : void 0,
      "aria-describedby": labelIds
    }),
    [disabled, invalid, labelIds]
  );
  const getLegendProps = (0, import_react320.useMemo)(
    () => () => ({
      ...parts13.legend.attrs,
      "data-disabled": disabled ? "true" : void 0,
      "data-invalid": invalid ? "true" : void 0
    }),
    [disabled, invalid]
  );
  const getHelperTextProps = (0, import_react320.useMemo)(
    () => () => ({
      id: helperTextId,
      ...parts13.helperText.attrs
    }),
    [helperTextId]
  );
  const getErrorTextProps = (0, import_react320.useMemo)(
    () => () => ({
      id: errorTextId,
      ...parts13.errorText.attrs,
      "aria-live": "polite"
    }),
    [errorTextId]
  );
  return {
    refs: {
      rootRef
    },
    disabled,
    invalid,
    getRootProps,
    getLegendProps,
    getHelperTextProps,
    getErrorTextProps
  };
};

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-root.js
var FieldsetRoot = (0, import_react322.forwardRef)((props34, ref2) => {
  const [useFieldsetProps, localProps] = createSplitProps2()(props34, [
    "id",
    "disabled",
    "invalid"
  ]);
  const fieldset = useFieldset(useFieldsetProps);
  const mergedProps = mergeProps2(fieldset.getRootProps(), localProps);
  return (0, import_jsx_runtime150.jsx)(FieldsetProvider, { value: fieldset, children: (0, import_jsx_runtime150.jsx)(ark.fieldset, { ...mergedProps, ref: composeRefs(ref2, fieldset.refs.rootRef) }) });
});
FieldsetRoot.displayName = "FieldsetRoot";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-root-provider.js
var import_jsx_runtime151 = __toESM(require_jsx_runtime(), 1);
var import_react324 = __toESM(require_react(), 1);
var FieldsetRootProvider = (0, import_react324.forwardRef)(
  (props34, ref2) => {
    const [{ value: fieldset }, localProps] = createSplitProps2()(props34, [
      "value"
    ]);
    const mergedProps = mergeProps2(fieldset.getRootProps(), localProps);
    return (0, import_jsx_runtime151.jsx)(FieldsetProvider, { value: fieldset, children: (0, import_jsx_runtime151.jsx)(ark.fieldset, { ...mergedProps, ref: ref2 }) });
  }
);
FieldsetRootProvider.displayName = "FieldsetRootProvider";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset.js
var fieldset_exports = {};
__export(fieldset_exports, {
  Context: () => FieldsetContext,
  ErrorText: () => FieldsetErrorText,
  HelperText: () => FieldsetHelperText,
  Legend: () => FieldsetLegend,
  Root: () => FieldsetRoot,
  RootProvider: () => FieldsetRootProvider
});

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-clear-trigger.js
var import_jsx_runtime152 = __toESM(require_jsx_runtime(), 1);
var import_react326 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/file-upload/use-file-upload-context.js
var [FileUploadProvider, useFileUploadContext] = createContext3({
  name: "FileUploadContext",
  hookName: "useFileUploadContext",
  providerName: "<FileUploadProvider />"
});

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-clear-trigger.js
var FileUploadClearTrigger = (0, import_react326.forwardRef)(
  (props34, ref2) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps2(fileUpload.getClearTriggerProps(), props34);
    return (0, import_jsx_runtime152.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
FileUploadClearTrigger.displayName = "FileUploadClearTrigger";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-context.js
var FileUploadContext = (props34) => props34.children(useFileUploadContext());

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-dropzone.js
var import_jsx_runtime153 = __toESM(require_jsx_runtime(), 1);
var import_react328 = __toESM(require_react(), 1);
var FileUploadDropzone = (0, import_react328.forwardRef)(
  (props34, ref2) => {
    const [dropzoneProps, localProps] = createSplitProps2()(props34, ["disableClick"]);
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps2(fileUpload.getDropzoneProps(dropzoneProps), localProps);
    return (0, import_jsx_runtime153.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
FileUploadDropzone.displayName = "FileUploadDropzone";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-hidden-input.js
var import_jsx_runtime154 = __toESM(require_jsx_runtime(), 1);
var import_react330 = __toESM(require_react(), 1);
var FileUploadHiddenInput = (0, import_react330.forwardRef)(
  (props34, ref2) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps2(fileUpload.getHiddenInputProps(), props34);
    const field = useFieldContext();
    return (0, import_jsx_runtime154.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
FileUploadHiddenInput.displayName = "FileUploadHiddenInput";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item.js
var import_jsx_runtime155 = __toESM(require_jsx_runtime(), 1);
var import_react332 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/file-upload/use-file-upload-item-props-context.js
var [FileUploadItemPropsProvider, useFileUploadItemPropsContext] = createContext3({
  name: "FileUploadItemPropsContext",
  hookName: "useFileUploadItemPropsContext",
  providerName: "<FileUploadItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item.js
var FileUploadItem = (0, import_react332.forwardRef)((props34, ref2) => {
  const [itemProps12, localProps] = createSplitProps2()(props34, ["file"]);
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps2(fileUpload.getItemProps(itemProps12), localProps);
  return (0, import_jsx_runtime155.jsx)(FileUploadItemPropsProvider, { value: itemProps12, children: (0, import_jsx_runtime155.jsx)(ark.li, { ...mergedProps, ref: ref2 }) });
});
FileUploadItem.displayName = "FileUploadItem";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-delete-trigger.js
var import_jsx_runtime156 = __toESM(require_jsx_runtime(), 1);
var import_react334 = __toESM(require_react(), 1);
var FileUploadItemDeleteTrigger = (0, import_react334.forwardRef)((props34, ref2) => {
  const fileUpload = useFileUploadContext();
  const itemProps12 = useFileUploadItemPropsContext();
  const mergedProps = mergeProps2(fileUpload.getItemDeleteTriggerProps(itemProps12), props34);
  return (0, import_jsx_runtime156.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
FileUploadItemDeleteTrigger.displayName = "FileUploadItemDeleteTrigger";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-group.js
var import_jsx_runtime157 = __toESM(require_jsx_runtime(), 1);
var import_react336 = __toESM(require_react(), 1);
var FileUploadItemGroup = (0, import_react336.forwardRef)(
  (props34, ref2) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps2(fileUpload.getItemGroupProps(), props34);
    return (0, import_jsx_runtime157.jsx)(ark.ul, { ...mergedProps, ref: ref2 });
  }
);
FileUploadItemGroup.displayName = "FileUploadItemGroup";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-name.js
var import_jsx_runtime158 = __toESM(require_jsx_runtime(), 1);
var import_react338 = __toESM(require_react(), 1);
var FileUploadItemName = (0, import_react338.forwardRef)(
  (props34, ref2) => {
    const { children, ...rest } = props34;
    const fileUpload = useFileUploadContext();
    const itemProps12 = useFileUploadItemPropsContext();
    const mergedProps = mergeProps2(fileUpload.getItemNameProps(itemProps12), rest);
    return (0, import_jsx_runtime158.jsx)(ark.div, { ...mergedProps, ref: ref2, children: children || itemProps12.file.name });
  }
);
FileUploadItemName.displayName = "FileUploadItemName";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-preview.js
var import_jsx_runtime159 = __toESM(require_jsx_runtime(), 1);
var import_react340 = __toESM(require_react(), 1);
var FileUploadItemPreview = (0, import_react340.forwardRef)(
  (props34, ref2) => {
    const fileUpload = useFileUploadContext();
    const itemProps12 = useFileUploadItemPropsContext();
    const mergedProps = mergeProps2(fileUpload.getItemPreviewProps(itemProps12), props34);
    if (!itemProps12.file.type.match(props34.type ?? ".*")) return null;
    return (0, import_jsx_runtime159.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
FileUploadItemPreview.displayName = "FileUploadItemPreview";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-preview-image.js
var import_jsx_runtime160 = __toESM(require_jsx_runtime(), 1);
var import_react342 = __toESM(require_react(), 1);
var FileUploadItemPreviewImage = (0, import_react342.forwardRef)((props34, ref2) => {
  const [url, setUrl] = (0, import_react342.useState)("");
  const fileUpload = useFileUploadContext();
  const itemProps12 = useFileUploadItemPropsContext();
  const mergedProps = mergeProps2(fileUpload.getItemPreviewImageProps({ ...itemProps12, url }), props34);
  (0, import_react342.useEffect)(() => {
    return fileUpload.createFileUrl(itemProps12.file, (url2) => setUrl(url2));
  }, [itemProps12, fileUpload]);
  if (!url) return null;
  return (0, import_jsx_runtime160.jsx)(ark.img, { ...mergedProps, ref: ref2 });
});
FileUploadItemPreviewImage.displayName = "FileUploadItemPreviewImage";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-size-text.js
var import_jsx_runtime161 = __toESM(require_jsx_runtime(), 1);
var import_react344 = __toESM(require_react(), 1);
var FileUploadItemSizeText = (0, import_react344.forwardRef)(
  (props34, ref2) => {
    const { children, ...rest } = props34;
    const fileUpload = useFileUploadContext();
    const itemProps12 = useFileUploadItemPropsContext();
    const mergedProps = mergeProps2(fileUpload.getItemSizeTextProps(itemProps12), rest);
    return (0, import_jsx_runtime161.jsx)(ark.div, { ...mergedProps, ref: ref2, children: children || fileUpload.getFileSize(itemProps12.file) });
  }
);
FileUploadItemSizeText.displayName = "FileUploadItemSizeText";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-label.js
var import_jsx_runtime162 = __toESM(require_jsx_runtime(), 1);
var import_react346 = __toESM(require_react(), 1);
var FileUploadLabel = (0, import_react346.forwardRef)((props34, ref2) => {
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps2(fileUpload.getLabelProps(), props34);
  return (0, import_jsx_runtime162.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
FileUploadLabel.displayName = "FileUploadLabel";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-root.js
var import_jsx_runtime163 = __toESM(require_jsx_runtime(), 1);
var import_react350 = __toESM(require_react(), 1);

// node_modules/@zag-js/file-utils/dist/index.mjs
function isMIMEType(v) {
  return v === "audio/*" || v === "video/*" || v === "image/*" || v === "text/*" || /\w+\/[-+.\w]+/g.test(v);
}
function isExt(v) {
  return /^.*\.[\w]+$/.test(v);
}
var isValidMIME = (v) => isMIMEType(v) || isExt(v);
function getAcceptAttrString(accept) {
  if (!accept) return;
  if (typeof accept === "string") {
    return accept;
  }
  if (Array.isArray(accept)) {
    return accept.filter(isValidMIME).join(",");
  }
  return Object.entries(accept).reduce((a2, [mimeType, ext]) => [...a2, mimeType, ...ext], []).filter(isValidMIME).join(",");
}
var isFileEqual = (file1, file2) => {
  return file1.name === file2.name && file1.size === file2.size && file1.type === file2.type;
};
var isDefined = (v) => v !== void 0 && v !== null;
function isValidFileSize(file, minSize, maxSize) {
  if (isDefined(file.size)) {
    if (isDefined(minSize) && isDefined(maxSize)) {
      if (file.size > maxSize) return [false, "FILE_TOO_LARGE"];
      if (file.size < minSize) return [false, "FILE_TOO_SMALL"];
    } else if (isDefined(minSize) && file.size < minSize) {
      return [false, "FILE_TOO_SMALL"];
    } else if (isDefined(maxSize) && file.size > maxSize) {
      return [false, "FILE_TOO_LARGE"];
    }
  }
  return [true, null];
}
function isFileAccepted(file, accept) {
  if (file && accept) {
    const types = Array.isArray(accept) ? accept : accept.split(",");
    const fileName = file.name || "";
    const mimeType = (file.type || "").toLowerCase();
    const baseMimeType = mimeType.replace(/\/.*$/, "");
    return types.some((type) => {
      const validType = type.trim().toLowerCase();
      if (validType.charAt(0) === ".") {
        return fileName.toLowerCase().endsWith(validType);
      }
      if (validType.endsWith("/*")) {
        return baseMimeType === validType.replace(/\/.*$/, "");
      }
      return mimeType === validType;
    });
  }
  return true;
}
function isValidFileType(file, accept) {
  const isAcceptable = file.type === "application/x-moz-file" || isFileAccepted(file, accept);
  return [isAcceptable, isAcceptable ? null : "FILE_INVALID_TYPE"];
}

// node_modules/@zag-js/file-upload/dist/index.mjs
var anatomy12 = createAnatomy("file-upload").parts(
  "root",
  "dropzone",
  "item",
  "itemDeleteTrigger",
  "itemGroup",
  "itemName",
  "itemPreview",
  "itemPreviewImage",
  "itemSizeText",
  "label",
  "trigger",
  "clearTrigger"
);
var parts14 = anatomy12.build();
var dom12 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `file:${ctx.id}`;
  },
  getDropzoneId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.dropzone) ?? `file:${ctx.id}:dropzone`;
  },
  getHiddenInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `file:${ctx.id}:input`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `file:${ctx.id}:trigger`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `file:${ctx.id}:label`;
  },
  getItemId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, id)) ?? `file:${ctx.id}:item:${id}`;
  },
  getItemNameId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemName) == null ? void 0 : _b7.call(_a8, id)) ?? `file:${ctx.id}:item-name:${id}`;
  },
  getItemSizeTextId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemSizeText) == null ? void 0 : _b7.call(_a8, id)) ?? `file:${ctx.id}:item-size:${id}`;
  },
  getItemPreviewId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemPreview) == null ? void 0 : _b7.call(_a8, id)) ?? `file:${ctx.id}:item-preview:${id}`;
  },
  getRootEl: (ctx) => dom12.getById(ctx, dom12.getRootId(ctx)),
  getHiddenInputEl: (ctx) => dom12.getById(ctx, dom12.getHiddenInputId(ctx)),
  getDropzoneEl: (ctx) => dom12.getById(ctx, dom12.getDropzoneId(ctx))
});
function isEventWithFiles(event) {
  const target = getEventTarget(event);
  if (!event.dataTransfer) return !!target && "files" in target;
  return event.dataTransfer.types.some((type) => {
    return type === "Files" || type === "application/x-moz-file";
  });
}
function isFilesWithinRange(ctx, incomingCount) {
  if (!ctx.multiple && incomingCount > 1) return false;
  if (!ctx.multiple && incomingCount + ctx.acceptedFiles.length === 2) return true;
  if (incomingCount + ctx.acceptedFiles.length > ctx.maxFiles) return false;
  return true;
}
function getFilesFromEvent(ctx, files) {
  const acceptedFiles = [];
  const rejectedFiles = [];
  files.forEach((file) => {
    var _a8;
    const [accepted, acceptError] = isValidFileType(file, ctx.acceptAttr);
    const [sizeMatch, sizeError] = isValidFileSize(file, ctx.minFileSize, ctx.maxFileSize);
    const validateErrors = (_a8 = ctx.validate) == null ? void 0 : _a8.call(ctx, file, {
      acceptedFiles: ctx.acceptedFiles,
      rejectedFiles: ctx.rejectedFiles
    });
    const valid = validateErrors ? validateErrors.length === 0 : true;
    if (accepted && sizeMatch && valid) {
      acceptedFiles.push(file);
    } else {
      const errors = [acceptError, sizeError];
      if (!valid) errors.push(...validateErrors ?? []);
      rejectedFiles.push({ file, errors: errors.filter(Boolean) });
    }
  });
  if (!isFilesWithinRange(ctx, acceptedFiles.length)) {
    acceptedFiles.forEach((file) => {
      rejectedFiles.push({ file, errors: ["TOO_MANY_FILES"] });
    });
    acceptedFiles.splice(0);
  }
  return {
    acceptedFiles,
    rejectedFiles
  };
}
function connect13(state2, send, normalize3) {
  const disabled = state2.context.disabled;
  const allowDrop = state2.context.allowDrop;
  const translations = state2.context.translations;
  const dragging = state2.matches("dragging");
  const focused = state2.matches("focused") && !disabled;
  return {
    dragging,
    focused,
    disabled: !!disabled,
    openFilePicker() {
      if (disabled) return;
      send("OPEN");
    },
    deleteFile(file) {
      send({ type: "FILE.DELETE", file });
    },
    acceptedFiles: state2.context.acceptedFiles,
    rejectedFiles: state2.context.rejectedFiles,
    setFiles(files) {
      const count = files.length;
      send({ type: "FILES.SET", files, count });
    },
    clearRejectedFiles() {
      send({ type: "REJECTED_FILES.CLEAR" });
    },
    clearFiles() {
      send({ type: "FILES.CLEAR" });
    },
    getFileSize(file) {
      return formatBytes(file.size, state2.context.locale);
    },
    createFileUrl(file, cb) {
      const win = dom12.getWin(state2.context);
      const url = win.URL.createObjectURL(file);
      cb(url);
      return () => win.URL.revokeObjectURL(url);
    },
    setClipboardFiles(dt) {
      if (disabled) return false;
      const items = Array.from((dt == null ? void 0 : dt.items) ?? []);
      const files = items.reduce((acc, item) => {
        if (item.kind !== "file") return acc;
        const file = item.getAsFile();
        if (!file) return acc;
        return [...acc, file];
      }, []);
      if (!files.length) return false;
      send({ type: "FILES.SET", files });
      return true;
    },
    getRootProps() {
      return normalize3.element({
        ...parts14.root.attrs,
        dir: state2.context.dir,
        id: dom12.getRootId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-dragging": dataAttr(dragging)
      });
    },
    getDropzoneProps(props210 = {}) {
      return normalize3.element({
        ...parts14.dropzone.attrs,
        dir: state2.context.dir,
        id: dom12.getDropzoneId(state2.context),
        tabIndex: disabled || props210.disableClick ? void 0 : 0,
        role: props210.disableClick ? "application" : "button",
        "aria-label": translations.dropzone,
        "aria-disabled": disabled,
        "data-invalid": dataAttr(state2.context.invalid),
        "data-disabled": dataAttr(disabled),
        "data-dragging": dataAttr(dragging),
        onKeyDown(event) {
          if (disabled) return;
          if (event.defaultPrevented) return;
          if (!isSelfTarget(event)) return;
          if (props210.disableClick) return;
          if (event.key !== "Enter" && event.key !== " ") return;
          send({ type: "DROPZONE.CLICK", src: "keydown" });
        },
        onClick(event) {
          if (disabled) return;
          if (event.defaultPrevented) return;
          if (props210.disableClick) return;
          if (!isSelfTarget(event)) return;
          if (event.currentTarget.localName === "label") {
            event.preventDefault();
          }
          send("DROPZONE.CLICK");
        },
        onDragOver(event) {
          if (disabled) return;
          if (!allowDrop) return;
          event.preventDefault();
          event.stopPropagation();
          try {
            event.dataTransfer.dropEffect = "copy";
          } catch {
          }
          const hasFiles = isEventWithFiles(event);
          if (!hasFiles) return;
          const count = event.dataTransfer.items.length;
          send({ type: "DROPZONE.DRAG_OVER", count });
        },
        onDragLeave(event) {
          if (disabled) return;
          if (!allowDrop) return;
          if (contains(event.currentTarget, event.relatedTarget)) return;
          send({ type: "DROPZONE.DRAG_LEAVE" });
        },
        onDrop(event) {
          if (disabled) return;
          if (allowDrop) {
            event.preventDefault();
            event.stopPropagation();
          }
          const hasFiles = isEventWithFiles(event);
          if (disabled || !hasFiles) return;
          send({ type: "DROPZONE.DROP", files: Array.from(event.dataTransfer.files) });
        },
        onFocus() {
          if (disabled) return;
          send("DROPZONE.FOCUS");
        },
        onBlur() {
          if (disabled) return;
          send("DROPZONE.BLUR");
        }
      });
    },
    getTriggerProps() {
      return normalize3.button({
        ...parts14.trigger.attrs,
        dir: state2.context.dir,
        id: dom12.getTriggerId(state2.context),
        disabled,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(state2.context.invalid),
        type: "button",
        onClick(event) {
          if (disabled) return;
          if (contains(dom12.getDropzoneEl(state2.context), event.currentTarget)) {
            event.stopPropagation();
          }
          send("OPEN");
        }
      });
    },
    getHiddenInputProps() {
      return normalize3.input({
        id: dom12.getHiddenInputId(state2.context),
        tabIndex: -1,
        disabled,
        type: "file",
        required: state2.context.required,
        capture: state2.context.capture,
        name: state2.context.name,
        accept: state2.context.acceptAttr,
        webkitdirectory: state2.context.directory ? "" : void 0,
        multiple: state2.context.multiple || state2.context.maxFiles > 1,
        onClick(event) {
          event.stopPropagation();
          event.currentTarget.value = "";
        },
        onInput(event) {
          if (disabled) return;
          const { files } = event.currentTarget;
          send({ type: "FILES.SET", files: files ? Array.from(files) : [] });
        },
        style: visuallyHiddenStyle
      });
    },
    getItemGroupProps() {
      return normalize3.element({
        ...parts14.itemGroup.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemProps(props210) {
      const { file } = props210;
      return normalize3.element({
        ...parts14.item.attrs,
        dir: state2.context.dir,
        id: dom12.getItemId(state2.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemNameProps(props210) {
      const { file } = props210;
      return normalize3.element({
        ...parts14.itemName.attrs,
        dir: state2.context.dir,
        id: dom12.getItemNameId(state2.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemSizeTextProps(props210) {
      const { file } = props210;
      return normalize3.element({
        ...parts14.itemSizeText.attrs,
        dir: state2.context.dir,
        id: dom12.getItemSizeTextId(state2.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemPreviewProps(props210) {
      const { file } = props210;
      return normalize3.element({
        ...parts14.itemPreview.attrs,
        dir: state2.context.dir,
        id: dom12.getItemPreviewId(state2.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemPreviewImageProps(props210) {
      var _a8;
      const { file, url } = props210;
      const isImage = file.type.startsWith("image/");
      if (!isImage) {
        throw new Error("Preview Image is only supported for image files");
      }
      return normalize3.img({
        ...parts14.itemPreviewImage.attrs,
        alt: (_a8 = translations.itemPreview) == null ? void 0 : _a8.call(translations, file),
        src: url,
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemDeleteTriggerProps(props210) {
      var _a8;
      const { file } = props210;
      return normalize3.button({
        ...parts14.itemDeleteTrigger.attrs,
        dir: state2.context.dir,
        type: "button",
        disabled,
        "data-disabled": dataAttr(disabled),
        "aria-label": (_a8 = translations.deleteFile) == null ? void 0 : _a8.call(translations, file),
        onClick() {
          if (disabled) return;
          send({ type: "FILE.DELETE", file });
        }
      });
    },
    getLabelProps() {
      return normalize3.label({
        ...parts14.label.attrs,
        dir: state2.context.dir,
        id: dom12.getLabelId(state2.context),
        htmlFor: dom12.getHiddenInputId(state2.context),
        "data-disabled": dataAttr(disabled)
      });
    },
    getClearTriggerProps() {
      return normalize3.button({
        ...parts14.clearTrigger.attrs,
        dir: state2.context.dir,
        type: "button",
        disabled,
        hidden: state2.context.acceptedFiles.length === 0,
        "data-disabled": dataAttr(disabled),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          send({ type: "FILES.CLEAR" });
        }
      });
    }
  };
}
function machine13(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "fileupload",
      initial: "idle",
      context: {
        minFileSize: 0,
        maxFileSize: Number.POSITIVE_INFINITY,
        maxFiles: 1,
        allowDrop: true,
        accept: ctx.accept,
        preventDocumentDrop: true,
        ...ctx,
        acceptedFiles: ref([]),
        rejectedFiles: ref([]),
        translations: {
          dropzone: "dropzone",
          itemPreview: (file) => `preview of ${file.name}`,
          deleteFile: (file) => `delete file ${file.name}`,
          ...ctx.translations
        }
      },
      computed: {
        acceptAttr: (ctx2) => getAcceptAttrString(ctx2.accept),
        multiple: (ctx2) => ctx2.maxFiles > 1
      },
      watch: {
        acceptedFiles: ["syncInputElement"]
      },
      on: {
        "FILES.SET": {
          actions: ["setFilesFromEvent"]
        },
        "FILE.DELETE": {
          actions: ["removeFile"]
        },
        "FILES.CLEAR": {
          actions: ["clearFiles"]
        },
        "REJECTED_FILES.CLEAR": {
          actions: ["clearRejectedFiles"]
        }
      },
      activities: ["preventDocumentDrop"],
      states: {
        idle: {
          on: {
            OPEN: {
              actions: ["openFilePicker"]
            },
            "DROPZONE.CLICK": {
              actions: ["openFilePicker"]
            },
            "DROPZONE.FOCUS": "focused",
            "DROPZONE.DRAG_OVER": "dragging"
          }
        },
        focused: {
          on: {
            "DROPZONE.BLUR": "idle",
            OPEN: {
              actions: ["openFilePicker"]
            },
            "DROPZONE.CLICK": {
              actions: ["openFilePicker"]
            },
            "DROPZONE.DRAG_OVER": "dragging"
          }
        },
        dragging: {
          on: {
            "DROPZONE.DROP": {
              target: "idle",
              actions: ["setFilesFromEvent"]
            },
            "DROPZONE.DRAG_LEAVE": "idle"
          }
        }
      }
    },
    {
      activities: {
        preventDocumentDrop(ctx2) {
          if (!ctx2.preventDocumentDrop) return;
          if (!ctx2.allowDrop) return;
          if (ctx2.disabled) return;
          const doc = dom12.getDoc(ctx2);
          const onDragOver = (event) => {
            event == null ? void 0 : event.preventDefault();
          };
          const onDrop = (event) => {
            if (contains(dom12.getRootEl(ctx2), getEventTarget(event))) return;
            event.preventDefault();
          };
          return callAll2(addDomEvent(doc, "dragover", onDragOver, false), addDomEvent(doc, "drop", onDrop, false));
        }
      },
      actions: {
        syncInputElement(ctx2) {
          queueMicrotask(() => {
            const inputEl = dom12.getHiddenInputEl(ctx2);
            if (!inputEl) return;
            const win = dom12.getWin(ctx2);
            const dataTransfer = new win.DataTransfer();
            ctx2.acceptedFiles.forEach((v) => {
              dataTransfer.items.add(v);
            });
            inputEl.files = dataTransfer.files;
            inputEl.dispatchEvent(new win.Event("change", { bubbles: true }));
          });
        },
        openFilePicker(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom12.getHiddenInputEl(ctx2)) == null ? void 0 : _a8.click();
          });
        },
        setFilesFromEvent(ctx2, evt) {
          const result = getFilesFromEvent(ctx2, evt.files);
          const { acceptedFiles, rejectedFiles } = result;
          if (ctx2.multiple) {
            const files = ref([...ctx2.acceptedFiles, ...acceptedFiles]);
            set10.files(ctx2, files, rejectedFiles);
            return;
          }
          if (acceptedFiles.length) {
            const files = ref([acceptedFiles[0]]);
            set10.files(ctx2, files, rejectedFiles);
          } else if (rejectedFiles.length) {
            set10.files(ctx2, ctx2.acceptedFiles, rejectedFiles);
          }
        },
        removeFile(ctx2, evt) {
          const files = Array.from(ctx2.acceptedFiles.filter((file) => file !== evt.file));
          const rejectedFiles = Array.from(ctx2.rejectedFiles.filter((item) => item.file !== evt.file));
          ctx2.acceptedFiles = ref(files);
          ctx2.rejectedFiles = ref(rejectedFiles);
          invoke8.change(ctx2);
        },
        clearRejectedFiles(ctx2) {
          ctx2.rejectedFiles = ref([]);
          invoke8.change(ctx2);
        },
        clearFiles(ctx2) {
          ctx2.acceptedFiles = ref([]);
          ctx2.rejectedFiles = ref([]);
          invoke8.change(ctx2);
        }
      },
      compareFns: {
        acceptedFiles: (a2, b2) => a2.length === b2.length && a2.every((file, i) => isFileEqual(file, b2[i]))
      }
    }
  );
}
var invoke8 = {
  change: (ctx) => {
    var _a8;
    (_a8 = ctx.onFileChange) == null ? void 0 : _a8.call(ctx, {
      acceptedFiles: ctx.acceptedFiles,
      rejectedFiles: ctx.rejectedFiles
    });
  },
  accept: (ctx) => {
    var _a8;
    (_a8 = ctx.onFileAccept) == null ? void 0 : _a8.call(ctx, { files: ctx.acceptedFiles });
  },
  reject: (ctx) => {
    var _a8;
    (_a8 = ctx.onFileReject) == null ? void 0 : _a8.call(ctx, { files: ctx.rejectedFiles });
  }
};
var set10 = {
  files: (ctx, acceptedFiles, rejectedFiles) => {
    ctx.acceptedFiles = ref(acceptedFiles);
    invoke8.accept(ctx);
    if (rejectedFiles) {
      ctx.rejectedFiles = ref(rejectedFiles);
      invoke8.reject(ctx);
    }
    invoke8.change(ctx);
  }
};
var props11 = createProps()([
  "accept",
  "allowDrop",
  "capture",
  "dir",
  "directory",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "locale",
  "maxFiles",
  "maxFileSize",
  "minFileSize",
  "name",
  "invalid",
  "onFileAccept",
  "onFileReject",
  "onFileChange",
  "preventDocumentDrop",
  "required",
  "translations",
  "validate"
]);
var splitProps11 = createSplitProps(props11);
var itemProps3 = createProps()(["file"]);
var splitItemProps3 = createSplitProps(itemProps3);

// node_modules/@ark-ui/react/dist/components/file-upload/use-file-upload.js
var import_react348 = __toESM(require_react(), 1);
var useFileUpload = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react348.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    required: field == null ? void 0 : field.required,
    invalid: field == null ? void 0 : field.invalid,
    getRootNode,
    ...props34
  };
  const context = {
    ...initialContext,
    onFileAccept: useEvent(props34.onFileAccept),
    onFileReject: useEvent(props34.onFileReject),
    onFileChange: useEvent(props34.onFileChange, { sync: true })
  };
  const [state2, send] = useMachine(machine13(initialContext), { context });
  return connect13(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-root.js
var FileUploadRoot = (0, import_react350.forwardRef)((props34, ref2) => {
  const [useFileUploadProps, localProps] = createSplitProps2()(props34, [
    "accept",
    "allowDrop",
    "capture",
    "directory",
    "disabled",
    "id",
    "ids",
    "invalid",
    "locale",
    "maxFiles",
    "maxFileSize",
    "minFileSize",
    "name",
    "onFileAccept",
    "onFileChange",
    "onFileReject",
    "preventDocumentDrop",
    "required",
    "translations",
    "validate"
  ]);
  const fileUpload = useFileUpload(useFileUploadProps);
  const mergedProps = mergeProps2(fileUpload.getRootProps(), localProps);
  return (0, import_jsx_runtime163.jsx)(FileUploadProvider, { value: fileUpload, children: (0, import_jsx_runtime163.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
FileUploadRoot.displayName = "FileUploadRoot";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-root-provider.js
var import_jsx_runtime164 = __toESM(require_jsx_runtime(), 1);
var import_react352 = __toESM(require_react(), 1);
var FileUploadRootProvider = (0, import_react352.forwardRef)(
  (props34, ref2) => {
    const [{ value: fileUpload }, localProps] = createSplitProps2()(props34, [
      "value"
    ]);
    const mergedProps = mergeProps2(fileUpload.getRootProps(), localProps);
    return (0, import_jsx_runtime164.jsx)(FileUploadProvider, { value: fileUpload, children: (0, import_jsx_runtime164.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
FileUploadRootProvider.displayName = "FileUploadRootProvider";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-trigger.js
var import_jsx_runtime165 = __toESM(require_jsx_runtime(), 1);
var import_react354 = __toESM(require_react(), 1);
var FileUploadTrigger = (0, import_react354.forwardRef)(
  (props34, ref2) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps2(fileUpload.getTriggerProps(), props34);
    return (0, import_jsx_runtime165.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
FileUploadTrigger.displayName = "FileUploadTrigger";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload.js
var file_upload_exports = {};
__export(file_upload_exports, {
  ClearTrigger: () => FileUploadClearTrigger,
  Context: () => FileUploadContext,
  Dropzone: () => FileUploadDropzone,
  HiddenInput: () => FileUploadHiddenInput,
  Item: () => FileUploadItem,
  ItemDeleteTrigger: () => FileUploadItemDeleteTrigger,
  ItemGroup: () => FileUploadItemGroup,
  ItemName: () => FileUploadItemName,
  ItemPreview: () => FileUploadItemPreview,
  ItemPreviewImage: () => FileUploadItemPreviewImage,
  ItemSizeText: () => FileUploadItemSizeText,
  Label: () => FileUploadLabel,
  Root: () => FileUploadRoot,
  RootProvider: () => FileUploadRootProvider,
  Trigger: () => FileUploadTrigger
});

// node_modules/@ark-ui/react/dist/components/focus-trap/focus-trap.js
var import_jsx_runtime166 = __toESM(require_jsx_runtime(), 1);
var import_react355 = __toESM(require_react(), 1);
var FocusTrap2 = (0, import_react355.forwardRef)((props34, ref2) => {
  const localRef = (0, import_react355.useRef)(null);
  const [trapProps, localProps] = createSplitProps2()(props34, [
    "disabled",
    "onActivate",
    "onDeactivate",
    "initialFocus",
    "fallbackFocus",
    "returnFocusOnDeactivate",
    "setReturnFocus"
  ]);
  useSafeLayoutEffect2(() => {
    const node2 = localRef.current;
    if (!node2 || trapProps.disabled) return;
    return trapFocus(node2, trapProps);
  }, [ref2, trapProps]);
  return (0, import_jsx_runtime166.jsx)(ark.div, { ref: composeRefs(localRef, ref2), ...localProps });
});
FocusTrap2.displayName = "FocusTrap";

// node_modules/@ark-ui/react/dist/components/frame/frame.js
var import_jsx_runtime168 = __toESM(require_jsx_runtime(), 1);
var import_react358 = __toESM(require_react(), 1);
var import_react_dom2 = __toESM(require_react_dom(), 1);

// node_modules/@ark-ui/react/dist/providers/environment/environment-provider.js
var import_jsx_runtime167 = __toESM(require_jsx_runtime(), 1);
var import_react356 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/run-if-fn.js
var isFunction3 = (value) => typeof value === "function";
var runIfFn2 = (valueOrFn, ...args) => isFunction3(valueOrFn) ? valueOrFn(...args) : valueOrFn;

// node_modules/@ark-ui/react/dist/providers/environment/environment-provider.js
var EnvironmentProvider = (props34) => {
  const { value, children } = props34;
  const [spanRef, setSpanRef] = (0, import_react356.useState)();
  const getRootNode = (0, import_react356.useMemo)(() => {
    return () => runIfFn2(value) ?? (spanRef == null ? void 0 : spanRef.ownerDocument) ?? document;
  }, [value, spanRef]);
  const environment = (0, import_react356.useMemo)(
    () => ({
      getRootNode,
      getWindow: () => getWindow(getRootNode()),
      getDocument: () => getDocument(getRootNode())
    }),
    [getRootNode]
  );
  return (0, import_jsx_runtime167.jsxs)(EnvironmentContextProvider, { value: environment, children: [
    children,
    !value && (0, import_jsx_runtime167.jsx)("span", { hidden: true, ref: setSpanRef })
  ] });
};

// node_modules/@ark-ui/react/dist/components/frame/frame-content.js
var import_react357 = __toESM(require_react(), 1);
var FrameContent = (props34) => {
  const { onMount, onUnmount, children } = props34;
  const mountedRef = (0, import_react357.useRef)(false);
  const calledRef = (0, import_react357.useRef)(false);
  (0, import_react357.useEffect)(() => {
    if (!mountedRef.current && !calledRef.current) {
      onMount == null ? void 0 : onMount();
      mountedRef.current = true;
      calledRef.current = true;
    }
    return () => {
      if (mountedRef.current) {
        onUnmount == null ? void 0 : onUnmount();
        mountedRef.current = false;
      }
    };
  }, []);
  return children;
};

// node_modules/@ark-ui/react/dist/components/frame/frame.js
var resetStyle = "<style>*,*::before,*::after { margin: 0; padding: 0; box-sizing: border-box; }</style>";
var initialSrcDoc = `<html><head>${resetStyle}</head><body><div class="frame-root"></div></body></html>`;
function getMountNode(frame) {
  var _a8;
  const doc = (_a8 = frame.contentWindow) == null ? void 0 : _a8.document;
  if (!doc) return null;
  const mountNode = doc.body.querySelector(".frame-root") || doc.body;
  return mountNode;
}
var Frame = (0, import_react358.forwardRef)((props34, ref2) => {
  const { children, head, onMount, onUnmount, srcDoc = initialSrcDoc, ...rest } = props34;
  const [frameRef, setFrameRef] = (0, import_react358.useState)(null);
  const [mountNode, setMountNode] = (0, import_react358.useState)(null);
  useSafeLayoutEffect2(() => {
    var _a8;
    if (!frameRef) return;
    const doc = (_a8 = frameRef.contentWindow) == null ? void 0 : _a8.document;
    if (!doc) return;
    doc.open();
    doc.write(srcDoc);
    doc.close();
    setMountNode(getMountNode(frameRef));
  }, [frameRef, srcDoc]);
  (0, import_react358.useEffect)(() => {
    if (!frameRef || !frameRef.contentDocument) return;
    const win = frameRef.contentWindow;
    if (!win) return;
    const mountNode2 = getMountNode(frameRef);
    if (!mountNode2) return;
    const exec2 = () => {
      var _a8;
      const rootEl = (_a8 = frameRef.contentDocument) == null ? void 0 : _a8.documentElement;
      if (!rootEl) return;
      frameRef.style.setProperty("--width", `${mountNode2.scrollWidth}px`);
      frameRef.style.setProperty("--height", `${mountNode2.scrollHeight}px`);
    };
    const resizeObserver = new win.ResizeObserver(exec2);
    exec2();
    if (frameRef.contentDocument) {
      resizeObserver.observe(mountNode2);
    }
    return () => {
      resizeObserver.disconnect();
    };
  }, [frameRef]);
  return (0, import_jsx_runtime168.jsx)(EnvironmentProvider, { value: () => (frameRef == null ? void 0 : frameRef.contentDocument) ?? document, children: (0, import_jsx_runtime168.jsxs)(
    "iframe",
    {
      title: `frame:${(0, import_react358.useId)()}`,
      ref: composeRefs(ref2, setFrameRef),
      ...rest,
      children: [
        mountNode ? (0, import_react_dom2.createPortal)(
          (0, import_jsx_runtime168.jsx)(FrameContent, { onMount, onUnmount, children }),
          mountNode
        ) : null,
        head && frameRef ? (0, import_react_dom2.createPortal)(head, frameRef.contentDocument.head) : null
      ]
    }
  ) });
});

// node_modules/@ark-ui/react/dist/components/highlight/highlight.js
var import_jsx_runtime169 = __toESM(require_jsx_runtime(), 1);
var import_react360 = __toESM(require_react(), 1);

// node_modules/@zag-js/highlight-word/dist/index.mjs
var normalizeSpan = (spans, len) => {
  const result = [];
  const append2 = (start, end, match5) => {
    if (end - start > 0) result.push({ start, end, match: match5 });
  };
  if (spans.length === 0) {
    append2(0, len, false);
  } else {
    let lastIndex = 0;
    for (const chunk2 of spans) {
      append2(lastIndex, chunk2.start, false);
      append2(chunk2.start, chunk2.end, true);
      lastIndex = chunk2.end;
    }
    append2(lastIndex, len, false);
  }
  return result;
};
function highlightFirst(props34) {
  const { text, query: query2, ignoreCase } = props34;
  const searchText = ignoreCase ? text.toLowerCase() : text;
  const searchQuery = ignoreCase ? typeof query2 === "string" ? query2.toLowerCase() : query2 : query2;
  const start = typeof searchText === "string" ? searchText.indexOf(searchQuery) : -1;
  if (start === -1) {
    return [{ text, match: false }];
  }
  const end = start + searchQuery.length;
  const spans = [{ start, end }];
  return normalizeSpan(spans, text.length).map((chunk2) => ({
    text: text.slice(chunk2.start, chunk2.end),
    match: !!chunk2.match
  }));
}
var escapeRegexp = (term) => term.replace(/[|\\{}()[\]^$+*?.-]/g, (char2) => `\\${char2}`);
var buildRegex = (queryProp, flags) => {
  const query2 = queryProp.filter(Boolean).map((text) => escapeRegexp(text));
  return new RegExp(`(${query2.join("|")})`, flags);
};
var getRegexFlags = (ignoreCase, matchAll = true) => `${ignoreCase ? "i" : ""}${matchAll ? "g" : ""}`;
function highlightMultiple(props34) {
  const { text, query: query2, ignoreCase, matchAll } = props34;
  if (query2.length === 0) {
    return [{ text, match: false }];
  }
  const flags = getRegexFlags(ignoreCase, matchAll);
  const regex = buildRegex(Array.isArray(query2) ? query2 : [query2], flags);
  const spans = [...text.matchAll(regex)].map((match5) => ({
    start: match5.index || 0,
    end: (match5.index || 0) + match5[0].length
  }));
  return normalizeSpan(spans, props34.text.length).map((chunk2) => ({
    text: props34.text.slice(chunk2.start, chunk2.end),
    match: !!chunk2.match
  }));
}
var highlightWord = (props34) => {
  if (props34.matchAll == null) {
    props34.matchAll = Array.isArray(props34.query);
  }
  if (!props34.matchAll && Array.isArray(props34.query)) {
    throw new Error("matchAll must be true when using multiple queries");
  }
  return props34.matchAll ? highlightMultiple(props34) : highlightFirst(props34);
};

// node_modules/@ark-ui/react/dist/components/highlight/use-highlight.js
var import_react359 = __toESM(require_react(), 1);
var useHighlight = (props34) => {
  return (0, import_react359.useMemo)(() => highlightWord(props34), [props34]);
};

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-arrow.js
var import_jsx_runtime170 = __toESM(require_jsx_runtime(), 1);
var import_react362 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/hover-card/use-hover-card-context.js
var [HoverCardProvider, useHoverCardContext] = createContext3({
  name: "HoverCardContext",
  hookName: "useHoverCardContext",
  providerName: "<HoverCardProvider />"
});

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-arrow.js
var HoverCardArrow = (0, import_react362.forwardRef)((props34, ref2) => {
  const hoverCard = useHoverCardContext();
  const mergedProps = mergeProps2(hoverCard.getArrowProps(), props34);
  return (0, import_jsx_runtime170.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
HoverCardArrow.displayName = "HoverCardArrow";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-arrow-tip.js
var import_jsx_runtime171 = __toESM(require_jsx_runtime(), 1);
var import_react364 = __toESM(require_react(), 1);
var HoverCardArrowTip = (0, import_react364.forwardRef)(
  (props34, ref2) => {
    const hoverCard = useHoverCardContext();
    const mergedProps = mergeProps2(hoverCard.getArrowTipProps(), props34);
    return (0, import_jsx_runtime171.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
HoverCardArrowTip.displayName = "HoverCardArrowTip";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-content.js
var import_jsx_runtime172 = __toESM(require_jsx_runtime(), 1);
var import_react366 = __toESM(require_react(), 1);
var HoverCardContent = (0, import_react366.forwardRef)((props34, ref2) => {
  const hoverCard = useHoverCardContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(hoverCard.getContentProps(), presence.getPresenceProps(), props34);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime172.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
HoverCardContent.displayName = "HoverCardContent";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-context.js
var HoverCardContext = (props34) => props34.children(useHoverCardContext());

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-positioner.js
var import_jsx_runtime173 = __toESM(require_jsx_runtime(), 1);
var import_react368 = __toESM(require_react(), 1);
var HoverCardPositioner = (0, import_react368.forwardRef)(
  (props34, ref2) => {
    const hoverCard = useHoverCardContext();
    const mergedProps = mergeProps2(hoverCard.getPositionerProps(), props34);
    const presence = usePresenceContext();
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime173.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
HoverCardPositioner.displayName = "HoverCardPositioner";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-root.js
var import_jsx_runtime174 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/hover-card/dist/index.mjs
var anatomy13 = createAnatomy("hoverCard").parts("arrow", "arrowTip", "trigger", "positioner", "content");
var parts15 = anatomy13.build();
var dom13 = createScope({
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `hover-card:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `hover-card:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `hover-card:${ctx.id}:popper`;
  },
  getArrowId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.arrow) ?? `hover-card:${ctx.id}:arrow`;
  },
  getTriggerEl: (ctx) => dom13.getById(ctx, dom13.getTriggerId(ctx)),
  getContentEl: (ctx) => dom13.getById(ctx, dom13.getContentId(ctx)),
  getPositionerEl: (ctx) => dom13.getById(ctx, dom13.getPositionerId(ctx))
});
function connect14(state2, send, normalize3) {
  const open = state2.hasTag("open");
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: state2.context.currentPlacement
  });
  return {
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getArrowProps() {
      return normalize3.element({
        id: dom13.getArrowId(state2.context),
        ...parts15.arrow.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize3.element({
        ...parts15.arrowTip.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getTriggerProps() {
      return normalize3.element({
        ...parts15.trigger.attrs,
        dir: state2.context.dir,
        "data-placement": state2.context.currentPlacement,
        id: dom13.getTriggerId(state2.context),
        "data-state": open ? "open" : "closed",
        onPointerEnter(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_ENTER", src: "trigger" });
        },
        onPointerLeave(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_LEAVE", src: "trigger" });
        },
        onFocus() {
          send("TRIGGER_FOCUS");
        },
        onBlur() {
          send("TRIGGER_BLUR");
        }
      });
    },
    getPositionerProps() {
      return normalize3.element({
        id: dom13.getPositionerId(state2.context),
        ...parts15.positioner.attrs,
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize3.element({
        ...parts15.content.attrs,
        dir: state2.context.dir,
        id: dom13.getContentId(state2.context),
        hidden: !open,
        "data-state": open ? "open" : "closed",
        "data-placement": state2.context.currentPlacement,
        onPointerEnter(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_ENTER", src: "content" });
        },
        onPointerLeave(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_LEAVE", src: "content" });
        }
      });
    }
  };
}
var { not: not5, and: and6 } = guards;
function machine14(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "hover-card",
      initial: ctx.open ? "open" : "closed",
      context: {
        openDelay: 700,
        closeDelay: 300,
        currentPlacement: void 0,
        ...ctx,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        }
      },
      watch: {
        open: ["toggleVisibility"]
      },
      states: {
        closed: {
          tags: ["closed"],
          entry: ["clearIsPointer"],
          on: {
            "CONTROLLED.OPEN": "open",
            POINTER_ENTER: {
              target: "opening",
              actions: ["setIsPointer"]
            },
            TRIGGER_FOCUS: "opening",
            OPEN: "opening"
          }
        },
        opening: {
          tags: ["closed"],
          after: {
            OPEN_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            POINTER_LEAVE: [
              {
                guard: "isOpenControlled",
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["invokeOnClose", "toggleVisibility"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            TRIGGER_BLUR: [
              {
                guard: and6("isOpenControlled", not5("isPointer")),
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["invokeOnClose", "toggleVisibility"]
              },
              {
                guard: not5("isPointer"),
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["invokeOnClose", "toggleVisibility"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackDismissableElement", "trackPositioning"],
          on: {
            "CONTROLLED.CLOSE": "closed",
            POINTER_ENTER: {
              actions: ["setIsPointer"]
            },
            POINTER_LEAVE: "closing",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            TRIGGER_BLUR: [
              {
                guard: and6("isOpenControlled", not5("isPointer")),
                actions: ["invokeOnClose"]
              },
              {
                guard: not5("isPointer"),
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackPositioning"],
          after: {
            CLOSE_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          },
          on: {
            "CONTROLLED.CLOSE": "closed",
            "CONTROLLED.OPEN": "open",
            POINTER_ENTER: {
              target: "open",
              // no need to invokeOnOpen here because it's still open (but about to close)
              actions: ["setIsPointer"]
            }
          }
        }
      }
    },
    {
      delays: {
        OPEN_DELAY: (ctx2) => ctx2.openDelay,
        CLOSE_DELAY: (ctx2) => ctx2.closeDelay
      },
      guards: {
        isPointer: (ctx2) => !!ctx2.isPointer,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement || (ctx2.currentPlacement = ctx2.positioning.placement);
          const getPositionerEl = () => dom13.getPositionerEl(ctx2);
          return getPlacement(dom13.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom13.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            defer: true,
            exclude: [dom13.getTriggerEl(ctx2)],
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside" });
            },
            onFocusOutside(event) {
              event.preventDefault();
            }
          });
        }
      },
      actions: {
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        setIsPointer(ctx2) {
          ctx2.isPointer = true;
        },
        clearIsPointer(ctx2) {
          ctx2.isPointer = false;
        },
        reposition(ctx2, evt) {
          const getPositionerEl = () => dom13.getPositionerEl(ctx2);
          getPlacement(dom13.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, evt, { send }) {
          queueMicrotask(() => {
            send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
          });
        }
      }
    }
  );
}
var props12 = createProps()([
  "closeDelay",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onOpenChange",
  "open.controlled",
  "open",
  "openDelay",
  "positioning"
]);
var splitProps12 = createSplitProps(props12);

// node_modules/@ark-ui/react/dist/components/hover-card/use-hover-card.js
var import_react370 = __toESM(require_react(), 1);
var useHoverCard = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react370.useId)(),
    dir,
    getRootNode,
    open: props34.defaultOpen,
    "open.controlled": props34.open !== void 0,
    ...props34
  };
  const context = {
    ...initialContext,
    open: props34.open,
    onOpenChange: useEvent(props34.onOpenChange, { sync: true })
  };
  const [state2, send] = useMachine(machine14(initialContext), { context });
  return connect14(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-root.js
var HoverCardRoot = (props34) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props34);
  const hoverCard = useHoverCard(localProps);
  const presence = usePresence(mergeProps2({ present: hoverCard.open }, presenceProps));
  return (0, import_jsx_runtime174.jsx)(HoverCardProvider, { value: hoverCard, children: (0, import_jsx_runtime174.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-root-provider.js
var import_jsx_runtime175 = __toESM(require_jsx_runtime(), 1);
var HoverCardRootProvider = (props34) => {
  const [presenceProps, { value: hoverCard, children }] = splitPresenceProps(props34);
  const presence = usePresence(mergeProps2({ present: hoverCard.open }, presenceProps));
  return (0, import_jsx_runtime175.jsx)(HoverCardProvider, { value: hoverCard, children: (0, import_jsx_runtime175.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-trigger.js
var import_jsx_runtime176 = __toESM(require_jsx_runtime(), 1);
var import_react374 = __toESM(require_react(), 1);
var HoverCardTrigger = (0, import_react374.forwardRef)(
  (props34, ref2) => {
    const hoverCard = useHoverCardContext();
    const mergedProps = mergeProps2(hoverCard.getTriggerProps(), props34);
    return (0, import_jsx_runtime176.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
HoverCardTrigger.displayName = "HoverCardTrigger";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card.js
var hover_card_exports = {};
__export(hover_card_exports, {
  Arrow: () => HoverCardArrow,
  ArrowTip: () => HoverCardArrowTip,
  Content: () => HoverCardContent,
  Context: () => HoverCardContext,
  Positioner: () => HoverCardPositioner,
  Root: () => HoverCardRoot,
  RootProvider: () => HoverCardRootProvider,
  Trigger: () => HoverCardTrigger
});

// node_modules/@ark-ui/react/dist/components/menu/menu-arrow.js
var import_jsx_runtime177 = __toESM(require_jsx_runtime(), 1);
var import_react376 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/menu/use-menu-context.js
var [MenuProvider, useMenuContext] = createContext3({
  name: "MenuContext",
  hookName: "useMenuContext",
  providerName: "<MenuProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/menu/menu-arrow.js
var MenuArrow = (0, import_react376.forwardRef)((props34, ref2) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getArrowProps(), props34);
  return (0, import_jsx_runtime177.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuArrow.displayName = "MenuArrow";

// node_modules/@ark-ui/react/dist/components/menu/menu-arrow-tip.js
var import_jsx_runtime178 = __toESM(require_jsx_runtime(), 1);
var import_react378 = __toESM(require_react(), 1);
var MenuArrowTip = (0, import_react378.forwardRef)((props34, ref2) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getArrowTipProps(), props34);
  return (0, import_jsx_runtime178.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuArrowTip.displayName = "MenuArrowTip";

// node_modules/@ark-ui/react/dist/components/menu/menu-checkbox-item.js
var import_jsx_runtime179 = __toESM(require_jsx_runtime(), 1);
var import_react380 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/menu/use-menu-item-context.js
var [MenuItemProvider, useMenuItemContext] = createContext3({
  name: "MenuItemContext",
  hookName: "useMenuItemContext",
  providerName: "<MenuItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/menu/use-menu-option-item-props-context.js
var [MenuOptionItemPropsProvider, useMenuOptionItemPropsContext] = createContext3({
  name: "MenuOptionItemPropsContext",
  hookName: "useMenuOptionItemPropsContext",
  providerName: "<MenuOptionItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/menu/menu-checkbox-item.js
var MenuCheckboxItem = (0, import_react380.forwardRef)((props34, ref2) => {
  const [partialOptionItemProps, localProps] = createSplitProps2()(props34, [
    "checked",
    "closeOnSelect",
    "disabled",
    "onCheckedChange",
    "value",
    "valueText"
  ]);
  const optionItemProps2 = {
    ...partialOptionItemProps,
    type: "checkbox"
  };
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getOptionItemProps(optionItemProps2), localProps);
  const optionItemState = menu.getOptionItemState(optionItemProps2);
  return (0, import_jsx_runtime179.jsx)(MenuOptionItemPropsProvider, { value: optionItemProps2, children: (0, import_jsx_runtime179.jsx)(MenuItemProvider, { value: optionItemState, children: (0, import_jsx_runtime179.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
MenuCheckboxItem.displayName = "MenuCheckboxItem";

// node_modules/@ark-ui/react/dist/components/menu/menu-content.js
var import_jsx_runtime180 = __toESM(require_jsx_runtime(), 1);
var import_react382 = __toESM(require_react(), 1);
var MenuContent = (0, import_react382.forwardRef)((props34, ref2) => {
  const menu = useMenuContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(menu.getContentProps(), presence.getPresenceProps(), props34);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime180.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
MenuContent.displayName = "MenuContent";

// node_modules/@ark-ui/react/dist/components/menu/menu-context.js
var MenuContext = (props34) => props34.children(useMenuContext());

// node_modules/@ark-ui/react/dist/components/menu/menu-context-trigger.js
var import_jsx_runtime181 = __toESM(require_jsx_runtime(), 1);
var import_react384 = __toESM(require_react(), 1);
var MenuContextTrigger = (0, import_react384.forwardRef)(
  (props34, ref2) => {
    const menu = useMenuContext();
    const mergedProps = mergeProps2(menu.getContextTriggerProps(), props34);
    return (0, import_jsx_runtime181.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
MenuContextTrigger.displayName = "MenuContextTrigger";

// node_modules/@ark-ui/react/dist/components/menu/menu-indicator.js
var import_jsx_runtime182 = __toESM(require_jsx_runtime(), 1);
var import_react386 = __toESM(require_react(), 1);
var MenuIndicator = (0, import_react386.forwardRef)((props34, ref2) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getIndicatorProps(), props34);
  return (0, import_jsx_runtime182.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuIndicator.displayName = "MenuIndicator";

// node_modules/@ark-ui/react/dist/components/menu/menu-item.js
var import_jsx_runtime183 = __toESM(require_jsx_runtime(), 1);
var import_react388 = __toESM(require_react(), 1);
var MenuItem = (0, import_react388.forwardRef)((props34, ref2) => {
  const [itemProps12, localProps] = createSplitProps2()(props34, [
    "closeOnSelect",
    "disabled",
    "value",
    "valueText"
  ]);
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getItemProps(itemProps12), localProps);
  const itemState = menu.getItemState(itemProps12);
  return (0, import_jsx_runtime183.jsx)(MenuItemProvider, { value: itemState, children: (0, import_jsx_runtime183.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
MenuItem.displayName = "MenuItem";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-context.js
var MenuItemContext = (props34) => props34.children(useMenuItemContext());

// node_modules/@ark-ui/react/dist/components/menu/menu-item-group.js
var import_jsx_runtime184 = __toESM(require_jsx_runtime(), 1);
var import_react390 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/menu/use-menu-item-group-context.js
var [MenuItemGroupProvider, useMenuItemGroupContext] = createContext3({
  name: "MenuItemGroupContext",
  hookName: "useMenuItemGroupContext",
  providerName: "<MenuItemGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/menu/menu-item-group.js
var MenuItemGroup = (0, import_react390.forwardRef)((props34, ref2) => {
  const [optionalItemGroupProps, localProps] = createSplitProps2()(props34, [
    "id"
  ]);
  const menu = useMenuContext();
  const id = (0, import_react390.useId)();
  const itemGroupProps3 = { id, ...optionalItemGroupProps };
  const mergedProps = mergeProps2(menu.getItemGroupProps(itemGroupProps3), localProps);
  return (0, import_jsx_runtime184.jsx)(MenuItemGroupProvider, { value: itemGroupProps3, children: (0, import_jsx_runtime184.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
MenuItemGroup.displayName = "MenuItemGroup";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-group-label.js
var import_jsx_runtime185 = __toESM(require_jsx_runtime(), 1);
var import_react392 = __toESM(require_react(), 1);
var MenuItemGroupLabel = (0, import_react392.forwardRef)(
  (props34, ref2) => {
    const menu = useMenuContext();
    const itemGroup = useMenuItemGroupContext();
    const mergedProps = mergeProps2(menu.getItemGroupLabelProps({ htmlFor: itemGroup.id }), props34);
    return (0, import_jsx_runtime185.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
MenuItemGroupLabel.displayName = "MenuItemGroupLabel";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-indicator.js
var import_jsx_runtime186 = __toESM(require_jsx_runtime(), 1);
var import_react394 = __toESM(require_react(), 1);
var MenuItemIndicator = (0, import_react394.forwardRef)(
  (props34, ref2) => {
    const menu = useMenuContext();
    const optionItemProps2 = useMenuOptionItemPropsContext();
    const mergedProps = mergeProps2(menu.getItemIndicatorProps(optionItemProps2), props34);
    return (0, import_jsx_runtime186.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
MenuItemIndicator.displayName = "MenuItemIndicator";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-text.js
var import_jsx_runtime187 = __toESM(require_jsx_runtime(), 1);
var import_react396 = __toESM(require_react(), 1);
var MenuItemText = (0, import_react396.forwardRef)((props34, ref2) => {
  const menu = useMenuContext();
  const optionItemProps2 = useMenuOptionItemPropsContext();
  const mergedProps = mergeProps2(menu.getItemTextProps(optionItemProps2), props34);
  return (0, import_jsx_runtime187.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuItemText.displayName = "MenuItemText";

// node_modules/@ark-ui/react/dist/components/menu/menu-positioner.js
var import_jsx_runtime188 = __toESM(require_jsx_runtime(), 1);
var import_react398 = __toESM(require_react(), 1);
var MenuPositioner = (0, import_react398.forwardRef)((props34, ref2) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getPositionerProps(), props34);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime188.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuPositioner.displayName = "MenuPositioner";

// node_modules/@ark-ui/react/dist/components/menu/menu-radio-item.js
var import_jsx_runtime189 = __toESM(require_jsx_runtime(), 1);
var import_react400 = __toESM(require_react(), 1);
var MenuRadioItem = (0, import_react400.forwardRef)((props34, ref2) => {
  const [partialItemProps, localProps] = createSplitProps2()(props34, [
    "closeOnSelect",
    "disabled",
    "value",
    "valueText"
  ]);
  const menu = useMenuContext();
  const itemGroup = useMenuItemGroupContext();
  const optionItemProps2 = {
    ...partialItemProps,
    checked: itemGroup.value === partialItemProps.value,
    type: "radio",
    onCheckedChange: () => {
      var _a8;
      return (_a8 = itemGroup.onValueChange) == null ? void 0 : _a8.call(itemGroup, { value: partialItemProps.value });
    }
  };
  const mergedProps = mergeProps2(menu.getOptionItemProps(optionItemProps2), localProps);
  const optionItemState = menu.getOptionItemState(optionItemProps2);
  return (0, import_jsx_runtime189.jsx)(MenuOptionItemPropsProvider, { value: optionItemProps2, children: (0, import_jsx_runtime189.jsx)(MenuItemProvider, { value: optionItemState, children: (0, import_jsx_runtime189.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
MenuRadioItem.displayName = "MenuRadioItem";

// node_modules/@ark-ui/react/dist/components/menu/menu-radio-item-group.js
var import_jsx_runtime190 = __toESM(require_jsx_runtime(), 1);
var import_react402 = __toESM(require_react(), 1);
var MenuRadioItemGroup = (0, import_react402.forwardRef)(
  (props34, ref2) => {
    const [optionalItemGroupProps, localProps] = createSplitProps2()(props34, ["id", "onValueChange", "value"]);
    const menu = useMenuContext();
    const id = (0, import_react402.useId)();
    const itemGroupProps3 = { id, ...optionalItemGroupProps };
    const mergedProps = mergeProps2(menu.getItemGroupProps({ id: itemGroupProps3.id }), localProps);
    return (0, import_jsx_runtime190.jsx)(MenuItemGroupProvider, { value: itemGroupProps3, children: (0, import_jsx_runtime190.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
MenuRadioItemGroup.displayName = "MenuRadioItemGroup";

// node_modules/@ark-ui/react/dist/components/menu/menu-root.js
var import_jsx_runtime191 = __toESM(require_jsx_runtime(), 1);
var import_react407 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/use-effect-once.js
var import_react403 = __toESM(require_react(), 1);
var useEffectOnce = (cb) => {
  const savedCallback = (0, import_react403.useRef)(cb);
  const effectGuard = (0, import_react403.useRef)(false);
  (0, import_react403.useEffect)(() => {
    savedCallback.current = cb;
  });
  (0, import_react403.useEffect)(() => {
    if (effectGuard.current !== true) {
      effectGuard.current = true;
      savedCallback.current();
    }
  }, []);
};

// node_modules/@zag-js/rect-utils/dist/index.mjs
var createPoint = (x, y) => ({ x, y });
function createRect(r) {
  const { x, y, width, height } = r;
  const midX = x + width / 2;
  const midY = y + height / 2;
  return {
    x,
    y,
    width,
    height,
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height,
    midX,
    midY,
    center: createPoint(midX, midY)
  };
}
function getRectCorners(v) {
  const top = createPoint(v.minX, v.minY);
  const right = createPoint(v.maxX, v.minY);
  const bottom = createPoint(v.maxX, v.maxY);
  const left = createPoint(v.minX, v.maxY);
  return { top, right, bottom, left };
}
var { min: min3, max: max3 } = Math;
function getElementPolygon(rectValue, placement) {
  const rect = createRect(rectValue);
  const { top, right, left, bottom } = getRectCorners(rect);
  const [base] = placement.split("-");
  return {
    top: [left, top, right, bottom],
    right: [top, right, bottom, left],
    bottom: [top, left, bottom, right],
    left: [right, top, left, bottom]
  }[base];
}
function isPointInPolygon(polygon, point) {
  const { x, y } = point;
  let c = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {
      c = !c;
    }
  }
  return c;
}
var { sign: sign2, abs: abs3, min: min22 } = Math;

// node_modules/@zag-js/menu/dist/index.mjs
var anatomy14 = createAnatomy("menu").parts(
  "arrow",
  "arrowTip",
  "content",
  "contextTrigger",
  "indicator",
  "item",
  "itemGroup",
  "itemGroupLabel",
  "itemIndicator",
  "itemText",
  "positioner",
  "separator",
  "trigger",
  "triggerItem"
);
var parts16 = anatomy14.build();
var dom14 = createScope({
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `menu:${ctx.id}:trigger`;
  },
  getContextTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.contextTrigger) ?? `menu:${ctx.id}:ctx-trigger`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `menu:${ctx.id}:content`;
  },
  getArrowId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.arrow) ?? `menu:${ctx.id}:arrow`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `menu:${ctx.id}:popper`;
  },
  getGroupId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.group) == null ? void 0 : _b7.call(_a8, id)) ?? `menu:${ctx.id}:group:${id}`;
  },
  getGroupLabelId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.groupLabel) == null ? void 0 : _b7.call(_a8, id)) ?? `menu:${ctx.id}:group-label:${id}`;
  },
  getContentEl: (ctx) => dom14.getById(ctx, dom14.getContentId(ctx)),
  getPositionerEl: (ctx) => dom14.getById(ctx, dom14.getPositionerId(ctx)),
  getTriggerEl: (ctx) => dom14.getById(ctx, dom14.getTriggerId(ctx)),
  getHighlightedItemEl: (ctx) => ctx.highlightedValue ? dom14.getById(ctx, ctx.highlightedValue) : null,
  getArrowEl: (ctx) => dom14.getById(ctx, dom14.getArrowId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom14.getContentId(ctx));
    const selector = `[role^="menuitem"][data-ownedby=${ownerId}]:not([data-disabled])`;
    return queryAll(dom14.getContentEl(ctx), selector);
  },
  getFirstEl: (ctx) => first(dom14.getElements(ctx)),
  getLastEl: (ctx) => last(dom14.getElements(ctx)),
  getNextEl: (ctx, loop) => nextById(dom14.getElements(ctx), ctx.highlightedValue, loop ?? ctx.loopFocus),
  getPrevEl: (ctx, loop) => prevById(dom14.getElements(ctx), ctx.highlightedValue, loop ?? ctx.loopFocus),
  getElemByKey: (ctx, key) => getByTypeahead(dom14.getElements(ctx), { state: ctx.typeaheadState, key, activeId: ctx.highlightedValue }),
  isTargetDisabled: (v) => {
    return isHTMLElement(v) && (v.dataset.disabled === "" || v.hasAttribute("disabled"));
  },
  isTriggerItem: (el) => {
    var _a8;
    return !!((_a8 = el == null ? void 0 : el.getAttribute("role")) == null ? void 0 : _a8.startsWith("menuitem")) && !!(el == null ? void 0 : el.hasAttribute("aria-controls"));
  },
  getOptionFromItemEl(el) {
    return {
      id: el.id,
      name: el.dataset.name,
      value: el.dataset.value,
      valueText: el.dataset.valueText,
      type: el.dataset.type
    };
  }
});
function connect15(state2, send, normalize3) {
  const isSubmenu = state2.context.isSubmenu;
  const isTypingAhead = state2.context.isTypingAhead;
  const composite = state2.context.composite;
  const open = state2.hasTag("open");
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: state2.context.anchorPoint ? "bottom" : state2.context.currentPlacement
  });
  function getItemState(props210) {
    return {
      disabled: !!props210.disabled,
      highlighted: state2.context.highlightedValue === props210.value
    };
  }
  function getOptionItemProps(props210) {
    const valueText = props210.valueText ?? props210.value;
    return { ...props210, id: props210.value, valueText };
  }
  function getOptionItemState(props210) {
    const itemState = getItemState(getOptionItemProps(props210));
    return {
      ...itemState,
      checked: !!props210.checked
    };
  }
  function getItemProps(props210) {
    const { value: id, closeOnSelect, valueText } = props210;
    const itemState = getItemState(props210);
    return normalize3.element({
      ...parts16.item.attrs,
      id,
      role: "menuitem",
      "aria-disabled": itemState.disabled,
      "data-disabled": dataAttr(itemState.disabled),
      "data-ownedby": dom14.getContentId(state2.context),
      "data-highlighted": dataAttr(itemState.highlighted),
      "data-valuetext": valueText,
      onDragStart(event) {
        const isLink = event.currentTarget.matches("a[href]");
        if (isLink) event.preventDefault();
      },
      onPointerMove(event) {
        if (itemState.disabled) return;
        if (event.pointerType !== "mouse") return;
        const target = event.currentTarget;
        if (itemState.highlighted) return;
        send({ type: "ITEM_POINTERMOVE", id, target, closeOnSelect });
      },
      onPointerLeave(event) {
        if (itemState.disabled) return;
        if (event.pointerType !== "mouse") return;
        const pointerMoved = state2.previousEvent.type.includes("POINTER");
        if (!pointerMoved) return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERLEAVE", id, target, closeOnSelect });
      },
      onPointerDown(event) {
        if (itemState.disabled) return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERDOWN", target, id, closeOnSelect });
      },
      onClick(event) {
        if (isDownloadingEvent(event)) return;
        if (isOpeningInNewTab(event)) return;
        if (itemState.disabled) return;
        const target = event.currentTarget;
        send({ type: "ITEM_CLICK", target, id, closeOnSelect });
      }
    });
  }
  return {
    highlightedValue: state2.context.highlightedValue,
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    setHighlightedValue(value) {
      send({ type: "HIGHLIGHTED.SET", id: value });
    },
    setParent(parent) {
      send({ type: "PARENT.SET", value: parent, id: parent.state.context.id });
    },
    setChild(child) {
      send({ type: "CHILD.SET", value: child, id: child.state.context.id });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getContextTriggerProps() {
      return normalize3.element({
        ...parts16.contextTrigger.attrs,
        dir: state2.context.dir,
        id: dom14.getContextTriggerId(state2.context),
        onPointerDown(event) {
          if (event.pointerType === "mouse") return;
          const point = getEventPoint(event);
          send({ type: "CONTEXT_MENU_START", point });
        },
        onPointerCancel(event) {
          if (event.pointerType === "mouse") return;
          send("CONTEXT_MENU_CANCEL");
        },
        onPointerMove(event) {
          if (event.pointerType === "mouse") return;
          send("CONTEXT_MENU_CANCEL");
        },
        onPointerUp(event) {
          if (event.pointerType === "mouse") return;
          send("CONTEXT_MENU_CANCEL");
        },
        onContextMenu(event) {
          const point = getEventPoint(event);
          send({ type: "CONTEXT_MENU", point });
          event.preventDefault();
        },
        style: {
          WebkitTouchCallout: "none",
          WebkitUserSelect: "none",
          userSelect: "none"
        }
      });
    },
    getTriggerItemProps(childApi) {
      return mergeProps2(
        getItemProps({ value: childApi.getTriggerProps().id }),
        childApi.getTriggerProps()
      );
    },
    getTriggerProps() {
      return normalize3.button({
        ...isSubmenu ? parts16.triggerItem.attrs : parts16.trigger.attrs,
        "data-placement": state2.context.currentPlacement,
        type: "button",
        dir: state2.context.dir,
        id: dom14.getTriggerId(state2.context),
        "data-uid": state2.context.id,
        "aria-haspopup": composite ? "menu" : "dialog",
        "aria-controls": dom14.getContentId(state2.context),
        "aria-expanded": open || void 0,
        "data-state": open ? "open" : "closed",
        onPointerMove(event) {
          if (event.pointerType !== "mouse") return;
          const disabled = dom14.isTargetDisabled(event.currentTarget);
          if (disabled || !isSubmenu) return;
          send({ type: "TRIGGER_POINTERMOVE", target: event.currentTarget });
        },
        onPointerLeave(event) {
          if (dom14.isTargetDisabled(event.currentTarget)) return;
          if (event.pointerType !== "mouse") return;
          if (!isSubmenu) return;
          const point = getEventPoint(event);
          send({ type: "TRIGGER_POINTERLEAVE", target: event.currentTarget, point });
        },
        onPointerDown(event) {
          if (dom14.isTargetDisabled(event.currentTarget)) return;
          if (isContextMenuEvent(event)) return;
          event.preventDefault();
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (dom14.isTargetDisabled(event.currentTarget)) return;
          send({ type: "TRIGGER_CLICK", target: event.currentTarget });
        },
        onBlur() {
          send("TRIGGER_BLUR");
        },
        onFocus() {
          send("TRIGGER_FOCUS");
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          const keyMap2 = {
            ArrowDown() {
              send("ARROW_DOWN");
            },
            ArrowUp() {
              send("ARROW_UP");
            },
            Enter() {
              send({ type: "ARROW_DOWN", src: "enter" });
            },
            Space() {
              send({ type: "ARROW_DOWN", src: "space" });
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            event.preventDefault();
            exec2(event);
          }
        }
      });
    },
    getIndicatorProps() {
      return normalize3.element({
        ...parts16.indicator.attrs,
        dir: state2.context.dir,
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize3.element({
        ...parts16.positioner.attrs,
        dir: state2.context.dir,
        id: dom14.getPositionerId(state2.context),
        style: popperStyles.floating
      });
    },
    getArrowProps() {
      return normalize3.element({
        id: dom14.getArrowId(state2.context),
        ...parts16.arrow.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize3.element({
        ...parts16.arrowTip.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getContentProps() {
      return normalize3.element({
        ...parts16.content.attrs,
        id: dom14.getContentId(state2.context),
        "aria-label": state2.context["aria-label"],
        hidden: !open,
        "data-state": open ? "open" : "closed",
        role: composite ? "menu" : "dialog",
        tabIndex: 0,
        dir: state2.context.dir,
        "aria-activedescendant": state2.context.highlightedValue ?? void 0,
        "aria-labelledby": dom14.getTriggerId(state2.context),
        "data-placement": state2.context.currentPlacement,
        onPointerEnter(event) {
          if (event.pointerType !== "mouse") return;
          send("MENU_POINTERENTER");
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!isSelfTarget(event)) return;
          const target = getEventTarget(event);
          const sameMenu = (target == null ? void 0 : target.closest("[role=menu]")) === event.currentTarget || target === event.currentTarget;
          if (!sameMenu) return;
          if (event.key === "Tab") {
            const valid = isValidTabEvent(event);
            if (!valid) {
              event.preventDefault();
              return;
            }
          }
          const item = dom14.getHighlightedItemEl(state2.context);
          const keyMap2 = {
            ArrowDown() {
              send("ARROW_DOWN");
            },
            ArrowUp() {
              send("ARROW_UP");
            },
            ArrowLeft() {
              send("ARROW_LEFT");
            },
            ArrowRight() {
              send("ARROW_RIGHT");
            },
            Enter() {
              send("ENTER");
              if (isAnchorElement(item)) {
                state2.context.navigate({ value: state2.context.highlightedValue, node: item });
              }
            },
            Space(event2) {
              var _a8;
              if (isTypingAhead) {
                send({ type: "TYPEAHEAD", key: event2.key });
              } else {
                (_a8 = keyMap2.Enter) == null ? void 0 : _a8.call(keyMap2, event2);
              }
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            }
          };
          const key = getEventKey(event, { dir: state2.context.dir });
          const exec2 = keyMap2[key];
          if (exec2) {
            exec2(event);
            event.stopPropagation();
            event.preventDefault();
            return;
          }
          if (!state2.context.typeahead) return;
          if (!isPrintableKey(event)) return;
          if (isModifierKey(event)) return;
          if (isEditableElement(target)) return;
          send({ type: "TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      });
    },
    getSeparatorProps() {
      return normalize3.element({
        ...parts16.separator.attrs,
        role: "separator",
        dir: state2.context.dir,
        "aria-orientation": "horizontal"
      });
    },
    getItemState,
    getItemProps,
    getOptionItemState,
    getOptionItemProps(props210) {
      const { type, disabled, onCheckedChange, closeOnSelect } = props210;
      const option = getOptionItemProps(props210);
      const itemState = getOptionItemState(props210);
      return {
        ...getItemProps(option),
        ...normalize3.element({
          "data-type": type,
          ...parts16.item.attrs,
          dir: state2.context.dir,
          "data-value": option.value,
          role: `menuitem${type}`,
          "aria-checked": !!itemState.checked,
          "data-state": itemState.checked ? "checked" : "unchecked",
          onClick(event) {
            if (disabled) return;
            if (isDownloadingEvent(event)) return;
            if (isOpeningInNewTab(event)) return;
            const target = event.currentTarget;
            send({ type: "ITEM_CLICK", target, option, closeOnSelect });
            onCheckedChange == null ? void 0 : onCheckedChange(!itemState.checked);
          }
        })
      };
    },
    getItemIndicatorProps(props210) {
      const itemState = getOptionItemState(props210);
      return normalize3.element({
        ...parts16.itemIndicator.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-state": itemState.checked ? "checked" : "unchecked",
        hidden: !itemState.checked
      });
    },
    getItemTextProps(props210) {
      const itemState = getOptionItemState(props210);
      return normalize3.element({
        ...parts16.itemText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-state": itemState.checked ? "checked" : "unchecked"
      });
    },
    getItemGroupLabelProps(props210) {
      return normalize3.element({
        id: dom14.getGroupLabelId(state2.context, props210.htmlFor),
        dir: state2.context.dir,
        ...parts16.itemGroupLabel.attrs
      });
    },
    getItemGroupProps(props210) {
      return normalize3.element({
        id: dom14.getGroupId(state2.context, props210.id),
        ...parts16.itemGroup.attrs,
        dir: state2.context.dir,
        "aria-labelledby": dom14.getGroupLabelId(state2.context, props210.id),
        role: "group"
      });
    }
  };
}
var { not: not6, and: and7, or: or2 } = guards;
function machine15(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "menu",
      initial: ctx.open ? "open" : "idle",
      context: {
        highlightedValue: null,
        loopFocus: false,
        anchorPoint: null,
        closeOnSelect: true,
        typeahead: true,
        composite: true,
        navigate(details) {
          clickIfLink(details.node);
        },
        ...ctx,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        },
        intentPolygon: null,
        parent: null,
        lastHighlightedValue: null,
        children: cast(ref({})),
        suspendPointer: false,
        typeaheadState: getByTypeahead.defaultOptions
      },
      computed: {
        isSubmenu: (ctx2) => ctx2.parent !== null,
        isRtl: (ctx2) => ctx2.dir === "rtl",
        isTypingAhead: (ctx2) => ctx2.typeaheadState.keysSoFar !== ""
      },
      watch: {
        isSubmenu: "setSubmenuPlacement",
        anchorPoint: "reposition",
        open: "toggleVisibility"
      },
      on: {
        "PARENT.SET": {
          actions: "setParentMenu"
        },
        "CHILD.SET": {
          actions: "setChildMenu"
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: "invokeOnOpen"
          },
          {
            target: "open",
            actions: "invokeOnOpen"
          }
        ],
        OPEN_AUTOFOCUS: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            internal: true,
            target: "open",
            actions: ["highlightFirstItem", "invokeOnOpen"]
          }
        ],
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: "invokeOnClose"
          },
          {
            target: "closed",
            actions: "invokeOnClose"
          }
        ],
        "HIGHLIGHTED.RESTORE": {
          actions: "restoreHighlightedItem"
        },
        "HIGHLIGHTED.SET": {
          actions: "setHighlightedItem"
        }
      },
      states: {
        idle: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            CONTEXT_MENU_START: {
              target: "opening:contextmenu",
              actions: "setAnchorPoint"
            },
            CONTEXT_MENU: [
              {
                guard: "isOpenControlled",
                actions: ["setAnchorPoint", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setAnchorPoint", "invokeOnOpen"]
              }
            ],
            TRIGGER_CLICK: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: "invokeOnOpen"
              }
            ],
            TRIGGER_FOCUS: {
              guard: not6("isSubmenu"),
              target: "closed"
            },
            TRIGGER_POINTERMOVE: {
              guard: "isSubmenu",
              target: "opening"
            }
          }
        },
        "opening:contextmenu": {
          tags: ["closed"],
          after: {
            LONG_PRESS_DELAY: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: "invokeOnOpen"
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            CONTEXT_MENU_CANCEL: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "closed",
                actions: "invokeOnClose"
              }
            ]
          }
        },
        opening: {
          tags: ["closed"],
          after: {
            SUBMENU_OPEN_DELAY: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: "invokeOnOpen"
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            BLUR: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "closed",
                actions: "invokeOnClose"
              }
            ],
            TRIGGER_POINTERLEAVE: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "closed",
                actions: "invokeOnClose"
              }
            ]
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackPointerMove", "trackInteractOutside"],
          after: {
            SUBMENU_CLOSE_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["focusParentMenu", "restoreParentHighlightedItem", "invokeOnClose"]
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": {
              target: "closed",
              actions: ["focusParentMenu", "restoreParentHighlightedItem"]
            },
            // don't invoke on open here since the menu is still open (we're only keeping it open)
            MENU_POINTERENTER: {
              target: "open",
              actions: "clearIntentPolygon"
            },
            POINTER_MOVED_AWAY_FROM_SUBMENU: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "closed",
                actions: ["focusParentMenu", "restoreParentHighlightedItem"]
              }
            ]
          }
        },
        closed: {
          tags: ["closed"],
          entry: ["clearHighlightedItem", "focusTrigger", "resumePointer"],
          on: {
            "CONTROLLED.OPEN": [
              {
                guard: or2("isOpenAutoFocusEvent", "isArrowDownEvent"),
                target: "open",
                actions: "highlightFirstItem"
              },
              {
                guard: "isArrowUpEvent",
                target: "open",
                actions: "highlightLastItem"
              },
              {
                target: "open"
              }
            ],
            CONTEXT_MENU_START: {
              target: "opening:contextmenu",
              actions: "setAnchorPoint"
            },
            CONTEXT_MENU: [
              {
                guard: "isOpenControlled",
                actions: ["setAnchorPoint", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setAnchorPoint", "invokeOnOpen"]
              }
            ],
            TRIGGER_CLICK: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: "invokeOnOpen"
              }
            ],
            TRIGGER_POINTERMOVE: {
              guard: "isTriggerItem",
              target: "opening"
            },
            TRIGGER_BLUR: "idle",
            ARROW_DOWN: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: ["highlightFirstItem", "invokeOnOpen"]
              }
            ],
            ARROW_UP: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: ["highlightLastItem", "invokeOnOpen"]
              }
            ]
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackInteractOutside", "trackPositioning", "scrollToHighlightedItem"],
          entry: ["focusMenu", "resumePointer"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                target: "closed",
                guard: "isArrowLeftEvent",
                actions: ["focusParentMenu"]
              },
              {
                target: "closed"
              }
            ],
            TRIGGER_CLICK: [
              {
                guard: and7(not6("isTriggerItem"), "isOpenControlled"),
                actions: "invokeOnClose"
              },
              {
                guard: not6("isTriggerItem"),
                target: "closed",
                actions: "invokeOnClose"
              }
            ],
            ARROW_UP: {
              actions: ["highlightPrevItem", "focusMenu"]
            },
            ARROW_DOWN: {
              actions: ["highlightNextItem", "focusMenu"]
            },
            ARROW_LEFT: [
              {
                guard: and7("isSubmenu", "isOpenControlled"),
                actions: "invokeOnClose"
              },
              {
                guard: "isSubmenu",
                target: "closed",
                actions: ["focusParentMenu", "invokeOnClose"]
              }
            ],
            HOME: {
              actions: ["highlightFirstItem", "focusMenu"]
            },
            END: {
              actions: ["highlightLastItem", "focusMenu"]
            },
            ARROW_RIGHT: {
              guard: "isTriggerItemHighlighted",
              actions: "openSubmenu"
            },
            ENTER: [
              {
                guard: "isTriggerItemHighlighted",
                actions: "openSubmenu"
              },
              {
                actions: "clickHighlightedItem"
              }
            ],
            ITEM_POINTERMOVE: [
              {
                guard: not6("suspendPointer"),
                actions: ["setHighlightedItem", "focusMenu"]
              },
              {
                actions: "setLastHighlightedItem"
              }
            ],
            ITEM_POINTERLEAVE: {
              guard: and7(not6("suspendPointer"), not6("isTriggerItem")),
              actions: "clearHighlightedItem"
            },
            ITEM_CLICK: [
              // == grouped ==
              {
                guard: and7(
                  not6("isTriggerItemHighlighted"),
                  not6("isHighlightedItemEditable"),
                  "closeOnSelect",
                  "isOpenControlled"
                ),
                actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
              },
              {
                guard: and7(not6("isTriggerItemHighlighted"), not6("isHighlightedItemEditable"), "closeOnSelect"),
                target: "closed",
                actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
              },
              //
              {
                guard: and7(not6("isTriggerItemHighlighted"), not6("isHighlightedItemEditable")),
                actions: ["invokeOnSelect", "setOptionState"]
              },
              { actions: "setHighlightedItem" }
            ],
            TRIGGER_POINTERLEAVE: {
              target: "closing",
              actions: "setIntentPolygon"
            },
            ITEM_POINTERDOWN: {
              actions: "setHighlightedItem"
            },
            TYPEAHEAD: {
              actions: "highlightMatchedItem"
            },
            FOCUS_MENU: {
              actions: "focusMenu"
            },
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        }
      }
    },
    {
      delays: {
        LONG_PRESS_DELAY: 700,
        SUBMENU_OPEN_DELAY: 100,
        SUBMENU_CLOSE_DELAY: 100
      },
      guards: {
        closeOnSelect: (ctx2, evt) => !!((evt == null ? void 0 : evt.closeOnSelect) ?? ctx2.closeOnSelect),
        // whether the trigger is also a menu item
        isTriggerItem: (_ctx, evt) => dom14.isTriggerItem(evt.target),
        // whether the trigger item is the active item
        isTriggerItemHighlighted: (ctx2, evt) => {
          const target = evt.target ?? dom14.getHighlightedItemEl(ctx2);
          return !!(target == null ? void 0 : target.hasAttribute("aria-controls"));
        },
        isSubmenu: (ctx2) => ctx2.isSubmenu,
        suspendPointer: (ctx2) => ctx2.suspendPointer,
        isHighlightedItemEditable: (ctx2) => isEditableElement(dom14.getHighlightedItemEl(ctx2)),
        isWithinPolygon: (ctx2, evt) => {
          if (!ctx2.intentPolygon) return false;
          return isPointInPolygon(ctx2.intentPolygon, evt.point);
        },
        // guard assertions (for controlled mode)
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        isArrowLeftEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "ARROW_LEFT";
        },
        isArrowUpEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "ARROW_UP";
        },
        isArrowDownEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "ARROW_DOWN";
        },
        isOpenAutoFocusEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "OPEN_AUTOFOCUS";
        }
      },
      activities: {
        trackPositioning(ctx2) {
          if (ctx2.anchorPoint) return;
          ctx2.currentPlacement = ctx2.positioning.placement;
          const getPositionerEl = () => dom14.getPositionerEl(ctx2);
          return getPlacement(dom14.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackInteractOutside(ctx2, _evt, { send }) {
          const getContentEl = () => dom14.getContentEl(ctx2);
          let restoreFocus = true;
          return trackDismissableElement(getContentEl, {
            defer: true,
            exclude: [dom14.getTriggerEl(ctx2)],
            onInteractOutside: ctx2.onInteractOutside,
            onFocusOutside: ctx2.onFocusOutside,
            onEscapeKeyDown(event) {
              var _a8;
              (_a8 = ctx2.onEscapeKeyDown) == null ? void 0 : _a8.call(ctx2, event);
              if (ctx2.isSubmenu) event.preventDefault();
              closeRootMenu(ctx2);
            },
            onPointerDownOutside(event) {
              var _a8;
              restoreFocus = !event.detail.focusable;
              (_a8 = ctx2.onPointerDownOutside) == null ? void 0 : _a8.call(ctx2, event);
            },
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside", restoreFocus });
            }
          });
        },
        trackPointerMove(ctx2, _evt, { guards: guards2, send }) {
          const { isWithinPolygon } = guards2;
          ctx2.parent.state.context.suspendPointer = true;
          const doc = dom14.getDoc(ctx2);
          return addDomEvent(doc, "pointermove", (e) => {
            const point = { x: e.clientX, y: e.clientY };
            const isMovingToSubmenu = isWithinPolygon(ctx2, { point });
            if (!isMovingToSubmenu) {
              send("POINTER_MOVED_AWAY_FROM_SUBMENU");
              ctx2.parent.state.context.suspendPointer = false;
            }
          });
        },
        scrollToHighlightedItem(ctx2, _evt, { getState }) {
          const exec2 = () => {
            const state2 = getState();
            if (state2.event.type.startsWith("ITEM_POINTER")) return;
            const itemEl = dom14.getHighlightedItemEl(ctx2);
            const contentEl2 = dom14.getContentEl(ctx2);
            scrollIntoView(itemEl, { rootEl: contentEl2, block: "nearest" });
          };
          raf(() => exec2());
          const contentEl = () => dom14.getContentEl(ctx2);
          return observeAttributes(contentEl, {
            defer: true,
            attributes: ["aria-activedescendant"],
            callback: exec2
          });
        }
      },
      actions: {
        setAnchorPoint(ctx2, evt) {
          ctx2.anchorPoint = evt.point;
        },
        setSubmenuPlacement(ctx2) {
          if (!ctx2.isSubmenu) return;
          ctx2.positioning.placement = ctx2.isRtl ? "left-start" : "right-start";
          ctx2.positioning.gutter = 0;
        },
        reposition(ctx2, evt) {
          const getPositionerEl = () => dom14.getPositionerEl(ctx2);
          const getAnchorRect = ctx2.anchorPoint ? () => ({ width: 0, height: 0, ...ctx2.anchorPoint }) : void 0;
          getPlacement(dom14.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            getAnchorRect,
            ...evt.options ?? {},
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        setOptionState(_ctx, evt) {
          if (!evt.option) return;
          const { checked, onCheckedChange, type } = evt.option;
          if (type === "radio") {
            onCheckedChange == null ? void 0 : onCheckedChange(true);
          } else if (type === "checkbox") {
            onCheckedChange == null ? void 0 : onCheckedChange(!checked);
          }
        },
        clickHighlightedItem(ctx2, _evt) {
          const itemEl = dom14.getHighlightedItemEl(ctx2);
          if (!itemEl || itemEl.dataset.disabled) return;
          queueMicrotask(() => itemEl.click());
        },
        setIntentPolygon(ctx2, evt) {
          const menu = dom14.getContentEl(ctx2);
          const placement = ctx2.currentPlacement;
          if (!menu || !placement) return;
          const rect = menu.getBoundingClientRect();
          const polygon = getElementPolygon(rect, placement);
          if (!polygon) return;
          const rightSide = getPlacementSide(placement) === "right";
          const bleed = rightSide ? -5 : 5;
          ctx2.intentPolygon = [{ ...evt.point, x: evt.point.x + bleed }, ...polygon];
        },
        clearIntentPolygon(ctx2) {
          ctx2.intentPolygon = null;
        },
        resumePointer(ctx2) {
          if (!ctx2.parent) return;
          ctx2.parent.state.context.suspendPointer = false;
        },
        setHighlightedItem(ctx2, evt) {
          set11.highlighted(ctx2, evt.id);
        },
        clearHighlightedItem(ctx2) {
          set11.highlighted(ctx2, null);
        },
        focusMenu(ctx2) {
          raf(() => {
            const contentEl = dom14.getContentEl(ctx2);
            const initialFocusEl = getInitialFocus({
              root: contentEl,
              enabled: !contains(contentEl, dom14.getActiveElement(ctx2)),
              filter(node2) {
                var _a8;
                return !((_a8 = node2.role) == null ? void 0 : _a8.startsWith("menuitem"));
              }
            });
            initialFocusEl == null ? void 0 : initialFocusEl.focus({ preventScroll: true });
          });
        },
        highlightFirstItem(ctx2) {
          const fn = !!dom14.getContentEl(ctx2) ? queueMicrotask : raf;
          fn(() => {
            const first2 = dom14.getFirstEl(ctx2);
            if (!first2) return;
            set11.highlighted(ctx2, first2.id);
          });
        },
        highlightLastItem(ctx2) {
          const fn = !!dom14.getContentEl(ctx2) ? queueMicrotask : raf;
          fn(() => {
            const last2 = dom14.getLastEl(ctx2);
            if (!last2) return;
            set11.highlighted(ctx2, last2.id);
          });
        },
        highlightNextItem(ctx2, evt) {
          const next3 = dom14.getNextEl(ctx2, evt.loop);
          set11.highlighted(ctx2, (next3 == null ? void 0 : next3.id) ?? null);
        },
        highlightPrevItem(ctx2, evt) {
          const prev3 = dom14.getPrevEl(ctx2, evt.loop);
          set11.highlighted(ctx2, (prev3 == null ? void 0 : prev3.id) ?? null);
        },
        invokeOnSelect(ctx2) {
          var _a8;
          if (!ctx2.highlightedValue) return;
          (_a8 = ctx2.onSelect) == null ? void 0 : _a8.call(ctx2, { value: ctx2.highlightedValue });
        },
        focusTrigger(ctx2, evt) {
          if (ctx2.isSubmenu || ctx2.anchorPoint || evt.restoreFocus === false) return;
          queueMicrotask(() => {
            var _a8;
            return (_a8 = dom14.getTriggerEl(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        highlightMatchedItem(ctx2, evt) {
          const node2 = dom14.getElemByKey(ctx2, evt.key);
          if (!node2) return;
          set11.highlighted(ctx2, node2.id);
        },
        setParentMenu(ctx2, evt) {
          ctx2.parent = ref(evt.value);
        },
        setChildMenu(ctx2, evt) {
          ctx2.children[evt.id] = ref(evt.value);
        },
        closeRootMenu(ctx2) {
          closeRootMenu(ctx2);
        },
        openSubmenu(ctx2) {
          const item = dom14.getHighlightedItemEl(ctx2);
          const id = item == null ? void 0 : item.getAttribute("data-uid");
          const child = id ? ctx2.children[id] : null;
          child == null ? void 0 : child.send("OPEN_AUTOFOCUS");
        },
        focusParentMenu(ctx2) {
          var _a8;
          (_a8 = ctx2.parent) == null ? void 0 : _a8.send("FOCUS_MENU");
        },
        setLastHighlightedItem(ctx2, evt) {
          ctx2.lastHighlightedValue = evt.id;
        },
        restoreHighlightedItem(ctx2) {
          if (!ctx2.lastHighlightedValue) return;
          set11.highlighted(ctx2, ctx2.lastHighlightedValue);
          ctx2.lastHighlightedValue = null;
        },
        restoreParentHighlightedItem(ctx2) {
          var _a8;
          (_a8 = ctx2.parent) == null ? void 0 : _a8.send("HIGHLIGHTED.RESTORE");
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      }
    }
  );
}
function closeRootMenu(ctx) {
  let parent = ctx.parent;
  while (parent && parent.state.context.isSubmenu) {
    parent = parent.state.context.parent;
  }
  parent == null ? void 0 : parent.send("CLOSE");
}
var set11 = {
  highlighted(ctx, value) {
    var _a8;
    if (isEqual(ctx.highlightedValue, value)) return;
    ctx.highlightedValue = value;
    (_a8 = ctx.onHighlightChange) == null ? void 0 : _a8.call(ctx, { highlightedValue: value });
  }
};
var props13 = createProps()([
  "anchorPoint",
  "aria-label",
  "closeOnSelect",
  "composite",
  "dir",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "loopFocus",
  "navigate",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onHighlightChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onSelect",
  "open.controlled",
  "open",
  "positioning",
  "typeahead"
]);
var splitProps13 = createSplitProps(props13);
var itemProps4 = createProps()(["closeOnSelect", "disabled", "value", "valueText"]);
var splitItemProps4 = createSplitProps(itemProps4);
var itemGroupLabelProps = createProps()(["htmlFor"]);
var splitItemGroupLabelProps = createSplitProps(itemGroupLabelProps);
var itemGroupProps = createProps()(["id"]);
var splitItemGroupProps = createSplitProps(itemGroupProps);
var optionItemProps = createProps()([
  "disabled",
  "valueText",
  "closeOnSelect",
  "type",
  "value",
  "checked",
  "onCheckedChange"
]);
var splitOptionItemProps = createSplitProps(optionItemProps);

// node_modules/@ark-ui/react/dist/components/menu/use-menu.js
var import_react405 = __toESM(require_react(), 1);
var useMenu = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react405.useId)(),
    dir,
    getRootNode,
    open: props34.defaultOpen,
    "open.controlled": props34.open !== void 0,
    ...props34
  };
  const context = {
    ...initialContext,
    onOpenChange: useEvent(props34.onOpenChange),
    onSelect: useEvent(props34.onSelect)
  };
  const [state2, send, machine38] = useMachine(machine15(initialContext), { context });
  const api = connect15(state2, send, normalizeProps);
  return { api, machine: machine38 };
};

// node_modules/@ark-ui/react/dist/components/menu/use-menu-machine-context.js
var [MenuMachineProvider, useMenuMachineContext] = createContext3({
  name: "MenuMachineContext",
  hookName: "useMenuMachineContext",
  providerName: "<MenuMachineProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/menu/use-menu-trigger-item-context.js
var [MenuTriggerItemProvider, useMenuTriggerItemContext] = createContext3({
  name: "MenuMachineContext",
  hookName: "useMenuMachineContext",
  providerName: "<MenuMachineProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/menu/menu-root.js
var MenuRoot = (props34) => {
  const [presenceProps, menuProps] = splitPresenceProps(props34);
  const [useMenuProps, localProps] = createSplitProps2()(menuProps, [
    "anchorPoint",
    "aria-label",
    "closeOnSelect",
    "composite",
    "defaultOpen",
    "highlightedValue",
    "id",
    "ids",
    "loopFocus",
    "navigate",
    "onEscapeKeyDown",
    "onFocusOutside",
    "onHighlightChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onSelect",
    "open",
    "positioning",
    "typeahead"
  ]);
  const parentApi = useMenuContext();
  const parentMachine = useMenuMachineContext();
  const { api, machine: machine38 } = useMenu(useMenuProps);
  const presence = usePresence(mergeProps2({ present: api.open }, presenceProps));
  useEffectOnce(() => {
    if (!parentMachine) return;
    if (!parentApi) return;
    parentApi.setChild(machine38);
    api.setParent(parentMachine);
  });
  const triggerItemContext = (0, import_react407.useCallback)(
    () => parentApi == null ? void 0 : parentApi.getTriggerItemProps(api),
    [api, parentApi]
  );
  return (0, import_jsx_runtime191.jsx)(MenuTriggerItemProvider, { value: triggerItemContext, children: (0, import_jsx_runtime191.jsx)(MenuMachineProvider, { value: machine38, children: (0, import_jsx_runtime191.jsx)(MenuProvider, { value: api, children: (0, import_jsx_runtime191.jsx)(PresenceProvider, { value: presence, ...localProps }) }) }) });
};

// node_modules/@ark-ui/react/dist/components/menu/menu-root-provider.js
var import_jsx_runtime192 = __toESM(require_jsx_runtime(), 1);
var import_react409 = __toESM(require_react(), 1);
var MenuRootProvider = (props34) => {
  const parentApi = useMenuContext();
  const parentMachine = useMenuMachineContext();
  const [presenceProps, { value: menu, children }] = splitPresenceProps(props34);
  const { api, machine: machine38 } = menu;
  const presence = usePresence(mergeProps2({ present: api.open }, presenceProps));
  useEffectOnce(() => {
    if (!parentMachine) return;
    if (!parentApi) return;
    parentApi.setChild(machine38);
    api.setParent(parentMachine);
  });
  const triggerItemContext = (0, import_react409.useCallback)(
    () => parentApi == null ? void 0 : parentApi.getTriggerItemProps(api),
    [api, parentApi]
  );
  return (0, import_jsx_runtime192.jsx)(MenuTriggerItemProvider, { value: triggerItemContext, children: (0, import_jsx_runtime192.jsx)(MenuMachineProvider, { value: machine38, children: (0, import_jsx_runtime192.jsx)(MenuProvider, { value: api, children: (0, import_jsx_runtime192.jsx)(PresenceProvider, { value: presence, children }) }) }) });
};

// node_modules/@ark-ui/react/dist/components/menu/menu-separator.js
var import_jsx_runtime193 = __toESM(require_jsx_runtime(), 1);
var import_react411 = __toESM(require_react(), 1);
var MenuSeparator = (0, import_react411.forwardRef)((props34, ref2) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getSeparatorProps(), props34);
  return (0, import_jsx_runtime193.jsx)(ark.hr, { ...mergedProps, ref: ref2 });
});
MenuSeparator.displayName = "MenuSeparator";

// node_modules/@ark-ui/react/dist/components/menu/menu-trigger.js
var import_jsx_runtime194 = __toESM(require_jsx_runtime(), 1);
var import_react413 = __toESM(require_react(), 1);
var MenuTrigger = (0, import_react413.forwardRef)((props34, ref2) => {
  const menu = useMenuContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(
    {
      ...menu.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : menu.getTriggerProps()["aria-controls"]
    },
    props34
  );
  return (0, import_jsx_runtime194.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
MenuTrigger.displayName = "MenuTrigger";

// node_modules/@ark-ui/react/dist/components/menu/menu-trigger-item.js
var import_jsx_runtime195 = __toESM(require_jsx_runtime(), 1);
var import_react415 = __toESM(require_react(), 1);
var MenuTriggerItem = (0, import_react415.forwardRef)((props34, ref2) => {
  const getTriggerItemProps = useMenuTriggerItemContext();
  const mergedProps = mergeProps2((getTriggerItemProps == null ? void 0 : getTriggerItemProps()) ?? {}, props34);
  return (0, import_jsx_runtime195.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuTriggerItem.displayName = "MenuTriggerItem";

// node_modules/@ark-ui/react/dist/components/menu/menu.js
var menu_exports = {};
__export(menu_exports, {
  Arrow: () => MenuArrow,
  ArrowTip: () => MenuArrowTip,
  CheckboxItem: () => MenuCheckboxItem,
  Content: () => MenuContent,
  Context: () => MenuContext,
  ContextTrigger: () => MenuContextTrigger,
  Indicator: () => MenuIndicator,
  Item: () => MenuItem,
  ItemContext: () => MenuItemContext,
  ItemGroup: () => MenuItemGroup,
  ItemGroupLabel: () => MenuItemGroupLabel,
  ItemIndicator: () => MenuItemIndicator,
  ItemText: () => MenuItemText,
  Positioner: () => MenuPositioner,
  RadioItem: () => MenuRadioItem,
  RadioItemGroup: () => MenuRadioItemGroup,
  Root: () => MenuRoot,
  RootProvider: () => MenuRootProvider,
  Separator: () => MenuSeparator,
  Trigger: () => MenuTrigger,
  TriggerItem: () => MenuTriggerItem
});

// node_modules/@ark-ui/react/dist/components/number-input/use-number-input-context.js
var [NumberInputProvider, useNumberInputContext] = createContext3({
  name: "NumberInputContext",
  hookName: "useNumberInputContext",
  providerName: "<NumberInputProvider />"
});

// node_modules/@ark-ui/react/dist/components/number-input/number-input-context.js
var NumberInputContext = (props34) => props34.children(useNumberInputContext());

// node_modules/@ark-ui/react/dist/components/number-input/number-input-control.js
var import_jsx_runtime196 = __toESM(require_jsx_runtime(), 1);
var import_react417 = __toESM(require_react(), 1);
var NumberInputControl = (0, import_react417.forwardRef)(
  (props34, ref2) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps2(numberInput.getControlProps(), props34);
    return (0, import_jsx_runtime196.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
NumberInputControl.displayName = "NumberInputControl";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-decrement-trigger.js
var import_jsx_runtime197 = __toESM(require_jsx_runtime(), 1);
var import_react419 = __toESM(require_react(), 1);
var NumberInputDecrementTrigger = (0, import_react419.forwardRef)((props34, ref2) => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps2(numberInput.getDecrementTriggerProps(), props34);
  return (0, import_jsx_runtime197.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
NumberInputDecrementTrigger.displayName = "NumberInputDecrementTrigger";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-increment-trigger.js
var import_jsx_runtime198 = __toESM(require_jsx_runtime(), 1);
var import_react421 = __toESM(require_react(), 1);
var NumberInputIncrementTrigger = (0, import_react421.forwardRef)((props34, ref2) => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps2(numberInput.getIncrementTriggerProps(), props34);
  return (0, import_jsx_runtime198.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
NumberInputIncrementTrigger.displayName = "NumberInputIncrementTrigger";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-input.js
var import_jsx_runtime199 = __toESM(require_jsx_runtime(), 1);
var import_react423 = __toESM(require_react(), 1);
var NumberInputInput = (0, import_react423.forwardRef)(
  (props34, ref2) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps2(numberInput.getInputProps(), props34);
    const field = useFieldContext();
    return (0, import_jsx_runtime199.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
NumberInputInput.displayName = "NumberInputInput";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-label.js
var import_jsx_runtime200 = __toESM(require_jsx_runtime(), 1);
var import_react425 = __toESM(require_react(), 1);
var NumberInputLabel = (0, import_react425.forwardRef)(
  (props34, ref2) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps2(numberInput.getLabelProps(), props34);
    return (0, import_jsx_runtime200.jsx)(ark.label, { ...mergedProps, ref: ref2 });
  }
);
NumberInputLabel.displayName = "NumberInputLabel";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-root.js
var import_jsx_runtime201 = __toESM(require_jsx_runtime(), 1);
var import_react429 = __toESM(require_react(), 1);

// node_modules/@internationalized/number/dist/NumberFormatter.mjs
var $488c6ddbf4ef74c2$var$formatterCache = /* @__PURE__ */ new Map();
var $488c6ddbf4ef74c2$var$supportsSignDisplay = false;
try {
  $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
var $488c6ddbf4ef74c2$var$supportsUnit = false;
try {
  $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
var $488c6ddbf4ef74c2$var$UNITS = {
  degree: {
    narrow: {
      default: "°",
      "ja-JP": " 度",
      "zh-TW": "度",
      "sl-SI": " °"
    }
  }
};
var $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 = class {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(value) {
    let res = "";
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);
    else res = this.numberFormatter.format(value);
    if (this.options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
      var _UNITS_unit;
      let { unit, unitDisplay = "short", locale } = this.resolvedOptions();
      if (!unit) return res;
      let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
      res += values[locale] || values.default;
    }
    return res;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(value) {
    return this.numberFormatter.formatToParts(value);
  }
  /** Formats a number range as a string. */
  formatRange(start, end) {
    if (typeof this.numberFormatter.formatRange === "function") return this.numberFormatter.formatRange(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    return `${this.format(start)} – ${this.format(end)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(start, end) {
    if (typeof this.numberFormatter.formatRangeToParts === "function") return this.numberFormatter.formatRangeToParts(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    let startParts = this.numberFormatter.formatToParts(start);
    let endParts = this.numberFormatter.formatToParts(end);
    return [
      ...startParts.map((p) => ({
        ...p,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...endParts.map((p) => ({
        ...p,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let options = this.numberFormatter.resolvedOptions();
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {
      ...options,
      signDisplay: this.options.signDisplay
    };
    if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === "unit") options = {
      ...options,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    };
    return options;
  }
  constructor(locale, options = {}) {
    this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);
    this.options = options;
  }
};
function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {
  let { numberingSystem } = options;
  if (numberingSystem && locale.includes("-nu-")) {
    if (!locale.includes("-u-")) locale += "-u-";
    locale += `-nu-${numberingSystem}`;
  }
  if (options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
    var _UNITS_unit;
    let { unit, unitDisplay = "short" } = options;
    if (!unit) throw new Error('unit option must be provided with style: "unit"');
    if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
    options = {
      ...options,
      style: "decimal"
    };
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a2, b2) => a2[0] < b2[0] ? -1 : 1).join() : "");
  if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.NumberFormat(locale, options);
  $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
  if (signDisplay === "auto") return numberFormat.format(num);
  else if (signDisplay === "never") return numberFormat.format(Math.abs(num));
  else {
    let needsPositiveSign = false;
    if (signDisplay === "always") needsPositiveSign = num > 0 || Object.is(num, 0);
    else if (signDisplay === "exceptZero") {
      if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);
      else needsPositiveSign = num > 0;
    }
    if (needsPositiveSign) {
      let negative = numberFormat.format(-num);
      let noSign = numberFormat.format(num);
      let minus = negative.replace(noSign, "").replace(/\u200e|\u061C/, "");
      if ([
        ...minus
      ].length !== 1) console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case");
      let positive = negative.replace(noSign, "!!!").replace(minus, "+").replace("!!!", noSign);
      return positive;
    } else return numberFormat.format(num);
  }
}

// node_modules/@internationalized/number/dist/NumberParser.mjs
var $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp("^.*\\(.*\\).*$");
var $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
  "latn",
  "arab",
  "hanidec",
  "deva",
  "beng"
];
var $6c7bd7858deea686$export$cd11ab140839f11d = class {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(value, minValue, maxValue2) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue2);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.options = options;
  }
};
var $6c7bd7858deea686$var$numberParserCache = /* @__PURE__ */ new Map();
function $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {
  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);
  if (!locale.includes("-nu-") && !defaultParser.isValidPartialNumber(value)) {
    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS) if (numberingSystem !== defaultParser.options.numberingSystem) {
      let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes("-u-") ? "-nu-" : "-u-nu-") + numberingSystem, options);
      if (parser.isValidPartialNumber(value)) return parser;
    }
  }
  return defaultParser;
}
function $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {
  let cacheKey = locale + (options ? Object.entries(options).sort((a2, b2) => a2[0] < b2[0] ? -1 : 1).join() : "");
  let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
  if (!parser) {
    parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);
    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);
  }
  return parser;
}
var $6c7bd7858deea686$var$NumberParserImpl = class {
  parse(value) {
    let fullySanitizedValue = this.sanitize(value);
    if (this.symbols.group)
      fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, "");
    if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, ".");
    if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, "-");
    fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);
    if (this.options.style === "percent") {
      let isNegative = fullySanitizedValue.indexOf("-");
      fullySanitizedValue = fullySanitizedValue.replace("-", "");
      let index = fullySanitizedValue.indexOf(".");
      if (index === -1) index = fullySanitizedValue.length;
      fullySanitizedValue = fullySanitizedValue.replace(".", "");
      if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;
      else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;
      else if (index - 2 === -2) fullySanitizedValue = "0.00";
      else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;
      if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;
    }
    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
    if (isNaN(newValue)) return NaN;
    if (this.options.style === "percent") {
      var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
      let options = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) + 2, 20),
        maximumFractionDigits: Math.min(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2, 20)
      };
      return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options).format(newValue));
    }
    if (this.options.currencySign === "accounting" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;
    return newValue;
  }
  sanitize(value) {
    value = value.replace(this.symbols.literals, "");
    if (this.symbols.minusSign) value = value.replace("-", this.symbols.minusSign);
    if (this.options.numberingSystem === "arab") {
      if (this.symbols.decimal) {
        value = value.replace(",", this.symbols.decimal);
        value = value.replace(String.fromCharCode(1548), this.symbols.decimal);
      }
      if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, ".", this.symbols.group);
    }
    if (this.options.locale === "fr-FR") value = $6c7bd7858deea686$var$replaceAll(value, ".", String.fromCharCode(8239));
    return value;
  }
  isValidPartialNumber(value, minValue = -Infinity, maxValue2 = Infinity) {
    value = this.sanitize(value);
    if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);
    else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue2 > 0) value = value.slice(this.symbols.plusSign.length);
    if (this.symbols.group && value.startsWith(this.symbols.group)) return false;
    if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;
    if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, "");
    value = value.replace(this.symbols.numeral, "");
    if (this.symbols.decimal) value = value.replace(this.symbols.decimal, "");
    return value.length === 0;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.formatter = new Intl.NumberFormat(locale, options);
    this.options = this.formatter.resolvedOptions();
    this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);
    var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
    if (this.options.style === "percent" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
};
var $6c7bd7858deea686$var$nonLiteralParts = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]);
var $6c7bd7858deea686$var$pluralNumbers = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
  var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
  let symbolFormatter = new Intl.NumberFormat(locale, {
    ...intlOptions,
    // Resets so we get the full range of symbols
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21,
    roundingIncrement: 1,
    roundingPriority: "auto",
    roundingMode: "halfExpand"
  });
  let allParts = symbolFormatter.formatToParts(-10000.111);
  let posAllParts = symbolFormatter.formatToParts(10000.111);
  let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n) => symbolFormatter.formatToParts(n));
  var _allParts_find_value;
  let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p) => p.type === "minusSign")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : "-";
  let plusSign = (_posAllParts_find = posAllParts.find((p) => p.type === "plusSign")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "exceptZero" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "always")) plusSign = "+";
  let decimalParts = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3);
  let decimal = (_decimalParts_find = decimalParts.find((p) => p.type === "decimal")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
  let group2 = (_allParts_find1 = allParts.find((p) => p.type === "group")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
  let allPartsLiterals = allParts.filter((p) => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p) => $6c7bd7858deea686$var$escapeRegex(p.value));
  let pluralPartsLiterals = pluralParts.flatMap((p) => p.filter((p2) => !$6c7bd7858deea686$var$nonLiteralParts.has(p2.type)).map((p2) => $6c7bd7858deea686$var$escapeRegex(p2.value)));
  let sortedLiterals = [
    .../* @__PURE__ */ new Set([
      ...allPartsLiterals,
      ...pluralPartsLiterals
    ])
  ].sort((a2, b2) => b2.length - a2.length);
  let literals = sortedLiterals.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${sortedLiterals.join("|")}|[\\p{White_Space}]`, "gu");
  let numerals = [
    ...new Intl.NumberFormat(intlOptions.locale, {
      useGrouping: false
    }).format(9876543210)
  ].reverse();
  let indexes = new Map(numerals.map((d, i) => [
    d,
    i
  ]));
  let numeral = new RegExp(`[${numerals.join("")}]`, "g");
  let index = (d) => String(indexes.get(d));
  return {
    minusSign,
    plusSign,
    decimal,
    group: group2,
    literals,
    numeral,
    index
  };
}
function $6c7bd7858deea686$var$replaceAll(str, find2, replace3) {
  if (str.replaceAll) return str.replaceAll(find2, replace3);
  return str.split(find2).join(replace3);
}
function $6c7bd7858deea686$var$escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// node_modules/@zag-js/number-input/dist/index.mjs
var anatomy15 = createAnatomy("numberInput").parts(
  "root",
  "label",
  "input",
  "control",
  "valueText",
  "incrementTrigger",
  "decrementTrigger",
  "scrubber"
);
var parts17 = anatomy15.build();
var dom15 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `number-input:${ctx.id}`;
  },
  getInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.input) ?? `number-input:${ctx.id}:input`;
  },
  getIncrementTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.incrementTrigger) ?? `number-input:${ctx.id}:inc`;
  },
  getDecrementTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.decrementTrigger) ?? `number-input:${ctx.id}:dec`;
  },
  getScrubberId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.scrubber) ?? `number-input:${ctx.id}:scrubber`;
  },
  getCursorId: (ctx) => `number-input:${ctx.id}:cursor`,
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `number-input:${ctx.id}:label`;
  },
  getInputEl: (ctx) => dom15.getById(ctx, dom15.getInputId(ctx)),
  getIncrementTriggerEl: (ctx) => dom15.getById(ctx, dom15.getIncrementTriggerId(ctx)),
  getDecrementTriggerEl: (ctx) => dom15.getById(ctx, dom15.getDecrementTriggerId(ctx)),
  getScrubberEl: (ctx) => dom15.getById(ctx, dom15.getScrubberId(ctx)),
  getCursorEl: (ctx) => dom15.getDoc(ctx).getElementById(dom15.getCursorId(ctx)),
  getPressedTriggerEl: (ctx, hint = ctx.hint) => {
    let btnEl = null;
    if (hint === "increment") {
      btnEl = dom15.getIncrementTriggerEl(ctx);
    }
    if (hint === "decrement") {
      btnEl = dom15.getDecrementTriggerEl(ctx);
    }
    return btnEl;
  },
  setupVirtualCursor(ctx) {
    if (isSafari()) return;
    dom15.createVirtualCursor(ctx);
    return () => {
      var _a8;
      (_a8 = dom15.getCursorEl(ctx)) == null ? void 0 : _a8.remove();
    };
  },
  preventTextSelection(ctx) {
    const doc = dom15.getDoc(ctx);
    const html = doc.documentElement;
    const body = doc.body;
    body.style.pointerEvents = "none";
    html.style.userSelect = "none";
    html.style.cursor = "ew-resize";
    return () => {
      body.style.pointerEvents = "";
      html.style.userSelect = "";
      html.style.cursor = "";
      if (!html.style.length) {
        html.removeAttribute("style");
      }
      if (!body.style.length) {
        body.removeAttribute("style");
      }
    };
  },
  getMousemoveValue(ctx, event) {
    const win = dom15.getWin(ctx);
    const x = roundToDpr(event.movementX, win.devicePixelRatio);
    const y = roundToDpr(event.movementY, win.devicePixelRatio);
    let hint = x > 0 ? "increment" : x < 0 ? "decrement" : null;
    if (ctx.isRtl && hint === "increment") hint = "decrement";
    if (ctx.isRtl && hint === "decrement") hint = "increment";
    const point = {
      x: ctx.scrubberCursorPoint.x + x,
      y: ctx.scrubberCursorPoint.y + y
    };
    const width = win.innerWidth;
    const half = roundToDpr(7.5, win.devicePixelRatio);
    point.x = wrap2(point.x + half, width) - half;
    return { hint, point };
  },
  createVirtualCursor(ctx) {
    const doc = dom15.getDoc(ctx);
    const el = doc.createElement("div");
    el.className = "scrubber--cursor";
    el.id = dom15.getCursorId(ctx);
    Object.assign(el.style, {
      width: "15px",
      height: "15px",
      position: "fixed",
      pointerEvents: "none",
      left: "0px",
      top: "0px",
      zIndex: MAX_Z_INDEX,
      transform: ctx.scrubberCursorPoint ? `translate3d(${ctx.scrubberCursorPoint.x}px, ${ctx.scrubberCursorPoint.y}px, 0px)` : void 0,
      willChange: "transform"
    });
    el.innerHTML = `
        <svg width="46" height="15" style="left: -15.5px; position: absolute; top: 0; filter: drop-shadow(rgba(0, 0, 0, 0.4) 0px 1px 1.1px);">
          <g transform="translate(2 3)">
            <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z" style="stroke-width: 2px; stroke: white;"></path>
            <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z"></path>
          </g>
        </svg>`;
    doc.body.appendChild(el);
  }
});
function connect16(state2, send, normalize3) {
  const focused = state2.hasTag("focus");
  const disabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  const empty2 = state2.context.isValueEmpty;
  const invalid = state2.context.isOutOfRange || !!state2.context.invalid;
  const isIncrementDisabled = disabled || !state2.context.canIncrement || readOnly;
  const isDecrementDisabled = disabled || !state2.context.canDecrement || readOnly;
  const translations = state2.context.translations;
  return {
    focused,
    invalid,
    empty: empty2,
    value: state2.context.formattedValue,
    valueAsNumber: state2.context.valueAsNumber,
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    clearValue() {
      send("VALUE.CLEAR");
    },
    increment() {
      send("VALUE.INCREMENT");
    },
    decrement() {
      send("VALUE.DECREMENT");
    },
    setToMax() {
      send({ type: "VALUE.SET", value: state2.context.max });
    },
    setToMin() {
      send({ type: "VALUE.SET", value: state2.context.min });
    },
    focus() {
      var _a8;
      (_a8 = dom15.getInputEl(state2.context)) == null ? void 0 : _a8.focus();
    },
    getRootProps() {
      return normalize3.element({
        id: dom15.getRootId(state2.context),
        ...parts17.root.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid)
      });
    },
    getLabelProps() {
      return normalize3.label({
        ...parts17.label.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid),
        id: dom15.getLabelId(state2.context),
        htmlFor: dom15.getInputId(state2.context)
      });
    },
    getControlProps() {
      return normalize3.element({
        ...parts17.control.attrs,
        dir: state2.context.dir,
        role: "group",
        "aria-disabled": disabled,
        "data-focus": dataAttr(focused),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "aria-invalid": ariaAttr(state2.context.invalid)
      });
    },
    getValueTextProps() {
      return normalize3.element({
        ...parts17.valueText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused)
      });
    },
    getInputProps() {
      return normalize3.input({
        ...parts17.input.attrs,
        dir: state2.context.dir,
        name: state2.context.name,
        form: state2.context.form,
        id: dom15.getInputId(state2.context),
        role: "spinbutton",
        defaultValue: state2.context.formattedValue,
        pattern: state2.context.pattern,
        inputMode: state2.context.inputMode,
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        disabled,
        "data-disabled": dataAttr(disabled),
        readOnly: state2.context.readOnly,
        required: state2.context.required,
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: "false",
        type: "text",
        "aria-roledescription": "numberfield",
        "aria-valuemin": state2.context.min,
        "aria-valuemax": state2.context.max,
        "aria-valuenow": Number.isNaN(state2.context.valueAsNumber) ? void 0 : state2.context.valueAsNumber,
        "aria-valuetext": state2.context.valueText,
        onFocus() {
          send("INPUT.FOCUS");
        },
        onBlur() {
          send("INPUT.BLUR");
        },
        onInput(event) {
          send({ type: "INPUT.CHANGE", target: event.currentTarget, hint: "set" });
        },
        onBeforeInput(event) {
          try {
            const { selectionStart, selectionEnd, value } = event.currentTarget;
            const nextValue = value.slice(0, selectionStart) + (event.data ?? "") + value.slice(selectionEnd);
            const isValid = state2.context.parser.isValidPartialNumber(nextValue);
            if (!isValid) {
              event.preventDefault();
            }
          } catch {
          }
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (readOnly) return;
          if (isComposingEvent(event)) return;
          const step = getEventStep(event) * state2.context.step;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "INPUT.ARROW_UP", step });
              event.preventDefault();
            },
            ArrowDown() {
              send({ type: "INPUT.ARROW_DOWN", step });
              event.preventDefault();
            },
            Home() {
              if (isModifierKey(event)) return;
              send("INPUT.HOME");
              event.preventDefault();
            },
            End() {
              if (isModifierKey(event)) return;
              send("INPUT.END");
              event.preventDefault();
            },
            Enter() {
              send("INPUT.ENTER");
            }
          };
          const exec2 = keyMap2[event.key];
          exec2 == null ? void 0 : exec2(event);
        }
      });
    },
    getDecrementTriggerProps() {
      return normalize3.button({
        ...parts17.decrementTrigger.attrs,
        dir: state2.context.dir,
        id: dom15.getDecrementTriggerId(state2.context),
        disabled: isDecrementDisabled,
        "data-disabled": dataAttr(isDecrementDisabled),
        "aria-label": translations.decrementLabel,
        type: "button",
        tabIndex: -1,
        "aria-controls": dom15.getInputId(state2.context),
        onPointerDown(event) {
          var _a8;
          if (isDecrementDisabled || !isLeftClick(event)) return;
          send({ type: "TRIGGER.PRESS_DOWN", hint: "decrement", pointerType: event.pointerType });
          if (event.pointerType === "mouse") {
            event.preventDefault();
          }
          if (event.pointerType === "touch") {
            (_a8 = event.currentTarget) == null ? void 0 : _a8.focus({ preventScroll: true });
          }
        },
        onPointerUp(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "decrement", pointerType: event.pointerType });
        },
        onPointerLeave() {
          if (isDecrementDisabled) return;
          send({ type: "TRIGGER.PRESS_UP", hint: "decrement" });
        }
      });
    },
    getIncrementTriggerProps() {
      return normalize3.button({
        ...parts17.incrementTrigger.attrs,
        dir: state2.context.dir,
        id: dom15.getIncrementTriggerId(state2.context),
        disabled: isIncrementDisabled,
        "data-disabled": dataAttr(isIncrementDisabled),
        "aria-label": translations.incrementLabel,
        type: "button",
        tabIndex: -1,
        "aria-controls": dom15.getInputId(state2.context),
        onPointerDown(event) {
          var _a8;
          if (isIncrementDisabled || !isLeftClick(event)) return;
          send({ type: "TRIGGER.PRESS_DOWN", hint: "increment", pointerType: event.pointerType });
          if (event.pointerType === "mouse") {
            event.preventDefault();
          }
          if (event.pointerType === "touch") {
            (_a8 = event.currentTarget) == null ? void 0 : _a8.focus({ preventScroll: true });
          }
        },
        onPointerUp(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "increment", pointerType: event.pointerType });
        },
        onPointerLeave(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "increment", pointerType: event.pointerType });
        }
      });
    },
    getScrubberProps() {
      return normalize3.element({
        ...parts17.scrubber.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        id: dom15.getScrubberId(state2.context),
        role: "presentation",
        onMouseDown(event) {
          if (disabled) return;
          const point = getEventPoint(event);
          const win = getWindow(event.currentTarget);
          const dpr = win.devicePixelRatio;
          point.x = point.x - roundToDpr(7.5, dpr);
          point.y = point.y - roundToDpr(7.5, dpr);
          send({ type: "SCRUBBER.PRESS_DOWN", point });
          event.preventDefault();
        },
        style: {
          cursor: disabled ? void 0 : "ew-resize"
        }
      });
    }
  };
}
function recordCursor(inputEl) {
  if (inputEl.ownerDocument.activeElement !== inputEl) return;
  try {
    const { selectionStart: start, selectionEnd: end, value } = inputEl;
    const beforeTxt = value.substring(0, start);
    const afterTxt = value.substring(end);
    return {
      start,
      end,
      value,
      beforeTxt,
      afterTxt
    };
  } catch {
  }
}
function restoreCursor(inputEl, selection) {
  if (inputEl.ownerDocument.activeElement !== inputEl) return;
  if (!selection) {
    inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
    return;
  }
  try {
    const { value } = inputEl;
    const { beforeTxt = "", afterTxt = "", start } = selection;
    let startPos = value.length;
    if (value.endsWith(afterTxt)) {
      startPos = value.length - afterTxt.length;
    } else if (value.startsWith(beforeTxt)) {
      startPos = beforeTxt.length;
    } else if (start != null) {
      const beforeLastChar = beforeTxt[start - 1];
      const newIndex = value.indexOf(beforeLastChar, start - 1);
      if (newIndex !== -1) {
        startPos = newIndex + 1;
      }
    }
    inputEl.setSelectionRange(startPos, startPos);
  } catch {
  }
}
var createFormatter = (locale, options = {}) => {
  return ref(new Intl.NumberFormat(locale, options));
};
var createParser = (locale, options = {}) => {
  return ref(new $6c7bd7858deea686$export$cd11ab140839f11d(locale, options));
};
var parseValue = (ctx, value) => {
  if (!ctx.formatOptions) return parseFloat(value);
  return ctx.parser.parse(String(value));
};
var formatValue = (ctx, value) => {
  if (Number.isNaN(value)) return "";
  if (!ctx.formatOptions) return value.toString();
  return ctx.formatter.format(value);
};
var { not: not7, and: and8 } = guards;
function machine16(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "number-input",
      initial: "idle",
      context: {
        dir: "ltr",
        locale: "en-US",
        focusInputOnChange: true,
        clampValueOnBlur: true,
        allowOverflow: false,
        inputMode: "decimal",
        pattern: "[0-9]*(.[0-9]+)?",
        value: "",
        step: 1,
        min: Number.MIN_SAFE_INTEGER,
        max: Number.MAX_SAFE_INTEGER,
        invalid: false,
        spinOnPress: true,
        disabled: false,
        readOnly: false,
        ...ctx,
        hint: null,
        scrubberCursorPoint: null,
        fieldsetDisabled: false,
        formatter: createFormatter(ctx.locale || "en-US", ctx.formatOptions),
        parser: createParser(ctx.locale || "en-US", ctx.formatOptions),
        translations: {
          incrementLabel: "increment value",
          decrementLabel: "decrease value",
          ...ctx.translations
        }
      },
      computed: {
        isRtl: (ctx2) => ctx2.dir === "rtl",
        valueAsNumber: (ctx2) => parseValue(ctx2, ctx2.value),
        formattedValue: (ctx2) => formatValue(ctx2, ctx2.valueAsNumber),
        isAtMin: (ctx2) => isValueAtMin(ctx2.valueAsNumber, ctx2.min),
        isAtMax: (ctx2) => isValueAtMax(ctx2.valueAsNumber, ctx2.max),
        isOutOfRange: (ctx2) => !isValueWithinRange(ctx2.valueAsNumber, ctx2.min, ctx2.max),
        isValueEmpty: (ctx2) => ctx2.value === "",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        canIncrement: (ctx2) => ctx2.allowOverflow || !ctx2.isAtMax,
        canDecrement: (ctx2) => ctx2.allowOverflow || !ctx2.isAtMin,
        valueText: (ctx2) => {
          var _a8, _b7;
          return (_b7 = (_a8 = ctx2.translations).valueText) == null ? void 0 : _b7.call(_a8, ctx2.value);
        }
      },
      watch: {
        formatOptions: ["setFormatterAndParser", "syncInputElement"],
        locale: ["setFormatterAndParser", "syncInputElement"],
        value: ["syncInputElement"],
        isOutOfRange: ["invokeOnInvalid"],
        scrubberCursorPoint: ["setVirtualCursorPosition"]
      },
      activities: ["trackFormControl"],
      on: {
        "VALUE.SET": {
          actions: ["setRawValue", "setHintToSet"]
        },
        "VALUE.CLEAR": {
          actions: ["clearValue"]
        },
        "VALUE.INCREMENT": {
          actions: ["increment"]
        },
        "VALUE.DECREMENT": {
          actions: ["decrement"]
        }
      },
      states: {
        idle: {
          on: {
            "TRIGGER.PRESS_DOWN": [
              { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
              {
                target: "before:spin",
                actions: ["focusInput", "invokeOnFocus", "setHint"]
              }
            ],
            "SCRUBBER.PRESS_DOWN": {
              target: "scrubbing",
              actions: ["focusInput", "invokeOnFocus", "setHint", "setCursorPoint"]
            },
            "INPUT.FOCUS": {
              target: "focused",
              actions: ["focusInput", "invokeOnFocus"]
            }
          }
        },
        focused: {
          tags: "focus",
          activities: "attachWheelListener",
          on: {
            "TRIGGER.PRESS_DOWN": [
              { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
              { target: "before:spin", actions: ["focusInput", "setHint"] }
            ],
            "SCRUBBER.PRESS_DOWN": {
              target: "scrubbing",
              actions: ["focusInput", "setHint", "setCursorPoint"]
            },
            "INPUT.ARROW_UP": {
              actions: "increment"
            },
            "INPUT.ARROW_DOWN": {
              actions: "decrement"
            },
            "INPUT.HOME": {
              actions: "decrementToMin"
            },
            "INPUT.END": {
              actions: "incrementToMax"
            },
            "INPUT.CHANGE": {
              actions: ["setValue", "setHint"]
            },
            "INPUT.BLUR": [
              {
                guard: and8("clampValueOnBlur", not7("isInRange")),
                target: "idle",
                actions: ["setClampedValue", "clearHint", "invokeOnBlur"]
              },
              {
                target: "idle",
                actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
              }
            ],
            "INPUT.ENTER": {
              actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
            }
          }
        },
        "before:spin": {
          tags: "focus",
          activities: "trackButtonDisabled",
          entry: choose([
            { guard: "isIncrementHint", actions: "increment" },
            { guard: "isDecrementHint", actions: "decrement" }
          ]),
          after: {
            CHANGE_DELAY: {
              target: "spinning",
              guard: and8("isInRange", "spinOnPress")
            }
          },
          on: {
            "TRIGGER.PRESS_UP": [
              { guard: "isTouchPointer", target: "focused", actions: "clearHint" },
              { target: "focused", actions: ["focusInput", "clearHint"] }
            ]
          }
        },
        spinning: {
          tags: "focus",
          activities: "trackButtonDisabled",
          every: [
            {
              delay: "CHANGE_INTERVAL",
              guard: and8(not7("isAtMin"), "isIncrementHint"),
              actions: "increment"
            },
            {
              delay: "CHANGE_INTERVAL",
              guard: and8(not7("isAtMax"), "isDecrementHint"),
              actions: "decrement"
            }
          ],
          on: {
            "TRIGGER.PRESS_UP": {
              target: "focused",
              actions: ["focusInput", "clearHint"]
            }
          }
        },
        scrubbing: {
          tags: "focus",
          activities: ["activatePointerLock", "trackMousemove", "setupVirtualCursor", "preventTextSelection"],
          on: {
            "SCRUBBER.POINTER_UP": {
              target: "focused",
              actions: ["focusInput", "clearCursorPoint"]
            },
            "SCRUBBER.POINTER_MOVE": [
              {
                guard: "isIncrementHint",
                actions: ["increment", "setCursorPoint"]
              },
              {
                guard: "isDecrementHint",
                actions: ["decrement", "setCursorPoint"]
              }
            ]
          }
        }
      }
    },
    {
      delays: {
        CHANGE_INTERVAL: 50,
        CHANGE_DELAY: 300
      },
      guards: {
        clampValueOnBlur: (ctx2) => ctx2.clampValueOnBlur,
        isAtMin: (ctx2) => ctx2.isAtMin,
        spinOnPress: (ctx2) => !!ctx2.spinOnPress,
        isAtMax: (ctx2) => ctx2.isAtMax,
        isInRange: (ctx2) => !ctx2.isOutOfRange,
        isDecrementHint: (ctx2, evt) => (evt.hint ?? ctx2.hint) === "decrement",
        isIncrementHint: (ctx2, evt) => (evt.hint ?? ctx2.hint) === "increment",
        isTouchPointer: (_ctx, evt) => evt.pointerType === "touch"
      },
      activities: {
        trackFormControl(ctx2, _evt, { initialContext }) {
          const inputEl = dom15.getInputEl(ctx2);
          return trackFormControl(inputEl, {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set12.value(ctx2, initialContext.value);
            }
          });
        },
        setupVirtualCursor(ctx2) {
          return dom15.setupVirtualCursor(ctx2);
        },
        preventTextSelection(ctx2) {
          return dom15.preventTextSelection(ctx2);
        },
        trackButtonDisabled(ctx2, _evt, { send }) {
          const btn = dom15.getPressedTriggerEl(ctx2, ctx2.hint);
          return observeAttributes(btn, {
            attributes: ["disabled"],
            callback() {
              send({ type: "TRIGGER.PRESS_UP", src: "attr" });
            }
          });
        },
        attachWheelListener(ctx2, _evt, { send }) {
          const inputEl = dom15.getInputEl(ctx2);
          if (!inputEl || !dom15.isActiveElement(ctx2, inputEl) || !ctx2.allowMouseWheel) return;
          function onWheel(event) {
            event.preventDefault();
            const dir = Math.sign(event.deltaY) * -1;
            if (dir === 1) {
              send("VALUE.INCREMENT");
            } else if (dir === -1) {
              send("VALUE.DECREMENT");
            }
          }
          return addDomEvent(inputEl, "wheel", onWheel, { passive: false });
        },
        activatePointerLock(ctx2) {
          if (isSafari()) return;
          return requestPointerLock(dom15.getDoc(ctx2));
        },
        trackMousemove(ctx2, _evt, { send }) {
          const doc = dom15.getDoc(ctx2);
          function onMousemove(event) {
            if (!ctx2.scrubberCursorPoint) return;
            const value = dom15.getMousemoveValue(ctx2, event);
            if (!value.hint) return;
            send({
              type: "SCRUBBER.POINTER_MOVE",
              hint: value.hint,
              point: value.point
            });
          }
          function onMouseup() {
            send("SCRUBBER.POINTER_UP");
          }
          return callAll2(
            addDomEvent(doc, "mousemove", onMousemove, false),
            addDomEvent(doc, "mouseup", onMouseup, false)
          );
        }
      },
      actions: {
        focusInput(ctx2) {
          if (!ctx2.focusInputOnChange) return;
          const inputEl = dom15.getInputEl(ctx2);
          if (dom15.isActiveElement(ctx2, inputEl)) return;
          raf(() => inputEl == null ? void 0 : inputEl.focus({ preventScroll: true }));
        },
        increment(ctx2, evt) {
          const nextValue = incrementValue(ctx2.valueAsNumber, evt.step ?? ctx2.step);
          const value = formatValue(ctx2, clampValue(nextValue, ctx2.min, ctx2.max));
          set12.value(ctx2, value);
        },
        decrement(ctx2, evt) {
          const nextValue = decrementValue(ctx2.valueAsNumber, evt.step ?? ctx2.step);
          const value = formatValue(ctx2, clampValue(nextValue, ctx2.min, ctx2.max));
          set12.value(ctx2, value);
        },
        setClampedValue(ctx2) {
          const nextValue = clampValue(ctx2.valueAsNumber, ctx2.min, ctx2.max);
          set12.value(ctx2, formatValue(ctx2, nextValue));
        },
        setRawValue(ctx2, evt) {
          const parsedValue = parseValue(ctx2, evt.value);
          const value = formatValue(ctx2, clampValue(parsedValue, ctx2.min, ctx2.max));
          set12.value(ctx2, value);
        },
        setValue(ctx2, evt) {
          var _a8;
          const value = ((_a8 = evt.target) == null ? void 0 : _a8.value) ?? evt.value;
          set12.value(ctx2, value);
        },
        clearValue(ctx2) {
          set12.value(ctx2, "");
        },
        incrementToMax(ctx2) {
          const value = formatValue(ctx2, ctx2.max);
          set12.value(ctx2, value);
        },
        decrementToMin(ctx2) {
          const value = formatValue(ctx2, ctx2.min);
          set12.value(ctx2, value);
        },
        setHint(ctx2, evt) {
          ctx2.hint = evt.hint;
        },
        clearHint(ctx2) {
          ctx2.hint = null;
        },
        setHintToSet(ctx2) {
          ctx2.hint = "set";
        },
        invokeOnFocus(ctx2) {
          var _a8;
          (_a8 = ctx2.onFocusChange) == null ? void 0 : _a8.call(ctx2, {
            focused: true,
            value: ctx2.formattedValue,
            valueAsNumber: ctx2.valueAsNumber
          });
        },
        invokeOnBlur(ctx2) {
          var _a8;
          (_a8 = ctx2.onFocusChange) == null ? void 0 : _a8.call(ctx2, {
            focused: false,
            value: ctx2.formattedValue,
            valueAsNumber: ctx2.valueAsNumber
          });
        },
        invokeOnInvalid(ctx2) {
          var _a8;
          if (!ctx2.isOutOfRange) return;
          const reason = ctx2.valueAsNumber > ctx2.max ? "rangeOverflow" : "rangeUnderflow";
          (_a8 = ctx2.onValueInvalid) == null ? void 0 : _a8.call(ctx2, {
            reason,
            value: ctx2.formattedValue,
            valueAsNumber: ctx2.valueAsNumber
          });
        },
        syncInputElement(ctx2, evt) {
          const value = evt.type.endsWith("CHANGE") ? ctx2.value : ctx2.formattedValue;
          sync4.input(ctx2, value);
        },
        setFormattedValue(ctx2) {
          set12.value(ctx2, ctx2.formattedValue);
        },
        setCursorPoint(ctx2, evt) {
          ctx2.scrubberCursorPoint = evt.point;
        },
        clearCursorPoint(ctx2) {
          ctx2.scrubberCursorPoint = null;
        },
        setVirtualCursorPosition(ctx2) {
          const cursorEl = dom15.getCursorEl(ctx2);
          if (!cursorEl || !ctx2.scrubberCursorPoint) return;
          const { x, y } = ctx2.scrubberCursorPoint;
          cursorEl.style.transform = `translate3d(${x}px, ${y}px, 0px)`;
        },
        setFormatterAndParser(ctx2) {
          if (!ctx2.locale) return;
          ctx2.formatter = createFormatter(ctx2.locale, ctx2.formatOptions);
          ctx2.parser = createParser(ctx2.locale, ctx2.formatOptions);
        }
      },
      compareFns: {
        formatOptions: (a2, b2) => isEqual(a2, b2),
        scrubberCursorPoint: (a2, b2) => isEqual(a2, b2)
      }
    }
  );
}
var sync4 = {
  input(ctx, value) {
    const inputEl = dom15.getInputEl(ctx);
    if (!inputEl) return;
    const sel = recordCursor(inputEl);
    raf(() => {
      setElementValue(inputEl, value);
      restoreCursor(inputEl, sel);
    });
  }
};
var invoke9 = {
  onChange: (ctx) => {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, {
      value: ctx.value,
      valueAsNumber: ctx.valueAsNumber
    });
  }
};
var set12 = {
  value: (ctx, value) => {
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke9.onChange(ctx);
  }
};

// node_modules/@ark-ui/react/dist/components/number-input/use-number-input.js
var import_react427 = __toESM(require_react(), 1);
var useNumberInput = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir, locale } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react427.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      input: field == null ? void 0 : field.ids.control
    },
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    invalid: field == null ? void 0 : field.invalid,
    dir,
    locale,
    getRootNode,
    value: props34.defaultValue,
    ...props34
  };
  const context = {
    ...initialContext,
    value: props34.value,
    onValueChange: useEvent(props34.onValueChange, { sync: true }),
    onValueInvalid: useEvent(props34.onValueInvalid),
    onFocusChange: useEvent(props34.onFocusChange)
  };
  const [state2, send] = useMachine(machine16(initialContext), { context });
  return connect16(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/number-input/number-input-root.js
var NumberInputRoot = (0, import_react429.forwardRef)((props34, ref2) => {
  const [useNumberInputProps, localProps] = createSplitProps2()(props34, [
    "allowMouseWheel",
    "allowOverflow",
    "clampValueOnBlur",
    "defaultValue",
    "disabled",
    "focusInputOnChange",
    "form",
    "formatOptions",
    "id",
    "ids",
    "inputMode",
    "invalid",
    "locale",
    "max",
    "min",
    "name",
    "onFocusChange",
    "onValueChange",
    "onValueInvalid",
    "pattern",
    "readOnly",
    "required",
    "spinOnPress",
    "step",
    "translations",
    "value"
  ]);
  const numberInput = useNumberInput(useNumberInputProps);
  const mergedProps = mergeProps2(numberInput.getRootProps(), localProps);
  return (0, import_jsx_runtime201.jsx)(NumberInputProvider, { value: numberInput, children: (0, import_jsx_runtime201.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
NumberInputRoot.displayName = "NumberInputRoot";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-root-provider.js
var import_jsx_runtime202 = __toESM(require_jsx_runtime(), 1);
var import_react431 = __toESM(require_react(), 1);
var NumberInputRootProvider = (0, import_react431.forwardRef)(
  (props34, ref2) => {
    const [{ value: numberInput }, localProps] = createSplitProps2()(props34, [
      "value"
    ]);
    const mergedProps = mergeProps2(numberInput.getRootProps(), localProps);
    return (0, import_jsx_runtime202.jsx)(NumberInputProvider, { value: numberInput, children: (0, import_jsx_runtime202.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
NumberInputRootProvider.displayName = "NumberInputRootProvider";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-scrubber.js
var import_jsx_runtime203 = __toESM(require_jsx_runtime(), 1);
var import_react433 = __toESM(require_react(), 1);
var NumberInputScrubber = (0, import_react433.forwardRef)(
  (props34, ref2) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps2(numberInput.getScrubberProps(), props34);
    return (0, import_jsx_runtime203.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
NumberInputScrubber.displayName = "NumberInputScrubber";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-value-text.js
var import_jsx_runtime204 = __toESM(require_jsx_runtime(), 1);
var import_react435 = __toESM(require_react(), 1);
var NumberInputValueText = (0, import_react435.forwardRef)(
  (props34, ref2) => {
    const { children, ...localProps } = props34;
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps2(numberInput.getValueTextProps(), localProps);
    return (0, import_jsx_runtime204.jsx)(ark.span, { ...mergedProps, ref: ref2, children: children || numberInput.value });
  }
);
NumberInputValueText.displayName = "NumberInputValueText";

// node_modules/@ark-ui/react/dist/components/number-input/number-input.js
var number_input_exports = {};
__export(number_input_exports, {
  Context: () => NumberInputContext,
  Control: () => NumberInputControl,
  DecrementTrigger: () => NumberInputDecrementTrigger,
  IncrementTrigger: () => NumberInputIncrementTrigger,
  Input: () => NumberInputInput,
  Label: () => NumberInputLabel,
  Root: () => NumberInputRoot,
  RootProvider: () => NumberInputRootProvider,
  Scrubber: () => NumberInputScrubber,
  ValueText: () => NumberInputValueText
});

// node_modules/@ark-ui/react/dist/components/pagination/use-pagination-context.js
var [PaginationProvider, usePaginationContext] = createContext3({
  name: "PaginationContext",
  hookName: "usePaginationContext",
  providerName: "<PaginationProvider />"
});

// node_modules/@ark-ui/react/dist/components/pagination/pagination-context.js
var PaginationContext = (props34) => props34.children(usePaginationContext());

// node_modules/@ark-ui/react/dist/components/pagination/pagination-ellipsis.js
var import_jsx_runtime205 = __toESM(require_jsx_runtime(), 1);
var import_react437 = __toESM(require_react(), 1);
var PaginationEllipsis = (0, import_react437.forwardRef)(
  (props34, ref2) => {
    const [ellipsisProps2, localProps] = createSplitProps2()(props34, ["index"]);
    const pagination = usePaginationContext();
    const mergedProps = mergeProps2(pagination.getEllipsisProps(ellipsisProps2), localProps);
    return (0, import_jsx_runtime205.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
PaginationEllipsis.displayName = "PaginationEllipsis";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-item.js
var import_jsx_runtime206 = __toESM(require_jsx_runtime(), 1);
var import_react439 = __toESM(require_react(), 1);
var PaginationItem = (0, import_react439.forwardRef)((props34, ref2) => {
  const [itemProps12, localProps] = createSplitProps2()(props34, ["value", "type"]);
  const pagination = usePaginationContext();
  const mergedProps = mergeProps2(pagination.getItemProps(itemProps12), localProps);
  return (0, import_jsx_runtime206.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
PaginationItem.displayName = "PaginationItem";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-next-trigger.js
var import_jsx_runtime207 = __toESM(require_jsx_runtime(), 1);
var import_react441 = __toESM(require_react(), 1);
var PaginationNextTrigger = (0, import_react441.forwardRef)(
  (props34, ref2) => {
    const pagination = usePaginationContext();
    const mergedProps = mergeProps2(pagination.getNextTriggerProps(), props34);
    return (0, import_jsx_runtime207.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
PaginationNextTrigger.displayName = "PaginationNextTrigger";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-prev-trigger.js
var import_jsx_runtime208 = __toESM(require_jsx_runtime(), 1);
var import_react443 = __toESM(require_react(), 1);
var PaginationPrevTrigger = (0, import_react443.forwardRef)(
  (props34, ref2) => {
    const pagination = usePaginationContext();
    const mergedProps = mergeProps2(pagination.getPrevTriggerProps(), props34);
    return (0, import_jsx_runtime208.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
PaginationPrevTrigger.displayName = "PaginationPrevTrigger";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-root.js
var import_jsx_runtime209 = __toESM(require_jsx_runtime(), 1);
var import_react447 = __toESM(require_react(), 1);

// node_modules/@zag-js/pagination/dist/index.mjs
var anatomy16 = createAnatomy("pagination").parts("root", "item", "ellipsis", "prevTrigger", "nextTrigger");
var parts18 = anatomy16.build();
var dom16 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `pagination:${ctx.id}`;
  },
  getPrevTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.prevTrigger) ?? `pagination:${ctx.id}:prev`;
  },
  getNextTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.nextTrigger) ?? `pagination:${ctx.id}:next`;
  },
  getEllipsisId: (ctx, index) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.ellipsis) == null ? void 0 : _b7.call(_a8, index)) ?? `pagination:${ctx.id}:ellipsis:${index}`;
  },
  getItemId: (ctx, page) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, page)) ?? `pagination:${ctx.id}:item:${page}`;
  }
});
var range = (start, end) => {
  let length2 = end - start + 1;
  return Array.from({ length: length2 }, (_, idx) => idx + start);
};
var transform = (items) => {
  return items.map((value) => {
    if (typeof value === "number") return { type: "page", value };
    return { type: "ellipsis" };
  });
};
var ELLIPSIS = "ellipsis";
var getRange = (ctx) => {
  const totalPageNumbers = Math.min(2 * ctx.siblingCount + 5, ctx.totalPages);
  const firstPageIndex = 1;
  const lastPageIndex = ctx.totalPages;
  const leftSiblingIndex = Math.max(ctx.page - ctx.siblingCount, firstPageIndex);
  const rightSiblingIndex = Math.min(ctx.page + ctx.siblingCount, lastPageIndex);
  const showLeftEllipsis = leftSiblingIndex > firstPageIndex + 1;
  const showRightEllipsis = rightSiblingIndex < lastPageIndex - 1;
  const itemCount = totalPageNumbers - 2;
  if (!showLeftEllipsis && showRightEllipsis) {
    const leftRange = range(1, itemCount);
    return [...leftRange, ELLIPSIS, lastPageIndex];
  }
  if (showLeftEllipsis && !showRightEllipsis) {
    const rightRange = range(lastPageIndex - itemCount + 1, lastPageIndex);
    return [firstPageIndex, ELLIPSIS, ...rightRange];
  }
  if (showLeftEllipsis && showRightEllipsis) {
    const middleRange = range(leftSiblingIndex, rightSiblingIndex);
    return [firstPageIndex, ELLIPSIS, ...middleRange, ELLIPSIS, lastPageIndex];
  }
  const fullRange = range(firstPageIndex, lastPageIndex);
  return fullRange;
};
var getTransformedRange = (ctx) => transform(getRange(ctx));
function connect17(state2, send, normalize3) {
  const totalPages = state2.context.totalPages;
  const page = state2.context.page;
  const translations = state2.context.translations;
  const count = state2.context.count;
  const previousPage = state2.context.previousPage;
  const nextPage = state2.context.nextPage;
  const pageRange = state2.context.pageRange;
  const type = state2.context.type;
  const isButton = type === "button";
  const isFirstPage = page === 1;
  const isLastPage = page === totalPages;
  const pages = getTransformedRange(state2.context);
  return {
    count,
    page,
    pageSize: state2.context.pageSize,
    totalPages,
    pages,
    previousPage,
    nextPage,
    pageRange,
    slice(data) {
      return data.slice(pageRange.start, pageRange.end);
    },
    setCount(count2) {
      send({ type: "SET_COUNT", count: count2 });
    },
    setPageSize(size3) {
      send({ type: "SET_PAGE_SIZE", size: size3 });
    },
    setPage(page2) {
      send({ type: "SET_PAGE", page: page2 });
    },
    goToNextPage() {
      send({ type: "NEXT_PAGE" });
    },
    goToPrevPage() {
      send({ type: "PREVIOUS_PAGE" });
    },
    goToFirstPage() {
      send({ type: "FIRST_PAGE" });
    },
    goToLastPage() {
      send({ type: "LAST_PAGE" });
    },
    getRootProps() {
      return normalize3.element({
        id: dom16.getRootId(state2.context),
        ...parts18.root.attrs,
        dir: state2.context.dir,
        "aria-label": translations.rootLabel
      });
    },
    getEllipsisProps(props210) {
      return normalize3.element({
        id: dom16.getEllipsisId(state2.context, props210.index),
        ...parts18.ellipsis.attrs,
        dir: state2.context.dir
      });
    },
    getItemProps(props210) {
      var _a8;
      const index = props210.value;
      const isCurrentPage = index === state2.context.page;
      return normalize3.element({
        id: dom16.getItemId(state2.context, index),
        ...parts18.item.attrs,
        dir: state2.context.dir,
        "data-index": index,
        "data-selected": dataAttr(isCurrentPage),
        "aria-current": isCurrentPage ? "page" : void 0,
        "aria-label": (_a8 = translations.itemLabel) == null ? void 0 : _a8.call(translations, { page: index, totalPages }),
        onClick() {
          send({ type: "SET_PAGE", page: index });
        },
        ...isButton && { type: "button" }
      });
    },
    getPrevTriggerProps() {
      return normalize3.element({
        id: dom16.getPrevTriggerId(state2.context),
        ...parts18.prevTrigger.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(isFirstPage),
        "aria-label": translations.prevTriggerLabel,
        onClick() {
          send({ type: "PREVIOUS_PAGE" });
        },
        ...isButton && { disabled: isFirstPage, type: "button" }
      });
    },
    getNextTriggerProps() {
      return normalize3.element({
        id: dom16.getNextTriggerId(state2.context),
        ...parts18.nextTrigger.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(isLastPage),
        "aria-label": translations.nextTriggerLabel,
        onClick() {
          send({ type: "NEXT_PAGE" });
        },
        ...isButton && { disabled: isLastPage, type: "button" }
      });
    }
  };
}
var defaultTranslations2 = {
  rootLabel: "pagination",
  prevTriggerLabel: "previous page",
  nextTriggerLabel: "next page",
  itemLabel({ page, totalPages }) {
    const isLastPage = totalPages > 1 && page === totalPages;
    return `${isLastPage ? "last page, " : ""}page ${page}`;
  }
};
function machine17(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "pagination",
      initial: "idle",
      context: {
        pageSize: 10,
        siblingCount: 1,
        page: 1,
        type: "button",
        translations: {
          ...defaultTranslations2,
          ...ctx.translations
        },
        ...ctx
      },
      watch: {
        pageSize: ["setPageIfNeeded"]
      },
      computed: {
        totalPages: (ctx2) => Math.ceil(ctx2.count / ctx2.pageSize),
        previousPage: (ctx2) => ctx2.page === 1 ? null : ctx2.page - 1,
        nextPage: (ctx2) => ctx2.page === ctx2.totalPages ? null : ctx2.page + 1,
        pageRange: (ctx2) => {
          const start = (ctx2.page - 1) * ctx2.pageSize;
          const end = Math.min(start + ctx2.pageSize, ctx2.count);
          return { start, end };
        },
        isValidPage: (ctx2) => ctx2.page >= 1 && ctx2.page <= ctx2.totalPages
      },
      on: {
        SET_COUNT: [
          {
            guard: "isValidCount",
            actions: ["setCount", "goToFirstPage"]
          },
          {
            actions: "setCount"
          }
        ],
        SET_PAGE: {
          guard: "isValidPage",
          actions: "setPage"
        },
        SET_PAGE_SIZE: {
          actions: "setPageSize"
        },
        FIRST_PAGE: {
          actions: "goToFirstPage"
        },
        LAST_PAGE: {
          actions: "goToLastPage"
        },
        PREVIOUS_PAGE: {
          guard: "canGoToPrevPage",
          actions: "goToPrevPage"
        },
        NEXT_PAGE: {
          guard: "canGoToNextPage",
          actions: "goToNextPage"
        }
      },
      states: {
        idle: {}
      }
    },
    {
      guards: {
        isValidPage: (ctx2, evt) => evt.page >= 1 && evt.page <= ctx2.totalPages,
        isValidCount: (ctx2, evt) => ctx2.page > evt.count,
        canGoToNextPage: (ctx2) => ctx2.page < ctx2.totalPages,
        canGoToPrevPage: (ctx2) => ctx2.page > 1
      },
      actions: {
        setCount(ctx2, evt) {
          ctx2.count = evt.count;
        },
        setPage(ctx2, evt) {
          set13.page(ctx2, evt.page);
        },
        setPageSize(ctx2, evt) {
          set13.pageSize(ctx2, evt.size);
        },
        goToFirstPage(ctx2) {
          set13.page(ctx2, 1);
        },
        goToLastPage(ctx2) {
          set13.page(ctx2, ctx2.totalPages);
        },
        goToPrevPage(ctx2) {
          set13.page(ctx2, ctx2.page - 1);
        },
        goToNextPage(ctx2) {
          set13.page(ctx2, ctx2.page + 1);
        },
        setPageIfNeeded(ctx2, _evt) {
          if (ctx2.isValidPage) return;
          set13.page(ctx2, 1);
        }
      }
    }
  );
}
var clampPage = (page, totalPages) => Math.min(Math.max(page, 1), totalPages);
var set13 = {
  pageSize: (ctx, value) => {
    var _a8;
    if (isEqual(ctx.pageSize, value)) return;
    ctx.pageSize = value;
    (_a8 = ctx.onPageSizeChange) == null ? void 0 : _a8.call(ctx, { pageSize: ctx.pageSize });
  },
  page: (ctx, value) => {
    var _a8;
    if (isEqual(ctx.page, value)) return;
    ctx.page = clampPage(value, ctx.totalPages);
    (_a8 = ctx.onPageChange) == null ? void 0 : _a8.call(ctx, { page: ctx.page, pageSize: ctx.pageSize });
  }
};
var props14 = createProps()([
  "count",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onPageChange",
  "onPageSizeChange",
  "page",
  "pageSize",
  "siblingCount",
  "translations",
  "type"
]);
var splitProps14 = createSplitProps(props14);
var itemProps5 = createProps()(["value", "type"]);
var splitItemProps5 = createSplitProps(itemProps5);
var ellipsisProps = createProps()(["index"]);
var splitEllipsisProps = createSplitProps(ellipsisProps);

// node_modules/@ark-ui/react/dist/components/pagination/use-pagination.js
var import_react445 = __toESM(require_react(), 1);
var usePagination = (props34) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react445.useId)(),
    dir,
    getRootNode,
    page: props34.defaultPage,
    ...props34
  };
  const context = {
    ...initialContext,
    page: props34.page,
    onPageChange: useEvent(props34.onPageChange, { sync: true })
  };
  const [state2, send] = useMachine(machine17(initialContext), { context });
  return connect17(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/pagination/pagination-root.js
var PaginationRoot = (0, import_react447.forwardRef)((props34, ref2) => {
  const [paginationProps, localProps] = createSplitProps2()(props34, [
    "count",
    "defaultPage",
    "id",
    "ids",
    "onPageChange",
    "onPageSizeChange",
    "page",
    "pageSize",
    "siblingCount",
    "translations",
    "type"
  ]);
  const pagination = usePagination(paginationProps);
  const mergedProps = mergeProps2(pagination.getRootProps(), localProps);
  return (0, import_jsx_runtime209.jsx)(PaginationProvider, { value: pagination, children: (0, import_jsx_runtime209.jsx)(ark.nav, { ...mergedProps, ref: ref2 }) });
});
PaginationRoot.displayName = "PaginationRoot";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-root-provider.js
var import_jsx_runtime210 = __toESM(require_jsx_runtime(), 1);
var import_react449 = __toESM(require_react(), 1);
var PaginationRootProvider = (0, import_react449.forwardRef)(
  (props34, ref2) => {
    const [{ value: pagination }, localProps] = createSplitProps2()(props34, [
      "value"
    ]);
    const mergedProps = mergeProps2(pagination.getRootProps(), localProps);
    return (0, import_jsx_runtime210.jsx)(PaginationProvider, { value: pagination, children: (0, import_jsx_runtime210.jsx)(ark.nav, { ...mergedProps, ref: ref2 }) });
  }
);
PaginationRootProvider.displayName = "PaginationRootProvider";

// node_modules/@ark-ui/react/dist/components/pagination/pagination.js
var pagination_exports = {};
__export(pagination_exports, {
  Context: () => PaginationContext,
  Ellipsis: () => PaginationEllipsis,
  Item: () => PaginationItem,
  NextTrigger: () => PaginationNextTrigger,
  PrevTrigger: () => PaginationPrevTrigger,
  Root: () => PaginationRoot,
  RootProvider: () => PaginationRootProvider
});

// node_modules/@ark-ui/react/dist/components/pin-input/use-pin-input-context.js
var [PinInputProvider, usePinInputContext] = createContext3({
  name: "PinInputContext",
  hookName: "usePinInputContext",
  providerName: "<PinInputProvider />"
});

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-context.js
var PinInputContext = (props34) => props34.children(usePinInputContext());

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-control.js
var import_jsx_runtime211 = __toESM(require_jsx_runtime(), 1);
var import_react451 = __toESM(require_react(), 1);
var PinInputControl = (0, import_react451.forwardRef)((props34, ref2) => {
  const pinInput = usePinInputContext();
  const mergedProps = mergeProps2(pinInput.getControlProps(), props34);
  return (0, import_jsx_runtime211.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PinInputControl.displayName = "PinInputControl";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-hidden-input.js
var import_jsx_runtime212 = __toESM(require_jsx_runtime(), 1);
var import_react453 = __toESM(require_react(), 1);
var PinInputHiddenInput = (0, import_react453.forwardRef)(
  (props34, ref2) => {
    const pinInput = usePinInputContext();
    const mergedProps = mergeProps2(pinInput.getHiddenInputProps(), props34);
    const field = useFieldContext();
    return (0, import_jsx_runtime212.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
PinInputHiddenInput.displayName = "PinInputHiddenInput";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-input.js
var import_jsx_runtime213 = __toESM(require_jsx_runtime(), 1);
var import_react455 = __toESM(require_react(), 1);
var PinInputInput = (0, import_react455.forwardRef)((props34, ref2) => {
  const [inputProps2, localProps] = createSplitProps2()(props34, ["index"]);
  const pinInput = usePinInputContext();
  const mergedProps = mergeProps2(pinInput.getInputProps(inputProps2), localProps);
  return (0, import_jsx_runtime213.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
PinInputInput.displayName = "PinInputInput";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-label.js
var import_jsx_runtime214 = __toESM(require_jsx_runtime(), 1);
var import_react457 = __toESM(require_react(), 1);
var PinInputLabel = (0, import_react457.forwardRef)((props34, ref2) => {
  const pinInput = usePinInputContext();
  const mergedProps = mergeProps2(pinInput.getLabelProps(), props34);
  return (0, import_jsx_runtime214.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
PinInputLabel.displayName = "PinInputLabel";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-root.js
var import_jsx_runtime215 = __toESM(require_jsx_runtime(), 1);
var import_react461 = __toESM(require_react(), 1);

// node_modules/@zag-js/pin-input/dist/index.mjs
var anatomy17 = createAnatomy("pinInput").parts("root", "label", "input", "control");
var parts19 = anatomy17.build();
var dom17 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `pin-input:${ctx.id}`;
  },
  getInputId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.input) == null ? void 0 : _b7.call(_a8, id)) ?? `pin-input:${ctx.id}:${id}`;
  },
  getHiddenInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `pin-input:${ctx.id}:hidden`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `pin-input:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `pin-input:${ctx.id}:control`;
  },
  getRootEl: (ctx) => dom17.getById(ctx, dom17.getRootId(ctx)),
  getInputEls: (ctx) => {
    const ownerId = CSS.escape(dom17.getRootId(ctx));
    const selector = `input[data-ownedby=${ownerId}]`;
    return queryAll(dom17.getRootEl(ctx), selector);
  },
  getInputEl: (ctx, id) => dom17.getById(ctx, dom17.getInputId(ctx, id)),
  getFocusedInputEl: (ctx) => dom17.getInputEls(ctx)[ctx.focusedIndex],
  getFirstInputEl: (ctx) => dom17.getInputEls(ctx)[0],
  getHiddenInputEl: (ctx) => dom17.getById(ctx, dom17.getHiddenInputId(ctx))
});
var REGEX = {
  numeric: /^[0-9]+$/,
  alphabetic: /^[A-Za-z]+$/,
  alphanumeric: /^[a-zA-Z0-9]+$/i
};
function isValidType(ctx, value) {
  var _a8;
  if (!ctx.type) return true;
  return !!((_a8 = REGEX[ctx.type]) == null ? void 0 : _a8.test(value));
}
function isValidValue(ctx, value) {
  if (!ctx.pattern) return isValidType(ctx, value);
  const regex = new RegExp(ctx.pattern, "g");
  return regex.test(value);
}
function connect18(state2, send, normalize3) {
  const complete = state2.context.isValueComplete;
  const invalid = state2.context.invalid;
  const focusedIndex = state2.context.focusedIndex;
  const translations = state2.context.translations;
  function focus() {
    var _a8;
    (_a8 = dom17.getFirstInputEl(state2.context)) == null ? void 0 : _a8.focus();
  }
  return {
    focus,
    value: state2.context.value,
    valueAsString: state2.context.valueAsString,
    complete,
    setValue(value) {
      if (!Array.isArray(value)) {
        invariant("[pin-input/setValue] value must be an array");
      }
      send({ type: "VALUE.SET", value });
    },
    clearValue() {
      send({ type: "VALUE.CLEAR" });
    },
    setValueAtIndex(index, value) {
      send({ type: "VALUE.SET", value, index });
    },
    getRootProps() {
      return normalize3.element({
        dir: state2.context.dir,
        ...parts19.root.attrs,
        id: dom17.getRootId(state2.context),
        "data-invalid": dataAttr(invalid),
        "data-disabled": dataAttr(state2.context.disabled),
        "data-complete": dataAttr(complete),
        "data-readonly": dataAttr(state2.context.readOnly)
      });
    },
    getLabelProps() {
      return normalize3.label({
        ...parts19.label.attrs,
        dir: state2.context.dir,
        htmlFor: dom17.getHiddenInputId(state2.context),
        id: dom17.getLabelId(state2.context),
        "data-invalid": dataAttr(invalid),
        "data-disabled": dataAttr(state2.context.disabled),
        "data-complete": dataAttr(complete),
        "data-readonly": dataAttr(state2.context.readOnly),
        onClick(event) {
          event.preventDefault();
          focus();
        }
      });
    },
    getHiddenInputProps() {
      return normalize3.input({
        "aria-hidden": true,
        type: "text",
        tabIndex: -1,
        id: dom17.getHiddenInputId(state2.context),
        readOnly: state2.context.readOnly,
        disabled: state2.context.disabled,
        required: state2.context.required,
        name: state2.context.name,
        form: state2.context.form,
        style: visuallyHiddenStyle,
        maxLength: state2.context.valueLength,
        defaultValue: state2.context.valueAsString
      });
    },
    getControlProps() {
      return normalize3.element({
        ...parts19.control.attrs,
        dir: state2.context.dir,
        id: dom17.getControlId(state2.context)
      });
    },
    getInputProps(props34) {
      const { index } = props34;
      const inputType = state2.context.type === "numeric" ? "tel" : "text";
      return normalize3.input({
        ...parts19.input.attrs,
        dir: state2.context.dir,
        disabled: state2.context.disabled,
        "data-disabled": dataAttr(state2.context.disabled),
        "data-complete": dataAttr(complete),
        id: dom17.getInputId(state2.context, index.toString()),
        "data-ownedby": dom17.getRootId(state2.context),
        "aria-label": translations.inputLabel(index, state2.context.valueLength),
        inputMode: state2.context.otp || state2.context.type === "numeric" ? "numeric" : "text",
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        type: state2.context.mask ? "password" : inputType,
        defaultValue: state2.context.value[index] || "",
        readOnly: state2.context.readOnly,
        autoCapitalize: "none",
        autoComplete: state2.context.otp ? "one-time-code" : "off",
        placeholder: focusedIndex === index ? "" : state2.context.placeholder,
        onBeforeInput(event) {
          try {
            const value = getBeforeInputValue(event);
            const isValid = isValidValue(state2.context, value);
            if (!isValid) {
              send({ type: "VALUE.INVALID", value });
              event.preventDefault();
            }
            if (value.length > 2) {
              event.currentTarget.setSelectionRange(0, 1, "forward");
            }
          } catch {
          }
        },
        onChange(event) {
          const evt = getNativeEvent(event);
          const { value } = event.currentTarget;
          if (evt.inputType === "insertFromPaste" || value.length > 2) {
            send({ type: "INPUT.PASTE", value });
            event.currentTarget.value = value[0];
            event.preventDefault();
            return;
          }
          if (evt.inputType === "deleteContentBackward") {
            send("INPUT.BACKSPACE");
            return;
          }
          send({ type: "INPUT.CHANGE", value, index });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          if (isModifierKey(event)) return;
          const keyMap2 = {
            Backspace() {
              send("INPUT.BACKSPACE");
            },
            Delete() {
              send("INPUT.DELETE");
            },
            ArrowLeft() {
              send("INPUT.ARROW_LEFT");
            },
            ArrowRight() {
              send("INPUT.ARROW_RIGHT");
            },
            Enter() {
              send("INPUT.ENTER");
            }
          };
          const exec2 = keyMap2[getEventKey(event, state2.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        },
        onFocus() {
          send({ type: "INPUT.FOCUS", index });
        },
        onBlur() {
          send({ type: "INPUT.BLUR", index });
        }
      });
    }
  };
}
function machine18(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "pin-input",
      initial: "idle",
      context: {
        value: [],
        placeholder: "○",
        otp: false,
        type: "numeric",
        ...ctx,
        focusedIndex: -1,
        translations: {
          inputLabel: (index, length2) => `pin code ${index + 1} of ${length2}`,
          ...ctx.translations
        }
      },
      computed: {
        valueLength: (ctx2) => ctx2.value.length,
        filledValueLength: (ctx2) => ctx2.value.filter((v) => (v == null ? void 0 : v.trim()) !== "").length,
        isValueComplete: (ctx2) => ctx2.valueLength === ctx2.filledValueLength,
        valueAsString: (ctx2) => ctx2.value.join(""),
        focusedValue: (ctx2) => ctx2.value[ctx2.focusedIndex] || ""
      },
      entry: choose([
        {
          guard: "autoFocus",
          actions: ["setupValue", "setFocusIndexToFirst"]
        },
        { actions: ["setupValue"] }
      ]),
      watch: {
        focusedIndex: ["focusInput", "selectInputIfNeeded"],
        value: ["syncInputElements"],
        isValueComplete: ["invokeOnComplete", "blurFocusedInputIfNeeded"]
      },
      on: {
        "VALUE.SET": [
          {
            guard: "hasIndex",
            actions: ["setValueAtIndex"]
          },
          { actions: ["setValue"] }
        ],
        "VALUE.CLEAR": {
          actions: ["clearValue", "setFocusIndexToFirst"]
        }
      },
      states: {
        idle: {
          on: {
            "INPUT.FOCUS": {
              target: "focused",
              actions: "setFocusedIndex"
            }
          }
        },
        focused: {
          on: {
            "INPUT.CHANGE": [
              {
                guard: "isFinalValue",
                actions: ["setFocusedValue", "syncInputValue"]
              },
              {
                actions: ["setFocusedValue", "setNextFocusedIndex", "syncInputValue"]
              }
            ],
            "INPUT.PASTE": {
              actions: ["setPastedValue", "setLastValueFocusIndex"]
            },
            "INPUT.BLUR": {
              target: "idle",
              actions: "clearFocusedIndex"
            },
            "INPUT.DELETE": {
              guard: "hasValue",
              actions: "clearFocusedValue"
            },
            "INPUT.ARROW_LEFT": {
              actions: "setPrevFocusedIndex"
            },
            "INPUT.ARROW_RIGHT": {
              actions: "setNextFocusedIndex"
            },
            "INPUT.BACKSPACE": [
              {
                guard: "hasValue",
                actions: ["clearFocusedValue"]
              },
              {
                actions: ["setPrevFocusedIndex", "clearFocusedValue"]
              }
            ],
            "INPUT.ENTER": {
              guard: "isValueComplete",
              actions: "requestFormSubmit"
            },
            "VALUE.INVALID": {
              actions: "invokeOnInvalid"
            }
          }
        }
      }
    },
    {
      guards: {
        autoFocus: (ctx2) => !!ctx2.autoFocus,
        isValueEmpty: (_ctx, evt) => evt.value === "",
        hasValue: (ctx2) => ctx2.value[ctx2.focusedIndex] !== "",
        isValueComplete: (ctx2) => ctx2.isValueComplete,
        isFinalValue: (ctx2) => ctx2.filledValueLength + 1 === ctx2.valueLength && ctx2.value.findIndex((v) => v.trim() === "") === ctx2.focusedIndex,
        hasIndex: (_ctx, evt) => evt.index !== void 0,
        isDisabled: (ctx2) => !!ctx2.disabled
      },
      actions: {
        setupValue(ctx2) {
          if (ctx2.value.length) return;
          const inputEls = dom17.getInputEls(ctx2);
          const emptyValues = Array.from({ length: inputEls.length }).fill("");
          assignValue(ctx2, emptyValues);
        },
        focusInput(ctx2) {
          var _a8;
          if (ctx2.focusedIndex === -1) return;
          (_a8 = dom17.getFocusedInputEl(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
        },
        selectInputIfNeeded(ctx2) {
          if (!ctx2.selectOnFocus || ctx2.focusedIndex === -1) return;
          raf(() => {
            var _a8;
            (_a8 = dom17.getFocusedInputEl(ctx2)) == null ? void 0 : _a8.select();
          });
        },
        invokeOnComplete(ctx2) {
          var _a8;
          if (!ctx2.isValueComplete) return;
          (_a8 = ctx2.onValueComplete) == null ? void 0 : _a8.call(ctx2, {
            value: Array.from(ctx2.value),
            valueAsString: ctx2.valueAsString
          });
        },
        invokeOnInvalid(ctx2, evt) {
          var _a8;
          (_a8 = ctx2.onValueInvalid) == null ? void 0 : _a8.call(ctx2, {
            value: evt.value,
            index: ctx2.focusedIndex
          });
        },
        clearFocusedIndex(ctx2) {
          ctx2.focusedIndex = -1;
        },
        setFocusedIndex(ctx2, evt) {
          ctx2.focusedIndex = evt.index;
        },
        setValue(ctx2, evt) {
          set14.value(ctx2, evt.value);
        },
        setFocusedValue(ctx2, evt) {
          const nextValue = getNextValue(ctx2.focusedValue, evt.value);
          set14.valueAtIndex(ctx2, ctx2.focusedIndex, nextValue);
        },
        revertInputValue(ctx2) {
          const inputEl = dom17.getFocusedInputEl(ctx2);
          dom17.setValue(inputEl, ctx2.focusedValue);
        },
        syncInputValue(ctx2, evt) {
          const inputEl = dom17.getInputEl(ctx2, evt.index.toString());
          dom17.setValue(inputEl, ctx2.value[evt.index]);
        },
        syncInputElements(ctx2) {
          const inputEls = dom17.getInputEls(ctx2);
          inputEls.forEach((inputEl, index) => {
            dom17.setValue(inputEl, ctx2.value[index]);
          });
        },
        setPastedValue(ctx2, evt) {
          raf(() => {
            const startIndex = Math.min(ctx2.focusedIndex, ctx2.filledValueLength);
            const left = startIndex > 0 ? ctx2.valueAsString.substring(0, ctx2.focusedIndex) : "";
            const right = evt.value.substring(0, ctx2.valueLength - startIndex);
            const value = left + right;
            set14.value(ctx2, value.split(""));
          });
        },
        setValueAtIndex(ctx2, evt) {
          const nextValue = getNextValue(ctx2.focusedValue, evt.value);
          set14.valueAtIndex(ctx2, evt.index, nextValue);
        },
        clearValue(ctx2) {
          const nextValue = Array.from({ length: ctx2.valueLength }).fill("");
          set14.value(ctx2, nextValue);
        },
        clearFocusedValue(ctx2) {
          set14.valueAtIndex(ctx2, ctx2.focusedIndex, "");
        },
        setFocusIndexToFirst(ctx2) {
          ctx2.focusedIndex = 0;
        },
        setNextFocusedIndex(ctx2) {
          ctx2.focusedIndex = Math.min(ctx2.focusedIndex + 1, ctx2.valueLength - 1);
        },
        setPrevFocusedIndex(ctx2) {
          ctx2.focusedIndex = Math.max(ctx2.focusedIndex - 1, 0);
        },
        setLastValueFocusIndex(ctx2) {
          raf(() => {
            ctx2.focusedIndex = Math.min(ctx2.filledValueLength, ctx2.valueLength - 1);
          });
        },
        blurFocusedInputIfNeeded(ctx2) {
          if (!ctx2.blurOnComplete) return;
          raf(() => {
            var _a8;
            (_a8 = dom17.getFocusedInputEl(ctx2)) == null ? void 0 : _a8.blur();
          });
        },
        requestFormSubmit(ctx2) {
          var _a8;
          if (!ctx2.name || !ctx2.isValueComplete) return;
          const inputEl = dom17.getHiddenInputEl(ctx2);
          (_a8 = inputEl == null ? void 0 : inputEl.form) == null ? void 0 : _a8.requestSubmit();
        }
      }
    }
  );
}
function assignValue(ctx, value) {
  const arr = Array.isArray(value) ? value : value.split("").filter(Boolean);
  arr.forEach((value2, index) => {
    ctx.value[index] = value2;
  });
}
function getNextValue(current, next3) {
  let nextValue = next3;
  if (current[0] === next3[0]) nextValue = next3[1];
  else if (current[0] === next3[1]) nextValue = next3[0];
  return nextValue.split("")[nextValue.length - 1];
}
var invoke10 = {
  change(ctx) {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, {
      value: Array.from(ctx.value),
      valueAsString: ctx.valueAsString
    });
    const inputEl = dom17.getHiddenInputEl(ctx);
    dispatchInputValueEvent(inputEl, { value: ctx.valueAsString });
  }
};
var set14 = {
  value(ctx, value) {
    if (isEqual(ctx.value, value)) return;
    assignValue(ctx, value);
    invoke10.change(ctx);
  },
  valueAtIndex(ctx, index, value) {
    if (isEqual(ctx.value[index], value)) return;
    ctx.value[index] = value;
    invoke10.change(ctx);
  }
};

// node_modules/@ark-ui/react/dist/components/pin-input/use-pin-input.js
var import_react459 = __toESM(require_react(), 1);
var usePinInput = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react459.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    invalid: field == null ? void 0 : field.invalid,
    dir,
    getRootNode,
    value: props34.defaultValue,
    ...props34
  };
  const context = {
    ...initialContext,
    value: props34.value,
    onValueChange: useEvent(props34.onValueChange, { sync: true }),
    onValueComplete: useEvent(props34.onValueComplete),
    onValueInvalid: useEvent(props34.onValueInvalid)
  };
  const [state2, send] = useMachine(machine18(initialContext), { context });
  return connect18(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-root.js
var PinInputRoot = (0, import_react461.forwardRef)((props34, ref2) => {
  const [usePinInputProps, localProps] = createSplitProps2()(props34, [
    "autoFocus",
    "blurOnComplete",
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "mask",
    "name",
    "onValueChange",
    "onValueComplete",
    "onValueInvalid",
    "otp",
    "pattern",
    "placeholder",
    "readOnly",
    "required",
    "selectOnFocus",
    "translations",
    "type",
    "value"
  ]);
  const pinInput = usePinInput(usePinInputProps);
  const mergedProps = mergeProps2(pinInput.getRootProps(), localProps);
  return (0, import_jsx_runtime215.jsx)(PinInputProvider, { value: pinInput, children: (0, import_jsx_runtime215.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
PinInputRoot.displayName = "PinInputRoot";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-root-provider.js
var import_jsx_runtime216 = __toESM(require_jsx_runtime(), 1);
var import_react463 = __toESM(require_react(), 1);
var PinInputRootProvider = (0, import_react463.forwardRef)(
  (props34, ref2) => {
    const [{ value: pinInput }, localProps] = createSplitProps2()(props34, [
      "value"
    ]);
    const mergedProps = mergeProps2(pinInput.getRootProps(), localProps);
    return (0, import_jsx_runtime216.jsx)(PinInputProvider, { value: pinInput, children: (0, import_jsx_runtime216.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
PinInputRootProvider.displayName = "PinInputRootProvider";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input.js
var pin_input_exports = {};
__export(pin_input_exports, {
  Context: () => PinInputContext,
  Control: () => PinInputControl,
  HiddenInput: () => PinInputHiddenInput,
  Input: () => PinInputInput,
  Label: () => PinInputLabel,
  Root: () => PinInputRoot,
  RootProvider: () => PinInputRootProvider
});

// node_modules/@ark-ui/react/dist/components/popover/popover-anchor.js
var import_jsx_runtime217 = __toESM(require_jsx_runtime(), 1);
var import_react465 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/popover/use-popover-context.js
var [PopoverProvider, usePopoverContext] = createContext3({
  name: "PopoverContext",
  hookName: "usePopoverContext",
  providerName: "<PopoverProvider />"
});

// node_modules/@ark-ui/react/dist/components/popover/popover-anchor.js
var PopoverAnchor = (0, import_react465.forwardRef)((props34, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps2(popover.getAnchorProps(), props34);
  return (0, import_jsx_runtime217.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverAnchor.displayName = "PopoverAnchor";

// node_modules/@ark-ui/react/dist/components/popover/popover-arrow.js
var import_jsx_runtime218 = __toESM(require_jsx_runtime(), 1);
var import_react467 = __toESM(require_react(), 1);
var PopoverArrow = (0, import_react467.forwardRef)((props34, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps2(popover.getArrowProps(), props34);
  return (0, import_jsx_runtime218.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverArrow.displayName = "PopoverArrow";

// node_modules/@ark-ui/react/dist/components/popover/popover-arrow-tip.js
var import_jsx_runtime219 = __toESM(require_jsx_runtime(), 1);
var import_react469 = __toESM(require_react(), 1);
var PopoverArrowTip = (0, import_react469.forwardRef)((props34, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps2(popover.getArrowTipProps(), props34);
  return (0, import_jsx_runtime219.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverArrowTip.displayName = "PopoverArrowTip";

// node_modules/@ark-ui/react/dist/components/popover/popover-close-trigger.js
var import_jsx_runtime220 = __toESM(require_jsx_runtime(), 1);
var import_react471 = __toESM(require_react(), 1);
var PopoverCloseTrigger = (0, import_react471.forwardRef)(
  (props34, ref2) => {
    const popover = usePopoverContext();
    const mergedProps = mergeProps2(popover.getCloseTriggerProps(), props34);
    return (0, import_jsx_runtime220.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
PopoverCloseTrigger.displayName = "PopoverCloseTrigger";

// node_modules/@ark-ui/react/dist/components/popover/popover-content.js
var import_jsx_runtime221 = __toESM(require_jsx_runtime(), 1);
var import_react473 = __toESM(require_react(), 1);
var PopoverContent = (0, import_react473.forwardRef)((props34, ref2) => {
  const popover = usePopoverContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(popover.getContentProps(), presence.getPresenceProps(), props34);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime221.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
PopoverContent.displayName = "PopoverContent";

// node_modules/@ark-ui/react/dist/components/popover/popover-context.js
var PopoverContext = (props34) => props34.children(usePopoverContext());

// node_modules/@ark-ui/react/dist/components/popover/popover-description.js
var import_jsx_runtime222 = __toESM(require_jsx_runtime(), 1);
var import_react475 = __toESM(require_react(), 1);
var PopoverDescription = (0, import_react475.forwardRef)(
  (props34, ref2) => {
    const popover = usePopoverContext();
    const mergedProps = mergeProps2(popover.getDescriptionProps(), props34);
    return (0, import_jsx_runtime222.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
PopoverDescription.displayName = "PopoverDescription";

// node_modules/@ark-ui/react/dist/components/popover/popover-indicator.js
var import_jsx_runtime223 = __toESM(require_jsx_runtime(), 1);
var import_react477 = __toESM(require_react(), 1);
var PopoverIndicator = (0, import_react477.forwardRef)((props34, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps2(popover.getIndicatorProps(), props34);
  return (0, import_jsx_runtime223.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverIndicator.displayName = "PopoverIndicator";

// node_modules/@ark-ui/react/dist/components/popover/popover-positioner.js
var import_jsx_runtime224 = __toESM(require_jsx_runtime(), 1);
var import_react479 = __toESM(require_react(), 1);
var PopoverPositioner = (0, import_react479.forwardRef)(
  (props34, ref2) => {
    const popover = usePopoverContext();
    const presence = usePresenceContext();
    const mergedProps = mergeProps2(popover.getPositionerProps(), props34);
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime224.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
PopoverPositioner.displayName = "PopoverPositioner";

// node_modules/@ark-ui/react/dist/components/popover/popover-root.js
var import_jsx_runtime225 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/popover/dist/index.mjs
var anatomy18 = createAnatomy("popover").parts(
  "arrow",
  "arrowTip",
  "anchor",
  "trigger",
  "indicator",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts20 = anatomy18.build();
var dom18 = createScope({
  getAnchorId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.anchor) ?? `popover:${ctx.id}:anchor`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `popover:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `popover:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `popover:${ctx.id}:popper`;
  },
  getArrowId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.arrow) ?? `popover:${ctx.id}:arrow`;
  },
  getTitleId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.title) ?? `popover:${ctx.id}:title`;
  },
  getDescriptionId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.description) ?? `popover:${ctx.id}:desc`;
  },
  getCloseTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.closeTrigger) ?? `popover:${ctx.id}:close`;
  },
  getAnchorEl: (ctx) => dom18.getById(ctx, dom18.getAnchorId(ctx)),
  getTriggerEl: (ctx) => dom18.getById(ctx, dom18.getTriggerId(ctx)),
  getContentEl: (ctx) => dom18.getById(ctx, dom18.getContentId(ctx)),
  getPositionerEl: (ctx) => dom18.getById(ctx, dom18.getPositionerId(ctx)),
  getTitleEl: (ctx) => dom18.getById(ctx, dom18.getTitleId(ctx)),
  getDescriptionEl: (ctx) => dom18.getById(ctx, dom18.getDescriptionId(ctx)),
  getFocusableEls: (ctx) => getFocusables(dom18.getContentEl(ctx)),
  getFirstFocusableEl: (ctx) => dom18.getFocusableEls(ctx)[0]
});
function connect19(state2, send, normalize3) {
  const open = state2.matches("open");
  const currentPlacement = state2.context.currentPlacement;
  const portalled = state2.context.currentPortalled;
  const rendered = state2.context.renderedElements;
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: currentPlacement
  });
  return {
    portalled,
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getArrowProps() {
      return normalize3.element({
        id: dom18.getArrowId(state2.context),
        ...parts20.arrow.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize3.element({
        ...parts20.arrowTip.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getAnchorProps() {
      return normalize3.element({
        ...parts20.anchor.attrs,
        dir: state2.context.dir,
        id: dom18.getAnchorId(state2.context)
      });
    },
    getTriggerProps() {
      return normalize3.button({
        ...parts20.trigger.attrs,
        dir: state2.context.dir,
        type: "button",
        "data-placement": currentPlacement,
        id: dom18.getTriggerId(state2.context),
        "aria-haspopup": "dialog",
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": dom18.getContentId(state2.context),
        onPointerDown(event) {
          if (isSafari()) {
            event.currentTarget.focus();
          }
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          send("TOGGLE");
        },
        onBlur(event) {
          send({ type: "TRIGGER_BLUR", target: event.relatedTarget });
        }
      });
    },
    getIndicatorProps() {
      return normalize3.element({
        ...parts20.indicator.attrs,
        dir: state2.context.dir,
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize3.element({
        id: dom18.getPositionerId(state2.context),
        ...parts20.positioner.attrs,
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize3.element({
        ...parts20.content.attrs,
        dir: state2.context.dir,
        id: dom18.getContentId(state2.context),
        tabIndex: -1,
        role: "dialog",
        hidden: !open,
        "data-state": open ? "open" : "closed",
        "data-expanded": dataAttr(open),
        "aria-labelledby": rendered.title ? dom18.getTitleId(state2.context) : void 0,
        "aria-describedby": rendered.description ? dom18.getDescriptionId(state2.context) : void 0,
        "data-placement": currentPlacement
      });
    },
    getTitleProps() {
      return normalize3.element({
        ...parts20.title.attrs,
        id: dom18.getTitleId(state2.context),
        dir: state2.context.dir
      });
    },
    getDescriptionProps() {
      return normalize3.element({
        ...parts20.description.attrs,
        id: dom18.getDescriptionId(state2.context),
        dir: state2.context.dir
      });
    },
    getCloseTriggerProps() {
      return normalize3.button({
        ...parts20.closeTrigger.attrs,
        dir: state2.context.dir,
        id: dom18.getCloseTriggerId(state2.context),
        type: "button",
        "aria-label": "close",
        onClick(event) {
          if (event.defaultPrevented) return;
          send("CLOSE");
        }
      });
    }
  };
}
function machine19(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "popover",
      initial: ctx.open ? "open" : "closed",
      context: {
        closeOnInteractOutside: true,
        closeOnEscape: true,
        autoFocus: true,
        modal: false,
        portalled: true,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        },
        currentPlacement: void 0,
        ...ctx,
        renderedElements: {
          title: true,
          description: true
        }
      },
      computed: {
        currentPortalled: (ctx2) => !!ctx2.modal || !!ctx2.portalled
      },
      watch: {
        open: ["toggleVisibility"]
      },
      entry: ["checkRenderedElements"],
      states: {
        closed: {
          on: {
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["setInitialFocus"]
            },
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ]
          }
        },
        open: {
          activities: [
            "trapFocus",
            "preventScroll",
            "hideContentBelow",
            "trackPositioning",
            "trackDismissableElement",
            "proxyTabFocus"
          ],
          on: {
            "CONTROLLED.CLOSE": {
              target: "closed",
              actions: ["setFinalFocus"]
            },
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose", "setFinalFocus"]
              }
            ],
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        }
      }
    },
    {
      guards: {
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const anchorEl = dom18.getAnchorEl(ctx2) ?? dom18.getTriggerEl(ctx2);
          const getPositionerEl = () => dom18.getPositionerEl(ctx2);
          return getPlacement(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom18.getContentEl(ctx2);
          let restoreFocus = true;
          return trackDismissableElement(getContentEl, {
            pointerBlocking: ctx2.modal,
            exclude: dom18.getTriggerEl(ctx2),
            defer: true,
            onEscapeKeyDown(event) {
              var _a8;
              (_a8 = ctx2.onEscapeKeyDown) == null ? void 0 : _a8.call(ctx2, event);
              if (ctx2.closeOnEscape) return;
              event.preventDefault();
            },
            onInteractOutside(event) {
              var _a8;
              (_a8 = ctx2.onInteractOutside) == null ? void 0 : _a8.call(ctx2, event);
              if (event.defaultPrevented) return;
              restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
              if (!ctx2.closeOnInteractOutside) {
                event.preventDefault();
              }
            },
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onFocusOutside: ctx2.onFocusOutside,
            persistentElements: ctx2.persistentElements,
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside", restoreFocus });
            }
          });
        },
        proxyTabFocus(ctx2) {
          if (ctx2.modal || !ctx2.portalled) return;
          const getContentEl = () => dom18.getContentEl(ctx2);
          return proxyTabFocus(getContentEl, {
            triggerElement: dom18.getTriggerEl(ctx2),
            defer: true,
            onFocus(el) {
              el.focus({ preventScroll: true });
            }
          });
        },
        hideContentBelow(ctx2) {
          if (!ctx2.modal) return;
          const getElements = () => [dom18.getContentEl(ctx2), dom18.getTriggerEl(ctx2)];
          return ariaHidden(getElements, { defer: true });
        },
        preventScroll(ctx2) {
          if (!ctx2.modal) return;
          return preventBodyScroll(dom18.getDoc(ctx2));
        },
        trapFocus(ctx2) {
          if (!ctx2.modal) return;
          const contentEl = () => dom18.getContentEl(ctx2);
          return trapFocus(contentEl, {
            initialFocus: () => getInitialFocus({
              root: dom18.getContentEl(ctx2),
              getInitialEl: ctx2.initialFocusEl,
              enabled: ctx2.autoFocus
            })
          });
        }
      },
      actions: {
        reposition(ctx2, evt) {
          const anchorEl = dom18.getAnchorEl(ctx2) ?? dom18.getTriggerEl(ctx2);
          const getPositionerEl = () => dom18.getPositionerEl(ctx2);
          getPlacement(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        checkRenderedElements(ctx2) {
          raf(() => {
            Object.assign(ctx2.renderedElements, {
              title: !!dom18.getTitleEl(ctx2),
              description: !!dom18.getDescriptionEl(ctx2)
            });
          });
        },
        setInitialFocus(ctx2) {
          if (ctx2.modal) return;
          raf(() => {
            const element = getInitialFocus({
              root: dom18.getContentEl(ctx2),
              getInitialEl: ctx2.initialFocusEl,
              enabled: ctx2.autoFocus
            });
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        setFinalFocus(ctx2, evt) {
          var _a8;
          const restoreFocus = evt.restoreFocus ?? ((_a8 = evt.previousEvent) == null ? void 0 : _a8.restoreFocus);
          if (restoreFocus != null && !restoreFocus) return;
          raf(() => {
            const element = dom18.getTriggerEl(ctx2);
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      }
    }
  );
}
var props15 = createProps()([
  "autoFocus",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "open.controlled",
  "open",
  "persistentElements",
  "portalled",
  "positioning"
]);
var splitProps15 = createSplitProps(props15);

// node_modules/@ark-ui/react/dist/components/popover/use-popover.js
var import_react481 = __toESM(require_react(), 1);
var usePopover = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react481.useId)(),
    dir,
    getRootNode,
    open: props34.defaultOpen,
    "open.controlled": props34.open !== void 0,
    ...props34
  };
  const context = {
    ...initialContext,
    open: props34.open,
    onOpenChange: useEvent(props34.onOpenChange, { sync: true })
  };
  const [state2, send] = useMachine(machine19(initialContext), { context });
  return connect19(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/popover/popover-root.js
var PopoverRoot = (props34) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props34);
  const popover = usePopover(localProps);
  const presence = usePresence(mergeProps2({ present: popover.open }, presenceProps));
  return (0, import_jsx_runtime225.jsx)(PopoverProvider, { value: popover, children: (0, import_jsx_runtime225.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/popover/popover-root-provider.js
var import_jsx_runtime226 = __toESM(require_jsx_runtime(), 1);
var PopoverRootProvider = (props34) => {
  const [presenceProps, { value: popover, children }] = splitPresenceProps(props34);
  const presence = usePresence(mergeProps2({ present: popover.open }, presenceProps));
  return (0, import_jsx_runtime226.jsx)(PopoverProvider, { value: popover, children: (0, import_jsx_runtime226.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/popover/popover-title.js
var import_jsx_runtime227 = __toESM(require_jsx_runtime(), 1);
var import_react485 = __toESM(require_react(), 1);
var PopoverTitle = (0, import_react485.forwardRef)((props34, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps2(popover.getTitleProps(), props34);
  return (0, import_jsx_runtime227.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverTitle.displayName = "PopoverTitle";

// node_modules/@ark-ui/react/dist/components/popover/popover-trigger.js
var import_jsx_runtime228 = __toESM(require_jsx_runtime(), 1);
var import_react487 = __toESM(require_react(), 1);
var PopoverTrigger = (0, import_react487.forwardRef)((props34, ref2) => {
  const popover = usePopoverContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(
    {
      ...popover.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : popover.getTriggerProps()["aria-controls"]
    },
    props34
  );
  return (0, import_jsx_runtime228.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
PopoverTrigger.displayName = "PopoverTrigger";

// node_modules/@ark-ui/react/dist/components/popover/popover.js
var popover_exports = {};
__export(popover_exports, {
  Anchor: () => PopoverAnchor,
  Arrow: () => PopoverArrow,
  ArrowTip: () => PopoverArrowTip,
  CloseTrigger: () => PopoverCloseTrigger,
  Content: () => PopoverContent,
  Context: () => PopoverContext,
  Description: () => PopoverDescription,
  Indicator: () => PopoverIndicator,
  Positioner: () => PopoverPositioner,
  Root: () => PopoverRoot,
  RootProvider: () => PopoverRootProvider,
  Title: () => PopoverTitle,
  Trigger: () => PopoverTrigger
});

// node_modules/@ark-ui/react/dist/components/portal/portal.js
var import_jsx_runtime229 = __toESM(require_jsx_runtime(), 1);
var import_react488 = __toESM(require_react(), 1);
var import_react_dom3 = __toESM(require_react_dom(), 1);
var Portal = (props34) => {
  var _a8;
  const { children, disabled } = props34;
  const [container, setContainer] = (0, import_react488.useState)((_a8 = props34.container) == null ? void 0 : _a8.current);
  const isServer = (0, import_react488.useSyncExternalStore)(
    subscribe2,
    () => false,
    () => true
  );
  const { getRootNode } = useEnvironmentContext();
  (0, import_react488.useEffect)(() => {
    setContainer(() => {
      var _a9;
      return (_a9 = props34.container) == null ? void 0 : _a9.current;
    });
  }, [props34.container]);
  if (isServer || disabled) return (0, import_jsx_runtime229.jsx)(import_jsx_runtime229.Fragment, { children });
  const mountNode = container ?? getPortalNode(getRootNode);
  return (0, import_jsx_runtime229.jsx)(import_jsx_runtime229.Fragment, { children: import_react488.Children.map(children, (child) => (0, import_react_dom3.createPortal)(child, mountNode)) });
};
var getPortalNode = (cb) => {
  const node2 = cb == null ? void 0 : cb();
  const rootNode = node2.getRootNode();
  if (isShadowRoot(rootNode)) return rootNode;
  return getDocument(node2).body;
};
var subscribe2 = () => () => {
};

// node_modules/@ark-ui/react/dist/components/progress/progress-circle.js
var import_jsx_runtime230 = __toESM(require_jsx_runtime(), 1);
var import_react490 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/progress/use-progress-context.js
var [ProgressProvider, useProgressContext] = createContext3({
  name: "ProgressContext",
  hookName: "useProgressContext",
  providerName: "<ProgressProvider />"
});

// node_modules/@ark-ui/react/dist/components/progress/progress-circle.js
var ProgressCircle = (0, import_react490.forwardRef)((props34, ref2) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps2(progress.getCircleProps(), props34);
  return (0, import_jsx_runtime230.jsx)(ark.svg, { ref: ref2, ...mergedProps });
});
ProgressCircle.displayName = "ProgressCircle";

// node_modules/@ark-ui/react/dist/components/progress/progress-circle-range.js
var import_jsx_runtime231 = __toESM(require_jsx_runtime(), 1);
var import_react492 = __toESM(require_react(), 1);
var ProgressCircleRange = (0, import_react492.forwardRef)(
  (props34, ref2) => {
    const progress = useProgressContext();
    const mergedProps = mergeProps2(progress.getCircleRangeProps(), props34);
    return (0, import_jsx_runtime231.jsx)(ark.circle, { ref: ref2, ...mergedProps });
  }
);
ProgressCircleRange.displayName = "ProgressCircleRange";

// node_modules/@ark-ui/react/dist/components/progress/progress-circle-track.js
var import_jsx_runtime232 = __toESM(require_jsx_runtime(), 1);
var import_react494 = __toESM(require_react(), 1);
var ProgressCircleTrack = (0, import_react494.forwardRef)(
  (props34, ref2) => {
    const progress = useProgressContext();
    const mergedProps = mergeProps2(progress.getCircleTrackProps(), props34);
    return (0, import_jsx_runtime232.jsx)(ark.circle, { ref: ref2, ...mergedProps });
  }
);
ProgressCircleTrack.displayName = "ProgressCircleTrack";

// node_modules/@ark-ui/react/dist/components/progress/progress-context.js
var ProgressContext = (props34) => props34.children(useProgressContext());

// node_modules/@ark-ui/react/dist/components/progress/progress-label.js
var import_jsx_runtime233 = __toESM(require_jsx_runtime(), 1);
var import_react496 = __toESM(require_react(), 1);
var ProgressLabel = (0, import_react496.forwardRef)((props34, ref2) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps2(progress.getLabelProps(), props34);
  return (0, import_jsx_runtime233.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
ProgressLabel.displayName = "ProgressLabel";

// node_modules/@ark-ui/react/dist/components/progress/progress-range.js
var import_jsx_runtime234 = __toESM(require_jsx_runtime(), 1);
var import_react498 = __toESM(require_react(), 1);
var ProgressRange = (0, import_react498.forwardRef)((props34, ref2) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps2(progress.getRangeProps(), props34);
  return (0, import_jsx_runtime234.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ProgressRange.displayName = "ProgressRange";

// node_modules/@ark-ui/react/dist/components/progress/progress-root.js
var import_jsx_runtime235 = __toESM(require_jsx_runtime(), 1);
var import_react502 = __toESM(require_react(), 1);

// node_modules/@zag-js/progress/dist/index.mjs
var anatomy19 = createAnatomy("progress").parts(
  "root",
  "label",
  "track",
  "range",
  "valueText",
  "view",
  "circle",
  "circleTrack",
  "circleRange"
);
var parts21 = anatomy19.build();
var dom19 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `progress-${ctx.id}`;
  },
  getTrackId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.track) ?? `progress-${ctx.id}-track`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `progress-${ctx.id}-label`;
  },
  getCircleId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.circle) ?? `progress-${ctx.id}-circle`;
  }
});
function connect20(state2, send, normalize3) {
  const percent = state2.context.percent;
  const percentAsString = state2.context.isIndeterminate ? "" : `${percent}%`;
  const max4 = state2.context.max;
  const min4 = state2.context.min;
  const orientation = state2.context.orientation;
  const translations = state2.context.translations;
  const indeterminate = state2.context.isIndeterminate;
  const value = state2.context.value;
  const valueAsString = translations.value({ value, max: max4, percent, min: min4 });
  const progressState = getProgressState(value, max4);
  const progressbarProps = {
    role: "progressbar",
    "aria-label": valueAsString,
    "data-max": max4,
    "aria-valuemin": min4,
    "aria-valuemax": max4,
    "aria-valuenow": value ?? void 0,
    "data-orientation": orientation,
    "data-state": progressState
  };
  const circleProps = getCircleProps(state2.context);
  return {
    value,
    valueAsString,
    min: min4,
    max: max4,
    percent,
    percentAsString,
    indeterminate,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    setToMax() {
      send({ type: "VALUE.SET", value: max4 });
    },
    setToMin() {
      send({ type: "VALUE.SET", value: min4 });
    },
    getRootProps() {
      return normalize3.element({
        dir: state2.context.dir,
        ...parts21.root.attrs,
        id: dom19.getRootId(state2.context),
        "data-max": max4,
        "data-value": value ?? void 0,
        "data-state": progressState,
        "data-orientation": orientation,
        style: {
          "--percent": indeterminate ? void 0 : percent
        }
      });
    },
    getLabelProps() {
      return normalize3.element({
        dir: state2.context.dir,
        id: dom19.getLabelId(state2.context),
        ...parts21.label.attrs,
        "data-orientation": orientation
      });
    },
    getValueTextProps() {
      return normalize3.element({
        dir: state2.context.dir,
        "aria-live": "polite",
        ...parts21.valueText.attrs
      });
    },
    getTrackProps() {
      return normalize3.element({
        dir: state2.context.dir,
        id: dom19.getTrackId(state2.context),
        ...parts21.track.attrs,
        ...progressbarProps
      });
    },
    getRangeProps() {
      return normalize3.element({
        dir: state2.context.dir,
        ...parts21.range.attrs,
        "data-orientation": orientation,
        "data-state": progressState,
        style: {
          [state2.context.isHorizontal ? "width" : "height"]: indeterminate ? void 0 : `${percent}%`
        }
      });
    },
    getCircleProps() {
      return normalize3.element({
        dir: state2.context.dir,
        id: dom19.getCircleId(state2.context),
        ...parts21.circle.attrs,
        ...progressbarProps,
        ...circleProps.root
      });
    },
    getCircleTrackProps() {
      return normalize3.element({
        dir: state2.context.dir,
        "data-orientation": orientation,
        ...parts21.circleTrack.attrs,
        ...circleProps.track
      });
    },
    getCircleRangeProps() {
      return normalize3.element({
        dir: state2.context.dir,
        ...parts21.circleRange.attrs,
        ...circleProps.range,
        "data-state": progressState
      });
    },
    getViewProps(props210) {
      return normalize3.element({
        dir: state2.context.dir,
        ...parts21.view.attrs,
        "data-state": props210.state,
        hidden: props210.state !== progressState
      });
    }
  };
}
function getProgressState(value, maxValue2) {
  return value == null ? "indeterminate" : value === maxValue2 ? "complete" : "loading";
}
function getCircleProps(ctx) {
  const circleProps = {
    style: {
      "--radius": "calc(var(--size) / 2 - var(--thickness) / 2)",
      cx: "calc(var(--size) / 2)",
      cy: "calc(var(--size) / 2)",
      r: "var(--radius)",
      fill: "transparent",
      strokeWidth: "var(--thickness)"
    }
  };
  return {
    root: {
      style: {
        width: "var(--size)",
        height: "var(--size)"
      }
    },
    track: circleProps,
    range: {
      opacity: ctx.value === 0 ? 0 : void 0,
      style: {
        ...circleProps.style,
        "--percent": ctx.percent,
        "--circumference": `calc(2 * 3.14159 * var(--radius))`,
        "--offset": `calc(var(--circumference) * (100 - var(--percent)) / 100)`,
        strokeDashoffset: `calc(var(--circumference) * ((100 - var(--percent)) / 100))`,
        strokeDasharray: ctx.isIndeterminate ? void 0 : `var(--circumference)`,
        transformOrigin: "center",
        transform: "rotate(-90deg)"
      }
    }
  };
}
function midValue(min4, max4) {
  return min4 + (max4 - min4) / 2;
}
function machine20(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "progress",
      initial: "idle",
      context: {
        max: ctx.max ?? 100,
        min: ctx.min ?? 0,
        value: midValue(ctx.min ?? 0, ctx.max ?? 100),
        orientation: "horizontal",
        translations: {
          value: ({ percent }) => percent === -1 ? "loading..." : `${percent} percent`,
          ...ctx.translations
        },
        ...ctx
      },
      created: ["validateContext"],
      computed: {
        isIndeterminate: (ctx2) => ctx2.value === null,
        percent(ctx2) {
          if (!isNumber(ctx2.value)) return -1;
          return Math.round((ctx2.value - ctx2.min) / (ctx2.max - ctx2.min) * 100);
        },
        isAtMax: (ctx2) => ctx2.value === ctx2.max,
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        isRtl: (ctx2) => ctx2.dir === "rtl"
      },
      states: {
        idle: {
          on: {
            "VALUE.SET": {
              actions: ["setValue"]
            }
          }
        }
      }
    },
    {
      actions: {
        setValue: (ctx2, evt) => {
          set15.value(ctx2, evt.value);
        },
        validateContext: (ctx2) => {
          if (ctx2.value == null) return;
          if (!isValidNumber(ctx2.max)) {
            throw new Error(`[progress] The max value passed \`${ctx2.max}\` is not a valid number`);
          }
          if (!isValidMax(ctx2.value, ctx2.max)) {
            throw new Error(`[progress] The value passed \`${ctx2.value}\` exceeds the max value \`${ctx2.max}\``);
          }
          if (!isValidMin(ctx2.value, ctx2.min)) {
            throw new Error(`[progress] The value passed \`${ctx2.value}\` exceeds the min value \`${ctx2.min}\``);
          }
        }
      }
    }
  );
}
function isValidNumber(max4) {
  return isNumber(max4) && !isNaN(max4);
}
function isValidMax(value, max4) {
  return isValidNumber(value) && value <= max4;
}
function isValidMin(value, min4) {
  return isValidNumber(value) && value >= min4;
}
var set15 = {
  value(ctx, value) {
    var _a8;
    if (isEqual(ctx.value, value)) return;
    ctx.value = value === null ? null : Math.max(0, Math.min(value, ctx.max));
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value });
  }
};
var props16 = createProps()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "max",
  "min",
  "orientation",
  "translations",
  "value",
  "onValueChange"
]);
var splitProps16 = createSplitProps(props16);

// node_modules/@ark-ui/react/dist/components/progress/use-progress.js
var import_react500 = __toESM(require_react(), 1);
var useProgress = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react500.useId)(),
    dir,
    getRootNode,
    value: props34.defaultValue,
    ...props34
  };
  const context = {
    ...initialContext,
    value: props34.value,
    onValueChange: useEvent(props34.onValueChange, { sync: true })
  };
  const [state2, send] = useMachine(machine20(initialContext), { context });
  return connect20(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/progress/progress-root.js
var ProgressRoot = (0, import_react502.forwardRef)((props34, ref2) => {
  const [progressProps, localProps] = createSplitProps2()(props34, [
    "defaultValue",
    "id",
    "ids",
    "max",
    "min",
    "onValueChange",
    "orientation",
    "translations",
    "value"
  ]);
  const progress = useProgress(progressProps);
  const mergedProps = mergeProps2(progress.getRootProps(), localProps);
  return (0, import_jsx_runtime235.jsx)(ProgressProvider, { value: progress, children: (0, import_jsx_runtime235.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
ProgressRoot.displayName = "ProgressRoot";

// node_modules/@ark-ui/react/dist/components/progress/progress-root-provider.js
var import_jsx_runtime236 = __toESM(require_jsx_runtime(), 1);
var import_react504 = __toESM(require_react(), 1);
var ProgressRootProvider = (0, import_react504.forwardRef)(
  (props34, ref2) => {
    const [{ value: progress }, localProps] = createSplitProps2()(props34, [
      "value"
    ]);
    const mergedProps = mergeProps2(progress.getRootProps(), localProps);
    return (0, import_jsx_runtime236.jsx)(ProgressProvider, { value: progress, children: (0, import_jsx_runtime236.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
ProgressRootProvider.displayName = "ProgressRootProvider";

// node_modules/@ark-ui/react/dist/components/progress/progress-track.js
var import_jsx_runtime237 = __toESM(require_jsx_runtime(), 1);
var import_react506 = __toESM(require_react(), 1);
var ProgressTrack = (0, import_react506.forwardRef)((props34, ref2) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps2(progress.getTrackProps(), props34);
  return (0, import_jsx_runtime237.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ProgressTrack.displayName = "ProgressTrack";

// node_modules/@ark-ui/react/dist/components/progress/progress-value-text.js
var import_jsx_runtime238 = __toESM(require_jsx_runtime(), 1);
var import_react508 = __toESM(require_react(), 1);
var ProgressValueText = (0, import_react508.forwardRef)(
  (props34, ref2) => {
    const { children, ...rest } = props34;
    const progress = useProgressContext();
    const mergedProps = mergeProps2(progress.getValueTextProps(), rest);
    return (0, import_jsx_runtime238.jsx)(ark.span, { ...mergedProps, ref: ref2, children: children || progress.percentAsString });
  }
);
ProgressValueText.displayName = "ProgressValueText";

// node_modules/@ark-ui/react/dist/components/progress/progress-view.js
var import_jsx_runtime239 = __toESM(require_jsx_runtime(), 1);
var import_react510 = __toESM(require_react(), 1);
var ProgressView = (0, import_react510.forwardRef)((props34, ref2) => {
  const [viewProps2, localProps] = createSplitProps2()(props34, ["state"]);
  const progress = useProgressContext();
  const mergedProps = mergeProps2(progress.getViewProps(viewProps2), localProps);
  return (0, import_jsx_runtime239.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
ProgressView.displayName = "ProgressView";

// node_modules/@ark-ui/react/dist/components/progress/progress.js
var progress_exports = {};
__export(progress_exports, {
  Circle: () => ProgressCircle,
  CircleRange: () => ProgressCircleRange,
  CircleTrack: () => ProgressCircleTrack,
  Context: () => ProgressContext,
  Label: () => ProgressLabel,
  Range: () => ProgressRange,
  Root: () => ProgressRoot,
  RootProvider: () => ProgressRootProvider,
  Track: () => ProgressTrack,
  ValueText: () => ProgressValueText,
  View: () => ProgressView
});

// node_modules/@ark-ui/react/dist/components/qr-code/use-qr-code-context.js
var [QrCodeProvider, useQrCodeContext] = createContext3({
  name: "QrCodeContext",
  hookName: "useQrCodeContext",
  providerName: "<QrCodeProvider />"
});

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-context.js
var QrCodeContext = (props34) => props34.children(useQrCodeContext());

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-download-trigger.js
var import_jsx_runtime240 = __toESM(require_jsx_runtime(), 1);
var import_react512 = __toESM(require_react(), 1);
var QrCodeDownloadTrigger = (0, import_react512.forwardRef)(
  (props34, ref2) => {
    const [downloadTriggerProps, localProps] = createSplitProps2()(props34, [
      "fileName",
      "mimeType",
      "quality"
    ]);
    const qrCode = useQrCodeContext();
    const mergedProps = mergeProps2(qrCode.getDownloadTriggerProps(downloadTriggerProps), localProps);
    return (0, import_jsx_runtime240.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
QrCodeDownloadTrigger.displayName = "QrCodeDownloadTrigger";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-frame.js
var import_jsx_runtime241 = __toESM(require_jsx_runtime(), 1);
var import_react514 = __toESM(require_react(), 1);
var QrCodeFrame = (0, import_react514.forwardRef)((props34, ref2) => {
  const qrCode = useQrCodeContext();
  const mergedProps = mergeProps2(qrCode.getFrameProps(), props34);
  return (0, import_jsx_runtime241.jsx)(ark.svg, { ...mergedProps, ref: ref2 });
});
QrCodeFrame.displayName = "QrCodeFrame";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-overlay.js
var import_jsx_runtime242 = __toESM(require_jsx_runtime(), 1);
var import_react516 = __toESM(require_react(), 1);
var QrCodeOverlay = (0, import_react516.forwardRef)((props34, ref2) => {
  const qrCode = useQrCodeContext();
  const mergedProps = mergeProps2(qrCode.getOverlayProps(), props34);
  return (0, import_jsx_runtime242.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
QrCodeOverlay.displayName = "QrCodeOverlay";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-pattern.js
var import_jsx_runtime243 = __toESM(require_jsx_runtime(), 1);
var import_react518 = __toESM(require_react(), 1);
var QrCodePattern = (0, import_react518.forwardRef)((props34, ref2) => {
  const qrCode = useQrCodeContext();
  const mergedProps = mergeProps2(qrCode.getPatternProps(), props34);
  return (0, import_jsx_runtime243.jsx)(ark.path, { ...mergedProps, ref: ref2 });
});
QrCodePattern.displayName = "QrCodePattern";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-root.js
var import_jsx_runtime244 = __toESM(require_jsx_runtime(), 1);
var import_react522 = __toESM(require_react(), 1);

// node_modules/proxy-memoize/dist/memoize.js
var targetCache2 = /* @__PURE__ */ new WeakMap();
var HAS_KEY_PROPERTY2 = "h";
var ALL_OWN_KEYS_PROPERTY2 = "w";
var HAS_OWN_KEY_PROPERTY2 = "o";
var KEYS_PROPERTY2 = "k";
var trackMemoUntrackedObjSet = /* @__PURE__ */ new WeakSet();
var isObject6 = (x) => typeof x === "object" && x !== null;
var untrack = (x, seen) => {
  if (!isObject6(x))
    return x;
  const untrackedObj = getUntracked(x);
  if (untrackedObj) {
    trackMemo(x);
    trackMemoUntrackedObjSet.add(untrackedObj);
    return untrackedObj;
  }
  if (!seen.has(x)) {
    seen.add(x);
    Object.entries(x).forEach(([k, v]) => {
      const vv = untrack(v, seen);
      if (!Object.is(vv, v))
        x[k] = vv;
    });
  }
  return x;
};
var touchAffected = (dst, src, affected) => {
  var _a8, _b7, _c6;
  if (!isObject6(dst) || !isObject6(src))
    return;
  const untrackedObj = getUntracked(src);
  const used = affected.get(untrackedObj || src);
  if (!used) {
    if (trackMemoUntrackedObjSet.has(untrackedObj)) {
      trackMemo(dst);
    }
    return;
  }
  (_a8 = used[HAS_KEY_PROPERTY2]) === null || _a8 === void 0 ? void 0 : _a8.forEach((key) => {
    Reflect.has(dst, key);
  });
  if (used[ALL_OWN_KEYS_PROPERTY2] === true) {
    Reflect.ownKeys(dst);
  }
  (_b7 = used[HAS_OWN_KEY_PROPERTY2]) === null || _b7 === void 0 ? void 0 : _b7.forEach((key) => {
    Reflect.getOwnPropertyDescriptor(dst, key);
  });
  (_c6 = used[KEYS_PROPERTY2]) === null || _c6 === void 0 ? void 0 : _c6.forEach((key) => {
    touchAffected(dst[key], src[key], affected);
  });
};
var isOriginalEqual = (x, y) => {
  for (let xx = x; xx; x = xx, xx = getUntracked(xx))
    ;
  for (let yy = y; yy; y = yy, yy = getUntracked(yy))
    ;
  return Object.is(x, y);
};
var OBJ_PROPERTY = "o";
var RESULT_PROPERTY = "r";
var AFFECTED_PROPERTY2 = "a";
function memoize2(fn, options) {
  var _a8;
  let memoListHead = 0;
  const size3 = (_a8 = options === null || options === void 0 ? void 0 : options.size) !== null && _a8 !== void 0 ? _a8 : 1;
  const memoList = [];
  const resultCache = (options === null || options === void 0 ? void 0 : options.noWeakMap) ? null : /* @__PURE__ */ new WeakMap();
  const memoizedFn = (obj) => {
    const cache2 = resultCache === null || resultCache === void 0 ? void 0 : resultCache.get(obj);
    if (cache2) {
      return cache2;
    }
    for (let i = 0; i < size3; i += 1) {
      const memo5 = memoList[(memoListHead + i) % size3];
      if (!memo5)
        break;
      const { [OBJ_PROPERTY]: memoObj, [AFFECTED_PROPERTY2]: memoAffected, [RESULT_PROPERTY]: memoResult } = memo5;
      if (!isChanged(memoObj, obj, memoAffected, /* @__PURE__ */ new WeakMap(), isOriginalEqual)) {
        touchAffected(obj, memoObj, memoAffected);
        resultCache === null || resultCache === void 0 ? void 0 : resultCache.set(obj, memoResult);
        return memoResult;
      }
    }
    const affected = /* @__PURE__ */ new WeakMap();
    const proxy2 = createProxy(obj, affected, void 0, targetCache2);
    const result = untrack(fn(proxy2), /* @__PURE__ */ new WeakSet());
    touchAffected(obj, obj, affected);
    const entry = {
      [OBJ_PROPERTY]: obj,
      [RESULT_PROPERTY]: result,
      [AFFECTED_PROPERTY2]: affected
    };
    memoListHead = (memoListHead - 1 + size3) % size3;
    memoList[memoListHead] = entry;
    resultCache === null || resultCache === void 0 ? void 0 : resultCache.set(obj, result);
    return result;
  };
  return memoizedFn;
}

// node_modules/uqr/dist/index.mjs
var QrCodeDataType = ((QrCodeDataType2) => {
  QrCodeDataType2[QrCodeDataType2["Border"] = -1] = "Border";
  QrCodeDataType2[QrCodeDataType2["Data"] = 0] = "Data";
  QrCodeDataType2[QrCodeDataType2["Function"] = 1] = "Function";
  QrCodeDataType2[QrCodeDataType2["Position"] = 2] = "Position";
  QrCodeDataType2[QrCodeDataType2["Timing"] = 3] = "Timing";
  QrCodeDataType2[QrCodeDataType2["Alignment"] = 4] = "Alignment";
  return QrCodeDataType2;
})(QrCodeDataType || {});
var __defProp5 = Object.defineProperty;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField5 = (obj, key, value) => {
  __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var LOW = [0, 1];
var MEDIUM = [1, 0];
var QUARTILE = [2, 3];
var HIGH = [3, 2];
var EccMap = {
  L: LOW,
  M: MEDIUM,
  Q: QUARTILE,
  H: HIGH
};
var NUMERIC_REGEX = /^[0-9]*$/;
var ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
var ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
var MIN_VERSION = 1;
var MAX_VERSION = 40;
var PENALTY_N1 = 3;
var PENALTY_N2 = 3;
var PENALTY_N3 = 40;
var PENALTY_N4 = 10;
var ECC_CODEWORDS_PER_BLOCK = [
  // Version: (note that index 0 is for padding, and is set to an illegal value)
  // 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
  [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
  // Low
  [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
  // Medium
  [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
  // Quartile
  [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
  // High
];
var NUM_ERROR_CORRECTION_BLOCKS = [
  // Version: (note that index 0 is for padding, and is set to an illegal value)
  // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
  [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
  // Low
  [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
  // Medium
  [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
  // Quartile
  [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
  // High
];
var QrCode = class {
  /* -- Constructor (low level) and fields -- */
  // Creates a new QR Code with the given version number,
  // error correction level, data codeword bytes, and mask number.
  // This is a low-level API that most users should not use directly.
  // A mid-level API is the encodeSegments() function.
  constructor(version2, ecc, dataCodewords, msk) {
    this.version = version2;
    this.ecc = ecc;
    __publicField5(this, "size");
    __publicField5(this, "mask");
    __publicField5(this, "modules", []);
    __publicField5(this, "types", []);
    if (version2 < MIN_VERSION || version2 > MAX_VERSION)
      throw new RangeError("Version value out of range");
    if (msk < -1 || msk > 7)
      throw new RangeError("Mask value out of range");
    this.size = version2 * 4 + 17;
    const row = Array.from({ length: this.size }, () => false);
    for (let i = 0; i < this.size; i++) {
      this.modules.push(row.slice());
      this.types.push(row.map(() => 0));
    }
    this.drawFunctionPatterns();
    const allCodewords = this.addEccAndInterleave(dataCodewords);
    this.drawCodewords(allCodewords);
    if (msk === -1) {
      let minPenalty = 1e9;
      for (let i = 0; i < 8; i++) {
        this.applyMask(i);
        this.drawFormatBits(i);
        const penalty = this.getPenaltyScore();
        if (penalty < minPenalty) {
          msk = i;
          minPenalty = penalty;
        }
        this.applyMask(i);
      }
    }
    this.mask = msk;
    this.applyMask(msk);
    this.drawFormatBits(msk);
  }
  /* -- Accessor methods -- */
  // Returns the color of the module (pixel) at the given coordinates, which is false
  // for light or true for dark. The top left corner has the coordinates (x=0, y=0).
  // If the given coordinates are out of bounds, then false (light) is returned.
  getModule(x, y) {
    return x >= 0 && x < this.size && y >= 0 && y < this.size && this.modules[y][x];
  }
  /* -- Private helper methods for constructor: Drawing function modules -- */
  // Reads this object's version field, and draws and marks all function modules.
  drawFunctionPatterns() {
    for (let i = 0; i < this.size; i++) {
      this.setFunctionModule(6, i, i % 2 === 0, QrCodeDataType.Timing);
      this.setFunctionModule(i, 6, i % 2 === 0, QrCodeDataType.Timing);
    }
    this.drawFinderPattern(3, 3);
    this.drawFinderPattern(this.size - 4, 3);
    this.drawFinderPattern(3, this.size - 4);
    const alignPatPos = this.getAlignmentPatternPositions();
    const numAlign = alignPatPos.length;
    for (let i = 0; i < numAlign; i++) {
      for (let j = 0; j < numAlign; j++) {
        if (!(i === 0 && j === 0 || i === 0 && j === numAlign - 1 || i === numAlign - 1 && j === 0))
          this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
      }
    }
    this.drawFormatBits(0);
    this.drawVersion();
  }
  // Draws two copies of the format bits (with its own error correction code)
  // based on the given mask and this object's error correction level field.
  drawFormatBits(mask) {
    const data = this.ecc[1] << 3 | mask;
    let rem = data;
    for (let i = 0; i < 10; i++)
      rem = rem << 1 ^ (rem >>> 9) * 1335;
    const bits = (data << 10 | rem) ^ 21522;
    for (let i = 0; i <= 5; i++)
      this.setFunctionModule(8, i, getBit(bits, i));
    this.setFunctionModule(8, 7, getBit(bits, 6));
    this.setFunctionModule(8, 8, getBit(bits, 7));
    this.setFunctionModule(7, 8, getBit(bits, 8));
    for (let i = 9; i < 15; i++)
      this.setFunctionModule(14 - i, 8, getBit(bits, i));
    for (let i = 0; i < 8; i++)
      this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
    for (let i = 8; i < 15; i++)
      this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
    this.setFunctionModule(8, this.size - 8, true);
  }
  // Draws two copies of the version bits (with its own error correction code),
  // based on this object's version field, iff 7 <= version <= 40.
  drawVersion() {
    if (this.version < 7)
      return;
    let rem = this.version;
    for (let i = 0; i < 12; i++)
      rem = rem << 1 ^ (rem >>> 11) * 7973;
    const bits = this.version << 12 | rem;
    for (let i = 0; i < 18; i++) {
      const color = getBit(bits, i);
      const a2 = this.size - 11 + i % 3;
      const b2 = Math.floor(i / 3);
      this.setFunctionModule(a2, b2, color);
      this.setFunctionModule(b2, a2, color);
    }
  }
  // Draws a 9*9 finder pattern including the border separator,
  // with the center module at (x, y). Modules can be out of bounds.
  drawFinderPattern(x, y) {
    for (let dy = -4; dy <= 4; dy++) {
      for (let dx = -4; dx <= 4; dx++) {
        const dist = Math.max(Math.abs(dx), Math.abs(dy));
        const xx = x + dx;
        const yy = y + dy;
        if (xx >= 0 && xx < this.size && yy >= 0 && yy < this.size)
          this.setFunctionModule(xx, yy, dist !== 2 && dist !== 4, QrCodeDataType.Position);
      }
    }
  }
  // Draws a 5*5 alignment pattern, with the center module
  // at (x, y). All modules must be in bounds.
  drawAlignmentPattern(x, y) {
    for (let dy = -2; dy <= 2; dy++) {
      for (let dx = -2; dx <= 2; dx++) {
        this.setFunctionModule(
          x + dx,
          y + dy,
          Math.max(Math.abs(dx), Math.abs(dy)) !== 1,
          QrCodeDataType.Alignment
        );
      }
    }
  }
  // Sets the color of a module and marks it as a function module.
  // Only used by the constructor. Coordinates must be in bounds.
  setFunctionModule(x, y, isDark, type = QrCodeDataType.Function) {
    this.modules[y][x] = isDark;
    this.types[y][x] = type;
  }
  /* -- Private helper methods for constructor: Codewords and masking -- */
  // Returns a new byte string representing the given data with the appropriate error correction
  // codewords appended to it, based on this object's version and error correction level.
  addEccAndInterleave(data) {
    const ver = this.version;
    const ecl = this.ecc;
    if (data.length !== getNumDataCodewords(ver, ecl))
      throw new RangeError("Invalid argument");
    const numBlocks = NUM_ERROR_CORRECTION_BLOCKS[ecl[0]][ver];
    const blockEccLen = ECC_CODEWORDS_PER_BLOCK[ecl[0]][ver];
    const rawCodewords = Math.floor(getNumRawDataModules(ver) / 8);
    const numShortBlocks = numBlocks - rawCodewords % numBlocks;
    const shortBlockLen = Math.floor(rawCodewords / numBlocks);
    const blocks = [];
    const rsDiv = reedSolomonComputeDivisor(blockEccLen);
    for (let i = 0, k = 0; i < numBlocks; i++) {
      const dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
      k += dat.length;
      const ecc = reedSolomonComputeRemainder(dat, rsDiv);
      if (i < numShortBlocks)
        dat.push(0);
      blocks.push(dat.concat(ecc));
    }
    const result = [];
    for (let i = 0; i < blocks[0].length; i++) {
      blocks.forEach((block, j) => {
        if (i !== shortBlockLen - blockEccLen || j >= numShortBlocks)
          result.push(block[i]);
      });
    }
    return result;
  }
  // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
  // data area of this QR Code. Function modules need to be marked off before this is called.
  drawCodewords(data) {
    if (data.length !== Math.floor(getNumRawDataModules(this.version) / 8))
      throw new RangeError("Invalid argument");
    let i = 0;
    for (let right = this.size - 1; right >= 1; right -= 2) {
      if (right === 6)
        right = 5;
      for (let vert = 0; vert < this.size; vert++) {
        for (let j = 0; j < 2; j++) {
          const x = right - j;
          const upward = (right + 1 & 2) === 0;
          const y = upward ? this.size - 1 - vert : vert;
          if (!this.types[y][x] && i < data.length * 8) {
            this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
            i++;
          }
        }
      }
    }
  }
  // XORs the codeword modules in this QR Code with the given mask pattern.
  // The function modules must be marked and the codeword bits must be drawn
  // before masking. Due to the arithmetic of XOR, calling applyMask() with
  // the same mask value a second time will undo the mask. A final well-formed
  // QR Code needs exactly one (not zero, two, etc.) mask applied.
  applyMask(mask) {
    if (mask < 0 || mask > 7)
      throw new RangeError("Mask value out of range");
    for (let y = 0; y < this.size; y++) {
      for (let x = 0; x < this.size; x++) {
        let invert;
        switch (mask) {
          case 0:
            invert = (x + y) % 2 === 0;
            break;
          case 1:
            invert = y % 2 === 0;
            break;
          case 2:
            invert = x % 3 === 0;
            break;
          case 3:
            invert = (x + y) % 3 === 0;
            break;
          case 4:
            invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 === 0;
            break;
          case 5:
            invert = x * y % 2 + x * y % 3 === 0;
            break;
          case 6:
            invert = (x * y % 2 + x * y % 3) % 2 === 0;
            break;
          case 7:
            invert = ((x + y) % 2 + x * y % 3) % 2 === 0;
            break;
          default:
            throw new Error("Unreachable");
        }
        if (!this.types[y][x] && invert)
          this.modules[y][x] = !this.modules[y][x];
      }
    }
  }
  // Calculates and returns the penalty score based on state of this QR Code's current modules.
  // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
  getPenaltyScore() {
    let result = 0;
    for (let y = 0; y < this.size; y++) {
      let runColor = false;
      let runX = 0;
      const runHistory = [0, 0, 0, 0, 0, 0, 0];
      for (let x = 0; x < this.size; x++) {
        if (this.modules[y][x] === runColor) {
          runX++;
          if (runX === 5)
            result += PENALTY_N1;
          else if (runX > 5)
            result++;
        } else {
          this.finderPenaltyAddHistory(runX, runHistory);
          if (!runColor)
            result += this.finderPenaltyCountPatterns(runHistory) * PENALTY_N3;
          runColor = this.modules[y][x];
          runX = 1;
        }
      }
      result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * PENALTY_N3;
    }
    for (let x = 0; x < this.size; x++) {
      let runColor = false;
      let runY = 0;
      const runHistory = [0, 0, 0, 0, 0, 0, 0];
      for (let y = 0; y < this.size; y++) {
        if (this.modules[y][x] === runColor) {
          runY++;
          if (runY === 5)
            result += PENALTY_N1;
          else if (runY > 5)
            result++;
        } else {
          this.finderPenaltyAddHistory(runY, runHistory);
          if (!runColor)
            result += this.finderPenaltyCountPatterns(runHistory) * PENALTY_N3;
          runColor = this.modules[y][x];
          runY = 1;
        }
      }
      result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * PENALTY_N3;
    }
    for (let y = 0; y < this.size - 1; y++) {
      for (let x = 0; x < this.size - 1; x++) {
        const color = this.modules[y][x];
        if (color === this.modules[y][x + 1] && color === this.modules[y + 1][x] && color === this.modules[y + 1][x + 1])
          result += PENALTY_N2;
      }
    }
    let dark = 0;
    for (const row of this.modules)
      dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);
    const total = this.size * this.size;
    const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
    result += k * PENALTY_N4;
    return result;
  }
  /* -- Private helper functions -- */
  // Returns an ascending list of positions of alignment patterns for this version number.
  // Each position is in the range [0,177), and are used on both the x and y axes.
  // This could be implemented as lookup table of 40 variable-length lists of integers.
  getAlignmentPatternPositions() {
    if (this.version === 1) {
      return [];
    } else {
      const numAlign = Math.floor(this.version / 7) + 2;
      const step = this.version === 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
      const result = [6];
      for (let pos = this.size - 7; result.length < numAlign; pos -= step)
        result.splice(1, 0, pos);
      return result;
    }
  }
  // Can only be called immediately after a light run is added, and
  // returns either 0, 1, or 2. A helper function for getPenaltyScore().
  finderPenaltyCountPatterns(runHistory) {
    const n = runHistory[1];
    const core = n > 0 && runHistory[2] === n && runHistory[3] === n * 3 && runHistory[4] === n && runHistory[5] === n;
    return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);
  }
  // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
  finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
    if (currentRunColor) {
      this.finderPenaltyAddHistory(currentRunLength, runHistory);
      currentRunLength = 0;
    }
    currentRunLength += this.size;
    this.finderPenaltyAddHistory(currentRunLength, runHistory);
    return this.finderPenaltyCountPatterns(runHistory);
  }
  // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
  finderPenaltyAddHistory(currentRunLength, runHistory) {
    if (runHistory[0] === 0)
      currentRunLength += this.size;
    runHistory.pop();
    runHistory.unshift(currentRunLength);
  }
};
function appendBits(val, len, bb) {
  if (len < 0 || len > 31 || val >>> len !== 0)
    throw new RangeError("Value out of range");
  for (let i = len - 1; i >= 0; i--)
    bb.push(val >>> i & 1);
}
function getBit(x, i) {
  return (x >>> i & 1) !== 0;
}
var QrSegment = class {
  // Creates a new QR Code segment with the given attributes and data.
  // The character count (numChars) must agree with the mode and the bit buffer length,
  // but the constraint isn't checked. The given bit buffer is cloned and stored.
  constructor(mode, numChars, bitData) {
    this.mode = mode;
    this.numChars = numChars;
    this.bitData = bitData;
    if (numChars < 0)
      throw new RangeError("Invalid argument");
    this.bitData = bitData.slice();
  }
  /* -- Methods -- */
  // Returns a new copy of the data bits of this segment.
  getData() {
    return this.bitData.slice();
  }
};
var MODE_NUMERIC = [1, 10, 12, 14];
var MODE_ALPHANUMERIC = [2, 9, 11, 13];
var MODE_BYTE = [4, 8, 16, 16];
function numCharCountBits(mode, ver) {
  return mode[Math.floor((ver + 7) / 17) + 1];
}
function makeBytes(data) {
  const bb = [];
  for (const b2 of data)
    appendBits(b2, 8, bb);
  return new QrSegment(MODE_BYTE, data.length, bb);
}
function makeNumeric(digits) {
  if (!isNumeric(digits))
    throw new RangeError("String contains non-numeric characters");
  const bb = [];
  for (let i = 0; i < digits.length; ) {
    const n = Math.min(digits.length - i, 3);
    appendBits(Number.parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);
    i += n;
  }
  return new QrSegment(MODE_NUMERIC, digits.length, bb);
}
function makeAlphanumeric(text) {
  if (!isAlphanumeric(text))
    throw new RangeError("String contains unencodable characters in alphanumeric mode");
  const bb = [];
  let i;
  for (i = 0; i + 2 <= text.length; i += 2) {
    let temp = ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
    temp += ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
    appendBits(temp, 11, bb);
  }
  if (i < text.length)
    appendBits(ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
  return new QrSegment(MODE_ALPHANUMERIC, text.length, bb);
}
function makeSegments(text) {
  if (text === "")
    return [];
  else if (isNumeric(text))
    return [makeNumeric(text)];
  else if (isAlphanumeric(text))
    return [makeAlphanumeric(text)];
  else
    return [makeBytes(toUtf8ByteArray(text))];
}
function isNumeric(text) {
  return NUMERIC_REGEX.test(text);
}
function isAlphanumeric(text) {
  return ALPHANUMERIC_REGEX.test(text);
}
function getTotalBits(segs, version2) {
  let result = 0;
  for (const seg of segs) {
    const ccbits = numCharCountBits(seg.mode, version2);
    if (seg.numChars >= 1 << ccbits)
      return Number.POSITIVE_INFINITY;
    result += 4 + ccbits + seg.bitData.length;
  }
  return result;
}
function toUtf8ByteArray(str) {
  str = encodeURI(str);
  const result = [];
  for (let i = 0; i < str.length; i++) {
    if (str.charAt(i) !== "%") {
      result.push(str.charCodeAt(i));
    } else {
      result.push(Number.parseInt(str.substring(i + 1, i + 3), 16));
      i += 2;
    }
  }
  return result;
}
function getNumRawDataModules(ver) {
  if (ver < MIN_VERSION || ver > MAX_VERSION)
    throw new RangeError("Version number out of range");
  let result = (16 * ver + 128) * ver + 64;
  if (ver >= 2) {
    const numAlign = Math.floor(ver / 7) + 2;
    result -= (25 * numAlign - 10) * numAlign - 55;
    if (ver >= 7)
      result -= 36;
  }
  return result;
}
function getNumDataCodewords(ver, ecl) {
  return Math.floor(getNumRawDataModules(ver) / 8) - ECC_CODEWORDS_PER_BLOCK[ecl[0]][ver] * NUM_ERROR_CORRECTION_BLOCKS[ecl[0]][ver];
}
function reedSolomonComputeDivisor(degree) {
  if (degree < 1 || degree > 255)
    throw new RangeError("Degree out of range");
  const result = [];
  for (let i = 0; i < degree - 1; i++)
    result.push(0);
  result.push(1);
  let root = 1;
  for (let i = 0; i < degree; i++) {
    for (let j = 0; j < result.length; j++) {
      result[j] = reedSolomonMultiply(result[j], root);
      if (j + 1 < result.length)
        result[j] ^= result[j + 1];
    }
    root = reedSolomonMultiply(root, 2);
  }
  return result;
}
function reedSolomonComputeRemainder(data, divisor) {
  const result = divisor.map((_) => 0);
  for (const b2 of data) {
    const factor = b2 ^ result.shift();
    result.push(0);
    divisor.forEach((coef, i) => result[i] ^= reedSolomonMultiply(coef, factor));
  }
  return result;
}
function reedSolomonMultiply(x, y) {
  if (x >>> 8 !== 0 || y >>> 8 !== 0)
    throw new RangeError("Byte out of range");
  let z = 0;
  for (let i = 7; i >= 0; i--) {
    z = z << 1 ^ (z >>> 7) * 285;
    z ^= (y >>> i & 1) * x;
  }
  return z;
}
function encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
  if (!(MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= MAX_VERSION) || mask < -1 || mask > 7)
    throw new RangeError("Invalid value");
  let version2;
  let dataUsedBits;
  for (version2 = minVersion; ; version2++) {
    const dataCapacityBits2 = getNumDataCodewords(version2, ecl) * 8;
    const usedBits = getTotalBits(segs, version2);
    if (usedBits <= dataCapacityBits2) {
      dataUsedBits = usedBits;
      break;
    }
    if (version2 >= maxVersion)
      throw new RangeError("Data too long");
  }
  for (const newEcl of [MEDIUM, QUARTILE, HIGH]) {
    if (boostEcl && dataUsedBits <= getNumDataCodewords(version2, newEcl) * 8)
      ecl = newEcl;
  }
  const bb = [];
  for (const seg of segs) {
    appendBits(seg.mode[0], 4, bb);
    appendBits(seg.numChars, numCharCountBits(seg.mode, version2), bb);
    for (const b2 of seg.getData())
      bb.push(b2);
  }
  const dataCapacityBits = getNumDataCodewords(version2, ecl) * 8;
  appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
  appendBits(0, (8 - bb.length % 8) % 8, bb);
  for (let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)
    appendBits(padByte, 8, bb);
  const dataCodewords = Array.from({ length: Math.ceil(bb.length / 8) }, () => 0);
  bb.forEach((b2, i) => dataCodewords[i >>> 3] |= b2 << 7 - (i & 7));
  return new QrCode(version2, ecl, dataCodewords, mask);
}
function encode(data, options) {
  var _a8;
  const {
    ecc = "L",
    boostEcc = false,
    minVersion = 1,
    maxVersion = 40,
    maskPattern = -1,
    border = 1
  } = options || {};
  const segment = typeof data === "string" ? makeSegments(data) : Array.isArray(data) ? [makeBytes(data)] : void 0;
  if (!segment)
    throw new Error(`uqr only supports encoding string and binary data, but got: ${typeof data}`);
  const qr = encodeSegments(
    segment,
    EccMap[ecc],
    minVersion,
    maxVersion,
    maskPattern,
    boostEcc
  );
  const result = addBorder({
    version: qr.version,
    maskPattern: qr.mask,
    size: qr.size,
    data: qr.modules,
    types: qr.types
  }, border);
  if (options == null ? void 0 : options.invert)
    result.data = result.data.map((row) => row.map((mod2) => !mod2));
  (_a8 = options == null ? void 0 : options.onEncoded) == null ? void 0 : _a8.call(options, result);
  return result;
}
function addBorder(input, border = 1) {
  if (!border)
    return input;
  const { size: size3 } = input;
  const newSize = size3 + border * 2;
  input.size = newSize;
  input.data.forEach((row) => {
    for (let i = 0; i < border; i++) {
      row.unshift(false);
      row.push(false);
    }
  });
  for (let i = 0; i < border; i++) {
    input.data.unshift(Array.from({ length: newSize }, (_) => false));
    input.data.push(Array.from({ length: newSize }, (_) => false));
  }
  const b2 = QrCodeDataType.Border;
  input.types.forEach((row) => {
    for (let i = 0; i < border; i++) {
      row.unshift(b2);
      row.push(b2);
    }
  });
  for (let i = 0; i < border; i++) {
    input.types.unshift(Array.from({ length: newSize }, (_) => b2));
    input.types.push(Array.from({ length: newSize }, (_) => b2));
  }
  return input;
}

// node_modules/@zag-js/qr-code/dist/index.mjs
var anatomy20 = createAnatomy("qr-code").parts("root", "frame", "pattern", "overlay", "downloadTrigger");
var parts22 = anatomy20.build();
var dom20 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `qrcode:${ctx.id}:root`;
  },
  getFrameId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.frame) ?? `qrcode:${ctx.id}:frame`;
  },
  getFrameEl: (ctx) => dom20.getById(ctx, dom20.getFrameId(ctx))
});
function connect21(state2, send, normalize3) {
  const encoded = state2.context.encoded;
  const pixelSize = state2.context.pixelSize;
  const height = encoded.size * pixelSize;
  const width = encoded.size * pixelSize;
  const paths = [];
  for (let row = 0; row < encoded.size; row++) {
    for (let col = 0; col < encoded.size; col++) {
      const x = col * pixelSize;
      const y = row * pixelSize;
      if (encoded.data[row][col]) {
        paths.push(`M${x},${y}h${pixelSize}v${pixelSize}h-${pixelSize}z`);
      }
    }
  }
  return {
    value: state2.context.value,
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    getDataUrl(type, quality) {
      const svgEl = dom20.getFrameEl(state2.context);
      return getDataUrl(svgEl, { type, quality });
    },
    getRootProps() {
      return normalize3.element({
        id: dom20.getRootId(state2.context),
        ...parts22.root.attrs,
        style: {
          "--qrcode-pixel-size": `${pixelSize}px`,
          "--qrcode-width": `${width}px`,
          "--qrcode-height": `${height}px`,
          position: "relative"
        }
      });
    },
    getFrameProps() {
      return normalize3.svg({
        id: dom20.getFrameId(state2.context),
        ...parts22.frame.attrs,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: `0 0 ${width} ${height}`
      });
    },
    getPatternProps() {
      return normalize3.path({
        d: paths.join(""),
        ...parts22.pattern.attrs
      });
    },
    getOverlayProps() {
      return normalize3.element({
        ...parts22.overlay.attrs,
        style: {
          position: "absolute",
          top: "50%",
          left: "50%",
          translate: "-50% -50%"
        }
      });
    },
    getDownloadTriggerProps(props210) {
      return normalize3.button({
        type: "button",
        ...parts22.downloadTrigger.attrs,
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "DOWNLOAD_TRIGGER.CLICK", ...props210 });
        }
      });
    }
  };
}
function machine21(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "qr-code",
      initial: "idle",
      context: {
        value: "",
        ...ctx,
        pixelSize: 10
      },
      computed: {
        encoded: memoize2((ctx2) => encode(ctx2.value, ctx2.encoding))
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        },
        "DOWNLOAD_TRIGGER.CLICK": {
          actions: ["downloadQrCode"]
        }
      }
    },
    {
      actions: {
        setValue(ctx2, evt) {
          set16.value(ctx2, evt.value);
        },
        downloadQrCode(ctx2, evt) {
          const { mimeType, quality, fileName } = evt;
          const svgEl = dom20.getFrameEl(ctx2);
          const doc = dom20.getDoc(ctx2);
          getDataUrl(svgEl, { type: mimeType, quality }).then((dataUri) => {
            const a2 = doc.createElement("a");
            a2.href = dataUri;
            a2.rel = "noopener";
            a2.download = fileName;
            a2.click();
            setTimeout(() => {
              a2.remove();
            }, 0);
          });
        }
      }
    }
  );
}
var set16 = {
  value(ctx, value) {
    var _a8;
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value });
  }
};
var props17 = createProps()([
  "ids",
  "value",
  "id",
  "encoding",
  "dir",
  "getRootNode",
  "onValueChange"
]);
var splitProps17 = createSplitProps(props17);

// node_modules/@ark-ui/react/dist/components/qr-code/use-qr-code.js
var import_react520 = __toESM(require_react(), 1);
var useQrCode = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react520.useId)(),
    dir,
    value: props34.defaultValue,
    getRootNode,
    onValueChange: useEvent(props34.onValueChange, { sync: true }),
    ...props34
  };
  const context = {
    ...initialContext,
    value: props34.value,
    onValueChange: useEvent(props34.onValueChange, { sync: true })
  };
  const [state2, send] = useMachine(machine21(initialContext), { context });
  return connect21(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-root.js
var QrCodeRoot = (0, import_react522.forwardRef)((props34, ref2) => {
  const [qrcodeProps, localProps] = createSplitProps2()(props34, [
    "defaultValue",
    "encoding",
    "id",
    "ids",
    "onValueChange",
    "value"
  ]);
  const qrCode = useQrCode(qrcodeProps);
  const mergedProps = mergeProps2(qrCode.getRootProps(), localProps);
  return (0, import_jsx_runtime244.jsx)(QrCodeProvider, { value: qrCode, children: (0, import_jsx_runtime244.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
QrCodeRoot.displayName = "QrcodeRoot";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-root-provider.js
var import_jsx_runtime245 = __toESM(require_jsx_runtime(), 1);
var import_react524 = __toESM(require_react(), 1);
var QrCodeRootProvider = (0, import_react524.forwardRef)(
  (props34, ref2) => {
    const [{ value: qrCode }, localProps] = createSplitProps2()(props34, ["value"]);
    const mergedProps = mergeProps2(qrCode.getRootProps(), localProps);
    return (0, import_jsx_runtime245.jsx)(QrCodeProvider, { value: qrCode, children: (0, import_jsx_runtime245.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
QrCodeRootProvider.displayName = "QrCodeRootProvider";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code.js
var qr_code_exports = {};
__export(qr_code_exports, {
  Context: () => QrCodeContext,
  DownloadTrigger: () => QrCodeDownloadTrigger,
  Frame: () => QrCodeFrame,
  Overlay: () => QrCodeOverlay,
  Pattern: () => QrCodePattern,
  Root: () => QrCodeRoot,
  RootProvider: () => QrCodeRootProvider
});

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group-context.js
var [RadioGroupProvider, useRadioGroupContext] = createContext3({
  name: "RadioGroupContext",
  hookName: "useRadioGroupContext",
  providerName: "<RadioGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-context.js
var RadioGroupContext = (props34) => props34.children(useRadioGroupContext());

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-indicator.js
var import_jsx_runtime246 = __toESM(require_jsx_runtime(), 1);
var import_react526 = __toESM(require_react(), 1);
var RadioGroupIndicator = (0, import_react526.forwardRef)(
  (props34, ref2) => {
    const radioGroup = useRadioGroupContext();
    const mergedProps = mergeProps2(radioGroup.getIndicatorProps(), props34);
    return (0, import_jsx_runtime246.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
RadioGroupIndicator.displayName = "RadioGroupIndicator";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item.js
var import_jsx_runtime247 = __toESM(require_jsx_runtime(), 1);
var import_react528 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group-item-context.js
var [RadioGroupItemProvider, useRadioGroupItemContext] = createContext3({
  name: "RadioGroupItemContext",
  hookName: "useRadioGroupItemContext",
  providerName: "<RadioGroupItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group-item-props-context.js
var [RadioGroupItemPropsProvider, useRadioGroupItemPropsContext] = createContext3({
  name: "RadioGroupItemPropsContext",
  hookName: "useRadioGroupItemPropsContext",
  providerName: "<RadioGroupItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item.js
var RadioGroupItem = (0, import_react528.forwardRef)((props34, ref2) => {
  const [itemProps12, localProps] = createSplitProps2()(props34, [
    "value",
    "disabled",
    "invalid"
  ]);
  const radioGroup = useRadioGroupContext();
  const mergedProps = mergeProps2(radioGroup.getItemProps(itemProps12), localProps);
  const itemState = radioGroup.getItemState(itemProps12);
  return (0, import_jsx_runtime247.jsx)(RadioGroupItemProvider, { value: itemState, children: (0, import_jsx_runtime247.jsx)(RadioGroupItemPropsProvider, { value: itemProps12, children: (0, import_jsx_runtime247.jsx)(ark.label, { ...mergedProps, ref: ref2 }) }) });
});
RadioGroupItem.displayName = "RadioGroupItem";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-context.js
var RadioGroupItemContext = (props34) => props34.children(useRadioGroupItemContext());

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-control.js
var import_jsx_runtime248 = __toESM(require_jsx_runtime(), 1);
var import_react530 = __toESM(require_react(), 1);
var RadioGroupItemControl = (0, import_react530.forwardRef)(
  (props34, ref2) => {
    const radioGroup = useRadioGroupContext();
    const itemProps12 = useRadioGroupItemPropsContext();
    const mergedProps = mergeProps2(radioGroup.getItemControlProps(itemProps12), props34);
    return (0, import_jsx_runtime248.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
RadioGroupItemControl.displayName = "RadioGroupItemControl";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-hidden-input.js
var import_jsx_runtime249 = __toESM(require_jsx_runtime(), 1);
var import_react532 = __toESM(require_react(), 1);
var RadioGroupItemHiddenInput = (0, import_react532.forwardRef)((props34, ref2) => {
  const radioGroup = useRadioGroupContext();
  const itemProps12 = useRadioGroupItemPropsContext();
  const mergedProps = mergeProps2(radioGroup.getItemHiddenInputProps(itemProps12), props34);
  return (0, import_jsx_runtime249.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
RadioGroupItemHiddenInput.displayName = "RadioGroupItemHiddenInput";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-text.js
var import_jsx_runtime250 = __toESM(require_jsx_runtime(), 1);
var import_react534 = __toESM(require_react(), 1);
var RadioGroupItemText = (0, import_react534.forwardRef)(
  (props34, ref2) => {
    const radioGroup = useRadioGroupContext();
    const itemProps12 = useRadioGroupItemPropsContext();
    const mergedProps = mergeProps2(radioGroup.getItemTextProps(itemProps12), props34);
    return (0, import_jsx_runtime250.jsx)(ark.span, { ...mergedProps, ref: ref2 });
  }
);
RadioGroupItemText.displayName = "RadioGroupItemText";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-label.js
var import_jsx_runtime251 = __toESM(require_jsx_runtime(), 1);
var import_react536 = __toESM(require_react(), 1);
var RadioGroupLabel = (0, import_react536.forwardRef)((props34, ref2) => {
  const radioGroup = useRadioGroupContext();
  const mergedProps = mergeProps2(radioGroup.getLabelProps(), props34);
  return (0, import_jsx_runtime251.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
RadioGroupLabel.displayName = "RadioGroupLabel";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-root.js
var import_jsx_runtime252 = __toESM(require_jsx_runtime(), 1);
var import_react540 = __toESM(require_react(), 1);

// node_modules/@zag-js/element-rect/dist/index.mjs
var rafId;
var observedElements = /* @__PURE__ */ new Map();
var getRectFn = (el) => el.getBoundingClientRect();
function trackElementRect(el, options) {
  const { scope = "rect", getRect = getRectFn, onChange } = options;
  const loop = getLoopFn({ scope, getRect });
  const data = observedElements.get(el);
  if (!data) {
    observedElements.set(el, {
      rect: {},
      callbacks: [onChange]
    });
    if (observedElements.size === 1) {
      rafId = requestAnimationFrame(loop);
    }
  } else {
    data.callbacks.push(onChange);
    onChange(getRect(el));
  }
  return function unobserve() {
    const data2 = observedElements.get(el);
    if (!data2) return;
    const index = data2.callbacks.indexOf(onChange);
    if (index > -1) {
      data2.callbacks.splice(index, 1);
    }
    if (data2.callbacks.length === 0) {
      observedElements.delete(el);
      if (observedElements.size === 0) {
        cancelAnimationFrame(rafId);
      }
    }
  };
}
function getLoopFn(options) {
  const { scope, getRect } = options;
  const isEqual3 = getEqualityFn(scope);
  return function loop() {
    const changedRectsData = [];
    observedElements.forEach((data, element) => {
      const newRect = getRect(element);
      if (!isEqual3(data.rect, newRect)) {
        data.rect = newRect;
        changedRectsData.push(data);
      }
    });
    changedRectsData.forEach((data) => {
      data.callbacks.forEach((callback) => callback(data.rect));
    });
    rafId = requestAnimationFrame(loop);
  };
}
var isEqualSize = (a2, b2) => a2.width === b2.width && a2.height === b2.height;
var isEqualPosition = (a2, b2) => a2.top === b2.top && a2.left === b2.left;
var isEqualRect = (a2, b2) => isEqualSize(a2, b2) && isEqualPosition(a2, b2);
function getEqualityFn(scope) {
  if (scope === "size") return isEqualSize;
  if (scope === "position") return isEqualPosition;
  return isEqualRect;
}

// node_modules/@zag-js/radio-group/dist/index.mjs
var anatomy21 = createAnatomy("radio-group").parts(
  "root",
  "label",
  "item",
  "itemText",
  "itemControl",
  "indicator"
);
var parts23 = anatomy21.build();
var dom21 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `radio-group:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `radio-group:${ctx.id}:label`;
  },
  getItemId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, value)) ?? `radio-group:${ctx.id}:radio:${value}`;
  },
  getItemHiddenInputId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemHiddenInput) == null ? void 0 : _b7.call(_a8, value)) ?? `radio-group:${ctx.id}:radio:input:${value}`;
  },
  getItemControlId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemControl) == null ? void 0 : _b7.call(_a8, value)) ?? `radio-group:${ctx.id}:radio:control:${value}`;
  },
  getItemLabelId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemLabel) == null ? void 0 : _b7.call(_a8, value)) ?? `radio-group:${ctx.id}:radio:label:${value}`;
  },
  getIndicatorId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.indicator) ?? `radio-group:${ctx.id}:indicator`;
  },
  getRootEl: (ctx) => dom21.getById(ctx, dom21.getRootId(ctx)),
  getItemHiddenInputEl: (ctx, value) => dom21.getById(ctx, dom21.getItemHiddenInputId(ctx, value)),
  getIndicatorEl: (ctx) => dom21.getById(ctx, dom21.getIndicatorId(ctx)),
  getFirstEnabledInputEl: (ctx) => {
    var _a8;
    return (_a8 = dom21.getRootEl(ctx)) == null ? void 0 : _a8.querySelector("input:not(:disabled)");
  },
  getFirstEnabledAndCheckedInputEl: (ctx) => {
    var _a8;
    return (_a8 = dom21.getRootEl(ctx)) == null ? void 0 : _a8.querySelector("input:not(:disabled):checked");
  },
  getInputEls: (ctx) => {
    const ownerId = CSS.escape(dom21.getRootId(ctx));
    const selector = `input[type=radio][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom21.getRootEl(ctx), selector);
  },
  getActiveRadioEl: (ctx) => {
    if (!ctx.value) return;
    return dom21.getById(ctx, dom21.getItemId(ctx, ctx.value));
  },
  getOffsetRect: (el) => ({
    left: (el == null ? void 0 : el.offsetLeft) ?? 0,
    top: (el == null ? void 0 : el.offsetTop) ?? 0,
    width: (el == null ? void 0 : el.offsetWidth) ?? 0,
    height: (el == null ? void 0 : el.offsetHeight) ?? 0
  }),
  getRectById: (ctx, id) => {
    const radioEl = dom21.getById(ctx, dom21.getItemId(ctx, id));
    if (!radioEl) return;
    return dom21.resolveRect(dom21.getOffsetRect(radioEl));
  },
  resolveRect: (rect) => ({
    width: `${rect.width}px`,
    height: `${rect.height}px`,
    left: `${rect.left}px`,
    top: `${rect.top}px`
  })
});
function connect22(state2, send, normalize3) {
  const groupDisabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  function getItemState(props210) {
    return {
      invalid: !!props210.invalid,
      disabled: !!props210.disabled || groupDisabled,
      checked: state2.context.value === props210.value,
      focused: state2.context.focusedValue === props210.value,
      hovered: state2.context.hoveredValue === props210.value,
      active: state2.context.activeValue === props210.value
    };
  }
  function getItemDataAttrs(props210) {
    const radioState = getItemState(props210);
    return {
      "data-focus": dataAttr(radioState.focused),
      "data-focus-visible": dataAttr(radioState.focused && state2.context.focusVisible),
      "data-disabled": dataAttr(radioState.disabled),
      "data-readonly": dataAttr(readOnly),
      "data-state": radioState.checked ? "checked" : "unchecked",
      "data-hover": dataAttr(radioState.hovered),
      "data-invalid": dataAttr(radioState.invalid),
      "data-orientation": state2.context.orientation,
      "data-ssr": dataAttr(state2.context.ssr)
    };
  }
  const focus = () => {
    const firstEnabledAndCheckedInput = dom21.getFirstEnabledAndCheckedInputEl(state2.context);
    if (firstEnabledAndCheckedInput) {
      firstEnabledAndCheckedInput.focus();
      return;
    }
    const firstEnabledInput = dom21.getFirstEnabledInputEl(state2.context);
    firstEnabledInput == null ? void 0 : firstEnabledInput.focus();
  };
  return {
    focus,
    value: state2.context.value,
    setValue(value) {
      send({ type: "SET_VALUE", value, isTrusted: false });
    },
    clearValue() {
      send({ type: "SET_VALUE", value: null, isTrusted: false });
    },
    getRootProps() {
      return normalize3.element({
        ...parts23.root.attrs,
        role: "radiogroup",
        id: dom21.getRootId(state2.context),
        "aria-labelledby": dom21.getLabelId(state2.context),
        "data-orientation": state2.context.orientation,
        "data-disabled": dataAttr(groupDisabled),
        "aria-orientation": state2.context.orientation,
        dir: state2.context.dir,
        style: {
          position: "relative"
        }
      });
    },
    getLabelProps() {
      return normalize3.element({
        ...parts23.label.attrs,
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        "data-disabled": dataAttr(groupDisabled),
        id: dom21.getLabelId(state2.context),
        onClick: focus
      });
    },
    getItemState,
    getItemProps(props210) {
      const itemState = getItemState(props210);
      return normalize3.label({
        ...parts23.item.attrs,
        dir: state2.context.dir,
        id: dom21.getItemId(state2.context, props210.value),
        htmlFor: dom21.getItemHiddenInputId(state2.context, props210.value),
        ...getItemDataAttrs(props210),
        onPointerMove() {
          if (itemState.disabled) return;
          if (itemState.hovered) return;
          send({ type: "SET_HOVERED", value: props210.value, hovered: true });
        },
        onPointerLeave() {
          if (itemState.disabled) return;
          send({ type: "SET_HOVERED", value: null });
        },
        onPointerDown(event) {
          if (itemState.disabled) return;
          if (itemState.focused && event.pointerType === "mouse") {
            event.preventDefault();
          }
          send({ type: "SET_ACTIVE", value: props210.value, active: true });
        },
        onPointerUp() {
          if (itemState.disabled) return;
          send({ type: "SET_ACTIVE", value: null });
        }
      });
    },
    getItemTextProps(props210) {
      return normalize3.element({
        ...parts23.itemText.attrs,
        dir: state2.context.dir,
        id: dom21.getItemLabelId(state2.context, props210.value),
        ...getItemDataAttrs(props210)
      });
    },
    getItemControlProps(props210) {
      const controlState = getItemState(props210);
      return normalize3.element({
        ...parts23.itemControl.attrs,
        dir: state2.context.dir,
        id: dom21.getItemControlId(state2.context, props210.value),
        "data-active": dataAttr(controlState.active),
        "aria-hidden": true,
        ...getItemDataAttrs(props210)
      });
    },
    getItemHiddenInputProps(props210) {
      const inputState = getItemState(props210);
      return normalize3.input({
        "data-ownedby": dom21.getRootId(state2.context),
        id: dom21.getItemHiddenInputId(state2.context, props210.value),
        type: "radio",
        name: state2.context.name || state2.context.id,
        form: state2.context.form,
        value: props210.value,
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          if (event.currentTarget.checked) {
            send({ type: "SET_VALUE", value: props210.value, isTrusted: true });
          }
        },
        onBlur() {
          send({ type: "SET_FOCUSED", value: null, focused: false, focusVisible: false });
        },
        onFocus() {
          const focusVisible = isFocusVisible();
          send({ type: "SET_FOCUSED", value: props210.value, focused: true, focusVisible });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: props210.value, active: true });
          }
        },
        onKeyUp(event) {
          if (event.defaultPrevented) return;
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: null });
          }
        },
        disabled: inputState.disabled,
        defaultChecked: inputState.checked,
        style: visuallyHiddenStyle
      });
    },
    getIndicatorProps() {
      var _a8, _b7, _c6, _d6;
      return normalize3.element({
        id: dom21.getIndicatorId(state2.context),
        ...parts23.indicator.attrs,
        dir: state2.context.dir,
        hidden: state2.context.value == null,
        "data-disabled": dataAttr(groupDisabled),
        "data-orientation": state2.context.orientation,
        style: {
          "--transition-property": "left, top, width, height",
          "--left": (_a8 = state2.context.indicatorRect) == null ? void 0 : _a8.left,
          "--top": (_b7 = state2.context.indicatorRect) == null ? void 0 : _b7.top,
          "--width": (_c6 = state2.context.indicatorRect) == null ? void 0 : _c6.width,
          "--height": (_d6 = state2.context.indicatorRect) == null ? void 0 : _d6.height,
          position: "absolute",
          willChange: "var(--transition-property)",
          transitionProperty: "var(--transition-property)",
          transitionDuration: state2.context.canIndicatorTransition ? "var(--transition-duration, 150ms)" : "0ms",
          transitionTimingFunction: "var(--transition-timing-function)",
          [state2.context.orientation === "horizontal" ? "left" : "top"]: state2.context.orientation === "horizontal" ? "var(--left)" : "var(--top)"
        }
      });
    }
  };
}
var { not: not8 } = guards;
function machine22(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "radio",
      initial: "idle",
      context: {
        value: null,
        activeValue: null,
        focusedValue: null,
        hoveredValue: null,
        disabled: false,
        orientation: "vertical",
        ...ctx,
        indicatorRect: {},
        canIndicatorTransition: false,
        fieldsetDisabled: false,
        focusVisible: false,
        ssr: true
      },
      computed: {
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled
      },
      entry: ["syncIndicatorRect", "syncSsr"],
      exit: ["cleanupObserver"],
      activities: ["trackFormControlState", "trackFocusVisible"],
      watch: {
        value: ["setIndicatorTransition", "syncIndicatorRect", "syncInputElements"]
      },
      on: {
        SET_VALUE: [
          {
            guard: not8("isTrusted"),
            actions: ["setValue", "dispatchChangeEvent"]
          },
          {
            actions: ["setValue"]
          }
        ],
        SET_HOVERED: {
          actions: "setHovered"
        },
        SET_ACTIVE: {
          actions: "setActive"
        },
        SET_FOCUSED: {
          actions: "setFocused"
        }
      },
      states: {
        idle: {}
      }
    },
    {
      guards: {
        isTrusted: (_ctx, evt) => !!evt.isTrusted
      },
      activities: {
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl(dom21.getRootEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "SET_VALUE", value: initialContext.value });
            }
          });
        },
        trackFocusVisible(ctx2) {
          return trackFocusVisible({ root: dom21.getRootNode(ctx2) });
        }
      },
      actions: {
        setValue(ctx2, evt) {
          set17.value(ctx2, evt.value);
        },
        setHovered(ctx2, evt) {
          ctx2.hoveredValue = evt.value;
        },
        setActive(ctx2, evt) {
          ctx2.activeValue = evt.value;
        },
        setFocused(ctx2, evt) {
          ctx2.focusedValue = evt.value;
          ctx2.focusVisible = evt.focusVisible;
        },
        syncInputElements(ctx2) {
          const inputs = dom21.getInputEls(ctx2);
          inputs.forEach((input) => {
            input.checked = input.value === ctx2.value;
          });
        },
        setIndicatorTransition(ctx2) {
          ctx2.canIndicatorTransition = isString2(ctx2.value);
        },
        cleanupObserver(ctx2) {
          var _a8;
          (_a8 = ctx2.indicatorCleanup) == null ? void 0 : _a8.call(ctx2);
        },
        syncSsr(ctx2) {
          ctx2.ssr = false;
        },
        syncIndicatorRect(ctx2) {
          var _a8;
          (_a8 = ctx2.indicatorCleanup) == null ? void 0 : _a8.call(ctx2);
          if (!dom21.getIndicatorEl(ctx2)) return;
          const value = ctx2.value;
          const radioEl = dom21.getActiveRadioEl(ctx2);
          if (value == null || !radioEl) {
            ctx2.indicatorRect = {};
            return;
          }
          ctx2.indicatorCleanup = trackElementRect(radioEl, {
            getRect(el) {
              return dom21.getOffsetRect(el);
            },
            onChange(rect) {
              ctx2.indicatorRect = dom21.resolveRect(rect);
              nextTick(() => {
                ctx2.canIndicatorTransition = false;
              });
            }
          });
        },
        dispatchChangeEvent(ctx2) {
          const inputEls = dom21.getInputEls(ctx2);
          inputEls.forEach((inputEl) => {
            const checked = inputEl.value === ctx2.value;
            if (checked === inputEl.checked) return;
            dispatchInputCheckedEvent(inputEl, { checked });
          });
        }
      }
    }
  );
}
var invoke11 = {
  change: (ctx) => {
    var _a8;
    if (ctx.value == null) return;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value: ctx.value });
  }
};
var set17 = {
  value: (ctx, value) => {
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke11.change(ctx);
  }
};
var props18 = createProps()([
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onValueChange",
  "orientation",
  "readOnly",
  "value"
]);
var splitProps18 = createSplitProps(props18);
var itemProps6 = createProps()(["value", "disabled", "invalid"]);
var splitItemProps6 = createSplitProps(itemProps6);

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group.js
var import_react538 = __toESM(require_react(), 1);
var useRadioGroup = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react538.useId)(),
    dir,
    getRootNode,
    value: props34.defaultValue,
    ...props34
  };
  const context = {
    ...initialContext,
    value: props34.value,
    onValueChange: useEvent(props34.onValueChange, { sync: true })
  };
  const [state2, send] = useMachine(machine22(initialContext), {
    context
  });
  return connect22(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-root.js
var RadioGroupRoot = (0, import_react540.forwardRef)((props34, ref2) => {
  const [useRadioGroupProps, localProps] = createSplitProps2()(props34, [
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "name",
    "onValueChange",
    "orientation",
    "readOnly",
    "value"
  ]);
  const radioGroup = useRadioGroup(useRadioGroupProps);
  const mergedProps = mergeProps2(radioGroup.getRootProps(), localProps);
  return (0, import_jsx_runtime252.jsx)(RadioGroupProvider, { value: radioGroup, children: (0, import_jsx_runtime252.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
RadioGroupRoot.displayName = "RadioGroupRoot";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-root-provider.js
var import_jsx_runtime253 = __toESM(require_jsx_runtime(), 1);
var import_react542 = __toESM(require_react(), 1);
var RadioGroupRootProvider = (0, import_react542.forwardRef)(
  (props34, ref2) => {
    const [{ value: radioGroup }, localProps] = createSplitProps2()(props34, [
      "value"
    ]);
    const mergedProps = mergeProps2(radioGroup.getRootProps(), localProps);
    return (0, import_jsx_runtime253.jsx)(RadioGroupProvider, { value: radioGroup, children: (0, import_jsx_runtime253.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
RadioGroupRootProvider.displayName = "RadioGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group.js
var radio_group_exports = {};
__export(radio_group_exports, {
  Context: () => RadioGroupContext,
  Indicator: () => RadioGroupIndicator,
  Item: () => RadioGroupItem,
  ItemContext: () => RadioGroupItemContext,
  ItemControl: () => RadioGroupItemControl,
  ItemHiddenInput: () => RadioGroupItemHiddenInput,
  ItemText: () => RadioGroupItemText,
  Label: () => RadioGroupLabel,
  Root: () => RadioGroupRoot,
  RootProvider: () => RadioGroupRootProvider
});

// node_modules/@ark-ui/react/dist/components/rating-group/use-rating-group-context.js
var [RatingGroupProvider, useRatingGroupContext] = createContext3({
  name: "RatingGroupContext",
  hookName: "useRatingGroupContext",
  providerName: "<RatingGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-context.js
var RatingGroupContext = (props34) => props34.children(useRatingGroupContext());

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-control.js
var import_jsx_runtime254 = __toESM(require_jsx_runtime(), 1);
var import_react544 = __toESM(require_react(), 1);
var RatingGroupControl = (0, import_react544.forwardRef)(
  (props34, ref2) => {
    const ratingGroup = useRatingGroupContext();
    const mergedProps = mergeProps2(ratingGroup.getControlProps(), props34);
    return (0, import_jsx_runtime254.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
RatingGroupControl.displayName = "RatingGroupControl";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-hidden-input.js
var import_jsx_runtime255 = __toESM(require_jsx_runtime(), 1);
var import_react546 = __toESM(require_react(), 1);
var RatingGroupHiddenInput = (0, import_react546.forwardRef)(
  (props34, ref2) => {
    const ratingGroup = useRatingGroupContext();
    const mergedProps = mergeProps2(ratingGroup.getHiddenInputProps(), props34);
    const field = useFieldContext();
    return (0, import_jsx_runtime255.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
RatingGroupHiddenInput.displayName = "RatingGroupHiddenInput";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-item.js
var import_jsx_runtime256 = __toESM(require_jsx_runtime(), 1);
var import_react548 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/rating-group/use-rating-group-item-context.js
var [RatingGroupItemProvider, useRatingGroupItemContext] = createContext3({
  name: "RatingGroupItemContext",
  hookName: "useRatingGroupItemContext",
  providerName: "<RatingGroupItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-item.js
var RatingGroupItem = (0, import_react548.forwardRef)((props34, ref2) => {
  const [itemProps12, localProps] = createSplitProps2()(props34, ["index"]);
  const ratingGroup = useRatingGroupContext();
  const mergedProps = mergeProps2(ratingGroup.getItemProps(itemProps12), localProps);
  const itemState = ratingGroup.getItemState(itemProps12);
  return (0, import_jsx_runtime256.jsx)(RatingGroupItemProvider, { value: itemState, children: (0, import_jsx_runtime256.jsx)(ark.span, { ...mergedProps, ref: ref2 }) });
});
RatingGroupItem.displayName = "RatingGroupItem";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-item-context.js
var RatingGroupItemContext = (props34) => props34.children(useRatingGroupItemContext());

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-label.js
var import_jsx_runtime257 = __toESM(require_jsx_runtime(), 1);
var import_react550 = __toESM(require_react(), 1);
var RatingGroupLabel = (0, import_react550.forwardRef)(
  (props34, ref2) => {
    const ratingGroup = useRatingGroupContext();
    const mergedProps = mergeProps2(ratingGroup.getLabelProps(), props34);
    return (0, import_jsx_runtime257.jsx)(ark.label, { ...mergedProps, ref: ref2 });
  }
);
RatingGroupLabel.displayName = "RatingGroupLabel";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-root.js
var import_jsx_runtime258 = __toESM(require_jsx_runtime(), 1);
var import_react554 = __toESM(require_react(), 1);

// node_modules/@zag-js/rating-group/dist/index.mjs
var anatomy22 = createAnatomy("rating-group").parts("root", "label", "item", "control");
var parts24 = anatomy22.build();
var dom22 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `rating:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `rating:${ctx.id}:label`;
  },
  getHiddenInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `rating:${ctx.id}:input`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `rating:${ctx.id}:control`;
  },
  getItemId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, id)) ?? `rating:${ctx.id}:item:${id}`;
  },
  getRootEl: (ctx) => dom22.getById(ctx, dom22.getRootId(ctx)),
  getControlEl: (ctx) => dom22.getById(ctx, dom22.getControlId(ctx)),
  getRadioEl: (ctx, value = ctx.value) => {
    const selector = `[role=radio][aria-posinset='${Math.ceil(value)}']`;
    return query(dom22.getControlEl(ctx), selector);
  },
  getHiddenInputEl: (ctx) => dom22.getById(ctx, dom22.getHiddenInputId(ctx)),
  dispatchChangeEvent: (ctx) => {
    const inputEl = dom22.getHiddenInputEl(ctx);
    if (!inputEl) return;
    dispatchInputValueEvent(inputEl, { value: ctx.value });
  }
});
function connect23(state2, send, normalize3) {
  const interactive = state2.context.isInteractive;
  const disabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  const value = state2.context.value;
  const hoveredValue = state2.context.hoveredValue;
  const translations = state2.context.translations;
  function getItemState(props210) {
    const value2 = state2.context.isHovering ? state2.context.hoveredValue : state2.context.value;
    const equal = Math.ceil(value2) === props210.index;
    const highlighted = props210.index <= value2 || equal;
    const half = equal && Math.abs(value2 - props210.index) === 0.5;
    return {
      highlighted,
      half,
      checked: equal || state2.context.value === -1 && props210.index === 1
    };
  }
  return {
    hovering: state2.context.isHovering,
    value,
    hoveredValue,
    count: state2.context.count,
    items: Array.from({ length: state2.context.count }).map((_, index) => index + 1),
    setValue(value2) {
      send({ type: "SET_VALUE", value: value2 });
    },
    clearValue() {
      send("CLEAR_VALUE");
    },
    getRootProps() {
      return normalize3.element({
        ...parts24.root.attrs,
        dir: state2.context.dir,
        id: dom22.getRootId(state2.context)
      });
    },
    getHiddenInputProps() {
      return normalize3.input({
        name: state2.context.name,
        form: state2.context.form,
        type: "text",
        hidden: true,
        disabled,
        readOnly,
        required: state2.context.required,
        id: dom22.getHiddenInputId(state2.context),
        defaultValue: state2.context.value
      });
    },
    getLabelProps() {
      return normalize3.label({
        ...parts24.label.attrs,
        dir: state2.context.dir,
        id: dom22.getLabelId(state2.context),
        "data-disabled": dataAttr(disabled),
        htmlFor: dom22.getHiddenInputId(state2.context),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          event.preventDefault();
          const radioEl = dom22.getRadioEl(state2.context, 1);
          radioEl == null ? void 0 : radioEl.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize3.element({
        id: dom22.getControlId(state2.context),
        ...parts24.control.attrs,
        dir: state2.context.dir,
        role: "radiogroup",
        "aria-orientation": "horizontal",
        "aria-labelledby": dom22.getLabelId(state2.context),
        "aria-readonly": ariaAttr(readOnly),
        "data-readonly": dataAttr(readOnly),
        "data-disabled": dataAttr(disabled),
        onPointerMove(event) {
          if (!interactive) return;
          if (event.pointerType === "touch") return;
          send("GROUP_POINTER_OVER");
        },
        onPointerLeave(event) {
          if (!interactive) return;
          if (event.pointerType === "touch") return;
          send("GROUP_POINTER_LEAVE");
        }
      });
    },
    getItemState,
    getItemProps(props210) {
      const { index } = props210;
      const itemState = getItemState(props210);
      const valueText = translations.ratingValueText(index);
      return normalize3.element({
        ...parts24.item.attrs,
        dir: state2.context.dir,
        id: dom22.getItemId(state2.context, index.toString()),
        role: "radio",
        tabIndex: (() => {
          if (readOnly) return itemState.checked ? 0 : void 0;
          if (disabled) return void 0;
          return itemState.checked ? 0 : -1;
        })(),
        "aria-roledescription": "rating",
        "aria-label": valueText,
        "aria-disabled": disabled,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly),
        "aria-setsize": state2.context.count,
        "aria-checked": itemState.checked,
        "data-checked": dataAttr(itemState.checked),
        "aria-posinset": index,
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-half": dataAttr(itemState.half),
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick(event)) return;
          event.preventDefault();
        },
        onPointerMove(event) {
          if (!interactive) return;
          const point = getEventPoint(event);
          const relativePoint = getRelativePoint(point, event.currentTarget);
          const percentX = relativePoint.getPercentValue({
            orientation: "horizontal",
            dir: state2.context.dir
          });
          const isMidway = percentX < 0.5;
          send({ type: "POINTER_OVER", index, isMidway });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const keyMap2 = {
            ArrowLeft() {
              send("ARROW_LEFT");
            },
            ArrowRight() {
              send("ARROW_RIGHT");
            },
            ArrowUp() {
              send("ARROW_LEFT");
            },
            ArrowDown() {
              send("ARROW_RIGHT");
            },
            Space() {
              send({ type: "SPACE", value: index });
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            event.preventDefault();
            exec2(event);
          }
        },
        onClick() {
          if (!interactive) return;
          send({ type: "CLICK", value: index });
        },
        onFocus() {
          if (!interactive) return;
          send("FOCUS");
        },
        onBlur() {
          if (!interactive) return;
          send("BLUR");
        }
      });
    }
  };
}
function machine23(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "rating",
      initial: "idle",
      context: {
        name: "rating",
        count: 5,
        dir: "ltr",
        value: -1,
        readOnly: false,
        disabled: false,
        ...ctx,
        hoveredValue: -1,
        fieldsetDisabled: false,
        translations: {
          ratingValueText: (index) => `${index} stars`,
          ...ctx.translations
        }
      },
      created: ["roundValueIfNeeded"],
      watch: {
        allowHalf: ["roundValueIfNeeded"]
      },
      computed: {
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.isDisabled || ctx2.readOnly),
        isHovering: (ctx2) => ctx2.hoveredValue > -1
      },
      activities: ["trackFormControlState"],
      on: {
        SET_VALUE: {
          actions: ["setValue"]
        },
        CLEAR_VALUE: {
          actions: ["clearValue"]
        }
      },
      states: {
        idle: {
          entry: "clearHoveredValue",
          on: {
            GROUP_POINTER_OVER: "hover",
            FOCUS: "focus",
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            }
          }
        },
        focus: {
          on: {
            POINTER_OVER: {
              actions: "setHoveredValue"
            },
            GROUP_POINTER_LEAVE: {
              actions: "clearHoveredValue"
            },
            BLUR: "idle",
            SPACE: {
              guard: "isValueEmpty",
              actions: ["setValue"]
            },
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            },
            ARROW_LEFT: {
              actions: ["setPrevValue", "focusActiveRadio"]
            },
            ARROW_RIGHT: {
              actions: ["setNextValue", "focusActiveRadio"]
            },
            HOME: {
              actions: ["setValueToMin", "focusActiveRadio"]
            },
            END: {
              actions: ["setValueToMax", "focusActiveRadio"]
            }
          }
        },
        hover: {
          on: {
            POINTER_OVER: {
              actions: "setHoveredValue"
            },
            GROUP_POINTER_LEAVE: [
              {
                guard: "isRadioFocused",
                target: "focus",
                actions: "clearHoveredValue"
              },
              {
                target: "idle",
                actions: "clearHoveredValue"
              }
            ],
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            }
          }
        }
      }
    },
    {
      guards: {
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly),
        isHoveredValueEmpty: (ctx2) => ctx2.hoveredValue === -1,
        isValueEmpty: (ctx2) => ctx2.value <= 0,
        isRadioFocused: (ctx2) => {
          var _a8;
          return !!((_a8 = dom22.getControlEl(ctx2)) == null ? void 0 : _a8.contains(dom22.getActiveElement(ctx2)));
        }
      },
      activities: {
        trackFormControlState(ctx2, _evt, { initialContext }) {
          return trackFormControl(dom22.getHiddenInputEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set18.value(ctx2, initialContext.value);
            }
          });
        }
      },
      actions: {
        clearHoveredValue(ctx2) {
          set18.hoveredValue(ctx2, -1);
        },
        focusActiveRadio(ctx2) {
          raf(() => {
            var _a8;
            return (_a8 = dom22.getRadioEl(ctx2)) == null ? void 0 : _a8.focus();
          });
        },
        setPrevValue(ctx2) {
          const factor = ctx2.allowHalf ? 0.5 : 1;
          set18.value(ctx2, Math.max(0, ctx2.value - factor));
        },
        setNextValue(ctx2) {
          const factor = ctx2.allowHalf ? 0.5 : 1;
          const value = ctx2.value === -1 ? 0 : ctx2.value;
          set18.value(ctx2, Math.min(ctx2.count, value + factor));
        },
        setValueToMin(ctx2) {
          set18.value(ctx2, 1);
        },
        setValueToMax(ctx2) {
          set18.value(ctx2, ctx2.count);
        },
        setValue(ctx2, evt) {
          const value = ctx2.hoveredValue === -1 ? evt.value : ctx2.hoveredValue;
          set18.value(ctx2, value);
        },
        clearValue(ctx2) {
          set18.value(ctx2, -1);
        },
        setHoveredValue(ctx2, evt) {
          const half = ctx2.allowHalf && evt.isMidway;
          const factor = half ? 0.5 : 0;
          set18.hoveredValue(ctx2, evt.index - factor);
        },
        roundValueIfNeeded(ctx2) {
          if (ctx2.allowHalf) return;
          ctx2.value = Math.round(ctx2.value);
        }
      }
    }
  );
}
var invoke12 = {
  change: (ctx) => {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value: ctx.value });
    dom22.dispatchChangeEvent(ctx);
  },
  hoverChange: (ctx) => {
    var _a8;
    (_a8 = ctx.onHoverChange) == null ? void 0 : _a8.call(ctx, { hoveredValue: ctx.hoveredValue });
  }
};
var set18 = {
  value: (ctx, value) => {
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke12.change(ctx);
  },
  hoveredValue: (ctx, value) => {
    if (isEqual(ctx.hoveredValue, value)) return;
    ctx.hoveredValue = value;
    invoke12.hoverChange(ctx);
  }
};
var props19 = createProps()([
  "allowHalf",
  "autoFocus",
  "count",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onHoverChange",
  "onValueChange",
  "required",
  "readOnly",
  "translations",
  "value"
]);
var splitProps19 = createSplitProps(props19);
var itemProps7 = createProps()(["index"]);
var splitItemProps7 = createSplitProps(itemProps7);

// node_modules/@ark-ui/react/dist/components/rating-group/use-rating-group.js
var import_react552 = __toESM(require_react(), 1);
var useRatingGroup = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react552.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    getRootNode,
    value: props34.defaultValue,
    ...props34
  };
  const context = {
    ...initialContext,
    value: props34.value,
    onValueChange: useEvent(props34.onValueChange, { sync: true }),
    onHoverChange: useEvent(props34.onHoverChange)
  };
  const [state2, send] = useMachine(machine23(initialContext), {
    context
  });
  return connect23(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-root.js
var RatingGroupRoot = (0, import_react554.forwardRef)((props34, ref2) => {
  const [useRatingProps, localProps] = createSplitProps2()(props34, [
    "allowHalf",
    "autoFocus",
    "count",
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "name",
    "onHoverChange",
    "onValueChange",
    "readOnly",
    "required",
    "translations",
    "value"
  ]);
  const ratingGroup = useRatingGroup(useRatingProps);
  const mergedProps = mergeProps2(ratingGroup.getRootProps(), localProps);
  return (0, import_jsx_runtime258.jsx)(RatingGroupProvider, { value: ratingGroup, children: (0, import_jsx_runtime258.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
RatingGroupRoot.displayName = "RatingGroupRoot";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-root-provider.js
var import_jsx_runtime259 = __toESM(require_jsx_runtime(), 1);
var import_react556 = __toESM(require_react(), 1);
var RatingGroupRootProvider = (0, import_react556.forwardRef)(
  (props34, ref2) => {
    const [{ value: ratingGroup }, localProps] = createSplitProps2()(props34, [
      "value"
    ]);
    const mergedProps = mergeProps2(ratingGroup.getRootProps(), localProps);
    return (0, import_jsx_runtime259.jsx)(RatingGroupProvider, { value: ratingGroup, children: (0, import_jsx_runtime259.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
RatingGroupRootProvider.displayName = "RatingGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group.js
var rating_group_exports = {};
__export(rating_group_exports, {
  Context: () => RatingGroupContext,
  Control: () => RatingGroupControl,
  HiddenInput: () => RatingGroupHiddenInput,
  Item: () => RatingGroupItem,
  ItemContext: () => RatingGroupItemContext,
  Label: () => RatingGroupLabel,
  Root: () => RatingGroupRoot,
  RootProvider: () => RatingGroupRootProvider
});

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group-context.js
var [SegmentGroupProvider, useSegmentGroupContext] = createContext3(
  {
    name: "SegmentGroupContext",
    hookName: "useSegmentGroupContext",
    providerName: "<SegmentGroupProvider />"
  }
);

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-context.js
var SegmentGroupContext = (props34) => props34.children(useSegmentGroupContext());

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-indicator.js
var import_jsx_runtime260 = __toESM(require_jsx_runtime(), 1);
var import_react558 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group.anatomy.js
var segmentGroupAnatomy = anatomy21.rename("segment-group");
var parts25 = segmentGroupAnatomy.build();

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-indicator.js
var SegmentGroupIndicator = (0, import_react558.forwardRef)(
  (props34, ref2) => {
    const segmentGroup = useSegmentGroupContext();
    const mergedProps = mergeProps2(
      segmentGroup.getIndicatorProps(),
      parts25.indicator.attrs,
      props34
    );
    return (0, import_jsx_runtime260.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SegmentGroupIndicator.displayName = "SegmentGroupIndicator";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item.js
var import_jsx_runtime261 = __toESM(require_jsx_runtime(), 1);
var import_react560 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group-item-context.js
var [SegmentGroupItemProvider, useSegmentGroupItemContext] = createContext3({
  name: "SegmentGroupItemContext",
  hookName: "useSegmentGroupItemContext",
  providerName: "<SegmentGroupItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group-item-props-context.js
var [SegmentGroupItemPropsProvider, useSegmentGroupItemPropsContext] = createContext3({
  name: "SegmentGroupItemPropsContext",
  hookName: "useSegmentGroupItemPropsContext",
  providerName: "<SegmentGroupItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item.js
var SegmentGroupItem = (0, import_react560.forwardRef)(
  (props34, ref2) => {
    const [itemProps12, localProps] = createSplitProps2()(props34, [
      "value",
      "disabled",
      "invalid"
    ]);
    const segmentGroup = useSegmentGroupContext();
    const mergedProps = mergeProps2(
      segmentGroup.getItemProps(itemProps12),
      parts25.item.attrs,
      localProps
    );
    const itemState = segmentGroup.getItemState(itemProps12);
    return (0, import_jsx_runtime261.jsx)(SegmentGroupItemPropsProvider, { value: itemProps12, children: (0, import_jsx_runtime261.jsx)(SegmentGroupItemProvider, { value: itemState, children: (0, import_jsx_runtime261.jsx)(ark.label, { ...mergedProps, ref: ref2 }) }) });
  }
);
SegmentGroupItem.displayName = "SegmentGroupItem";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-context.js
var SegmentGroupItemContext = (props34) => props34.children(useSegmentGroupItemContext());

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-control.js
var import_jsx_runtime262 = __toESM(require_jsx_runtime(), 1);
var import_react562 = __toESM(require_react(), 1);
var SegmentGroupItemControl = (0, import_react562.forwardRef)(
  (props34, ref2) => {
    const segmentGroup = useSegmentGroupContext();
    const itemProps12 = useSegmentGroupItemPropsContext();
    const mergedProps = mergeProps2(
      segmentGroup.getItemControlProps(itemProps12),
      parts25.itemControl.attrs,
      props34
    );
    return (0, import_jsx_runtime262.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SegmentGroupItemControl.displayName = "SegmentGroupItemControl";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-hidden-input.js
var import_jsx_runtime263 = __toESM(require_jsx_runtime(), 1);
var import_react564 = __toESM(require_react(), 1);
var SegmentGroupItemHiddenInput = (0, import_react564.forwardRef)((props34, ref2) => {
  const segmentGroup = useSegmentGroupContext();
  const itemProps12 = useSegmentGroupItemPropsContext();
  const mergedProps = mergeProps2(segmentGroup.getItemHiddenInputProps(itemProps12), props34);
  return (0, import_jsx_runtime263.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
SegmentGroupItemHiddenInput.displayName = "SegmentGroupItemHiddenInput";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-text.js
var import_jsx_runtime264 = __toESM(require_jsx_runtime(), 1);
var import_react566 = __toESM(require_react(), 1);
var SegmentGroupItemText = (0, import_react566.forwardRef)(
  (props34, ref2) => {
    const segmentGroup = useSegmentGroupContext();
    const itemProps12 = useSegmentGroupItemPropsContext();
    const mergedProps = mergeProps2(
      segmentGroup.getItemTextProps(itemProps12),
      parts25.itemText.attrs,
      props34
    );
    return (0, import_jsx_runtime264.jsx)(ark.span, { ...mergedProps, ref: ref2 });
  }
);
SegmentGroupItemText.displayName = "SegmentGroupItemText";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-label.js
var import_jsx_runtime265 = __toESM(require_jsx_runtime(), 1);
var import_react568 = __toESM(require_react(), 1);
var SegmentGroupLabel = (0, import_react568.forwardRef)(
  (props34, ref2) => {
    const segmentGroup = useSegmentGroupContext();
    const mergedProps = mergeProps2(
      segmentGroup.getLabelProps(),
      parts25.label.attrs,
      props34
    );
    return (0, import_jsx_runtime265.jsx)(ark.label, { ...mergedProps, ref: ref2 });
  }
);
SegmentGroupLabel.displayName = "SegmentGroupLabel";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-root.js
var import_jsx_runtime266 = __toESM(require_jsx_runtime(), 1);
var import_react572 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group.js
var import_react570 = __toESM(require_react(), 1);
var useSegmentGroup = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react570.useId)(),
    dir,
    getRootNode,
    value: props34.defaultValue,
    ...props34
  };
  const context = {
    ...initialContext,
    value: props34.value,
    onValueChange: useEvent(props34.onValueChange, { sync: true })
  };
  const [state2, send] = useMachine(machine22(initialContext), {
    context
  });
  return connect22(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-root.js
var SegmentGroupRoot = (0, import_react572.forwardRef)((props34, ref2) => {
  const [useSegmentGroupProps, localProps] = createSplitProps2()(props34, [
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "name",
    "onValueChange",
    "orientation",
    "readOnly",
    "value"
  ]);
  const segmentGroup = useSegmentGroup(useSegmentGroupProps);
  const mergedProps = mergeProps2(
    segmentGroup.getRootProps(),
    parts25.root.attrs,
    localProps
  );
  return (0, import_jsx_runtime266.jsx)(SegmentGroupProvider, { value: segmentGroup, children: (0, import_jsx_runtime266.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
SegmentGroupRoot.displayName = "SegmentGroupRoot";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-root-provider.js
var import_jsx_runtime267 = __toESM(require_jsx_runtime(), 1);
var import_react574 = __toESM(require_react(), 1);
var SegmentGroupRootProvider = (0, import_react574.forwardRef)(
  (props34, ref2) => {
    const [{ value: segmentGroup }, localProps] = createSplitProps2()(props34, [
      "value"
    ]);
    const mergedProps = mergeProps2(
      segmentGroup.getRootProps(),
      parts25.root.attrs,
      localProps
    );
    return (0, import_jsx_runtime267.jsx)(SegmentGroupProvider, { value: segmentGroup, children: (0, import_jsx_runtime267.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
SegmentGroupRootProvider.displayName = "SegmentGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group.js
var segment_group_exports = {};
__export(segment_group_exports, {
  Context: () => SegmentGroupContext,
  Indicator: () => SegmentGroupIndicator,
  Item: () => SegmentGroupItem,
  ItemContext: () => SegmentGroupItemContext,
  ItemControl: () => SegmentGroupItemControl,
  ItemHiddenInput: () => SegmentGroupItemHiddenInput,
  ItemText: () => SegmentGroupItemText,
  Label: () => SegmentGroupLabel,
  Root: () => SegmentGroupRoot,
  RootProvider: () => SegmentGroupRootProvider
});

// node_modules/@ark-ui/react/dist/components/select/select-clear-trigger.js
var import_jsx_runtime268 = __toESM(require_jsx_runtime(), 1);
var import_react576 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/select/use-select-context.js
var [SelectProvider, useSelectContext] = createContext3({
  name: "SelectContext",
  hookName: "useSelectContext",
  providerName: "<SelectProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/select-clear-trigger.js
var SelectClearTrigger = (0, import_react576.forwardRef)(
  (props34, ref2) => {
    const select = useSelectContext();
    const mergedProps = mergeProps2(select.getClearTriggerProps(), props34);
    return (0, import_jsx_runtime268.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
SelectClearTrigger.displayName = "SelectClearTrigger";

// node_modules/@ark-ui/react/dist/components/select/select-content.js
var import_jsx_runtime269 = __toESM(require_jsx_runtime(), 1);
var import_react578 = __toESM(require_react(), 1);
var SelectContent = (0, import_react578.forwardRef)((props34, ref2) => {
  const select = useSelectContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(select.getContentProps(), presence.getPresenceProps(), props34);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime269.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
SelectContent.displayName = "SelectContent";

// node_modules/@ark-ui/react/dist/components/select/select-context.js
var SelectContext = (props34) => props34.children(useSelectContext());

// node_modules/@ark-ui/react/dist/components/select/select-control.js
var import_jsx_runtime270 = __toESM(require_jsx_runtime(), 1);
var import_react580 = __toESM(require_react(), 1);
var SelectControl = (0, import_react580.forwardRef)((props34, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getControlProps(), props34);
  return (0, import_jsx_runtime270.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SelectControl.displayName = "SelectControl";

// node_modules/@ark-ui/react/dist/components/select/select-hidden-select.js
var import_jsx_runtime271 = __toESM(require_jsx_runtime(), 1);
var import_react582 = __toESM(require_react(), 1);
var SelectHiddenSelect = (0, import_react582.forwardRef)(
  (props34, ref2) => {
    const select = useSelectContext();
    const mergedProps = mergeProps2(select.getHiddenSelectProps(), props34);
    const isValueEmpty = select.value.length === 0;
    const field = useFieldContext();
    return (0, import_jsx_runtime271.jsxs)(ark.select, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2, children: [
      isValueEmpty && (0, import_jsx_runtime271.jsx)("option", { value: "" }),
      select.collection.items.map((item, index) => (0, import_jsx_runtime271.jsx)(
        "option",
        {
          value: select.collection.getItemValue(item) ?? "",
          disabled: select.collection.getItemDisabled(item),
          children: select.collection.stringifyItem(item)
        },
        index
      ))
    ] });
  }
);
SelectHiddenSelect.displayName = "SelectHiddenSelect";

// node_modules/@ark-ui/react/dist/components/select/select-indicator.js
var import_jsx_runtime272 = __toESM(require_jsx_runtime(), 1);
var import_react584 = __toESM(require_react(), 1);
var SelectIndicator = (0, import_react584.forwardRef)((props34, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getIndicatorProps(), props34);
  return (0, import_jsx_runtime272.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SelectIndicator.displayName = "SelectIndicator";

// node_modules/@ark-ui/react/dist/components/select/select-item.js
var import_jsx_runtime273 = __toESM(require_jsx_runtime(), 1);
var import_react586 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/select/use-select-item-context.js
var [SelectItemProvider, useSelectItemContext] = createContext3({
  name: "SelectItemContext",
  hookName: "useSelectItemContext",
  providerName: "<SelectItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/use-select-item-props-context.js
var [SelectItemPropsProvider, useSelectItemPropsContext] = createContext3({
  name: "SelectItemPropsContext",
  hookName: "useSelectItemPropsContext",
  providerName: "<SelectItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/select-item.js
var SelectItem = (0, import_react586.forwardRef)((props34, ref2) => {
  const [itemProps12, localProps] = createSplitProps2()(props34, ["item", "persistFocus"]);
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getItemProps(itemProps12), localProps);
  const itemState = select.getItemState(itemProps12);
  return (0, import_jsx_runtime273.jsx)(SelectItemPropsProvider, { value: itemProps12, children: (0, import_jsx_runtime273.jsx)(SelectItemProvider, { value: itemState, children: (0, import_jsx_runtime273.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
SelectItem.displayName = "SelectItem";

// node_modules/@ark-ui/react/dist/components/select/select-item-context.js
var SelectItemContext = (props34) => props34.children(useSelectItemContext());

// node_modules/@ark-ui/react/dist/components/select/select-item-group.js
var import_jsx_runtime274 = __toESM(require_jsx_runtime(), 1);
var import_react588 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/select/use-select-item-group-props.js
var [SelectItemGroupPropsProvider, useSelectItemGroupPropsContext] = createContext3({
  name: "SelectItemGroupPropsContext",
  hookName: "useSelectItemGroupPropsContext",
  providerName: "<SelectItemGroupPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/select-item-group.js
var SelectItemGroup = (0, import_react588.forwardRef)((props34, ref2) => {
  const id = (0, import_react588.useId)();
  const [_itemGroupProps, localProps] = createSplitProps2()(props34, ["id"]);
  const itemGroupProps3 = { id, ..._itemGroupProps };
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getItemGroupProps(itemGroupProps3), localProps);
  return (0, import_jsx_runtime274.jsx)(SelectItemGroupPropsProvider, { value: itemGroupProps3, children: (0, import_jsx_runtime274.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
SelectItemGroup.displayName = "SelectItemGroup";

// node_modules/@ark-ui/react/dist/components/select/select-item-group-label.js
var import_jsx_runtime275 = __toESM(require_jsx_runtime(), 1);
var import_react590 = __toESM(require_react(), 1);
var SelectItemGroupLabel = (0, import_react590.forwardRef)(
  (props34, ref2) => {
    const select = useSelectContext();
    const itemGroupProps3 = useSelectItemGroupPropsContext();
    const mergedProps = mergeProps2(
      select.getItemGroupLabelProps({ htmlFor: itemGroupProps3.id }),
      props34
    );
    return (0, import_jsx_runtime275.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SelectItemGroupLabel.displayName = "SelectItemGroupLabel";

// node_modules/@ark-ui/react/dist/components/select/select-item-indicator.js
var import_jsx_runtime276 = __toESM(require_jsx_runtime(), 1);
var import_react592 = __toESM(require_react(), 1);
var SelectItemIndicator = (0, import_react592.forwardRef)(
  (props34, ref2) => {
    const select = useSelectContext();
    const itemProps12 = useSelectItemPropsContext();
    const mergedProps = mergeProps2(select.getItemIndicatorProps(itemProps12), props34);
    return (0, import_jsx_runtime276.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SelectItemIndicator.displayName = "SelectItemIndicator";

// node_modules/@ark-ui/react/dist/components/select/select-item-text.js
var import_jsx_runtime277 = __toESM(require_jsx_runtime(), 1);
var import_react594 = __toESM(require_react(), 1);
var SelectItemText = (0, import_react594.forwardRef)((props34, ref2) => {
  const select = useSelectContext();
  const itemProps12 = useSelectItemPropsContext();
  const mergedProps = mergeProps2(select.getItemTextProps(itemProps12), props34);
  return (0, import_jsx_runtime277.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
SelectItemText.displayName = "SelectItemText";

// node_modules/@ark-ui/react/dist/components/select/select-label.js
var import_jsx_runtime278 = __toESM(require_jsx_runtime(), 1);
var import_react596 = __toESM(require_react(), 1);
var SelectLabel = (0, import_react596.forwardRef)((props34, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getLabelProps(), props34);
  return (0, import_jsx_runtime278.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
SelectLabel.displayName = "SelectLabel";

// node_modules/@ark-ui/react/dist/components/select/select-list.js
var import_jsx_runtime279 = __toESM(require_jsx_runtime(), 1);
var import_react598 = __toESM(require_react(), 1);
var SelectList = (0, import_react598.forwardRef)((props34, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getListProps(), props34);
  return (0, import_jsx_runtime279.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SelectList.displayName = "SelectList";

// node_modules/@ark-ui/react/dist/components/select/select-positioner.js
var import_jsx_runtime280 = __toESM(require_jsx_runtime(), 1);
var import_react600 = __toESM(require_react(), 1);
var SelectPositioner = (0, import_react600.forwardRef)((props34, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getPositionerProps(), props34);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime280.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SelectPositioner.displayName = "SelectPositioner";

// node_modules/@ark-ui/react/dist/components/select/select-root.js
var import_jsx_runtime281 = __toESM(require_jsx_runtime(), 1);
var import_react604 = __toESM(require_react(), 1);

// node_modules/@zag-js/select/dist/index.mjs
var anatomy23 = createAnatomy("select").parts(
  "label",
  "positioner",
  "trigger",
  "indicator",
  "clearTrigger",
  "item",
  "itemText",
  "itemIndicator",
  "itemGroup",
  "itemGroupLabel",
  "list",
  "content",
  "root",
  "control",
  "valueText"
);
var parts26 = anatomy23.build();
var collection2 = (options) => {
  return ref(new ListCollection(options));
};
collection2.empty = () => {
  return ref(new ListCollection({ items: [] }));
};
var dom23 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `select:${ctx.id}`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `select:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `select:${ctx.id}:trigger`;
  },
  getClearTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.clearTrigger) ?? `select:${ctx.id}:clear-trigger`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `select:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `select:${ctx.id}:control`;
  },
  getItemId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, id)) ?? `select:${ctx.id}:option:${id}`;
  },
  getHiddenSelectId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenSelect) ?? `select:${ctx.id}:select`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `select:${ctx.id}:positioner`;
  },
  getItemGroupId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemGroup) == null ? void 0 : _b7.call(_a8, id)) ?? `select:${ctx.id}:optgroup:${id}`;
  },
  getItemGroupLabelId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemGroupLabel) == null ? void 0 : _b7.call(_a8, id)) ?? `select:${ctx.id}:optgroup-label:${id}`;
  },
  getHiddenSelectEl: (ctx) => dom23.getById(ctx, dom23.getHiddenSelectId(ctx)),
  getContentEl: (ctx) => dom23.getById(ctx, dom23.getContentId(ctx)),
  getControlEl: (ctx) => dom23.getById(ctx, dom23.getControlId(ctx)),
  getTriggerEl: (ctx) => dom23.getById(ctx, dom23.getTriggerId(ctx)),
  getClearTriggerEl: (ctx) => dom23.getById(ctx, dom23.getClearTriggerId(ctx)),
  getPositionerEl: (ctx) => dom23.getById(ctx, dom23.getPositionerId(ctx)),
  getHighlightedOptionEl(ctx) {
    if (!ctx.highlightedValue) return null;
    return dom23.getById(ctx, dom23.getItemId(ctx, ctx.highlightedValue));
  }
});
function connect24(state2, send, normalize3) {
  const disabled = state2.context.isDisabled;
  const invalid = state2.context.invalid;
  const readOnly = state2.context.readOnly;
  const interactive = state2.context.isInteractive;
  const composite = state2.context.composite;
  const open = state2.hasTag("open");
  const focused = state2.matches("focused");
  const highlightedValue = state2.context.highlightedValue;
  const highlightedItem = state2.context.highlightedItem;
  const selectedItems = state2.context.selectedItems;
  const isTypingAhead = state2.context.isTypingAhead;
  const collection22 = state2.context.collection;
  const ariaActiveDescendant = highlightedValue ? dom23.getItemId(state2.context, highlightedValue) : void 0;
  function getItemState(props210) {
    const _disabled = collection22.getItemDisabled(props210.item);
    const value = collection22.getItemValue(props210.item);
    return {
      value,
      disabled: Boolean(disabled || _disabled),
      highlighted: highlightedValue === value,
      selected: state2.context.value.includes(value)
    };
  }
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: state2.context.currentPlacement
  });
  return {
    open,
    focused,
    empty: state2.context.value.length === 0,
    highlightedItem,
    highlightedValue,
    selectedItems,
    hasSelectedItems: state2.context.hasSelectedItems,
    value: state2.context.value,
    valueAsString: state2.context.valueAsString,
    collection: collection22,
    multiple: !!state2.context.multiple,
    disabled: !!disabled,
    setCollection(collection32) {
      send({ type: "COLLECTION.SET", value: collection32 });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    focus() {
      var _a8;
      (_a8 = dom23.getTriggerEl(state2.context)) == null ? void 0 : _a8.focus({ preventScroll: true });
    },
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    selectValue(value) {
      send({ type: "ITEM.SELECT", value });
    },
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    selectAll() {
      send({ type: "VALUE.SET", value: collection22.getValues() });
    },
    highlightValue(value) {
      send({ type: "HIGHLIGHTED_VALUE.SET", value });
    },
    clearValue(value) {
      if (value) {
        send({ type: "ITEM.CLEAR", value });
      } else {
        send({ type: "VALUE.CLEAR" });
      }
    },
    getItemState,
    getRootProps() {
      return normalize3.element({
        ...parts26.root.attrs,
        dir: state2.context.dir,
        id: dom23.getRootId(state2.context),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getLabelProps() {
      return normalize3.label({
        dir: state2.context.dir,
        id: dom23.getLabelId(state2.context),
        ...parts26.label.attrs,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        htmlFor: dom23.getHiddenSelectId(state2.context),
        onClick(event) {
          var _a8;
          if (event.defaultPrevented) return;
          if (disabled) return;
          (_a8 = dom23.getTriggerEl(state2.context)) == null ? void 0 : _a8.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize3.element({
        ...parts26.control.attrs,
        dir: state2.context.dir,
        id: dom23.getControlId(state2.context),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr(focused),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid)
      });
    },
    getValueTextProps() {
      return normalize3.element({
        ...parts26.valueText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused)
      });
    },
    getTriggerProps() {
      return normalize3.button({
        id: dom23.getTriggerId(state2.context),
        disabled,
        dir: state2.context.dir,
        type: "button",
        role: "combobox",
        "aria-controls": dom23.getContentId(state2.context),
        "aria-expanded": open,
        "aria-haspopup": "listbox",
        "data-state": open ? "open" : "closed",
        "aria-invalid": invalid,
        "aria-labelledby": dom23.getLabelId(state2.context),
        ...parts26.trigger.attrs,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        "data-placement": state2.context.currentPlacement,
        "data-placeholder-shown": dataAttr(!state2.context.hasSelectedItems),
        onClick(event) {
          if (!interactive) return;
          if (event.defaultPrevented) return;
          send({ type: "TRIGGER.CLICK" });
        },
        onFocus() {
          send("TRIGGER.FOCUS");
        },
        onBlur() {
          send("TRIGGER.BLUR");
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "TRIGGER.ARROW_UP" });
            },
            ArrowDown(event2) {
              send({ type: event2.altKey ? "OPEN" : "TRIGGER.ARROW_DOWN" });
            },
            ArrowLeft() {
              send({ type: "TRIGGER.ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "TRIGGER.ARROW_RIGHT" });
            },
            Home() {
              send({ type: "TRIGGER.HOME" });
            },
            End() {
              send({ type: "TRIGGER.END" });
            },
            Enter() {
              send({ type: "TRIGGER.ENTER" });
            },
            Space(event2) {
              if (isTypingAhead) {
                send({ type: "TRIGGER.TYPEAHEAD", key: event2.key });
              } else {
                send({ type: "TRIGGER.ENTER" });
              }
            }
          };
          const exec2 = keyMap2[getEventKey(event, state2.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
            return;
          }
          if (getByTypeahead.isValidEvent(event)) {
            send({ type: "TRIGGER.TYPEAHEAD", key: event.key });
            event.preventDefault();
          }
        }
      });
    },
    getIndicatorProps() {
      return normalize3.element({
        ...parts26.indicator.attrs,
        dir: state2.context.dir,
        "aria-hidden": true,
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getItemProps(props210) {
      const itemState = getItemState(props210);
      return normalize3.element({
        id: dom23.getItemId(state2.context, itemState.value),
        role: "option",
        ...parts26.item.attrs,
        dir: state2.context.dir,
        "data-value": itemState.value,
        "aria-selected": itemState.selected,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-disabled": dataAttr(itemState.disabled),
        "aria-disabled": ariaAttr(itemState.disabled),
        onPointerMove(event) {
          if (itemState.disabled || event.pointerType !== "mouse") return;
          if (itemState.value === state2.context.highlightedValue) return;
          send({ type: "ITEM.POINTER_MOVE", value: itemState.value });
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (itemState.disabled) return;
          send({ type: "ITEM.CLICK", src: "pointerup", value: itemState.value });
        },
        onPointerLeave(event) {
          if (itemState.disabled) return;
          if (props210.persistFocus) return;
          if (event.pointerType !== "mouse") return;
          const pointerMoved = state2.previousEvent.type.includes("POINTER");
          if (!pointerMoved) return;
          send({ type: "ITEM.POINTER_LEAVE" });
        }
      });
    },
    getItemTextProps(props210) {
      const itemState = getItemState(props210);
      return normalize3.element({
        ...parts26.itemText.attrs,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted)
      });
    },
    getItemIndicatorProps(props210) {
      const itemState = getItemState(props210);
      return normalize3.element({
        "aria-hidden": true,
        ...parts26.itemIndicator.attrs,
        "data-state": itemState.selected ? "checked" : "unchecked",
        hidden: !itemState.selected
      });
    },
    getItemGroupLabelProps(props210) {
      const { htmlFor } = props210;
      return normalize3.element({
        ...parts26.itemGroupLabel.attrs,
        id: dom23.getItemGroupLabelId(state2.context, htmlFor),
        role: "group",
        dir: state2.context.dir
      });
    },
    getItemGroupProps(props210) {
      const { id } = props210;
      return normalize3.element({
        ...parts26.itemGroup.attrs,
        "data-disabled": dataAttr(disabled),
        id: dom23.getItemGroupId(state2.context, id),
        "aria-labelledby": dom23.getItemGroupLabelId(state2.context, id),
        dir: state2.context.dir
      });
    },
    getClearTriggerProps() {
      return normalize3.button({
        ...parts26.clearTrigger.attrs,
        id: dom23.getClearTriggerId(state2.context),
        type: "button",
        "aria-label": "Clear value",
        "data-invalid": dataAttr(invalid),
        disabled,
        hidden: !state2.context.hasSelectedItems,
        dir: state2.context.dir,
        onClick(event) {
          if (event.defaultPrevented) return;
          send("CLEAR.CLICK");
        }
      });
    },
    getHiddenSelectProps() {
      return normalize3.select({
        name: state2.context.name,
        form: state2.context.form,
        disabled,
        multiple: state2.context.multiple,
        required: state2.context.required,
        "aria-hidden": true,
        id: dom23.getHiddenSelectId(state2.context),
        defaultValue: state2.context.multiple ? state2.context.value : state2.context.value[0],
        style: visuallyHiddenStyle,
        tabIndex: -1,
        // Some browser extensions will focus the hidden select.
        // Let's forward the focus to the trigger.
        onFocus() {
          var _a8;
          (_a8 = dom23.getTriggerEl(state2.context)) == null ? void 0 : _a8.focus({ preventScroll: true });
        },
        "aria-labelledby": dom23.getLabelId(state2.context)
      });
    },
    getPositionerProps() {
      return normalize3.element({
        ...parts26.positioner.attrs,
        dir: state2.context.dir,
        id: dom23.getPositionerId(state2.context),
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize3.element({
        hidden: !open,
        dir: state2.context.dir,
        id: dom23.getContentId(state2.context),
        role: composite ? "listbox" : "dialog",
        ...parts26.content.attrs,
        "data-state": open ? "open" : "closed",
        "data-placement": state2.context.currentPlacement,
        "data-activedescendant": ariaActiveDescendant,
        "aria-activedescendant": composite ? ariaActiveDescendant : void 0,
        "aria-multiselectable": state2.context.multiple && composite ? true : void 0,
        "aria-labelledby": dom23.getLabelId(state2.context),
        tabIndex: 0,
        onKeyDown(event) {
          if (!interactive) return;
          if (!isSelfTarget(event)) return;
          if (event.key === "Tab") {
            const valid = isValidTabEvent(event);
            if (!valid) {
              event.preventDefault();
              return;
            }
          }
          const keyMap2 = {
            ArrowUp() {
              send({ type: "CONTENT.ARROW_UP" });
            },
            ArrowDown() {
              send({ type: "CONTENT.ARROW_DOWN" });
            },
            Home() {
              send({ type: "CONTENT.HOME" });
            },
            End() {
              send({ type: "CONTENT.END" });
            },
            Enter() {
              send({ type: "ITEM.CLICK", src: "keydown.enter" });
            },
            Space(event2) {
              var _a8;
              if (isTypingAhead) {
                send({ type: "CONTENT.TYPEAHEAD", key: event2.key });
              } else {
                (_a8 = keyMap2.Enter) == null ? void 0 : _a8.call(keyMap2, event2);
              }
            }
          };
          const exec2 = keyMap2[getEventKey(event)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
            return;
          }
          const target = getEventTarget(event);
          if (isEditableElement(target)) {
            return;
          }
          if (getByTypeahead.isValidEvent(event)) {
            send({ type: "CONTENT.TYPEAHEAD", key: event.key });
            event.preventDefault();
          }
        }
      });
    },
    getListProps() {
      return normalize3.element({
        ...parts26.list.attrs,
        tabIndex: 0,
        role: !composite ? "listbox" : void 0,
        "aria-labelledby": dom23.getTriggerId(state2.context),
        "aria-activedescendant": !composite ? ariaActiveDescendant : void 0,
        "aria-multiselectable": !composite && state2.context.multiple ? true : void 0
      });
    }
  };
}
var { and: and9, not: not9, or: or3 } = guards;
function machine24(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "select",
      context: {
        value: [],
        highlightedValue: null,
        loopFocus: false,
        closeOnSelect: !ctx.multiple,
        disabled: false,
        readOnly: false,
        composite: true,
        ...ctx,
        highlightedItem: null,
        selectedItems: [],
        valueAsString: "",
        collection: ctx.collection ?? collection2.empty(),
        typeahead: getByTypeahead.defaultOptions,
        fieldsetDisabled: false,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        }
      },
      computed: {
        hasSelectedItems: (ctx2) => ctx2.value.length > 0,
        isTypingAhead: (ctx2) => ctx2.typeahead.keysSoFar !== "",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.isDisabled || ctx2.readOnly)
      },
      initial: ctx.open ? "open" : "idle",
      created: ["syncCollection"],
      entry: ["syncSelectElement"],
      watch: {
        open: ["toggleVisibility"],
        value: ["syncSelectedItems", "syncSelectElement"],
        highlightedValue: ["syncHighlightedItem"],
        collection: ["syncCollection"]
      },
      on: {
        "HIGHLIGHTED_VALUE.SET": {
          actions: ["setHighlightedItem"]
        },
        "ITEM.SELECT": {
          actions: ["selectItem"]
        },
        "ITEM.CLEAR": {
          actions: ["clearItem"]
        },
        "VALUE.SET": {
          actions: ["setSelectedItems"]
        },
        "VALUE.CLEAR": {
          actions: ["clearSelectedItems"]
        },
        "CLEAR.CLICK": {
          actions: ["clearSelectedItems", "focusTriggerEl"]
        },
        "COLLECTION.SET": {
          actions: ["setCollection"]
        }
      },
      activities: ["trackFormControlState"],
      states: {
        idle: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": [
              {
                guard: "isTriggerClickEvent",
                target: "open",
                actions: ["setInitialFocus", "highlightFirstSelectedItem"]
              },
              {
                target: "open",
                actions: ["setInitialFocus"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus", "highlightFirstSelectedItem"]
              }
            ],
            "TRIGGER.FOCUS": {
              target: "focused"
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen"]
              }
            ]
          }
        },
        focused: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": [
              {
                guard: "isTriggerClickEvent",
                target: "open",
                actions: ["setInitialFocus", "highlightFirstSelectedItem"]
              },
              {
                guard: "isTriggerArrowUpEvent",
                target: "open",
                actions: ["setInitialFocus", "highlightComputedLastItem"]
              },
              {
                guard: or3("isTriggerArrowDownEvent", "isTriggerEnterEvent"),
                target: "open",
                actions: ["setInitialFocus", "highlightComputedFirstItem"]
              },
              {
                target: "open",
                actions: ["setInitialFocus"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen"]
              }
            ],
            "TRIGGER.BLUR": {
              target: "idle"
            },
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen", "highlightFirstSelectedItem"]
              }
            ],
            "TRIGGER.ENTER": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedFirstItem"]
              }
            ],
            "TRIGGER.ARROW_UP": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedLastItem"]
              }
            ],
            "TRIGGER.ARROW_DOWN": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedFirstItem"]
              }
            ],
            "TRIGGER.ARROW_LEFT": [
              {
                guard: and9(not9("multiple"), "hasSelectedItems"),
                actions: ["selectPreviousItem"]
              },
              {
                guard: not9("multiple"),
                actions: ["selectLastItem"]
              }
            ],
            "TRIGGER.ARROW_RIGHT": [
              {
                guard: and9(not9("multiple"), "hasSelectedItems"),
                actions: ["selectNextItem"]
              },
              {
                guard: not9("multiple"),
                actions: ["selectFirstItem"]
              }
            ],
            "TRIGGER.HOME": {
              guard: not9("multiple"),
              actions: ["selectFirstItem"]
            },
            "TRIGGER.END": {
              guard: not9("multiple"),
              actions: ["selectLastItem"]
            },
            "TRIGGER.TYPEAHEAD": {
              guard: not9("multiple"),
              actions: ["selectMatchingItem"]
            }
          }
        },
        open: {
          tags: ["open"],
          exit: ["scrollContentToTop"],
          activities: ["trackDismissableElement", "computePlacement", "scrollToHighlightedItem"],
          on: {
            "CONTROLLED.CLOSE": {
              target: "focused",
              actions: ["focusTriggerEl", "clearHighlightedItem"]
            },
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose", "focusTriggerEl", "clearHighlightedItem"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose", "clearHighlightedItem"]
              }
            ],
            "ITEM.CLICK": [
              {
                guard: and9("closeOnSelect", "isOpenControlled"),
                actions: ["selectHighlightedItem", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectHighlightedItem", "invokeOnClose", "focusTriggerEl", "clearHighlightedItem"]
              },
              {
                actions: ["selectHighlightedItem"]
              }
            ],
            "CONTENT.HOME": {
              actions: ["highlightFirstItem"]
            },
            "CONTENT.END": {
              actions: ["highlightLastItem"]
            },
            "CONTENT.ARROW_DOWN": [
              {
                guard: and9("hasHighlightedItem", "loop", "isLastItemHighlighted"),
                actions: ["highlightFirstItem"]
              },
              {
                guard: "hasHighlightedItem",
                actions: ["highlightNextItem"]
              },
              {
                actions: ["highlightFirstItem"]
              }
            ],
            "CONTENT.ARROW_UP": [
              {
                guard: and9("hasHighlightedItem", "loop", "isFirstItemHighlighted"),
                actions: ["highlightLastItem"]
              },
              {
                guard: "hasHighlightedItem",
                actions: ["highlightPreviousItem"]
              },
              {
                actions: ["highlightLastItem"]
              }
            ],
            "CONTENT.TYPEAHEAD": {
              actions: ["highlightMatchingItem"]
            },
            "ITEM.POINTER_MOVE": {
              actions: ["highlightItem"]
            },
            "ITEM.POINTER_LEAVE": {
              actions: ["clearHighlightedItem"]
            },
            "POSITIONING.SET": {
              actions: ["reposition"]
            }
          }
        }
      }
    },
    {
      guards: {
        loop: (ctx2) => !!ctx2.loopFocus,
        multiple: (ctx2) => !!ctx2.multiple,
        hasSelectedItems: (ctx2) => !!ctx2.hasSelectedItems,
        hasHighlightedItem: (ctx2) => ctx2.highlightedValue != null,
        isFirstItemHighlighted: (ctx2) => ctx2.highlightedValue === ctx2.collection.firstValue,
        isLastItemHighlighted: (ctx2) => ctx2.highlightedValue === ctx2.collection.lastValue,
        closeOnSelect: (ctx2, evt) => !!(evt.closeOnSelect ?? ctx2.closeOnSelect),
        // guard assertions (for controlled mode)
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        isTriggerClickEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "TRIGGER.CLICK";
        },
        isTriggerEnterEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "TRIGGER.ENTER";
        },
        isTriggerArrowUpEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "TRIGGER.ARROW_UP";
        },
        isTriggerArrowDownEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "TRIGGER.ARROW_DOWN";
        }
      },
      activities: {
        trackFormControlState(ctx2, _evt, { initialContext }) {
          return trackFormControl(dom23.getHiddenSelectEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set19.selectedItems(ctx2, initialContext.value);
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const contentEl = () => dom23.getContentEl(ctx2);
          let restoreFocus = true;
          return trackDismissableElement(contentEl, {
            defer: true,
            exclude: [dom23.getTriggerEl(ctx2), dom23.getClearTriggerEl(ctx2)],
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onInteractOutside(event) {
              var _a8;
              (_a8 = ctx2.onInteractOutside) == null ? void 0 : _a8.call(ctx2, event);
              restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
            },
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside", restoreFocus });
            }
          });
        },
        computePlacement(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const triggerEl = () => dom23.getTriggerEl(ctx2);
          const positionerEl = () => dom23.getPositionerEl(ctx2);
          return getPlacement(triggerEl, positionerEl, {
            defer: true,
            ...ctx2.positioning,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        scrollToHighlightedItem(ctx2, _evt, { getState }) {
          const exec2 = (immediate) => {
            if (ctx2.highlightedValue == null) return;
            const state2 = getState();
            if (state2.event.type.includes("POINTER")) return;
            const optionEl = dom23.getHighlightedOptionEl(ctx2);
            const contentEl2 = dom23.getContentEl(ctx2);
            if (ctx2.scrollToIndexFn) {
              const highlightedIndex = ctx2.collection.indexOf(ctx2.highlightedValue);
              ctx2.scrollToIndexFn({ index: highlightedIndex, immediate });
              return;
            }
            scrollIntoView(optionEl, { rootEl: contentEl2, block: "nearest" });
          };
          raf(() => exec2(true));
          const contentEl = () => dom23.getContentEl(ctx2);
          return observeAttributes(contentEl, {
            defer: true,
            attributes: ["data-activedescendant"],
            callback() {
              exec2(false);
            }
          });
        }
      },
      actions: {
        reposition(ctx2, evt) {
          const positionerEl = () => dom23.getPositionerEl(ctx2);
          getPlacement(dom23.getTriggerEl(ctx2), positionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        },
        highlightPreviousItem(ctx2) {
          if (ctx2.highlightedValue == null) return;
          const value = ctx2.collection.getPreviousValue(ctx2.highlightedValue);
          set19.highlightedItem(ctx2, value);
        },
        highlightNextItem(ctx2) {
          if (ctx2.highlightedValue == null) return;
          const value = ctx2.collection.getNextValue(ctx2.highlightedValue);
          set19.highlightedItem(ctx2, value);
        },
        highlightFirstItem(ctx2) {
          const value = ctx2.collection.firstValue;
          set19.highlightedItem(ctx2, value);
        },
        highlightLastItem(ctx2) {
          const value = ctx2.collection.lastValue;
          set19.highlightedItem(ctx2, value);
        },
        setInitialFocus(ctx2) {
          raf(() => {
            const element = getInitialFocus({
              root: dom23.getContentEl(ctx2)
            });
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        focusTriggerEl(ctx2, evt) {
          var _a8;
          const restoreFocus = evt.restoreFocus ?? ((_a8 = evt.previousEvent) == null ? void 0 : _a8.restoreFocus);
          if (restoreFocus != null && !restoreFocus) return;
          raf(() => {
            const element = dom23.getTriggerEl(ctx2);
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        selectHighlightedItem(ctx2, evt) {
          let value = evt.value ?? ctx2.highlightedValue;
          if (value == null) return;
          const nullable = ctx2.deselectable && !ctx2.multiple && ctx2.value.includes(value);
          value = nullable ? null : value;
          set19.selectedItem(ctx2, value, nullable);
        },
        highlightComputedFirstItem(ctx2) {
          const value = ctx2.hasSelectedItems ? ctx2.collection.sort(ctx2.value)[0] : ctx2.collection.firstValue;
          set19.highlightedItem(ctx2, value);
        },
        highlightComputedLastItem(ctx2) {
          const value = ctx2.hasSelectedItems ? ctx2.collection.sort(ctx2.value)[0] : ctx2.collection.lastValue;
          set19.highlightedItem(ctx2, value);
        },
        highlightFirstSelectedItem(ctx2) {
          if (!ctx2.hasSelectedItems) return;
          const [value] = ctx2.collection.sort(ctx2.value);
          set19.highlightedItem(ctx2, value);
        },
        highlightItem(ctx2, evt) {
          set19.highlightedItem(ctx2, evt.value);
        },
        highlightMatchingItem(ctx2, evt) {
          const value = ctx2.collection.search(evt.key, {
            state: ctx2.typeahead,
            currentValue: ctx2.highlightedValue
          });
          if (value == null) return;
          set19.highlightedItem(ctx2, value);
        },
        setHighlightedItem(ctx2, evt) {
          set19.highlightedItem(ctx2, evt.value);
        },
        clearHighlightedItem(ctx2) {
          set19.highlightedItem(ctx2, null, true);
        },
        selectItem(ctx2, evt) {
          const nullable = ctx2.deselectable && !ctx2.multiple && ctx2.value.includes(evt.value);
          const value = nullable ? null : evt.value;
          set19.selectedItem(ctx2, value, nullable);
        },
        clearItem(ctx2, evt) {
          const value = ctx2.value.filter((v) => v !== evt.value);
          set19.selectedItems(ctx2, value);
        },
        setSelectedItems(ctx2, evt) {
          set19.selectedItems(ctx2, evt.value);
        },
        clearSelectedItems(ctx2) {
          set19.selectedItems(ctx2, []);
        },
        selectPreviousItem(ctx2) {
          const value = ctx2.collection.getPreviousValue(ctx2.value[0]);
          set19.selectedItem(ctx2, value);
        },
        selectNextItem(ctx2) {
          const value = ctx2.collection.getNextValue(ctx2.value[0]);
          set19.selectedItem(ctx2, value);
        },
        selectFirstItem(ctx2) {
          const value = ctx2.collection.firstValue;
          set19.selectedItem(ctx2, value);
        },
        selectLastItem(ctx2) {
          const value = ctx2.collection.lastValue;
          set19.selectedItem(ctx2, value);
        },
        selectMatchingItem(ctx2, evt) {
          const value = ctx2.collection.search(evt.key, {
            state: ctx2.typeahead,
            currentValue: ctx2.value[0]
          });
          if (value == null) return;
          set19.selectedItem(ctx2, value);
        },
        scrollContentToTop(ctx2) {
          var _a8;
          if (ctx2.scrollToIndexFn) {
            ctx2.scrollToIndexFn({ index: 0, immediate: true });
          } else {
            (_a8 = dom23.getContentEl(ctx2)) == null ? void 0 : _a8.scrollTo(0, 0);
          }
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        syncSelectElement(ctx2) {
          const selectEl = dom23.getHiddenSelectEl(ctx2);
          if (!selectEl) return;
          if (ctx2.value.length === 0 && !ctx2.multiple) {
            selectEl.selectedIndex = -1;
            return;
          }
          for (const option of selectEl.options) {
            option.selected = ctx2.value.includes(option.value);
          }
        },
        setCollection(ctx2, evt) {
          ctx2.collection = evt.value;
        },
        syncCollection(ctx2) {
          const selectedItems = ctx2.collection.findMany(ctx2.value);
          const valueAsString = ctx2.collection.stringifyItems(selectedItems);
          ctx2.highlightedItem = ctx2.collection.find(ctx2.highlightedValue);
          ctx2.selectedItems = selectedItems;
          ctx2.valueAsString = valueAsString;
        },
        syncSelectedItems(ctx2) {
          sync5.valueChange(ctx2);
        },
        syncHighlightedItem(ctx2) {
          sync5.highlightChange(ctx2);
        }
      }
    }
  );
}
function dispatchChangeEvent(ctx) {
  raf(() => {
    const node2 = dom23.getHiddenSelectEl(ctx);
    if (!node2) return;
    const win = dom23.getWin(ctx);
    const changeEvent = new win.Event("change", { bubbles: true, composed: true });
    node2.dispatchEvent(changeEvent);
  });
}
var sync5 = {
  valueChange: (ctx) => {
    const prevSelectedItems = ctx.selectedItems;
    ctx.selectedItems = ctx.value.map((value) => {
      const foundItem = prevSelectedItems.find((item) => ctx.collection.getItemValue(item) === value);
      if (foundItem) return foundItem;
      return ctx.collection.find(value);
    });
    ctx.valueAsString = ctx.collection.stringifyItems(ctx.selectedItems);
  },
  highlightChange: (ctx) => {
    ctx.highlightedItem = ctx.collection.find(ctx.highlightedValue);
  }
};
var invoke13 = {
  valueChange: (ctx) => {
    var _a8;
    sync5.valueChange(ctx);
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, {
      value: Array.from(ctx.value),
      items: Array.from(ctx.selectedItems)
    });
    dispatchChangeEvent(ctx);
  },
  highlightChange: (ctx) => {
    var _a8;
    sync5.highlightChange(ctx);
    (_a8 = ctx.onHighlightChange) == null ? void 0 : _a8.call(ctx, {
      highlightedValue: ctx.highlightedValue,
      highlightedItem: ctx.highlightedItem,
      highlightedIndex: ctx.collection.indexOf(ctx.highlightedValue)
    });
  }
};
var set19 = {
  selectedItem: (ctx, value, force = false) => {
    if (isEqual(ctx.value, value)) return;
    if (value == null && !force) return;
    if (value == null && force) {
      ctx.value = [];
      invoke13.valueChange(ctx);
      return;
    }
    ctx.value = ctx.multiple ? addOrRemove(ctx.value, value) : [value];
    invoke13.valueChange(ctx);
  },
  selectedItems: (ctx, value) => {
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke13.valueChange(ctx);
  },
  highlightedItem: (ctx, value, force = false) => {
    if (isEqual(ctx.highlightedValue, value)) return;
    if (value == null && !force) return;
    ctx.highlightedValue = value ?? null;
    invoke13.highlightChange(ctx);
  }
};
var props20 = createProps()([
  "closeOnSelect",
  "collection",
  "dir",
  "disabled",
  "deselectable",
  "form",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "invalid",
  "loopFocus",
  "multiple",
  "name",
  "onFocusOutside",
  "onHighlightChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onValueChange",
  "open.controlled",
  "open",
  "composite",
  "positioning",
  "required",
  "readOnly",
  "scrollToIndexFn",
  "value"
]);
var splitProps20 = createSplitProps(props20);
var itemProps8 = createProps()(["item", "persistFocus"]);
var splitItemProps8 = createSplitProps(itemProps8);
var itemGroupProps2 = createProps()(["id"]);
var splitItemGroupProps2 = createSplitProps(itemGroupProps2);
var itemGroupLabelProps2 = createProps()(["htmlFor"]);
var splitItemGroupLabelProps2 = createSplitProps(itemGroupLabelProps2);

// node_modules/@ark-ui/react/dist/components/select/use-select.js
var import_react602 = __toESM(require_react(), 1);
var useSelect = (props34) => {
  const { collection: collection4, ...selectProps } = props34;
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react602.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenSelect: field == null ? void 0 : field.ids.control
    },
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    invalid: field == null ? void 0 : field.invalid,
    required: field == null ? void 0 : field.required,
    dir: locale.dir,
    getRootNode: environment.getRootNode,
    collection: collection4,
    open: props34.defaultOpen,
    value: props34.defaultValue,
    "open.controlled": props34.open !== void 0,
    ...selectProps
  };
  const context = (() => {
    const { collection: _, ...restProps } = initialContext;
    return {
      ...restProps,
      value: props34.value,
      onValueChange: useEvent(props34.onValueChange, { sync: true }),
      onHighlightChange: useEvent(props34.onHighlightChange),
      onOpenChange: useEvent(props34.onOpenChange)
    };
  })();
  const [state2, send, service] = useMachine(machine24(initialContext), {
    context
  });
  (0, import_react602.useEffect)(() => {
    service.setContext({ collection: collection4 });
  }, [collection4]);
  return connect24(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/select/select-root.js
var SelectImpl = (props34, ref2) => {
  const [presenceProps, selectProps] = splitPresenceProps(props34);
  const [useSelectProps, localProps] = createSplitProps2()(selectProps, [
    "closeOnSelect",
    "collection",
    "composite",
    "defaultOpen",
    "defaultValue",
    "deselectable",
    "disabled",
    "form",
    "highlightedValue",
    "id",
    "ids",
    "invalid",
    "loopFocus",
    "multiple",
    "name",
    "onFocusOutside",
    "onHighlightChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onValueChange",
    "open",
    "positioning",
    "readOnly",
    "required",
    "scrollToIndexFn",
    "value"
  ]);
  const select = useSelect(useSelectProps);
  const presence = usePresence(mergeProps2({ present: select.open }, presenceProps));
  const mergedProps = mergeProps2(select.getRootProps(), localProps);
  return (0, import_jsx_runtime281.jsx)(SelectProvider, { value: select, children: (0, import_jsx_runtime281.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime281.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
};
var SelectRoot = (0, import_react604.forwardRef)(SelectImpl);

// node_modules/@ark-ui/react/dist/components/select/select-root-provider.js
var import_jsx_runtime282 = __toESM(require_jsx_runtime(), 1);
var import_react606 = __toESM(require_react(), 1);
var SelectImpl2 = (props34, ref2) => {
  const [presenceProps, selectProps] = splitPresenceProps(props34);
  const [{ value: select }, localProps] = createSplitProps2()(selectProps, [
    "value"
  ]);
  const presence = usePresence(mergeProps2({ present: select.open }, presenceProps));
  const mergedProps = mergeProps2(select.getRootProps(), localProps);
  return (0, import_jsx_runtime282.jsx)(SelectProvider, { value: select, children: (0, import_jsx_runtime282.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime282.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
};
var SelectRootProvider = (0, import_react606.forwardRef)(SelectImpl2);

// node_modules/@ark-ui/react/dist/components/select/select-trigger.js
var import_jsx_runtime283 = __toESM(require_jsx_runtime(), 1);
var import_react608 = __toESM(require_react(), 1);
var SelectTrigger = (0, import_react608.forwardRef)((props34, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getTriggerProps(), props34);
  return (0, import_jsx_runtime283.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
SelectTrigger.displayName = "SelectTrigger";

// node_modules/@ark-ui/react/dist/components/select/select-value-text.js
var import_jsx_runtime284 = __toESM(require_jsx_runtime(), 1);
var import_react610 = __toESM(require_react(), 1);
var SelectValueText = (0, import_react610.forwardRef)((props34, ref2) => {
  const { children, placeholder, ...localprops } = props34;
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getValueTextProps(), localprops);
  return (0, import_jsx_runtime284.jsx)(ark.span, { ...mergedProps, ref: ref2, children: children || select.valueAsString || placeholder });
});
SelectValueText.displayName = "SelectValueText";

// node_modules/@ark-ui/react/dist/components/select/select.js
var select_exports = {};
__export(select_exports, {
  ClearTrigger: () => SelectClearTrigger,
  Content: () => SelectContent,
  Context: () => SelectContext,
  Control: () => SelectControl,
  HiddenSelect: () => SelectHiddenSelect,
  Indicator: () => SelectIndicator,
  Item: () => SelectItem,
  ItemContext: () => SelectItemContext,
  ItemGroup: () => SelectItemGroup,
  ItemGroupLabel: () => SelectItemGroupLabel,
  ItemIndicator: () => SelectItemIndicator,
  ItemText: () => SelectItemText,
  Label: () => SelectLabel,
  List: () => SelectList,
  Positioner: () => SelectPositioner,
  Root: () => SelectRoot,
  RootProvider: () => SelectRootProvider,
  Trigger: () => SelectTrigger,
  ValueText: () => SelectValueText
});

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-clear-trigger.js
var import_jsx_runtime285 = __toESM(require_jsx_runtime(), 1);
var import_react612 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/signature-pad/use-signature-pad-context.js
var [SignaturePadProvider, useSignaturePadContext] = createContext3(
  {
    name: "SignaturePadContext",
    hookName: "useSignaturePadContext",
    providerName: "<SignaturePadProvider />"
  }
);

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-clear-trigger.js
var SignaturePadClearTrigger = (0, import_react612.forwardRef)((props34, ref2) => {
  const signaturePad = useSignaturePadContext();
  const mergedProps = mergeProps2(signaturePad.getClearTriggerProps(), props34);
  return (0, import_jsx_runtime285.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
SignaturePadClearTrigger.displayName = "SignaturePadClearTrigger";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-control.js
var import_jsx_runtime286 = __toESM(require_jsx_runtime(), 1);
var import_react614 = __toESM(require_react(), 1);
var SignaturePadControl = (0, import_react614.forwardRef)(
  (props34, ref2) => {
    const signaturePad = useSignaturePadContext();
    const mergedProps = mergeProps2(signaturePad.getControlProps(), props34);
    return (0, import_jsx_runtime286.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SignaturePadControl.displayName = "SignaturePadControl";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-guide.js
var import_jsx_runtime287 = __toESM(require_jsx_runtime(), 1);
var import_react616 = __toESM(require_react(), 1);
var SignaturePadGuide = (0, import_react616.forwardRef)(
  (props34, ref2) => {
    const signaturePad = useSignaturePadContext();
    const mergedProps = mergeProps2(signaturePad.getGuideProps(), props34);
    return (0, import_jsx_runtime287.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SignaturePadGuide.displayName = "SignaturePadGuide";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-hidden-input.js
var import_jsx_runtime288 = __toESM(require_jsx_runtime(), 1);
var import_react618 = __toESM(require_react(), 1);
var SignaturePadHiddenInput = (0, import_react618.forwardRef)(
  (props34, ref2) => {
    const [hiddenInputProps, localProps] = createSplitProps2()(props34, ["value"]);
    const signaturePad = useSignaturePadContext();
    const mergedProps = mergeProps2(signaturePad.getHiddenInputProps(hiddenInputProps), localProps);
    const field = useFieldContext();
    return (0, import_jsx_runtime288.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
SignaturePadHiddenInput.displayName = "SignaturePadHiddenInput";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-label.js
var import_jsx_runtime289 = __toESM(require_jsx_runtime(), 1);
var import_react620 = __toESM(require_react(), 1);
var SignaturePadLabel = (0, import_react620.forwardRef)(
  (props34, ref2) => {
    const signaturePad = useSignaturePadContext();
    const mergedProps = mergeProps2(signaturePad.getLabelProps(), props34);
    return (0, import_jsx_runtime289.jsx)(ark.label, { ...mergedProps, ref: ref2 });
  }
);
SignaturePadLabel.displayName = "SignaturePadLabel";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-root.js
var import_jsx_runtime290 = __toESM(require_jsx_runtime(), 1);
var import_react624 = __toESM(require_react(), 1);

// node_modules/perfect-freehand/dist/esm/index.mjs
function $(e, t, u, x = (h) => h) {
  return e * x(0.5 - t * (0.5 - u));
}
function se(e) {
  return [-e[0], -e[1]];
}
function l(e, t) {
  return [e[0] + t[0], e[1] + t[1]];
}
function a(e, t) {
  return [e[0] - t[0], e[1] - t[1]];
}
function b(e, t) {
  return [e[0] * t, e[1] * t];
}
function he(e, t) {
  return [e[0] / t, e[1] / t];
}
function R(e) {
  return [e[1], -e[0]];
}
function B(e, t) {
  return e[0] * t[0] + e[1] * t[1];
}
function ue(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}
function ge(e) {
  return Math.hypot(e[0], e[1]);
}
function de(e) {
  return e[0] * e[0] + e[1] * e[1];
}
function A(e, t) {
  return de(a(e, t));
}
function G(e) {
  return he(e, ge(e));
}
function ie(e, t) {
  return Math.hypot(e[1] - t[1], e[0] - t[0]);
}
function L(e, t, u) {
  let x = Math.sin(u), h = Math.cos(u), y = e[0] - t[0], n = e[1] - t[1], f = y * h - n * x, d = y * x + n * h;
  return [f + t[0], d + t[1]];
}
function K(e, t, u) {
  return l(e, b(a(t, e), u));
}
function ee(e, t, u) {
  return l(e, b(t, u));
}
var { min: C, PI: xe } = Math;
var pe = 0.275;
var V = xe + 1e-4;
function ce(e, t = {}) {
  let { size: u = 16, smoothing: x = 0.5, thinning: h = 0.5, simulatePressure: y = true, easing: n = (r) => r, start: f = {}, end: d = {}, last: D = false } = t, { cap: S = true, easing: j = (r) => r * (2 - r) } = f, { cap: q = true, easing: c = (r) => --r * r * r + 1 } = d;
  if (e.length === 0 || u <= 0) return [];
  let p = e[e.length - 1].runningLength, g = f.taper === false ? 0 : f.taper === true ? Math.max(u, p) : f.taper, T = d.taper === false ? 0 : d.taper === true ? Math.max(u, p) : d.taper, te = Math.pow(u * x, 2), _ = [], M = [], H = e.slice(0, 10).reduce((r, i) => {
    let o = i.pressure;
    if (y) {
      let s = C(1, i.distance / u), W = C(1, 1 - s);
      o = C(1, r + (W - r) * (s * pe));
    }
    return (r + o) / 2;
  }, e[0].pressure), m = $(u, h, e[e.length - 1].pressure, n), U, X = e[0].vector, z = e[0].point, F = z, O = z, E = F, J = false;
  for (let r = 0; r < e.length; r++) {
    let { pressure: i } = e[r], { point: o, vector: s, distance: W, runningLength: I } = e[r];
    if (r < e.length - 1 && p - I < 3) continue;
    if (h) {
      if (y) {
        let v = C(1, W / u), Z = C(1, 1 - v);
        i = C(1, H + (Z - H) * (v * pe));
      }
      m = $(u, h, i, n);
    } else m = u / 2;
    U === void 0 && (U = m);
    let le = I < g ? j(I / g) : 1, fe = p - I < T ? c((p - I) / T) : 1;
    m = Math.max(0.01, m * Math.min(le, fe));
    let re = (r < e.length - 1 ? e[r + 1] : e[r]).vector, Y = r < e.length - 1 ? B(s, re) : 1, be = B(s, X) < 0 && !J, ne = Y !== null && Y < 0;
    if (be || ne) {
      let v = b(R(X), m);
      for (let Z = 1 / 13, w = 0; w <= 1; w += Z) O = L(a(o, v), o, V * w), _.push(O), E = L(l(o, v), o, V * -w), M.push(E);
      z = O, F = E, ne && (J = true);
      continue;
    }
    if (J = false, r === e.length - 1) {
      let v = b(R(s), m);
      _.push(a(o, v)), M.push(l(o, v));
      continue;
    }
    let oe = b(R(K(re, s, Y)), m);
    O = a(o, oe), (r <= 1 || A(z, O) > te) && (_.push(O), z = O), E = l(o, oe), (r <= 1 || A(F, E) > te) && (M.push(E), F = E), H = i, X = s;
  }
  let P = e[0].point.slice(0, 2), k = e.length > 1 ? e[e.length - 1].point.slice(0, 2) : l(e[0].point, [1, 1]), Q = [], N = [];
  if (e.length === 1) {
    if (!(g || T) || D) {
      let r = ee(P, G(R(a(P, k))), -(U || m)), i = [];
      for (let o = 1 / 13, s = o; s <= 1; s += o) i.push(L(r, P, V * 2 * s));
      return i;
    }
  } else {
    if (!(g || T && e.length === 1)) if (S) for (let i = 1 / 13, o = i; o <= 1; o += i) {
      let s = L(M[0], P, V * o);
      Q.push(s);
    }
    else {
      let i = a(_[0], M[0]), o = b(i, 0.5), s = b(i, 0.51);
      Q.push(a(P, o), a(P, s), l(P, s), l(P, o));
    }
    let r = R(se(e[e.length - 1].vector));
    if (T || g && e.length === 1) N.push(k);
    else if (q) {
      let i = ee(k, r, m);
      for (let o = 1 / 29, s = o; s < 1; s += o) N.push(L(i, k, V * 3 * s));
    } else N.push(l(k, b(r, m)), l(k, b(r, m * 0.99)), a(k, b(r, m * 0.99)), a(k, b(r, m)));
  }
  return _.concat(N, M.reverse(), Q);
}
function me(e, t = {}) {
  var q;
  let { streamline: u = 0.5, size: x = 16, last: h = false } = t;
  if (e.length === 0) return [];
  let y = 0.15 + (1 - u) * 0.85, n = Array.isArray(e[0]) ? e : e.map(({ x: c, y: p, pressure: g = 0.5 }) => [c, p, g]);
  if (n.length === 2) {
    let c = n[1];
    n = n.slice(0, -1);
    for (let p = 1; p < 5; p++) n.push(K(n[0], c, p / 4));
  }
  n.length === 1 && (n = [...n, [...l(n[0], [1, 1]), ...n[0].slice(2)]]);
  let f = [{ point: [n[0][0], n[0][1]], pressure: n[0][2] >= 0 ? n[0][2] : 0.25, vector: [1, 1], distance: 0, runningLength: 0 }], d = false, D = 0, S = f[0], j = n.length - 1;
  for (let c = 1; c < n.length; c++) {
    let p = h && c === j ? n[c].slice(0, 2) : K(S.point, n[c], y);
    if (ue(S.point, p)) continue;
    let g = ie(p, S.point);
    if (D += g, c < j && !d) {
      if (D < x) continue;
      d = true;
    }
    S = { point: p, pressure: n[c][2] >= 0 ? n[c][2] : 0.5, vector: G(a(S.point, p)), distance: g, runningLength: D }, f.push(S);
  }
  return f[0].vector = ((q = f[1]) == null ? void 0 : q.vector) || [0, 0], f;
}
function ae(e, t = {}) {
  return ce(me(e, t), t);
}
var _e = ae;

// node_modules/@zag-js/signature-pad/dist/index.mjs
var anatomy24 = createAnatomy("signature-pad").parts(
  "root",
  "control",
  "segment",
  "segmentPath",
  "guide",
  "clearTrigger",
  "label"
);
var parts27 = anatomy24.build();
var dom24 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `signature-${ctx.id}`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `signature-control-${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `signature-label-${ctx.id}`;
  },
  getHiddenInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `signature-input-${ctx.id}`;
  },
  getControlEl: (ctx) => dom24.getById(ctx, dom24.getControlId(ctx)),
  getSegmentEl: (ctx) => query(dom24.getControlEl(ctx), "[data-part=segment]"),
  getHiddenInputEl: (ctx) => dom24.getById(ctx, dom24.getHiddenInputId(ctx)),
  getDataUrl: (ctx, options) => {
    if (ctx.isEmpty) return Promise.resolve("");
    return getDataUrl(dom24.getSegmentEl(ctx), options);
  }
});
var defaultTranslations3 = {
  control: "signature pad",
  clearTrigger: "clear signature"
};
function connect25(state2, send, normalize3) {
  const drawing = state2.matches("drawing");
  const empty2 = state2.context.isEmpty;
  const interactive = state2.context.isInteractive;
  const disabled = !!state2.context.disabled;
  const translations = state2.context.translations || defaultTranslations3;
  return {
    empty: empty2,
    drawing,
    currentPath: state2.context.currentPath,
    paths: state2.context.paths,
    clear() {
      send({ type: "CLEAR" });
    },
    getDataUrl(type, quality) {
      return dom24.getDataUrl(state2.context, { type, quality });
    },
    getLabelProps() {
      return normalize3.label({
        ...parts27.label.attrs,
        id: dom24.getLabelId(state2.context),
        "data-disabled": dataAttr(disabled),
        htmlFor: dom24.getHiddenInputId(state2.context),
        onClick(event) {
          if (!interactive) return;
          if (event.defaultPrevented) return;
          const controlEl = dom24.getControlEl(state2.context);
          controlEl == null ? void 0 : controlEl.focus({ preventScroll: true });
        }
      });
    },
    getRootProps() {
      return normalize3.element({
        ...parts27.root.attrs,
        "data-disabled": dataAttr(disabled),
        id: dom24.getRootId(state2.context)
      });
    },
    getControlProps() {
      return normalize3.element({
        ...parts27.control.attrs,
        tabIndex: disabled ? void 0 : 0,
        id: dom24.getControlId(state2.context),
        role: "application",
        "aria-roledescription": "signature pad",
        "aria-label": translations.control,
        "aria-disabled": disabled,
        "data-disabled": dataAttr(disabled),
        onPointerDown(event) {
          if (!isLeftClick(event)) return;
          if (isModifierKey(event)) return;
          if (!interactive) return;
          const target = getEventTarget(event);
          if (target == null ? void 0 : target.closest("[data-part=clear-trigger]")) return;
          event.currentTarget.setPointerCapture(event.pointerId);
          const point = { x: event.clientX, y: event.clientY };
          const { offset: offset3 } = getRelativePoint(point, dom24.getControlEl(state2.context));
          send({ type: "POINTER_DOWN", point: offset3, pressure: event.pressure });
        },
        onPointerUp(event) {
          if (!interactive) return;
          if (event.currentTarget.hasPointerCapture(event.pointerId)) {
            event.currentTarget.releasePointerCapture(event.pointerId);
          }
        },
        style: {
          position: "relative",
          touchAction: "none",
          userSelect: "none",
          WebkitUserSelect: "none"
        }
      });
    },
    getSegmentProps() {
      return normalize3.svg({
        ...parts27.segment.attrs,
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          pointerEvents: "none",
          fill: state2.context.drawing.fill
        }
      });
    },
    getSegmentPathProps(props210) {
      return normalize3.path({
        ...parts27.segmentPath.attrs,
        d: props210.path
      });
    },
    getGuideProps() {
      return normalize3.element({
        ...parts27.guide.attrs,
        "data-disabled": dataAttr(disabled)
      });
    },
    getClearTriggerProps() {
      return normalize3.button({
        ...parts27.clearTrigger.attrs,
        type: "button",
        "aria-label": translations.clearTrigger,
        hidden: !state2.context.paths.length || drawing,
        disabled,
        onClick() {
          send({ type: "CLEAR" });
        }
      });
    },
    getHiddenInputProps(props210) {
      return normalize3.input({
        id: dom24.getHiddenInputId(state2.context),
        type: "text",
        hidden: true,
        disabled,
        required: state2.context.required,
        readOnly: state2.context.readOnly,
        name: state2.context.name,
        value: props210.value
      });
    }
  };
}
var average = (a2, b2) => (a2 + b2) / 2;
function getSvgPathFromStroke(points, closed = true) {
  const len = points.length;
  if (len < 4) {
    return "";
  }
  let a2 = points[0];
  let b2 = points[1];
  const c = points[2];
  let result = `M${a2[0].toFixed(2)},${a2[1].toFixed(2)} Q${b2[0].toFixed(2)},${b2[1].toFixed(2)} ${average(b2[0], c[0]).toFixed(2)},${average(
    b2[1],
    c[1]
  ).toFixed(2)} T`;
  for (let i = 2, max4 = len - 1; i < max4; i++) {
    a2 = points[i];
    b2 = points[i + 1];
    result += `${average(a2[0], b2[0]).toFixed(2)},${average(a2[1], b2[1]).toFixed(2)} `;
  }
  if (closed) {
    result += "Z";
  }
  return result;
}
function machine25(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "signature-pad",
      initial: "idle",
      context: {
        readOnly: false,
        disabled: false,
        ...ctx,
        paths: [],
        currentPoints: [],
        currentPath: null,
        drawing: {
          size: 2,
          simulatePressure: false,
          thinning: 0.7,
          smoothing: 0.4,
          streamline: 0.6,
          ...ctx.drawing
        }
      },
      computed: {
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly),
        isEmpty: (ctx2) => ctx2.paths.length === 0
      },
      on: {
        CLEAR: {
          actions: ["clearPoints", "invokeOnDrawEnd", "focusCanvasEl"]
        }
      },
      states: {
        idle: {
          on: {
            POINTER_DOWN: {
              target: "drawing",
              actions: ["addPoint"]
            }
          }
        },
        drawing: {
          activities: ["trackPointerMove"],
          on: {
            POINTER_MOVE: {
              actions: ["addPoint", "invokeOnDraw"]
            },
            POINTER_UP: {
              target: "idle",
              actions: ["endStroke", "invokeOnDrawEnd"]
            }
          }
        }
      }
    },
    {
      activities: {
        trackPointerMove(ctx2, _evt, { send }) {
          const doc = dom24.getDoc(ctx2);
          return trackPointerMove(doc, {
            onPointerMove({ event, point }) {
              const { offset: offset3 } = getRelativePoint(point, dom24.getControlEl(ctx2));
              send({ type: "POINTER_MOVE", point: offset3, pressure: event.pressure });
            },
            onPointerUp() {
              send({ type: "POINTER_UP" });
            }
          });
        }
      },
      actions: {
        addPoint(ctx2, evt) {
          ctx2.currentPoints.push(evt.point);
          const stroke = _e(ctx2.currentPoints, ctx2.drawing);
          ctx2.currentPath = getSvgPathFromStroke(stroke);
        },
        endStroke(ctx2) {
          ctx2.paths.push(ctx2.currentPath);
          ctx2.currentPoints = [];
          ctx2.currentPath = null;
        },
        clearPoints(ctx2) {
          ctx2.currentPoints = [];
          ctx2.paths = [];
        },
        focusCanvasEl(ctx2) {
          queueMicrotask(() => {
            var _a8;
            (_a8 = dom24.getControlEl(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        invokeOnDraw(ctx2) {
          var _a8;
          (_a8 = ctx2.onDraw) == null ? void 0 : _a8.call(ctx2, {
            paths: [...ctx2.paths, ctx2.currentPath]
          });
        },
        invokeOnDrawEnd(ctx2) {
          var _a8;
          (_a8 = ctx2.onDrawEnd) == null ? void 0 : _a8.call(ctx2, {
            paths: [...ctx2.paths],
            getDataUrl(type, quality = 0.92) {
              return dom24.getDataUrl(ctx2, { type, quality });
            }
          });
        }
      }
    }
  );
}
var props21 = createProps()([
  "dir",
  "disabled",
  "drawing",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onDraw",
  "onDrawEnd",
  "readOnly",
  "required",
  "translations"
]);
var splitProps21 = createSplitProps(props21);

// node_modules/@ark-ui/react/dist/components/signature-pad/use-signature-pad.js
var import_react622 = __toESM(require_react(), 1);
var useSignaturePad = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react622.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    getRootNode,
    ...props34
  };
  const context = {
    ...initialContext,
    drawing: props34.drawing,
    onDraw: useEvent(props34.onDraw),
    onDrawEnd: useEvent(props34.onDrawEnd)
  };
  const [state2, send] = useMachine(machine25(initialContext), { context });
  return connect25(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-root.js
var SignaturePadRoot = (0, import_react624.forwardRef)((props34, ref2) => {
  const [useSignaturePadProps, localProps] = createSplitProps2()(props34, [
    "id",
    "ids",
    "drawing",
    "disabled",
    "readOnly",
    "name",
    "onDraw",
    "onDrawEnd",
    "readOnly",
    "required",
    "translations"
  ]);
  const signaturePad = useSignaturePad(useSignaturePadProps);
  const mergedProps = mergeProps2(signaturePad.getRootProps(), localProps);
  return (0, import_jsx_runtime290.jsx)(SignaturePadProvider, { value: signaturePad, children: (0, import_jsx_runtime290.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
SignaturePadRoot.displayName = "SignaturePadRoot";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-root-provider.js
var import_jsx_runtime291 = __toESM(require_jsx_runtime(), 1);
var import_react626 = __toESM(require_react(), 1);
var SignaturePadRootProvider = (0, import_react626.forwardRef)(
  (props34, ref2) => {
    const [{ value: signaturePad }, localProps] = createSplitProps2()(props34, [
      "value"
    ]);
    const mergedProps = mergeProps2(signaturePad.getRootProps(), localProps);
    return (0, import_jsx_runtime291.jsx)(SignaturePadProvider, { value: signaturePad, children: (0, import_jsx_runtime291.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
SignaturePadRootProvider.displayName = "SignaturePadRootProvider";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-segment.js
var import_jsx_runtime292 = __toESM(require_jsx_runtime(), 1);
var import_react628 = __toESM(require_react(), 1);
var SignaturePadSegment = (0, import_react628.forwardRef)(
  (props34, ref2) => {
    const signaturePad = useSignaturePadContext();
    const mergedProps = mergeProps2(signaturePad.getSegmentProps(), props34);
    return (0, import_jsx_runtime292.jsxs)(ark.svg, { ...mergedProps, ref: ref2, children: [
      (0, import_jsx_runtime292.jsx)("title", { children: "Signature" }),
      signaturePad.paths.map((path, i) => (0, import_jsx_runtime292.jsx)("path", { ...signaturePad.getSegmentPathProps({ path }) }, i)),
      signaturePad.currentPath && (0, import_jsx_runtime292.jsx)("path", { ...signaturePad.getSegmentPathProps({ path: signaturePad.currentPath }) })
    ] });
  }
);
SignaturePadSegment.displayName = "SignaturePadSegment";

// node_modules/@ark-ui/react/dist/components/slider/use-slider-context.js
var [SliderProvider, useSliderContext] = createContext3({
  name: "SliderContext",
  hookName: "useSliderContext",
  providerName: "<SliderProvider />"
});

// node_modules/@ark-ui/react/dist/components/slider/slider-context.js
var SliderContext = (props34) => props34.children(useSliderContext());

// node_modules/@ark-ui/react/dist/components/slider/slider-control.js
var import_jsx_runtime293 = __toESM(require_jsx_runtime(), 1);
var import_react630 = __toESM(require_react(), 1);
var SliderControl = (0, import_react630.forwardRef)((props34, ref2) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getControlProps(), props34);
  return (0, import_jsx_runtime293.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SliderControl.displayName = "SliderControl";

// node_modules/@ark-ui/react/dist/components/slider/slider-dragging-indicator.js
var import_jsx_runtime294 = __toESM(require_jsx_runtime(), 1);
var import_react632 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/slider/use-slider-thumb-props-context.js
var [SliderThumbPropsProvider, useSliderThumbPropsContext] = createContext3({
  name: "SliderThumbPropsContext",
  hookName: "useSliderThumbPropsContext",
  providerName: "<SliderThumbPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/slider/slider-dragging-indicator.js
var SliderDraggingIndicator = (0, import_react632.forwardRef)(
  (props34, ref2) => {
    const slider = useSliderContext();
    const { index } = useSliderThumbPropsContext();
    const mergedProps = mergeProps2(slider.getDraggingIndicatorProps({ index }), props34);
    return (0, import_jsx_runtime294.jsx)(ark.span, { ...mergedProps, ref: ref2, children: props34.children || slider.getThumbValue(index) });
  }
);
SliderDraggingIndicator.displayName = "SliderDraggingIndicator";

// node_modules/@ark-ui/react/dist/components/slider/slider-hidden-input.js
var import_jsx_runtime295 = __toESM(require_jsx_runtime(), 1);
var import_react634 = __toESM(require_react(), 1);
var SliderHiddenInput = (0, import_react634.forwardRef)(
  (props34, ref2) => {
    const slider = useSliderContext();
    const thumbProps2 = useSliderThumbPropsContext();
    const mergedProps = mergeProps2(slider.getHiddenInputProps(thumbProps2), props34);
    return (0, import_jsx_runtime295.jsx)(ark.input, { ...mergedProps, ref: ref2 });
  }
);
SliderHiddenInput.displayName = "SliderHiddenInput";

// node_modules/@ark-ui/react/dist/components/slider/slider-label.js
var import_jsx_runtime296 = __toESM(require_jsx_runtime(), 1);
var import_react636 = __toESM(require_react(), 1);
var SliderLabel = (0, import_react636.forwardRef)((props34, ref2) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getLabelProps(), props34);
  return (0, import_jsx_runtime296.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
SliderLabel.displayName = "SliderLabel";

// node_modules/@ark-ui/react/dist/components/slider/slider-marker.js
var import_jsx_runtime297 = __toESM(require_jsx_runtime(), 1);
var import_react638 = __toESM(require_react(), 1);
var SliderMarker = (0, import_react638.forwardRef)((props34, ref2) => {
  const [markerProps, localProps] = createSplitProps2()(props34, ["value"]);
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getMarkerProps(markerProps), localProps);
  return (0, import_jsx_runtime297.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
SliderMarker.displayName = "SliderMarker";

// node_modules/@ark-ui/react/dist/components/slider/slider-marker-group.js
var import_jsx_runtime298 = __toESM(require_jsx_runtime(), 1);
var import_react640 = __toESM(require_react(), 1);
var SliderMarkerGroup = (0, import_react640.forwardRef)(
  (props34, ref2) => {
    const slider = useSliderContext();
    const mergedProps = mergeProps2(slider.getMarkerGroupProps(), props34);
    return (0, import_jsx_runtime298.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SliderMarkerGroup.displayName = "SliderMarkerGroup";

// node_modules/@ark-ui/react/dist/components/slider/slider-range.js
var import_jsx_runtime299 = __toESM(require_jsx_runtime(), 1);
var import_react642 = __toESM(require_react(), 1);
var SliderRange = (0, import_react642.forwardRef)((props34, ref2) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getRangeProps(), props34);
  return (0, import_jsx_runtime299.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SliderRange.displayName = "SliderRange";

// node_modules/@ark-ui/react/dist/components/slider/slider-root.js
var import_jsx_runtime300 = __toESM(require_jsx_runtime(), 1);
var import_react646 = __toESM(require_react(), 1);

// node_modules/@zag-js/element-size/dist/index.mjs
function trackElementSize(element, callback) {
  if (!element) {
    callback(void 0);
    return;
  }
  callback({ width: element.offsetWidth, height: element.offsetHeight });
  const win = element.ownerDocument.defaultView ?? window;
  const observer = new win.ResizeObserver((entries) => {
    if (!Array.isArray(entries) || !entries.length) return;
    const [entry] = entries;
    let width;
    let height;
    if ("borderBoxSize" in entry) {
      const borderSizeEntry = entry["borderBoxSize"];
      const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
      width = borderSize["inlineSize"];
      height = borderSize["blockSize"];
    } else {
      width = element.offsetWidth;
      height = element.offsetHeight;
    }
    callback({ width, height });
  });
  observer.observe(element, { box: "border-box" });
  return () => observer.unobserve(element);
}
function trackElementsSize(options) {
  const { getNodes, observeMutation = true, callback } = options;
  const cleanups2 = [];
  let firstNode = null;
  function trigger() {
    const elements = getNodes();
    firstNode = elements[0];
    const fns = elements.map(
      (element, index) => trackElementSize(element, (size3) => {
        callback(size3, index);
      })
    );
    cleanups2.push(...fns);
  }
  trigger();
  if (observeMutation) {
    const fn = trackMutation(firstNode, trigger);
    cleanups2.push(fn);
  }
  return () => {
    cleanups2.forEach((cleanup) => {
      cleanup == null ? void 0 : cleanup();
    });
  };
}
function trackMutation(el, cb) {
  var _a8;
  if (!el || !el.parentElement) return;
  const win = ((_a8 = el.ownerDocument) == null ? void 0 : _a8.defaultView) ?? window;
  const observer = new win.MutationObserver(() => {
    cb();
  });
  observer.observe(el.parentElement, { childList: true });
  return () => {
    observer.disconnect();
  };
}

// node_modules/@zag-js/slider/dist/index.mjs
var anatomy25 = createAnatomy("slider").parts(
  "root",
  "label",
  "thumb",
  "valueText",
  "track",
  "range",
  "control",
  "markerGroup",
  "marker",
  "draggingIndicator"
);
var parts28 = anatomy25.build();
function getBounds(value) {
  const firstValue = value[0];
  const lastThumb = value[value.length - 1];
  return [firstValue, lastThumb];
}
function getRangeOffsets(ctx) {
  const [firstPercent, lastPercent] = getBounds(ctx.valuePercent);
  if (ctx.valuePercent.length === 1) {
    if (ctx.origin === "center") {
      const isNegative = ctx.valuePercent[0] < 50;
      const start = isNegative ? `${ctx.valuePercent[0]}%` : "50%";
      const end = isNegative ? "50%" : `${100 - ctx.valuePercent[0]}%`;
      return { start, end };
    }
    return { start: "0%", end: `${100 - lastPercent}%` };
  }
  return { start: `${firstPercent}%`, end: `${100 - lastPercent}%` };
}
function getRangeStyle(ctx) {
  if (ctx.isVertical) {
    return {
      position: "absolute",
      bottom: "var(--slider-range-start)",
      top: "var(--slider-range-end)"
    };
  }
  return {
    position: "absolute",
    [ctx.isRtl ? "right" : "left"]: "var(--slider-range-start)",
    [ctx.isRtl ? "left" : "right"]: "var(--slider-range-end)"
  };
}
function getVerticalThumbOffset(ctx) {
  const { height = 0 } = ctx.thumbSize ?? {};
  const getValue = getValueTransformer([ctx.min, ctx.max], [-height / 2, height / 2]);
  return parseFloat(getValue(ctx.value).toFixed(2));
}
function getHorizontalThumbOffset(ctx) {
  const { width = 0 } = ctx.thumbSize ?? {};
  if (ctx.isRtl) {
    const getValue2 = getValueTransformer([ctx.max, ctx.min], [-width / 2, width / 2]);
    return -1 * parseFloat(getValue2(ctx.value).toFixed(2));
  }
  const getValue = getValueTransformer([ctx.min, ctx.max], [-width / 2, width / 2]);
  return parseFloat(getValue(ctx.value).toFixed(2));
}
function getOffset(ctx, percent) {
  if (ctx.thumbAlignment === "center") return `${percent}%`;
  const offset3 = ctx.isVertical ? getVerticalThumbOffset(ctx) : getHorizontalThumbOffset(ctx);
  return `calc(${percent}% - ${offset3}px)`;
}
function getThumbOffset(ctx) {
  let percent = getValuePercent(ctx.value, ctx.min, ctx.max) * 100;
  return getOffset(ctx, percent);
}
function getVisibility(ctx) {
  let visibility = "visible";
  if (ctx.thumbAlignment === "contain" && !ctx.hasMeasuredThumbSize) {
    visibility = "hidden";
  }
  return visibility;
}
function getThumbStyle(ctx, index) {
  const placementProp = ctx.isVertical ? "bottom" : "insetInlineStart";
  return {
    visibility: getVisibility(ctx),
    position: "absolute",
    transform: "var(--slider-thumb-transform)",
    [placementProp]: `var(--slider-thumb-offset-${index})`
  };
}
function getControlStyle() {
  return {
    touchAction: "none",
    userSelect: "none",
    WebkitUserSelect: "none",
    position: "relative"
  };
}
function getRootStyle(ctx) {
  const range2 = getRangeOffsets(ctx);
  const offsetStyles = ctx.value.reduce((styles, value, index) => {
    const offset3 = getThumbOffset({ ...ctx, value });
    return { ...styles, [`--slider-thumb-offset-${index}`]: offset3 };
  }, {});
  return {
    ...offsetStyles,
    "--slider-thumb-transform": ctx.isVertical ? "translateY(50%)" : ctx.isRtl ? "translateX(50%)" : "translateX(-50%)",
    "--slider-range-start": range2.start,
    "--slider-range-end": range2.end
  };
}
function getMarkerStyle(ctx, value) {
  return {
    // @ts-expect-error
    visibility: getVisibility(ctx),
    position: "absolute",
    pointerEvents: "none",
    // @ts-expect-error
    [ctx.isHorizontal ? "insetInlineStart" : "bottom"]: getThumbOffset({ ...ctx, value }),
    translate: "var(--tx) var(--ty)",
    "--tx": ctx.isHorizontal ? ctx.isRtl ? "50%" : "-50%" : "0%",
    "--ty": !ctx.isHorizontal ? "50%" : "0%"
  };
}
function getMarkerGroupStyle() {
  return {
    userSelect: "none",
    WebkitUserSelect: "none",
    pointerEvents: "none",
    position: "relative"
  };
}
var styleGetterFns = {
  getRootStyle,
  getControlStyle,
  getThumbStyle,
  getRangeStyle,
  getMarkerStyle,
  getMarkerGroupStyle
};
var dom25 = createScope({
  ...styleGetterFns,
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `slider:${ctx.id}`;
  },
  getThumbId: (ctx, index) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.thumb) == null ? void 0 : _b7.call(_a8, index)) ?? `slider:${ctx.id}:thumb:${index}`;
  },
  getHiddenInputId: (ctx, index) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) == null ? void 0 : _b7.call(_a8, index)) ?? `slider:${ctx.id}:input:${index}`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `slider:${ctx.id}:control`;
  },
  getTrackId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.track) ?? `slider:${ctx.id}:track`;
  },
  getRangeId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.range) ?? `slider:${ctx.id}:range`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `slider:${ctx.id}:label`;
  },
  getValueTextId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.valueText) ?? `slider:${ctx.id}:value-text`;
  },
  getMarkerId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.marker) == null ? void 0 : _b7.call(_a8, value)) ?? `slider:${ctx.id}:marker:${value}`;
  },
  getRootEl: (ctx) => dom25.getById(ctx, dom25.getRootId(ctx)),
  getThumbEl: (ctx, index) => dom25.getById(ctx, dom25.getThumbId(ctx, index)),
  getHiddenInputEl: (ctx, index) => dom25.getById(ctx, dom25.getHiddenInputId(ctx, index)),
  getControlEl: (ctx) => dom25.getById(ctx, dom25.getControlId(ctx)),
  getElements: (ctx) => queryAll(dom25.getControlEl(ctx), "[role=slider]"),
  getFirstEl: (ctx) => dom25.getElements(ctx)[0],
  getRangeEl: (ctx) => dom25.getById(ctx, dom25.getRangeId(ctx)),
  getValueFromPoint(ctx, point) {
    const controlEl = dom25.getControlEl(ctx);
    if (!controlEl) return;
    const relativePoint = getRelativePoint(point, controlEl);
    const percent = relativePoint.getPercentValue({
      orientation: ctx.orientation,
      dir: ctx.dir,
      inverted: { y: true }
    });
    return getPercentValue(percent, ctx.min, ctx.max, ctx.step);
  },
  dispatchChangeEvent(ctx) {
    const valueArray = Array.from(ctx.value);
    valueArray.forEach((value, index) => {
      const inputEl = dom25.getHiddenInputEl(ctx, index);
      if (!inputEl) return;
      dispatchInputValueEvent(inputEl, { value });
    });
  }
});
function normalizeValues(ctx, nextValues) {
  return nextValues.map((value, index, values) => {
    return constrainValue2({ ...ctx, value: values }, value, index);
  });
}
function getRangeAtIndex(ctx, index) {
  return getValueRanges(ctx.value, ctx.min, ctx.max, ctx.minStepsBetweenThumbs)[index];
}
function constrainValue2(ctx, value, index) {
  const range2 = getRangeAtIndex(ctx, index);
  const snapValue = snapValueToStep(value, ctx.min, ctx.max, ctx.step);
  return clampValue(snapValue, range2.min, range2.max);
}
function decrement(ctx, index, step) {
  const idx = index ?? ctx.focusedIndex;
  const range2 = getRangeAtIndex(ctx, idx);
  const nextValues = getPreviousStepValue(idx, {
    ...range2,
    step: step ?? ctx.step,
    values: ctx.value
  });
  nextValues[idx] = clampValue(nextValues[idx], range2.min, range2.max);
  return nextValues;
}
function increment(ctx, index, step) {
  const idx = index ?? ctx.focusedIndex;
  const range2 = getRangeAtIndex(ctx, idx);
  const nextValues = getNextStepValue(idx, {
    ...range2,
    step: step ?? ctx.step,
    values: ctx.value
  });
  nextValues[idx] = clampValue(nextValues[idx], range2.min, range2.max);
  return nextValues;
}
function getClosestIndex(ctx, pointValue) {
  return getClosestValueIndex(ctx.value, pointValue);
}
function assignArray(current, next3) {
  for (let i = 0; i < next3.length; i++) {
    const value = next3[i];
    current[i] = value;
  }
}
function connect26(state2, send, normalize3) {
  const ariaLabel = state2.context["aria-label"];
  const ariaLabelledBy = state2.context["aria-labelledby"];
  const sliderValue = state2.context.value;
  const focused = state2.matches("focus");
  const dragging = state2.matches("dragging");
  const disabled = state2.context.isDisabled;
  const invalid = state2.context.invalid;
  const interactive = state2.context.isInteractive;
  const isHorizontal = state2.context.orientation === "horizontal";
  const isVertical = state2.context.orientation === "vertical";
  function getValuePercentFn(value) {
    return getValuePercent(value, state2.context.min, state2.context.max);
  }
  function getPercentValueFn(percent) {
    return getPercentValue(percent, state2.context.min, state2.context.max, state2.context.step);
  }
  return {
    value: state2.context.value,
    dragging,
    focused,
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    getThumbValue(index) {
      return sliderValue[index];
    },
    setThumbValue(index, value) {
      send({ type: "SET_VALUE", index, value });
    },
    getValuePercent: getValuePercentFn,
    getPercentValue: getPercentValueFn,
    getThumbPercent(index) {
      return getValuePercentFn(sliderValue[index]);
    },
    setThumbPercent(index, percent) {
      const value = getPercentValueFn(percent);
      send({ type: "SET_VALUE", index, value });
    },
    getThumbMin(index) {
      return getRangeAtIndex(state2.context, index).min;
    },
    getThumbMax(index) {
      return getRangeAtIndex(state2.context, index).max;
    },
    increment(index) {
      send({ type: "INCREMENT", index });
    },
    decrement(index) {
      send({ type: "DECREMENT", index });
    },
    focus() {
      if (!interactive) return;
      send({ type: "FOCUS", index: 0 });
    },
    getLabelProps() {
      return normalize3.label({
        ...parts28.label.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-invalid": dataAttr(invalid),
        "data-dragging": dataAttr(dragging),
        "data-focus": dataAttr(focused),
        id: dom25.getLabelId(state2.context),
        htmlFor: dom25.getHiddenInputId(state2.context, 0),
        onClick(event) {
          var _a8;
          if (!interactive) return;
          event.preventDefault();
          (_a8 = dom25.getFirstEl(state2.context)) == null ? void 0 : _a8.focus();
        },
        style: {
          userSelect: "none",
          WebkitUserSelect: "none"
        }
      });
    },
    getRootProps() {
      return normalize3.element({
        ...parts28.root.attrs,
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-dragging": dataAttr(dragging),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        id: dom25.getRootId(state2.context),
        dir: state2.context.dir,
        style: dom25.getRootStyle(state2.context)
      });
    },
    getValueTextProps() {
      return normalize3.element({
        ...parts28.valueText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        id: dom25.getValueTextId(state2.context)
      });
    },
    getTrackProps() {
      return normalize3.element({
        ...parts28.track.attrs,
        dir: state2.context.dir,
        id: dom25.getTrackId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-dragging": dataAttr(dragging),
        "data-orientation": state2.context.orientation,
        "data-focus": dataAttr(focused),
        style: { position: "relative" }
      });
    },
    getThumbProps(props210) {
      var _a8, _b7;
      const { index = 0, name } = props210;
      const value = sliderValue[index];
      const range2 = getRangeAtIndex(state2.context, index);
      const valueText = (_b7 = (_a8 = state2.context).getAriaValueText) == null ? void 0 : _b7.call(_a8, { value, index });
      const _ariaLabel = Array.isArray(ariaLabel) ? ariaLabel[index] : ariaLabel;
      const _ariaLabelledBy = Array.isArray(ariaLabelledBy) ? ariaLabelledBy[index] : ariaLabelledBy;
      return normalize3.element({
        ...parts28.thumb.attrs,
        dir: state2.context.dir,
        "data-index": index,
        "data-name": name,
        id: dom25.getThumbId(state2.context, index),
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-focus": dataAttr(focused && state2.context.focusedIndex === index),
        "data-dragging": dataAttr(dragging && state2.context.focusedIndex === index),
        draggable: false,
        "aria-disabled": ariaAttr(disabled),
        "aria-label": _ariaLabel,
        "aria-labelledby": _ariaLabelledBy ?? dom25.getLabelId(state2.context),
        "aria-orientation": state2.context.orientation,
        "aria-valuemax": range2.max,
        "aria-valuemin": range2.min,
        "aria-valuenow": sliderValue[index],
        "aria-valuetext": valueText,
        role: "slider",
        tabIndex: disabled ? void 0 : 0,
        style: dom25.getThumbStyle(state2.context, index),
        onPointerDown(event) {
          if (!interactive) return;
          send({ type: "THUMB_POINTER_DOWN", index });
          event.stopPropagation();
        },
        onBlur() {
          if (!interactive) return;
          send("BLUR");
        },
        onFocus() {
          if (!interactive) return;
          send({ type: "FOCUS", index });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const step = getEventStep(event) * state2.context.step;
          const keyMap2 = {
            ArrowUp() {
              if (isHorizontal) return;
              send({ type: "ARROW_INC", step, src: "ArrowUp" });
            },
            ArrowDown() {
              if (isHorizontal) return;
              send({ type: "ARROW_DEC", step, src: "ArrowDown" });
            },
            ArrowLeft() {
              if (isVertical) return;
              send({ type: "ARROW_DEC", step, src: "ArrowLeft" });
            },
            ArrowRight() {
              if (isVertical) return;
              send({ type: "ARROW_INC", step, src: "ArrowRight" });
            },
            PageUp() {
              send({ type: "ARROW_INC", step, src: "PageUp" });
            },
            PageDown() {
              send({ type: "ARROW_DEC", step, src: "PageDown" });
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            exec2(event);
            event.preventDefault();
            event.stopPropagation();
          }
        }
      });
    },
    getHiddenInputProps(props210) {
      const { index = 0, name } = props210;
      return normalize3.input({
        name: name ?? (state2.context.name ? state2.context.name + (state2.context.value.length > 1 ? "[]" : "") : void 0),
        form: state2.context.form,
        type: "text",
        hidden: true,
        defaultValue: state2.context.value[index],
        id: dom25.getHiddenInputId(state2.context, index)
      });
    },
    getRangeProps() {
      return normalize3.element({
        id: dom25.getRangeId(state2.context),
        ...parts28.range.attrs,
        dir: state2.context.dir,
        "data-dragging": dataAttr(dragging),
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid),
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        style: dom25.getRangeStyle(state2.context)
      });
    },
    getControlProps() {
      return normalize3.element({
        ...parts28.control.attrs,
        dir: state2.context.dir,
        id: dom25.getControlId(state2.context),
        "data-dragging": dataAttr(dragging),
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        style: dom25.getControlStyle(),
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick(event)) return;
          if (isModifierKey(event)) return;
          const point = getEventPoint(event);
          send({ type: "POINTER_DOWN", point });
          event.preventDefault();
          event.stopPropagation();
        }
      });
    },
    getMarkerGroupProps() {
      return normalize3.element({
        ...parts28.markerGroup.attrs,
        role: "presentation",
        dir: state2.context.dir,
        "aria-hidden": true,
        "data-orientation": state2.context.orientation,
        style: dom25.getMarkerGroupStyle()
      });
    },
    getMarkerProps(props210) {
      const style = dom25.getMarkerStyle(state2.context, props210.value);
      let markerState;
      const first2 = state2.context.value[0];
      const last2 = state2.context.value[state2.context.value.length - 1];
      if (props210.value < first2) {
        markerState = "under-value";
      } else if (props210.value > last2) {
        markerState = "over-value";
      } else {
        markerState = "at-value";
      }
      return normalize3.element({
        ...parts28.marker.attrs,
        id: dom25.getMarkerId(state2.context, props210.value),
        role: "presentation",
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        "data-value": props210.value,
        "data-disabled": dataAttr(disabled),
        "data-state": markerState,
        style
      });
    },
    getDraggingIndicatorProps(props210) {
      const { index = 0 } = props210;
      const isDragging = index === state2.context.focusedIndex && dragging;
      return normalize3.element({
        ...parts28.draggingIndicator.attrs,
        role: "presentation",
        dir: state2.context.dir,
        hidden: !isDragging,
        "data-orientation": state2.context.orientation,
        "data-state": isDragging ? "open" : "closed",
        style: dom25.getThumbStyle(state2.context, index)
      });
    }
  };
}
var isEqualSize2 = (a2, b2) => {
  return (a2 == null ? void 0 : a2.width) === (b2 == null ? void 0 : b2.width) && (a2 == null ? void 0 : a2.height) === (b2 == null ? void 0 : b2.height);
};
function machine26(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "slider",
      initial: "idle",
      context: {
        thumbSize: null,
        thumbAlignment: "contain",
        min: 0,
        max: 100,
        step: 1,
        value: [0],
        origin: "start",
        orientation: "horizontal",
        dir: "ltr",
        minStepsBetweenThumbs: 0,
        disabled: false,
        readOnly: false,
        ...ctx,
        focusedIndex: -1,
        fieldsetDisabled: false
      },
      computed: {
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        isVertical: (ctx2) => ctx2.orientation === "vertical",
        isRtl: (ctx2) => ctx2.orientation === "horizontal" && ctx2.dir === "rtl",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.readOnly || ctx2.isDisabled),
        hasMeasuredThumbSize: (ctx2) => ctx2.thumbSize != null,
        valuePercent(ctx2) {
          return ctx2.value.map((value) => 100 * getValuePercent(value, ctx2.min, ctx2.max));
        }
      },
      watch: {
        value: ["syncInputElements"]
      },
      entry: ["coarseValue"],
      activities: ["trackFormControlState", "trackThumbsSize"],
      on: {
        SET_VALUE: [
          {
            guard: "hasIndex",
            actions: "setValueAtIndex"
          },
          { actions: "setValue" }
        ],
        INCREMENT: {
          actions: "incrementThumbAtIndex"
        },
        DECREMENT: {
          actions: "decrementThumbAtIndex"
        }
      },
      states: {
        idle: {
          on: {
            POINTER_DOWN: {
              target: "dragging",
              actions: ["setClosestThumbIndex", "setPointerValue", "focusActiveThumb"]
            },
            FOCUS: {
              target: "focus",
              actions: "setFocusedIndex"
            },
            THUMB_POINTER_DOWN: {
              target: "dragging",
              actions: ["setFocusedIndex", "focusActiveThumb"]
            }
          }
        },
        focus: {
          entry: "focusActiveThumb",
          on: {
            POINTER_DOWN: {
              target: "dragging",
              actions: ["setClosestThumbIndex", "setPointerValue", "focusActiveThumb"]
            },
            THUMB_POINTER_DOWN: {
              target: "dragging",
              actions: ["setFocusedIndex", "focusActiveThumb"]
            },
            ARROW_DEC: {
              actions: ["decrementThumbAtIndex", "invokeOnChangeEnd"]
            },
            ARROW_INC: {
              actions: ["incrementThumbAtIndex", "invokeOnChangeEnd"]
            },
            HOME: {
              actions: ["setFocusedThumbToMin", "invokeOnChangeEnd"]
            },
            END: {
              actions: ["setFocusedThumbToMax", "invokeOnChangeEnd"]
            },
            BLUR: {
              target: "idle",
              actions: "clearFocusedIndex"
            }
          }
        },
        dragging: {
          entry: "focusActiveThumb",
          activities: "trackPointerMove",
          on: {
            POINTER_UP: {
              target: "focus",
              actions: "invokeOnChangeEnd"
            },
            POINTER_MOVE: {
              actions: "setPointerValue"
            }
          }
        }
      }
    },
    {
      guards: {
        hasIndex: (_ctx, evt) => evt.index != null
      },
      activities: {
        trackFormControlState(ctx2, _evt, { initialContext }) {
          return trackFormControl(dom25.getRootEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set20.value(ctx2, initialContext.value);
            }
          });
        },
        trackPointerMove(ctx2, _evt, { send }) {
          return trackPointerMove(dom25.getDoc(ctx2), {
            onPointerMove(info) {
              send({ type: "POINTER_MOVE", point: info.point });
            },
            onPointerUp() {
              send("POINTER_UP");
            }
          });
        },
        trackThumbsSize(ctx2) {
          if (ctx2.thumbAlignment !== "contain" || ctx2.thumbSize) return;
          return trackElementsSize({
            getNodes: () => dom25.getElements(ctx2),
            observeMutation: true,
            callback(size3) {
              if (!size3 || isEqualSize2(ctx2.thumbSize, size3)) return;
              ctx2.thumbSize = size3;
            }
          });
        }
      },
      actions: {
        syncInputElements(ctx2) {
          ctx2.value.forEach((value, index) => {
            const inputEl = dom25.getHiddenInputEl(ctx2, index);
            dom25.setValue(inputEl, value);
          });
        },
        invokeOnChangeEnd(ctx2) {
          invoke14.valueChangeEnd(ctx2);
        },
        setClosestThumbIndex(ctx2, evt) {
          const pointValue = dom25.getValueFromPoint(ctx2, evt.point);
          if (pointValue == null) return;
          const focusedIndex = getClosestIndex(ctx2, pointValue);
          set20.focusedIndex(ctx2, focusedIndex);
        },
        setFocusedIndex(ctx2, evt) {
          set20.focusedIndex(ctx2, evt.index);
        },
        clearFocusedIndex(ctx2) {
          set20.focusedIndex(ctx2, -1);
        },
        setPointerValue(ctx2, evt) {
          const pointerValue = dom25.getValueFromPoint(ctx2, evt.point);
          if (pointerValue == null) return;
          const value = constrainValue2(ctx2, pointerValue, ctx2.focusedIndex);
          set20.valueAtIndex(ctx2, ctx2.focusedIndex, value);
        },
        focusActiveThumb(ctx2) {
          raf(() => {
            const thumbEl = dom25.getThumbEl(ctx2, ctx2.focusedIndex);
            thumbEl == null ? void 0 : thumbEl.focus({ preventScroll: true });
          });
        },
        decrementThumbAtIndex(ctx2, evt) {
          const value = decrement(ctx2, evt.index, evt.step);
          set20.value(ctx2, value);
        },
        incrementThumbAtIndex(ctx2, evt) {
          const value = increment(ctx2, evt.index, evt.step);
          set20.value(ctx2, value);
        },
        setFocusedThumbToMin(ctx2) {
          const { min: min4 } = getRangeAtIndex(ctx2, ctx2.focusedIndex);
          set20.valueAtIndex(ctx2, ctx2.focusedIndex, min4);
        },
        setFocusedThumbToMax(ctx2) {
          const { max: max4 } = getRangeAtIndex(ctx2, ctx2.focusedIndex);
          set20.valueAtIndex(ctx2, ctx2.focusedIndex, max4);
        },
        coarseValue(ctx2) {
          const value = normalizeValues(ctx2, ctx2.value);
          set20.value(ctx2, value);
        },
        setValueAtIndex(ctx2, evt) {
          const value = constrainValue2(ctx2, evt.value, evt.index);
          set20.valueAtIndex(ctx2, evt.index, value);
        },
        setValue(ctx2, evt) {
          const value = normalizeValues(ctx2, evt.value);
          set20.value(ctx2, value);
        }
      }
    }
  );
}
var invoke14 = {
  valueChange(ctx) {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, {
      value: Array.from(ctx.value)
    });
    dom25.dispatchChangeEvent(ctx);
  },
  valueChangeEnd(ctx) {
    var _a8;
    (_a8 = ctx.onValueChangeEnd) == null ? void 0 : _a8.call(ctx, {
      value: Array.from(ctx.value)
    });
  },
  focusChange(ctx) {
    var _a8;
    (_a8 = ctx.onFocusChange) == null ? void 0 : _a8.call(ctx, {
      value: Array.from(ctx.value),
      focusedIndex: ctx.focusedIndex
    });
  }
};
var set20 = {
  valueAtIndex: (ctx, index, value) => {
    if (isEqual(ctx.value[index], value)) return;
    ctx.value[index] = value;
    invoke14.valueChange(ctx);
  },
  value: (ctx, value) => {
    if (isEqual(ctx.value, value)) return;
    assignArray(ctx.value, value);
    invoke14.valueChange(ctx);
  },
  focusedIndex: (ctx, index) => {
    if (isEqual(ctx.focusedIndex, index)) return;
    ctx.focusedIndex = index;
    invoke14.focusChange(ctx);
  }
};
var props22 = createProps()([
  "aria-label",
  "aria-labelledby",
  "dir",
  "disabled",
  "form",
  "getAriaValueText",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "max",
  "min",
  "minStepsBetweenThumbs",
  "name",
  "onFocusChange",
  "onValueChange",
  "onValueChangeEnd",
  "orientation",
  "origin",
  "readOnly",
  "step",
  "thumbAlignment",
  "thumbAlignment",
  "thumbSize",
  "value"
]);
var splitProps22 = createSplitProps(props22);
var thumbProps = createProps()(["index", "name"]);
var splitThumbProps = createSplitProps(thumbProps);

// node_modules/@ark-ui/react/dist/components/slider/use-slider.js
var import_react644 = __toESM(require_react(), 1);
var useSlider = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react644.useId)(),
    dir,
    getRootNode,
    value: props34.defaultValue,
    ...props34
  };
  const context = {
    ...initialContext,
    value: props34.value,
    onValueChange: useEvent(props34.onValueChange, { sync: true }),
    onValueChangeEnd: useEvent(props34.onValueChangeEnd),
    onFocusChange: useEvent(props34.onFocusChange)
  };
  const [state2, send] = useMachine(machine26(initialContext), {
    context
  });
  return connect26(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/slider/slider-root.js
var SliderRoot = (0, import_react646.forwardRef)((props34, ref2) => {
  const [useSliderProps, localProps] = createSplitProps2()(props34, [
    "aria-label",
    "aria-labelledby",
    "defaultValue",
    "disabled",
    "form",
    "getAriaValueText",
    "id",
    "ids",
    "invalid",
    "max",
    "min",
    "minStepsBetweenThumbs",
    "name",
    "onFocusChange",
    "onValueChange",
    "onValueChangeEnd",
    "orientation",
    "origin",
    "readOnly",
    "step",
    "thumbAlignment",
    "thumbAlignment",
    "thumbSize",
    "value"
  ]);
  const slider = useSlider(useSliderProps);
  const mergedProps = mergeProps2(slider.getRootProps(), localProps);
  return (0, import_jsx_runtime300.jsx)(SliderProvider, { value: slider, children: (0, import_jsx_runtime300.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
SliderRoot.displayName = "SliderRoot";

// node_modules/@ark-ui/react/dist/components/slider/slider-root-provider.js
var import_jsx_runtime301 = __toESM(require_jsx_runtime(), 1);
var import_react648 = __toESM(require_react(), 1);
var SliderRootProvider = (0, import_react648.forwardRef)(
  (props34, ref2) => {
    const [{ value: slider }, localProps] = createSplitProps2()(props34, ["value"]);
    const mergedProps = mergeProps2(slider.getRootProps(), localProps);
    return (0, import_jsx_runtime301.jsx)(SliderProvider, { value: slider, children: (0, import_jsx_runtime301.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
SliderRootProvider.displayName = "SliderRootProvider";

// node_modules/@ark-ui/react/dist/components/slider/slider-thumb.js
var import_jsx_runtime302 = __toESM(require_jsx_runtime(), 1);
var import_react650 = __toESM(require_react(), 1);
var SliderThumb = (0, import_react650.forwardRef)((props34, ref2) => {
  const [thumbProps2, localProps] = createSplitProps2()(props34, ["index", "name"]);
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getThumbProps(thumbProps2), localProps);
  return (0, import_jsx_runtime302.jsx)(SliderThumbPropsProvider, { value: thumbProps2, children: (0, import_jsx_runtime302.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
SliderThumb.displayName = "SliderThumb";

// node_modules/@ark-ui/react/dist/components/slider/slider-track.js
var import_jsx_runtime303 = __toESM(require_jsx_runtime(), 1);
var import_react652 = __toESM(require_react(), 1);
var SliderTrack = (0, import_react652.forwardRef)((props34, ref2) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getTrackProps(), props34);
  return (0, import_jsx_runtime303.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SliderTrack.displayName = "SliderTrack";

// node_modules/@ark-ui/react/dist/components/slider/slider-value-text.js
var import_jsx_runtime304 = __toESM(require_jsx_runtime(), 1);
var import_react654 = __toESM(require_react(), 1);
var SliderValueText = (0, import_react654.forwardRef)((props34, ref2) => {
  const { children, ...rest } = props34;
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getValueTextProps(), rest);
  return (0, import_jsx_runtime304.jsx)(ark.span, { ...mergedProps, ref: ref2, children: children || slider.value.join(", ") });
});
SliderValueText.displayName = "SliderValueText";

// node_modules/@ark-ui/react/dist/components/slider/slider.js
var slider_exports = {};
__export(slider_exports, {
  Context: () => SliderContext,
  Control: () => SliderControl,
  DraggingIndicator: () => SliderDraggingIndicator,
  HiddenInput: () => SliderHiddenInput,
  Label: () => SliderLabel,
  Marker: () => SliderMarker,
  MarkerGroup: () => SliderMarkerGroup,
  Range: () => SliderRange,
  Root: () => SliderRoot,
  RootProvider: () => SliderRootProvider,
  Thumb: () => SliderThumb,
  Track: () => SliderTrack,
  ValueText: () => SliderValueText
});

// node_modules/@ark-ui/react/dist/components/splitter/use-splitter-context.js
var [SplitterProvider, useSplitterContext] = createContext3({
  name: "SplitterContext",
  hookName: "useSplitterContext",
  providerName: "<SplitterProvider />"
});

// node_modules/@ark-ui/react/dist/components/splitter/splitter-panel.js
var import_jsx_runtime305 = __toESM(require_jsx_runtime(), 1);
var import_react656 = __toESM(require_react(), 1);
var SplitterPanel = (0, import_react656.forwardRef)((props34, ref2) => {
  const [splitterPanelProps, localProps] = createSplitProps2()(props34, ["id", "snapSize"]);
  const splitter = useSplitterContext();
  const mergedProps = mergeProps2(splitter.getPanelProps(splitterPanelProps), localProps);
  return (0, import_jsx_runtime305.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SplitterPanel.displayName = "SplitterPanel";

// node_modules/@ark-ui/react/dist/components/splitter/splitter-resize-trigger.js
var import_jsx_runtime306 = __toESM(require_jsx_runtime(), 1);
var import_react658 = __toESM(require_react(), 1);
var SplitterResizeTrigger = (0, import_react658.forwardRef)(
  (props34, ref2) => {
    const [triggerProps2, localProps] = createSplitProps2()(props34, [
      "disabled",
      "id",
      "step"
    ]);
    const splitter = useSplitterContext();
    const mergedProps = mergeProps2(splitter.getResizeTriggerProps(triggerProps2), localProps);
    return (0, import_jsx_runtime306.jsx)(ark.button, { ref: ref2, ...mergedProps });
  }
);
SplitterResizeTrigger.displayName = "SplitterResizeTrigger";

// node_modules/@ark-ui/react/dist/components/splitter/splitter-root.js
var import_jsx_runtime307 = __toESM(require_jsx_runtime(), 1);
var import_react662 = __toESM(require_react(), 1);

// node_modules/@zag-js/splitter/dist/index.mjs
var anatomy26 = createAnatomy("splitter").parts("root", "panel", "resizeTrigger");
var parts29 = anatomy26.build();
var dom26 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `splitter:${ctx.id}`;
  },
  getResizeTriggerId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.resizeTrigger) == null ? void 0 : _b7.call(_a8, id)) ?? `splitter:${ctx.id}:splitter:${id}`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `splitter:${ctx.id}:label`;
  },
  getPanelId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.panel) == null ? void 0 : _b7.call(_a8, id)) ?? `splitter:${ctx.id}:panel:${id}`;
  },
  getGlobalCursorId: (ctx) => `splitter:${ctx.id}:global-cursor`,
  getRootEl: (ctx) => dom26.getById(ctx, dom26.getRootId(ctx)),
  getResizeTriggerEl: (ctx, id) => dom26.getById(ctx, dom26.getResizeTriggerId(ctx, id)),
  getPanelEl: (ctx, id) => dom26.getById(ctx, dom26.getPanelId(ctx, id)),
  getCursor(ctx) {
    const x = ctx.isHorizontal;
    let cursor3 = x ? "col-resize" : "row-resize";
    if (ctx.activeResizeState.isAtMin) cursor3 = x ? "e-resize" : "s-resize";
    if (ctx.activeResizeState.isAtMax) cursor3 = x ? "w-resize" : "n-resize";
    return cursor3;
  },
  getPanelStyle(ctx, id) {
    var _a8;
    const flexGrow = ((_a8 = ctx.panels.find((panel) => panel.id === id)) == null ? void 0 : _a8.size) ?? "0";
    return {
      flexBasis: 0,
      flexGrow,
      flexShrink: 1,
      overflow: "hidden"
    };
  },
  getActiveHandleEl(ctx) {
    const activeId = ctx.activeResizeId;
    if (activeId == null) return;
    return dom26.getById(ctx, dom26.getResizeTriggerId(ctx, activeId));
  },
  getResizeTriggerEls(ctx) {
    const ownerId = CSS.escape(dom26.getRootId(ctx));
    return queryAll(dom26.getRootEl(ctx), `[role=separator][data-ownedby='${ownerId}']`);
  },
  setupGlobalCursor(ctx) {
    const styleEl = dom26.getById(ctx, dom26.getGlobalCursorId(ctx));
    const textContent = `* { cursor: ${dom26.getCursor(ctx)} !important; }`;
    if (styleEl) {
      styleEl.textContent = textContent;
    } else {
      const style = dom26.getDoc(ctx).createElement("style");
      style.id = dom26.getGlobalCursorId(ctx);
      style.textContent = textContent;
      dom26.getDoc(ctx).head.appendChild(style);
    }
  },
  removeGlobalCursor(ctx) {
    var _a8;
    (_a8 = dom26.getById(ctx, dom26.getGlobalCursorId(ctx))) == null ? void 0 : _a8.remove();
  }
});
function validateSize(key, size3) {
  if (Math.floor(size3) > 100) {
    throw new Error(`Total ${key} of panels cannot be greater than 100`);
  }
}
function getNormalizedPanels(ctx) {
  let numOfPanelsWithoutSize = 0;
  let totalSize = 0;
  let totalMinSize = 0;
  const panels = ctx.size.map((panel) => {
    const minSize = panel.minSize ?? 0;
    const maxSize = panel.maxSize ?? 100;
    totalMinSize += minSize;
    if (panel.size == null) {
      numOfPanelsWithoutSize++;
    } else {
      totalSize += panel.size;
    }
    return {
      ...panel,
      minSize,
      maxSize
    };
  });
  validateSize("minSize", totalMinSize);
  validateSize("size", totalSize);
  let end = 0;
  let remainingSize = 0;
  const result = panels.map((panel) => {
    let start = end;
    if (panel.size != null) {
      end += panel.size;
      remainingSize = panel.size - panel.minSize;
      return {
        ...panel,
        start,
        end,
        remainingSize
      };
    }
    const size3 = (100 - totalSize) / numOfPanelsWithoutSize;
    end += size3;
    remainingSize = size3 - panel.minSize;
    return { ...panel, size: size3, start, end, remainingSize };
  });
  return result;
}
function getHandlePanels(ctx, id = ctx.activeResizeId) {
  const [beforeId, afterId] = (id == null ? void 0 : id.split(":")) ?? [];
  if (!beforeId || !afterId) return;
  const beforeIndex = ctx.previousPanels.findIndex((panel) => panel.id === beforeId);
  const afterIndex = ctx.previousPanels.findIndex((panel) => panel.id === afterId);
  if (beforeIndex === -1 || afterIndex === -1) return;
  const before = ctx.previousPanels[beforeIndex];
  const after = ctx.previousPanels[afterIndex];
  return {
    before: {
      ...before,
      index: beforeIndex
    },
    after: {
      ...after,
      index: afterIndex
    }
  };
}
function getHandleBounds(ctx, id = ctx.activeResizeId) {
  const panels = getHandlePanels(ctx, id);
  if (!panels) return;
  const { before, after } = panels;
  return {
    min: Math.max(before.start + before.minSize, after.end - after.maxSize),
    max: Math.min(after.end - after.minSize, before.maxSize + before.start)
  };
}
function getPanelBounds(ctx, id) {
  const bounds = getHandleBounds(ctx, id);
  const panels = getHandlePanels(ctx, id);
  if (!bounds || !panels) return;
  const { before, after } = panels;
  const beforeMin = Math.abs(before.start - bounds.min);
  const afterMin = after.size + (before.size - beforeMin);
  const beforeMax = Math.abs(before.start - bounds.max);
  const afterMax = after.size - (beforeMax - before.size);
  return {
    before: {
      index: before.index,
      min: beforeMin,
      max: beforeMax,
      isAtMin: beforeMin === before.size,
      isAtMax: beforeMax === before.size,
      up(step) {
        return Math.min(before.size + step, beforeMax);
      },
      down(step) {
        return Math.max(before.size - step, beforeMin);
      }
    },
    after: {
      index: after.index,
      min: afterMin,
      max: afterMax,
      isAtMin: afterMin === after.size,
      isAtMax: afterMax === after.size,
      up(step) {
        return Math.min(after.size + step, afterMin);
      },
      down(step) {
        return Math.max(after.size - step, afterMax);
      }
    }
  };
}
function clamp5(value, min4, max4) {
  return Math.min(Math.max(value, min4), max4);
}
function connect27(state2, send, normalize3) {
  const horizontal = state2.context.isHorizontal;
  const focused = state2.hasTag("focus");
  const dragging = state2.matches("dragging");
  const panels = state2.context.panels;
  function getResizeTriggerState(props210) {
    const { id, disabled } = props210;
    const ids = id.split(":");
    const panelIds = ids.map((id2) => dom26.getPanelId(state2.context, id2));
    const panels2 = getHandleBounds(state2.context, id);
    return {
      disabled: !!disabled,
      focused: state2.context.activeResizeId === id && focused,
      panelIds,
      min: panels2 == null ? void 0 : panels2.min,
      max: panels2 == null ? void 0 : panels2.max,
      value: 0
    };
  }
  return {
    focused,
    dragging,
    getResizeTriggerState,
    bounds: getHandleBounds(state2.context),
    setToMinSize(id) {
      const panel = panels.find((panel2) => panel2.id === id);
      send({ type: "SET_PANEL_SIZE", id, size: panel == null ? void 0 : panel.minSize, src: "setToMinSize" });
    },
    setToMaxSize(id) {
      const panel = panels.find((panel2) => panel2.id === id);
      send({ type: "SET_PANEL_SIZE", id, size: panel == null ? void 0 : panel.maxSize, src: "setToMaxSize" });
    },
    setSize(id, size3) {
      send({ type: "SET_PANEL_SIZE", id, size: size3 });
    },
    getRootProps() {
      return normalize3.element({
        ...parts29.root.attrs,
        "data-orientation": state2.context.orientation,
        id: dom26.getRootId(state2.context),
        dir: state2.context.dir,
        style: {
          display: "flex",
          flexDirection: horizontal ? "row" : "column",
          height: "100%",
          width: "100%",
          overflow: "hidden"
        }
      });
    },
    getPanelProps(props210) {
      const { id } = props210;
      return normalize3.element({
        ...parts29.panel.attrs,
        "data-orientation": state2.context.orientation,
        dir: state2.context.dir,
        id: dom26.getPanelId(state2.context, id),
        "data-ownedby": dom26.getRootId(state2.context),
        style: dom26.getPanelStyle(state2.context, id)
      });
    },
    getResizeTriggerProps(props210) {
      const { id, disabled, step = 1 } = props210;
      const triggerState = getResizeTriggerState(props210);
      return normalize3.element({
        ...parts29.resizeTrigger.attrs,
        dir: state2.context.dir,
        id: dom26.getResizeTriggerId(state2.context, id),
        role: "separator",
        "data-ownedby": dom26.getRootId(state2.context),
        tabIndex: disabled ? void 0 : 0,
        "aria-valuenow": triggerState.value,
        "aria-valuemin": triggerState.min,
        "aria-valuemax": triggerState.max,
        "data-orientation": state2.context.orientation,
        "aria-orientation": state2.context.orientation,
        "aria-controls": triggerState.panelIds.join(" "),
        "data-focus": dataAttr(triggerState.focused),
        "data-disabled": dataAttr(disabled),
        style: {
          touchAction: "none",
          userSelect: "none",
          WebkitUserSelect: "none",
          flex: "0 0 auto",
          pointerEvents: dragging && !triggerState.focused ? "none" : void 0,
          cursor: horizontal ? "col-resize" : "row-resize",
          [horizontal ? "minHeight" : "minWidth"]: "0"
        },
        onPointerDown(event) {
          if (disabled) {
            event.preventDefault();
            return;
          }
          send({ type: "POINTER_DOWN", id });
          event.currentTarget.setPointerCapture(event.pointerId);
          event.preventDefault();
          event.stopPropagation();
        },
        onPointerUp(event) {
          if (disabled) return;
          if (event.currentTarget.hasPointerCapture(event.pointerId)) {
            event.currentTarget.releasePointerCapture(event.pointerId);
          }
        },
        onPointerOver() {
          if (disabled) return;
          send({ type: "POINTER_OVER", id });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "POINTER_LEAVE", id });
        },
        onBlur() {
          send("BLUR");
        },
        onFocus() {
          send({ type: "FOCUS", id });
        },
        onDoubleClick() {
          if (disabled) return;
          send({ type: "DOUBLE_CLICK", id });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          const moveStep = getEventStep(event) * step;
          const keyMap2 = {
            Enter() {
              send("ENTER");
            },
            ArrowUp() {
              send({ type: "ARROW_UP", step: moveStep });
            },
            ArrowDown() {
              send({ type: "ARROW_DOWN", step: moveStep });
            },
            ArrowLeft() {
              send({ type: "ARROW_LEFT", step: moveStep });
            },
            ArrowRight() {
              send({ type: "ARROW_RIGHT", step: moveStep });
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        }
      });
    }
  };
}
function machine27(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "splitter",
      initial: "idle",
      context: {
        orientation: "horizontal",
        activeResizeId: null,
        previousPanels: [],
        size: [],
        initialSize: [],
        activeResizeState: {
          isAtMin: false,
          isAtMax: false
        },
        ...ctx
      },
      created: ["setPreviousPanels", "setInitialSize"],
      watch: {
        size: ["setActiveResizeState"]
      },
      computed: {
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        panels: (ctx2) => getNormalizedPanels(ctx2)
      },
      on: {
        SET_PANEL_SIZE: {
          actions: "setPanelSize"
        }
      },
      states: {
        idle: {
          entry: ["clearActiveHandleId"],
          on: {
            POINTER_OVER: {
              target: "hover:temp",
              actions: ["setActiveHandleId"]
            },
            FOCUS: {
              target: "focused",
              actions: ["setActiveHandleId"]
            },
            DOUBLE_CLICK: {
              actions: ["resetStartPanel", "setPreviousPanels"]
            }
          }
        },
        "hover:temp": {
          after: {
            HOVER_DELAY: "hover"
          },
          on: {
            POINTER_DOWN: {
              target: "dragging",
              actions: ["setActiveHandleId"]
            },
            POINTER_LEAVE: "idle"
          }
        },
        hover: {
          tags: ["focus"],
          on: {
            POINTER_DOWN: "dragging",
            POINTER_LEAVE: "idle"
          }
        },
        focused: {
          tags: ["focus"],
          on: {
            BLUR: "idle",
            POINTER_DOWN: {
              target: "dragging",
              actions: ["setActiveHandleId"]
            },
            ARROW_LEFT: {
              guard: "isHorizontal",
              actions: ["shrinkStartPanel", "setPreviousPanels"]
            },
            ARROW_RIGHT: {
              guard: "isHorizontal",
              actions: ["expandStartPanel", "setPreviousPanels"]
            },
            ARROW_UP: {
              guard: "isVertical",
              actions: ["shrinkStartPanel", "setPreviousPanels"]
            },
            ARROW_DOWN: {
              guard: "isVertical",
              actions: ["expandStartPanel", "setPreviousPanels"]
            },
            ENTER: [
              {
                guard: "isStartPanelAtMax",
                actions: ["setStartPanelToMin", "setPreviousPanels"]
              },
              { actions: ["setStartPanelToMax", "setPreviousPanels"] }
            ],
            HOME: {
              actions: ["setStartPanelToMin", "setPreviousPanels"]
            },
            END: {
              actions: ["setStartPanelToMax", "setPreviousPanels"]
            }
          }
        },
        dragging: {
          tags: ["focus"],
          entry: "focusResizeHandle",
          activities: ["trackPointerMove"],
          on: {
            POINTER_MOVE: {
              actions: ["setPointerValue", "setGlobalCursor", "invokeOnResize"]
            },
            POINTER_UP: {
              target: "focused",
              actions: ["setPreviousPanels", "clearGlobalCursor", "blurResizeHandle", "invokeOnResizeEnd"]
            }
          }
        }
      }
    },
    {
      activities: {
        trackPointerMove: (ctx2, _evt, { send }) => {
          const doc = dom26.getDoc(ctx2);
          return trackPointerMove(doc, {
            onPointerMove(info) {
              send({ type: "POINTER_MOVE", point: info.point });
            },
            onPointerUp() {
              send("POINTER_UP");
            }
          });
        }
      },
      guards: {
        isStartPanelAtMin: (ctx2) => ctx2.activeResizeState.isAtMin,
        isStartPanelAtMax: (ctx2) => ctx2.activeResizeState.isAtMax,
        isHorizontal: (ctx2) => ctx2.isHorizontal,
        isVertical: (ctx2) => !ctx2.isHorizontal
      },
      delays: {
        HOVER_DELAY: 250
      },
      actions: {
        setGlobalCursor(ctx2) {
          dom26.setupGlobalCursor(ctx2);
        },
        clearGlobalCursor(ctx2) {
          dom26.removeGlobalCursor(ctx2);
        },
        invokeOnResize(ctx2) {
          var _a8;
          (_a8 = ctx2.onSizeChange) == null ? void 0 : _a8.call(ctx2, { size: Array.from(ctx2.size), activeHandleId: ctx2.activeResizeId });
        },
        invokeOnResizeEnd(ctx2) {
          var _a8;
          (_a8 = ctx2.onSizeChangeEnd) == null ? void 0 : _a8.call(ctx2, { size: Array.from(ctx2.size), activeHandleId: ctx2.activeResizeId });
        },
        setActiveHandleId(ctx2, evt) {
          ctx2.activeResizeId = evt.id;
        },
        clearActiveHandleId(ctx2) {
          ctx2.activeResizeId = null;
        },
        setInitialSize(ctx2) {
          ctx2.initialSize = ctx2.panels.slice().map((panel) => ({
            id: panel.id,
            size: panel.size
          }));
        },
        setPanelSize(ctx2, evt) {
          const { id, size: size3 } = evt;
          ctx2.size = ctx2.size.map((panel) => {
            const panelSize = clamp5(size3, panel.minSize ?? 0, panel.maxSize ?? 100);
            return panel.id === id ? { ...panel, size: panelSize } : panel;
          });
        },
        setStartPanelToMin(ctx2) {
          const bounds = getPanelBounds(ctx2);
          if (!bounds) return;
          const { before, after } = bounds;
          ctx2.size[before.index].size = before.min;
          ctx2.size[after.index].size = after.min;
        },
        setStartPanelToMax(ctx2) {
          const bounds = getPanelBounds(ctx2);
          if (!bounds) return;
          const { before, after } = bounds;
          ctx2.size[before.index].size = before.max;
          ctx2.size[after.index].size = after.max;
        },
        expandStartPanel(ctx2, evt) {
          const bounds = getPanelBounds(ctx2);
          if (!bounds) return;
          const { before, after } = bounds;
          ctx2.size[before.index].size = before.up(evt.step);
          ctx2.size[after.index].size = after.down(evt.step);
        },
        shrinkStartPanel(ctx2, evt) {
          const bounds = getPanelBounds(ctx2);
          if (!bounds) return;
          const { before, after } = bounds;
          ctx2.size[before.index].size = before.down(evt.step);
          ctx2.size[after.index].size = after.up(evt.step);
        },
        resetStartPanel(ctx2, evt) {
          const bounds = getPanelBounds(ctx2, evt.id);
          if (!bounds) return;
          const { before, after } = bounds;
          ctx2.size[before.index].size = ctx2.initialSize[before.index].size;
          ctx2.size[after.index].size = ctx2.initialSize[after.index].size;
        },
        focusResizeHandle(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom26.getActiveHandleEl(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        blurResizeHandle(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom26.getActiveHandleEl(ctx2)) == null ? void 0 : _a8.blur();
          });
        },
        setPreviousPanels(ctx2) {
          ctx2.previousPanels = ctx2.panels.slice();
        },
        setActiveResizeState(ctx2) {
          const panels = getPanelBounds(ctx2);
          if (!panels) return;
          const { before } = panels;
          ctx2.activeResizeState = {
            isAtMin: before.isAtMin,
            isAtMax: before.isAtMax
          };
        },
        setPointerValue(ctx2, evt) {
          const panels = getHandlePanels(ctx2);
          const bounds = getHandleBounds(ctx2);
          if (!panels || !bounds) return;
          const rootEl = dom26.getRootEl(ctx2);
          if (!rootEl) return;
          const relativePoint = getRelativePoint(evt.point, rootEl);
          const percentValue = relativePoint.getPercentValue({
            dir: ctx2.dir,
            orientation: ctx2.orientation
          });
          let pointValue = percentValue * 100;
          ctx2.activeResizeState = {
            isAtMin: pointValue < bounds.min,
            isAtMax: pointValue > bounds.max
          };
          pointValue = clamp5(pointValue, bounds.min, bounds.max);
          const { before, after } = panels;
          const offset3 = pointValue - before.end;
          ctx2.size[before.index].size = before.size + offset3;
          ctx2.size[after.index].size = after.size - offset3;
        }
      }
    }
  );
}
var props23 = createProps()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onSizeChange",
  "onSizeChangeEnd",
  "orientation",
  "size"
]);
var splitProps23 = createSplitProps(props23);
var panelProps = createProps()(["id", "snapSize"]);
var splitPanelProps = createSplitProps(panelProps);
var resizeTriggerProps = createProps()(["disabled", "id", "step"]);
var splitResizeTriggerProps = createSplitProps(resizeTriggerProps);

// node_modules/@ark-ui/react/dist/components/splitter/use-splitter.js
var import_react660 = __toESM(require_react(), 1);
var useSplitter = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react660.useId)(),
    dir,
    getRootNode,
    size: props34.defaultSize,
    ...props34
  };
  const context = {
    ...initialContext,
    size: props34.size,
    onSizeChange: useEvent(props34.onSizeChange, { sync: true }),
    onSizeChangeEnd: useEvent(props34.onSizeChangeEnd)
  };
  const [state2, send] = useMachine(machine27(initialContext), { context });
  return connect27(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/splitter/splitter-root.js
var SplitterRoot = (0, import_react662.forwardRef)((props34, ref2) => {
  const [useSplitterProps, localProps] = createSplitProps2()(props34, [
    "defaultSize",
    "id",
    "ids",
    "onSizeChange",
    "onSizeChangeEnd",
    "orientation",
    "size"
  ]);
  const splitter = useSplitter(useSplitterProps);
  const mergedProps = mergeProps2(splitter.getRootProps(), localProps);
  return (0, import_jsx_runtime307.jsx)(SplitterProvider, { value: splitter, children: (0, import_jsx_runtime307.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
SplitterRoot.displayName = "SplitterRoot";

// node_modules/@ark-ui/react/dist/components/splitter/splitter-root-provider.js
var import_jsx_runtime308 = __toESM(require_jsx_runtime(), 1);
var import_react664 = __toESM(require_react(), 1);
var SplitterRootProvider = (0, import_react664.forwardRef)(
  (props34, ref2) => {
    const [{ value: splitter }, localProps] = createSplitProps2()(props34, [
      "value"
    ]);
    const mergedProps = mergeProps2(splitter.getRootProps(), localProps);
    return (0, import_jsx_runtime308.jsx)(SplitterProvider, { value: splitter, children: (0, import_jsx_runtime308.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
SplitterRootProvider.displayName = "SplitterRootProvider";

// node_modules/@ark-ui/react/dist/components/steps/steps-completed-content.js
var import_jsx_runtime309 = __toESM(require_jsx_runtime(), 1);
var import_react666 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/steps/use-steps-context.js
var [StepsProvider, useStepsContext] = createContext3({
  name: "StepsContext",
  hookName: "useStepsContext",
  providerName: "<StepsProvider />"
});

// node_modules/@ark-ui/react/dist/components/steps/steps-completed-content.js
var StepsCompletedContent = (0, import_react666.forwardRef)(
  (props34, ref2) => {
    const steps = useStepsContext();
    const mergedProps = mergeProps2(steps.getContentProps({ index: steps.count }), props34);
    return (0, import_jsx_runtime309.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
StepsCompletedContent.displayName = "StepsCompletedContent";

// node_modules/@ark-ui/react/dist/components/steps/steps-content.js
var import_jsx_runtime310 = __toESM(require_jsx_runtime(), 1);
var import_react668 = __toESM(require_react(), 1);
var StepsContent = (0, import_react668.forwardRef)((props34, ref2) => {
  const [itemProps12, localProps] = createSplitProps2()(props34, ["index"]);
  const steps = useStepsContext();
  const mergedProps = mergeProps2(steps.getContentProps(itemProps12), localProps);
  return (0, import_jsx_runtime310.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
StepsContent.displayName = "StepsContent";

// node_modules/@ark-ui/react/dist/components/steps/steps-context.js
var StepsContext = (props34) => {
  const context = useStepsContext();
  return props34.children(context);
};
StepsContext.displayName = "StepsContext";

// node_modules/@ark-ui/react/dist/components/steps/steps-indicator.js
var import_jsx_runtime311 = __toESM(require_jsx_runtime(), 1);
var import_react670 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/steps/use-steps-item-props-context.js
var [StepsItemPropsProvider, useStepsItemPropsContext] = createContext3({
  name: "StepsItemPropsContext",
  hookName: "useStepsItemPropsContext",
  providerName: "<StepsItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/steps/steps-indicator.js
var StepsIndicator = (0, import_react670.forwardRef)((props34, ref2) => {
  const steps = useStepsContext();
  const itemProps12 = useStepsItemPropsContext();
  const mergedProps = mergeProps2(steps.getIndicatorProps(itemProps12), props34);
  return (0, import_jsx_runtime311.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
StepsIndicator.displayName = "StepsIndicator";

// node_modules/@ark-ui/react/dist/components/steps/steps-item.js
var import_jsx_runtime312 = __toESM(require_jsx_runtime(), 1);
var import_react672 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/steps/use-steps-item-context.js
var [StepsItemProvider, useStepsItemContext] = createContext3({
  name: "StepsItemContext",
  hookName: "useStepsItemContext",
  providerName: "<StepsItem />"
});

// node_modules/@ark-ui/react/dist/components/steps/steps-item.js
var StepsItem = (0, import_react672.forwardRef)((props34, ref2) => {
  const [itemProps12, localProps] = createSplitProps2()(props34, ["index"]);
  const steps = useStepsContext();
  const mergedProps = mergeProps2(steps.getItemProps(itemProps12), localProps);
  const itemState = steps.getItemState(itemProps12);
  return (0, import_jsx_runtime312.jsx)(StepsItemPropsProvider, { value: itemProps12, children: (0, import_jsx_runtime312.jsx)(StepsItemProvider, { value: itemState, children: (0, import_jsx_runtime312.jsx)(ark.li, { ...mergedProps, ref: ref2 }) }) });
});
StepsItem.displayName = "StepsItem";

// node_modules/@ark-ui/react/dist/components/steps/steps-item-context.js
var StepsItemContext = (props34) => {
  return props34.children(useStepsItemContext());
};
StepsItemContext.displayName = "StepsItemContext";

// node_modules/@ark-ui/react/dist/components/steps/steps-list.js
var import_jsx_runtime313 = __toESM(require_jsx_runtime(), 1);
var import_react674 = __toESM(require_react(), 1);
var StepsList = (0, import_react674.forwardRef)((props34, ref2) => {
  const steps = useStepsContext();
  const mergedProps = mergeProps2(steps.getListProps(), props34);
  return (0, import_jsx_runtime313.jsx)(ark.ol, { ...mergedProps, ref: ref2 });
});
StepsList.displayName = "StepsList";

// node_modules/@ark-ui/react/dist/components/steps/steps-next-trigger.js
var import_jsx_runtime314 = __toESM(require_jsx_runtime(), 1);
var import_react676 = __toESM(require_react(), 1);
var StepsNextTrigger = (0, import_react676.forwardRef)(
  (props34, ref2) => {
    const steps = useStepsContext();
    const mergedProps = mergeProps2(steps.getNextTriggerProps(), props34);
    return (0, import_jsx_runtime314.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
StepsNextTrigger.displayName = "StepsNextTrigger";

// node_modules/@ark-ui/react/dist/components/steps/steps-prev-trigger.js
var import_jsx_runtime315 = __toESM(require_jsx_runtime(), 1);
var import_react678 = __toESM(require_react(), 1);
var StepsPrevTrigger = (0, import_react678.forwardRef)(
  (props34, ref2) => {
    const steps = useStepsContext();
    const mergedProps = mergeProps2(steps.getPrevTriggerProps(), props34);
    return (0, import_jsx_runtime315.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
StepsPrevTrigger.displayName = "StepsPrevTrigger";

// node_modules/@ark-ui/react/dist/components/steps/steps-progress.js
var import_jsx_runtime316 = __toESM(require_jsx_runtime(), 1);
var import_react680 = __toESM(require_react(), 1);
var StepsProgress = (0, import_react680.forwardRef)((props34, ref2) => {
  const steps = useStepsContext();
  const mergedProps = mergeProps2(steps.getProgressProps(), props34);
  return (0, import_jsx_runtime316.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
StepsProgress.displayName = "StepsProgress";

// node_modules/@ark-ui/react/dist/components/steps/steps-root.js
var import_jsx_runtime317 = __toESM(require_jsx_runtime(), 1);
var import_react684 = __toESM(require_react(), 1);

// node_modules/@zag-js/steps/dist/index.mjs
var anatomy27 = createAnatomy("steps").parts(
  "root",
  "list",
  "item",
  "trigger",
  "indicator",
  "separator",
  "content",
  "nextTrigger",
  "prevTrigger",
  "progress"
);
var parts30 = anatomy27.build();
var dom27 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `steps:${ctx.id}`;
  },
  getListId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.list) ?? `steps:${ctx.id}:list`;
  },
  getTriggerId: (ctx, index) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.triggerId) == null ? void 0 : _b7.call(_a8, index)) ?? `steps:${ctx.id}:trigger:${index}`;
  },
  getContentId: (ctx, index) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.contentId) == null ? void 0 : _b7.call(_a8, index)) ?? `steps:${ctx.id}:content:${index}`;
  }
});
function connect28(state2, send, normalize3) {
  const step = state2.context.step;
  const count = state2.context.count;
  const percent = state2.context.percent;
  const hasNextStep = state2.context.hasNextStep;
  const hasPrevStep = state2.context.hasPrevStep;
  const getItemState = (props210) => ({
    triggerId: dom27.getTriggerId(state2.context, props210.index),
    contentId: dom27.getContentId(state2.context, props210.index),
    current: props210.index === step,
    completed: props210.index < step,
    incomplete: props210.index > step,
    index: props210.index,
    first: props210.index === 0,
    last: props210.index === count - 1
  });
  const goToNextStep = () => {
    send({ type: "STEP.NEXT", src: "next.trigger.click" });
  };
  const goToPrevStep = () => {
    send({ type: "STEP.PREV", src: "prev.trigger.click" });
  };
  const resetStep = () => {
    send({ type: "STEP.RESET", src: "reset.trigger.click" });
  };
  const setStep = (value) => {
    send({ type: "STEP.SET", value, src: "api.setValue" });
  };
  return {
    value: step,
    count,
    percent,
    hasNextStep,
    hasPrevStep,
    isCompleted: state2.context.completed,
    goToNextStep,
    goToPrevStep,
    resetStep,
    getItemState,
    setStep,
    getRootProps() {
      return normalize3.element({
        ...parts30.root.attrs,
        id: dom27.getRootId(state2.context),
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        style: {
          "--percent": `${percent}%`
        }
      });
    },
    getListProps() {
      const arr = fromLength(state2.context.count);
      const triggerIds = arr.map((_, index) => dom27.getTriggerId(state2.context, index));
      return normalize3.element({
        ...parts30.list.attrs,
        dir: state2.context.dir,
        id: dom27.getListId(state2.context),
        role: "tablist",
        "aria-owns": triggerIds.join(" "),
        "aria-orientation": state2.context.orientation,
        "data-orientation": state2.context.orientation
      });
    },
    getItemProps(props210) {
      const itemState = getItemState(props210);
      return normalize3.element({
        ...parts30.item.attrs,
        dir: state2.context.dir,
        "aria-current": itemState.current ? "step" : void 0,
        "data-orientation": state2.context.orientation
      });
    },
    getTriggerProps(props210) {
      const itemState = getItemState(props210);
      return normalize3.button({
        ...parts30.trigger.attrs,
        id: itemState.triggerId,
        role: "tab",
        dir: state2.context.dir,
        tabIndex: !state2.context.linear || itemState.current ? 0 : -1,
        "aria-selected": itemState.current,
        "aria-controls": itemState.contentId,
        "data-state": itemState.current ? "open" : "closed",
        "data-orientation": state2.context.orientation,
        "data-complete": dataAttr(itemState.completed),
        "data-current": dataAttr(itemState.current),
        "data-incomplete": dataAttr(itemState.incomplete),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (state2.context.linear) return;
          send({ type: "STEP.SET", value: props210.index, src: "trigger.click" });
        }
      });
    },
    getContentProps(props210) {
      const itemState = getItemState(props210);
      return normalize3.element({
        ...parts30.content.attrs,
        dir: state2.context.dir,
        id: itemState.contentId,
        role: "tabpanel",
        tabIndex: 0,
        hidden: !itemState.current,
        "data-state": itemState.current ? "open" : "closed",
        "data-orientation": state2.context.orientation,
        "aria-labelledby": itemState.triggerId
      });
    },
    getIndicatorProps(props210) {
      const itemState = getItemState(props210);
      return normalize3.element({
        ...parts30.indicator.attrs,
        dir: state2.context.dir,
        "aria-hidden": true,
        "data-complete": dataAttr(itemState.completed),
        "data-current": dataAttr(itemState.current),
        "data-incomplete": dataAttr(itemState.incomplete)
      });
    },
    getSeparatorProps(props210) {
      const itemState = getItemState(props210);
      return normalize3.element({
        ...parts30.separator.attrs,
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        "data-complete": dataAttr(itemState.completed),
        "data-current": dataAttr(itemState.current),
        "data-incomplete": dataAttr(itemState.incomplete)
      });
    },
    getNextTriggerProps() {
      return normalize3.button({
        ...parts30.nextTrigger.attrs,
        dir: state2.context.dir,
        type: "button",
        disabled: !hasNextStep,
        onClick(event) {
          if (event.defaultPrevented) return;
          goToNextStep();
        }
      });
    },
    getPrevTriggerProps() {
      return normalize3.button({
        dir: state2.context.dir,
        ...parts30.prevTrigger.attrs,
        type: "button",
        disabled: !hasPrevStep,
        onClick(event) {
          if (event.defaultPrevented) return;
          goToPrevStep();
        }
      });
    },
    getProgressProps() {
      return normalize3.element({
        dir: state2.context.dir,
        ...parts30.progress.attrs,
        role: "progressbar",
        "aria-valuenow": percent,
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuetext": `${percent}% complete`,
        "data-complete": dataAttr(percent === 100)
      });
    }
  };
}
function machine28(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "steps",
      initial: "idle",
      context: {
        step: 0,
        count: 1,
        linear: false,
        orientation: "horizontal",
        ...ctx
      },
      computed: {
        percent: (ctx2) => ctx2.step / ctx2.count * 100,
        hasNextStep: (ctx2) => ctx2.step < ctx2.count,
        hasPrevStep: (ctx2) => ctx2.step > 0,
        completed: (ctx2) => ctx2.step === ctx2.count
      },
      states: {
        idle: {
          on: {
            "STEP.SET": {
              actions: "setStep"
            },
            "STEP.NEXT": {
              actions: "goToNextStep"
            },
            "STEP.PREV": {
              actions: "goToPrevStep"
            },
            "STEP.RESET": {
              actions: "resetStep"
            }
          }
        }
      }
    },
    {
      actions: {
        goToNextStep(ctx2) {
          const value = Math.min(ctx2.step + 1, ctx2.count);
          set21.value(ctx2, value);
        },
        goToPrevStep(ctx2) {
          const value = Math.max(ctx2.step - 1, 0);
          set21.value(ctx2, value);
        },
        resetStep(ctx2) {
          set21.value(ctx2, 0);
        },
        setStep(ctx2, evt) {
          set21.value(ctx2, evt.value);
        }
      }
    }
  );
}
var validateStep = (ctx, step) => {
  if (!isValueWithinRange(step, 0, ctx.count)) {
    throw new RangeError(`[zag-js/steps] step index ${step} is out of bounds`);
  }
};
var set21 = {
  value(ctx, step) {
    var _a8, _b7;
    if (isEqual(ctx.step, step)) return;
    validateStep(ctx, step);
    ctx.step = step;
    (_a8 = ctx.onStepChange) == null ? void 0 : _a8.call(ctx, { step });
    if (ctx.completed) {
      (_b7 = ctx.onStepComplete) == null ? void 0 : _b7.call(ctx);
    }
  }
};
var props24 = createProps()([
  "count",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "linear",
  "onStepChange",
  "onStepComplete",
  "orientation",
  "step"
]);
var splitProps24 = createSplitProps(props24);

// node_modules/@ark-ui/react/dist/components/steps/use-steps.js
var import_react682 = __toESM(require_react(), 1);
function useSteps(props34 = {}) {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react682.useId)(),
    dir,
    getRootNode,
    step: props34.defaultStep,
    ...props34
  };
  const context = {
    ...initialContext,
    step: props34.step,
    onStepChange: useEvent(props34.onStepChange),
    onStepComplete: useEvent(props34.onStepComplete)
  };
  const [state2, send] = useMachine(machine28(initialContext), {
    context
  });
  return connect28(state2, send, normalizeProps);
}

// node_modules/@ark-ui/react/dist/components/steps/steps-root.js
var StepsRoot = (0, import_react684.forwardRef)((props34, ref2) => {
  const [useStepsProps, localProps] = createSplitProps2()(props34, [
    "defaultStep",
    "id",
    "ids",
    "count",
    "linear",
    "onStepChange",
    "onStepComplete",
    "orientation",
    "step"
  ]);
  const steps = useSteps(useStepsProps);
  const mergedProps = mergeProps2(steps.getRootProps(), localProps);
  return (0, import_jsx_runtime317.jsx)(StepsProvider, { value: steps, children: (0, import_jsx_runtime317.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
StepsRoot.displayName = "StepsRoot";

// node_modules/@ark-ui/react/dist/components/steps/steps-root-provider.js
var import_jsx_runtime318 = __toESM(require_jsx_runtime(), 1);
var import_react686 = __toESM(require_react(), 1);
var StepsRootProvider = (0, import_react686.forwardRef)(
  (props34, ref2) => {
    const [{ value: steps }, rootProps] = createSplitProps2()(props34, ["value"]);
    const mergedProps = mergeProps2(steps.getRootProps(), rootProps);
    return (0, import_jsx_runtime318.jsx)(StepsProvider, { value: steps, children: (0, import_jsx_runtime318.jsx)(ark.div, { ...mergedProps, ref: ref2, children: props34.children }) });
  }
);
StepsRootProvider.displayName = "StepsRootProvider";

// node_modules/@ark-ui/react/dist/components/steps/steps-separator.js
var import_jsx_runtime319 = __toESM(require_jsx_runtime(), 1);
var import_react688 = __toESM(require_react(), 1);
var StepsSeparator = (0, import_react688.forwardRef)((props34, ref2) => {
  const steps = useStepsContext();
  const itemProps12 = useStepsItemPropsContext();
  const mergedProps = mergeProps2(steps.getSeparatorProps(itemProps12), props34);
  return (0, import_jsx_runtime319.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
StepsSeparator.displayName = "StepsSeparator";

// node_modules/@ark-ui/react/dist/components/steps/steps-trigger.js
var import_jsx_runtime320 = __toESM(require_jsx_runtime(), 1);
var import_react690 = __toESM(require_react(), 1);
var StepsTrigger = (0, import_react690.forwardRef)((props34, ref2) => {
  const steps = useStepsContext();
  const itemProps12 = useStepsItemPropsContext();
  const mergedProps = mergeProps2(steps.getTriggerProps(itemProps12), props34);
  return (0, import_jsx_runtime320.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
StepsTrigger.displayName = "StepsTrigger";

// node_modules/@ark-ui/react/dist/components/steps/steps.js
var steps_exports = {};
__export(steps_exports, {
  CompletedContent: () => StepsCompletedContent,
  Content: () => StepsContent,
  Context: () => StepsContext,
  Indicator: () => StepsIndicator,
  Item: () => StepsItem,
  ItemContext: () => StepsItemContext,
  List: () => StepsList,
  NextTrigger: () => StepsNextTrigger,
  PrevTrigger: () => StepsPrevTrigger,
  Progress: () => StepsProgress,
  Root: () => StepsRoot,
  RootProvider: () => StepsRootProvider,
  Separator: () => StepsSeparator,
  Trigger: () => StepsTrigger
});

// node_modules/@ark-ui/react/dist/components/switch/use-switch-context.js
var [SwitchProvider, useSwitchContext] = createContext3({
  name: "SwitchContext",
  hookName: "useSwitchContext",
  providerName: "<SwitchProvider />"
});

// node_modules/@ark-ui/react/dist/components/switch/switch-context.js
var SwitchContext = (props34) => props34.children(useSwitchContext());

// node_modules/@ark-ui/react/dist/components/switch/switch-control.js
var import_jsx_runtime321 = __toESM(require_jsx_runtime(), 1);
var import_react692 = __toESM(require_react(), 1);
var SwitchControl = (0, import_react692.forwardRef)((props34, ref2) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps2(switchContext.getControlProps(), props34);
  return (0, import_jsx_runtime321.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
SwitchControl.displayName = "SwitchControl";

// node_modules/@ark-ui/react/dist/components/switch/switch-hidden-input.js
var import_jsx_runtime322 = __toESM(require_jsx_runtime(), 1);
var import_react694 = __toESM(require_react(), 1);
var SwitchHiddenInput = (0, import_react694.forwardRef)(
  (props34, ref2) => {
    const switchContext = useSwitchContext();
    const mergedProps = mergeProps2(switchContext.getHiddenInputProps(), props34);
    const field = useFieldContext();
    return (0, import_jsx_runtime322.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
SwitchHiddenInput.displayName = "SwitchHiddenInput";

// node_modules/@ark-ui/react/dist/components/switch/switch-label.js
var import_jsx_runtime323 = __toESM(require_jsx_runtime(), 1);
var import_react696 = __toESM(require_react(), 1);
var SwitchLabel = (0, import_react696.forwardRef)((props34, ref2) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps2(switchContext.getLabelProps(), props34);
  return (0, import_jsx_runtime323.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
SwitchLabel.displayName = "SwitchLabel";

// node_modules/@ark-ui/react/dist/components/switch/switch-root.js
var import_jsx_runtime324 = __toESM(require_jsx_runtime(), 1);
var import_react700 = __toESM(require_react(), 1);

// node_modules/@zag-js/switch/dist/index.mjs
var anatomy28 = createAnatomy("switch").parts("root", "label", "control", "thumb");
var parts31 = anatomy28.build();
var dom28 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `switch:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `switch:${ctx.id}:label`;
  },
  getThumbId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.thumb) ?? `switch:${ctx.id}:thumb`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `switch:${ctx.id}:control`;
  },
  getHiddenInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `switch:${ctx.id}:input`;
  },
  getRootEl: (ctx) => dom28.getById(ctx, dom28.getRootId(ctx)),
  getHiddenInputEl: (ctx) => dom28.getById(ctx, dom28.getHiddenInputId(ctx))
});
function connect29(state2, send, normalize3) {
  const disabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  const checked = state2.context.checked;
  const focused = !disabled && state2.context.focused;
  const focusVisible = !disabled && state2.context.focusVisible;
  const dataAttrs = {
    "data-active": dataAttr(state2.context.active),
    "data-focus": dataAttr(focused),
    "data-focus-visible": dataAttr(focusVisible),
    "data-readonly": dataAttr(readOnly),
    "data-hover": dataAttr(state2.context.hovered),
    "data-disabled": dataAttr(disabled),
    "data-state": state2.context.checked ? "checked" : "unchecked",
    "data-invalid": dataAttr(state2.context.invalid)
  };
  return {
    checked,
    disabled,
    focused,
    setChecked(checked2) {
      send({ type: "CHECKED.SET", checked: checked2, isTrusted: false });
    },
    toggleChecked() {
      send({ type: "CHECKED.TOGGLE", checked, isTrusted: false });
    },
    getRootProps() {
      return normalize3.label({
        ...parts31.root.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom28.getRootId(state2.context),
        htmlFor: dom28.getHiddenInputId(state2.context),
        onPointerMove() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: true } });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: false } });
        },
        onClick(event) {
          if (disabled) return;
          const target = getEventTarget(event);
          if (target === dom28.getHiddenInputEl(state2.context)) {
            event.stopPropagation();
          }
        }
      });
    },
    getLabelProps() {
      return normalize3.element({
        ...parts31.label.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom28.getLabelId(state2.context)
      });
    },
    getThumbProps() {
      return normalize3.element({
        ...parts31.thumb.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom28.getThumbId(state2.context),
        "aria-hidden": true
      });
    },
    getControlProps() {
      return normalize3.element({
        ...parts31.control.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom28.getControlId(state2.context),
        "aria-hidden": true
      });
    },
    getHiddenInputProps() {
      return normalize3.input({
        id: dom28.getHiddenInputId(state2.context),
        type: "checkbox",
        required: state2.context.required,
        defaultChecked: checked,
        disabled,
        "aria-labelledby": dom28.getLabelId(state2.context),
        "aria-invalid": state2.context.invalid,
        name: state2.context.name,
        form: state2.context.form,
        value: state2.context.value,
        style: visuallyHiddenStyle,
        onFocus() {
          const focusVisible2 = isFocusVisible();
          send({ type: "CONTEXT.SET", context: { focused: true, focusVisible: focusVisible2 } });
        },
        onBlur() {
          send({ type: "CONTEXT.SET", context: { focused: false, focusVisible: false } });
        },
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          const checked2 = event.currentTarget.checked;
          send({ type: "CHECKED.SET", checked: checked2, isTrusted: true });
        }
      });
    }
  };
}
var { not: not10 } = guards;
function machine29(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "switch",
      initial: "ready",
      context: {
        checked: false,
        label: "switch",
        value: "on",
        disabled: false,
        ...ctx,
        fieldsetDisabled: false,
        focusVisible: false
      },
      computed: {
        isDisabled: (ctx2) => ctx2.disabled || ctx2.fieldsetDisabled
      },
      watch: {
        disabled: "removeFocusIfNeeded",
        checked: "syncInputElement"
      },
      activities: ["trackFormControlState", "trackPressEvent", "trackFocusVisible"],
      on: {
        "CHECKED.TOGGLE": [
          {
            guard: not10("isTrusted"),
            actions: ["toggleChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["toggleChecked"]
          }
        ],
        "CHECKED.SET": [
          {
            guard: not10("isTrusted"),
            actions: ["setChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["setChecked"]
          }
        ],
        "CONTEXT.SET": {
          actions: ["setContext"]
        }
      },
      states: {
        ready: {}
      }
    },
    {
      guards: {
        isTrusted: (_ctx, evt) => !!evt.isTrusted
      },
      activities: {
        trackPressEvent(ctx2) {
          if (ctx2.isDisabled) return;
          return trackPress({
            pointerNode: dom28.getRootEl(ctx2),
            keyboardNode: dom28.getHiddenInputEl(ctx2),
            isValidKey: (event) => event.key === " ",
            onPress: () => ctx2.active = false,
            onPressStart: () => ctx2.active = true,
            onPressEnd: () => ctx2.active = false
          });
        },
        trackFocusVisible(ctx2) {
          if (ctx2.isDisabled) return;
          return trackFocusVisible({ root: dom28.getRootNode(ctx2) });
        },
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl(dom28.getHiddenInputEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "CHECKED.SET", checked: !!initialContext.checked, src: "form-reset" });
            }
          });
        }
      },
      actions: {
        setContext(ctx2, evt) {
          Object.assign(ctx2, evt.context);
        },
        syncInputElement(ctx2) {
          const inputEl = dom28.getHiddenInputEl(ctx2);
          if (!inputEl) return;
          inputEl.checked = !!ctx2.checked;
        },
        removeFocusIfNeeded(ctx2) {
          if (ctx2.disabled && ctx2.focused) {
            ctx2.focused = false;
          }
        },
        setChecked(ctx2, evt) {
          set22.checked(ctx2, evt.checked);
        },
        toggleChecked(ctx2, _evt) {
          set22.checked(ctx2, !ctx2.checked);
        },
        dispatchChangeEvent(ctx2) {
          const inputEl = dom28.getHiddenInputEl(ctx2);
          dispatchInputCheckedEvent(inputEl, { checked: ctx2.checked });
        }
      }
    }
  );
}
var invoke15 = {
  change: (ctx) => {
    var _a8;
    (_a8 = ctx.onCheckedChange) == null ? void 0 : _a8.call(ctx, { checked: ctx.checked });
  }
};
var set22 = {
  checked: (ctx, checked) => {
    if (isEqual(ctx.checked, checked)) return;
    ctx.checked = checked;
    invoke15.change(ctx);
  }
};
var props25 = createProps()([
  "checked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "label",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
var splitProps25 = createSplitProps(props25);

// node_modules/@ark-ui/react/dist/components/switch/use-switch.js
var import_react698 = __toESM(require_react(), 1);
var useSwitch = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react698.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    invalid: field == null ? void 0 : field.invalid,
    required: field == null ? void 0 : field.required,
    getRootNode,
    checked: props34.defaultChecked,
    ...props34
  };
  const context = {
    ...initialContext,
    checked: props34.checked,
    onCheckedChange: useEvent(props34.onCheckedChange, { sync: true })
  };
  const [state2, send] = useMachine(machine29(initialContext), { context });
  return connect29(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/switch/switch-root.js
var SwitchRoot = (0, import_react700.forwardRef)((props34, ref2) => {
  const [switchProps, localProps] = createSplitProps2()(props34, [
    "checked",
    "defaultChecked",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "label",
    "name",
    "onCheckedChange",
    "readOnly",
    "required",
    "value"
  ]);
  const switchContext = useSwitch(switchProps);
  const mergedProps = mergeProps2(switchContext.getRootProps(), localProps);
  return (0, import_jsx_runtime324.jsx)(SwitchProvider, { value: switchContext, children: (0, import_jsx_runtime324.jsx)(ark.label, { ...mergedProps, ref: ref2 }) });
});
SwitchRoot.displayName = "SwitchRoot";

// node_modules/@ark-ui/react/dist/components/switch/switch-root-provider.js
var import_jsx_runtime325 = __toESM(require_jsx_runtime(), 1);
var import_react702 = __toESM(require_react(), 1);
var SwitchRootProvider = (0, import_react702.forwardRef)(
  (props34, ref2) => {
    const [{ value: api }, localProps] = createSplitProps2()(props34, ["value"]);
    const mergedProps = mergeProps2(api.getRootProps(), localProps);
    return (0, import_jsx_runtime325.jsx)(SwitchProvider, { value: api, children: (0, import_jsx_runtime325.jsx)(ark.label, { ...mergedProps, ref: ref2 }) });
  }
);
SwitchRootProvider.displayName = "SwitchRootProvider";

// node_modules/@ark-ui/react/dist/components/switch/switch-thumb.js
var import_jsx_runtime326 = __toESM(require_jsx_runtime(), 1);
var import_react704 = __toESM(require_react(), 1);
var SwitchThumb = (0, import_react704.forwardRef)((props34, ref2) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps2(switchContext.getThumbProps(), props34);
  return (0, import_jsx_runtime326.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
SwitchThumb.displayName = "SwitchThumb";

// node_modules/@ark-ui/react/dist/components/switch/switch.js
var switch_exports = {};
__export(switch_exports, {
  Context: () => SwitchContext,
  Control: () => SwitchControl,
  HiddenInput: () => SwitchHiddenInput,
  Label: () => SwitchLabel,
  Root: () => SwitchRoot,
  RootProvider: () => SwitchRootProvider,
  Thumb: () => SwitchThumb
});

// node_modules/@ark-ui/react/dist/components/tabs/tab-content.js
var import_jsx_runtime327 = __toESM(require_jsx_runtime(), 1);
var import_react707 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/use-debounce.js
var import_react705 = __toESM(require_react(), 1);
function useDebounce(value, delay2) {
  const [debouncedValue, setDebouncedValue] = (0, import_react705.useState)(value);
  (0, import_react705.useEffect)(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay2);
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay2]);
  return debouncedValue;
}

// node_modules/@ark-ui/react/dist/components/tabs/use-tabs-context.js
var [TabsProvider, useTabsContext] = createContext3({
  name: "TabsContext",
  hookName: "useTabsContext",
  providerName: "<TabsProvider />"
});

// node_modules/@ark-ui/react/dist/components/tabs/tab-content.js
var TabContent = (0, import_react707.forwardRef)((props34, ref2) => {
  const [contentProps2, localProps] = createSplitProps2()(props34, ["value"]);
  const tabs = useTabsContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const presence = usePresence({
    ...renderStrategyProps,
    present: useDebounce(tabs.value === props34.value, 0),
    immediate: true
  });
  const mergedProps = mergeProps2(
    tabs.getContentProps(contentProps2),
    presence.getPresenceProps(),
    localProps
  );
  return (0, import_jsx_runtime327.jsx)(PresenceProvider, { value: presence, children: presence.unmounted ? null : (0, import_jsx_runtime327.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) }) });
});
TabContent.displayName = "TabContent";

// node_modules/@ark-ui/react/dist/components/tabs/tab-indicator.js
var import_jsx_runtime328 = __toESM(require_jsx_runtime(), 1);
var import_react709 = __toESM(require_react(), 1);
var TabIndicator = (0, import_react709.forwardRef)((props34, ref2) => {
  const tabs = useTabsContext();
  const mergedProps = mergeProps2(tabs.getIndicatorProps(), props34);
  return (0, import_jsx_runtime328.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TabIndicator.displayName = "TabIndicator";

// node_modules/@ark-ui/react/dist/components/tabs/tab-list.js
var import_jsx_runtime329 = __toESM(require_jsx_runtime(), 1);
var import_react711 = __toESM(require_react(), 1);
var TabList = (0, import_react711.forwardRef)((props34, ref2) => {
  const tabs = useTabsContext();
  const mergedProps = mergeProps2(tabs.getListProps(), props34);
  return (0, import_jsx_runtime329.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TabList.displayName = "TabList";

// node_modules/@ark-ui/react/dist/components/tabs/tab-trigger.js
var import_jsx_runtime330 = __toESM(require_jsx_runtime(), 1);
var import_react713 = __toESM(require_react(), 1);
var TabTrigger = (0, import_react713.forwardRef)((props34, ref2) => {
  const [tabProps, localProps] = createSplitProps2()(props34, ["disabled", "value"]);
  const tabs = useTabsContext();
  const mergedProps = mergeProps2(tabs.getTriggerProps(tabProps), localProps);
  return (0, import_jsx_runtime330.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
TabTrigger.displayName = "TabTrigger";

// node_modules/@ark-ui/react/dist/components/tabs/tabs-context.js
var TabsContext = (props34) => props34.children(useTabsContext());

// node_modules/@ark-ui/react/dist/components/tabs/tabs-root.js
var import_jsx_runtime331 = __toESM(require_jsx_runtime(), 1);
var import_react717 = __toESM(require_react(), 1);

// node_modules/@zag-js/tabs/dist/index.mjs
var anatomy29 = createAnatomy("tabs").parts("root", "list", "trigger", "content", "indicator");
var parts32 = anatomy29.build();
var dom29 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `tabs:${ctx.id}`;
  },
  getListId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.list) ?? `tabs:${ctx.id}:list`;
  },
  getContentId: (ctx, id) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `tabs:${ctx.id}:content-${id}`;
  },
  getTriggerId: (ctx, id) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `tabs:${ctx.id}:trigger-${id}`;
  },
  getIndicatorId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.indicator) ?? `tabs:${ctx.id}:indicator`;
  },
  getListEl: (ctx) => dom29.getById(ctx, dom29.getListId(ctx)),
  getContentEl: (ctx, id) => dom29.getById(ctx, dom29.getContentId(ctx, id)),
  getTriggerEl: (ctx, id) => dom29.getById(ctx, dom29.getTriggerId(ctx, id)),
  getIndicatorEl: (ctx) => dom29.getById(ctx, dom29.getIndicatorId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom29.getListId(ctx));
    const selector = `[role=tab][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom29.getListEl(ctx), selector);
  },
  getFirstTriggerEl: (ctx) => first(dom29.getElements(ctx)),
  getLastTriggerEl: (ctx) => last(dom29.getElements(ctx)),
  getNextTriggerEl: (ctx, id) => nextById(dom29.getElements(ctx), dom29.getTriggerId(ctx, id), ctx.loopFocus),
  getPrevTriggerEl: (ctx, id) => prevById(dom29.getElements(ctx), dom29.getTriggerId(ctx, id), ctx.loopFocus),
  getSelectedContentEl: (ctx) => {
    if (!ctx.value) return;
    return dom29.getContentEl(ctx, ctx.value);
  },
  getSelectedTriggerEl: (ctx) => {
    if (!ctx.value) return;
    return dom29.getTriggerEl(ctx, ctx.value);
  },
  getOffsetRect: (el) => {
    return {
      left: (el == null ? void 0 : el.offsetLeft) ?? 0,
      top: (el == null ? void 0 : el.offsetTop) ?? 0,
      width: (el == null ? void 0 : el.offsetWidth) ?? 0,
      height: (el == null ? void 0 : el.offsetHeight) ?? 0
    };
  },
  getRectById: (ctx, id) => {
    const tab = itemById(dom29.getElements(ctx), dom29.getTriggerId(ctx, id));
    return dom29.resolveRect(dom29.getOffsetRect(tab));
  },
  resolveRect: (rect) => ({
    width: `${rect.width}px`,
    height: `${rect.height}px`,
    left: `${rect.left}px`,
    top: `${rect.top}px`
  })
});
function connect30(state2, send, normalize3) {
  const translations = state2.context.translations;
  const focused = state2.matches("focused");
  const isVertical = state2.context.orientation === "vertical";
  const isHorizontal = state2.context.orientation === "horizontal";
  const composite = state2.context.composite;
  const indicator = state2.context.indicatorState;
  function getTriggerState(props210) {
    return {
      selected: state2.context.value === props210.value,
      focused: state2.context.focusedValue === props210.value,
      disabled: !!props210.disabled
    };
  }
  return {
    value: state2.context.value,
    focusedValue: state2.context.focusedValue,
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    clearValue() {
      send({ type: "CLEAR_VALUE" });
    },
    setIndicatorRect(value) {
      const id = dom29.getTriggerId(state2.context, value);
      send({ type: "SET_INDICATOR_RECT", id });
    },
    syncTabIndex() {
      send("SYNC_TAB_INDEX");
    },
    selectNext(fromValue) {
      send({ type: "TAB_FOCUS", value: fromValue, src: "selectNext" });
      send({ type: "ARROW_NEXT", src: "selectNext" });
    },
    selectPrev(fromValue) {
      send({ type: "TAB_FOCUS", value: fromValue, src: "selectPrev" });
      send({ type: "ARROW_PREV", src: "selectPrev" });
    },
    focus() {
      var _a8;
      (_a8 = dom29.getSelectedTriggerEl(state2.context)) == null ? void 0 : _a8.focus();
    },
    getRootProps() {
      return normalize3.element({
        ...parts32.root.attrs,
        id: dom29.getRootId(state2.context),
        "data-orientation": state2.context.orientation,
        "data-focus": dataAttr(focused),
        dir: state2.context.dir
      });
    },
    getListProps() {
      return normalize3.element({
        ...parts32.list.attrs,
        id: dom29.getListId(state2.context),
        role: "tablist",
        dir: state2.context.dir,
        "data-focus": dataAttr(focused),
        "aria-orientation": state2.context.orientation,
        "data-orientation": state2.context.orientation,
        "aria-label": translations == null ? void 0 : translations.listLabel,
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!isSelfTarget(event)) return;
          if (isComposingEvent(event)) return;
          const keyMap2 = {
            ArrowDown() {
              if (isHorizontal) return;
              send({ type: "ARROW_NEXT", key: "ArrowDown" });
            },
            ArrowUp() {
              if (isHorizontal) return;
              send({ type: "ARROW_PREV", key: "ArrowUp" });
            },
            ArrowLeft() {
              if (isVertical) return;
              send({ type: "ARROW_PREV", key: "ArrowLeft" });
            },
            ArrowRight() {
              if (isVertical) return;
              send({ type: "ARROW_NEXT", key: "ArrowRight" });
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            },
            Enter() {
              send({ type: "ENTER" });
            }
          };
          let key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            event.preventDefault();
            exec2(event);
          }
        }
      });
    },
    getTriggerState,
    getTriggerProps(props210) {
      const { value, disabled } = props210;
      const triggerState = getTriggerState(props210);
      return normalize3.button({
        ...parts32.trigger.attrs,
        role: "tab",
        type: "button",
        disabled,
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        "data-disabled": dataAttr(disabled),
        "aria-disabled": disabled,
        "data-value": value,
        "aria-selected": triggerState.selected,
        "data-selected": dataAttr(triggerState.selected),
        "data-focus": dataAttr(triggerState.focused),
        "aria-controls": triggerState.selected ? dom29.getContentId(state2.context, value) : void 0,
        "data-ownedby": dom29.getListId(state2.context),
        "data-ssr": dataAttr(state2.context.ssr),
        id: dom29.getTriggerId(state2.context, value),
        tabIndex: triggerState.selected && composite ? 0 : -1,
        onFocus() {
          send({ type: "TAB_FOCUS", value });
        },
        onBlur(event) {
          const target = event.relatedTarget;
          if ((target == null ? void 0 : target.getAttribute("role")) !== "tab") {
            send({ type: "TAB_BLUR" });
          }
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (isSafari()) {
            event.currentTarget.focus();
          }
          send({ type: "TAB_CLICK", value });
        }
      });
    },
    getContentProps(props210) {
      const { value } = props210;
      const selected = state2.context.value === value;
      return normalize3.element({
        ...parts32.content.attrs,
        dir: state2.context.dir,
        id: dom29.getContentId(state2.context, value),
        tabIndex: composite ? 0 : -1,
        "aria-labelledby": dom29.getTriggerId(state2.context, value),
        role: "tabpanel",
        "data-ownedby": dom29.getListId(state2.context),
        "data-selected": dataAttr(selected),
        "data-orientation": state2.context.orientation,
        hidden: !selected
      });
    },
    getIndicatorProps() {
      var _a8, _b7, _c6, _d6;
      return normalize3.element({
        id: dom29.getIndicatorId(state2.context),
        ...parts32.indicator.attrs,
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        style: {
          "--transition-property": "left, right, top, bottom, width, height",
          "--left": (_a8 = indicator.rect) == null ? void 0 : _a8.left,
          "--top": (_b7 = indicator.rect) == null ? void 0 : _b7.top,
          "--width": (_c6 = indicator.rect) == null ? void 0 : _c6.width,
          "--height": (_d6 = indicator.rect) == null ? void 0 : _d6.height,
          position: "absolute",
          willChange: "var(--transition-property)",
          transitionProperty: "var(--transition-property)",
          transitionDuration: indicator.transition ? "var(--transition-duration, 150ms)" : "0ms",
          transitionTimingFunction: "var(--transition-timing-function)",
          [isHorizontal ? "left" : "top"]: isHorizontal ? "var(--left)" : "var(--top)"
        }
      });
    }
  };
}
var { not: not11 } = guards;
function machine30(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      initial: "idle",
      context: {
        dir: "ltr",
        orientation: "horizontal",
        activationMode: "automatic",
        value: null,
        loopFocus: true,
        composite: true,
        navigate(details) {
          clickIfLink(details.node);
        },
        ...ctx,
        focusedValue: ctx.value ?? null,
        ssr: true,
        indicatorState: {
          rendered: false,
          transition: false,
          rect: { left: "0px", top: "0px", width: "0px", height: "0px" }
        }
      },
      watch: {
        value: ["allowIndicatorTransition", "syncIndicatorRect", "syncTabIndex", "navigateIfNeeded"],
        dir: ["syncIndicatorRect"],
        orientation: ["syncIndicatorRect"]
      },
      on: {
        SET_VALUE: {
          actions: "setValue"
        },
        CLEAR_VALUE: {
          actions: "clearValue"
        },
        SET_INDICATOR_RECT: {
          actions: "setIndicatorRect"
        },
        SYNC_TAB_INDEX: {
          actions: "syncTabIndex"
        }
      },
      created: ["syncFocusedValue"],
      entry: ["checkRenderedElements", "syncIndicatorRect", "syncTabIndex", "syncSsr"],
      exit: ["cleanupObserver"],
      states: {
        idle: {
          on: {
            TAB_FOCUS: {
              target: "focused",
              actions: "setFocusedValue"
            },
            TAB_CLICK: {
              target: "focused",
              actions: ["setFocusedValue", "setValue"]
            }
          }
        },
        focused: {
          on: {
            TAB_CLICK: {
              target: "focused",
              actions: ["setFocusedValue", "setValue"]
            },
            ARROW_PREV: [
              {
                guard: "selectOnFocus",
                actions: ["focusPrevTab", "selectFocusedTab"]
              },
              {
                actions: "focusPrevTab"
              }
            ],
            ARROW_NEXT: [
              {
                guard: "selectOnFocus",
                actions: ["focusNextTab", "selectFocusedTab"]
              },
              {
                actions: "focusNextTab"
              }
            ],
            HOME: [
              {
                guard: "selectOnFocus",
                actions: ["focusFirstTab", "selectFocusedTab"]
              },
              {
                actions: "focusFirstTab"
              }
            ],
            END: [
              {
                guard: "selectOnFocus",
                actions: ["focusLastTab", "selectFocusedTab"]
              },
              {
                actions: "focusLastTab"
              }
            ],
            ENTER: {
              guard: not11("selectOnFocus"),
              actions: "selectFocusedTab"
            },
            TAB_FOCUS: {
              actions: ["setFocusedValue"]
            },
            TAB_BLUR: {
              target: "idle",
              actions: "clearFocusedValue"
            }
          }
        }
      }
    },
    {
      guards: {
        selectOnFocus: (ctx2) => ctx2.activationMode === "automatic"
      },
      actions: {
        syncFocusedValue(ctx2) {
          if (ctx2.value != null && ctx2.focusedValue == null) {
            ctx2.focusedValue = ctx2.value;
          }
        },
        selectFocusedTab(ctx2) {
          raf(() => {
            const nullable = ctx2.deselectable && ctx2.value === ctx2.focusedValue;
            const value = nullable ? null : ctx2.focusedValue;
            set23.value(ctx2, value);
          });
        },
        setFocusedValue(ctx2, evt) {
          if (evt.value == null) return;
          set23.focusedValue(ctx2, evt.value);
        },
        clearFocusedValue(ctx2) {
          set23.focusedValue(ctx2, null);
        },
        setValue(ctx2, evt) {
          const nullable = ctx2.deselectable && ctx2.value === ctx2.focusedValue;
          const value = nullable ? null : evt.value;
          set23.value(ctx2, value);
        },
        clearValue(ctx2) {
          set23.value(ctx2, null);
        },
        focusFirstTab(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom29.getFirstTriggerEl(ctx2)) == null ? void 0 : _a8.focus();
          });
        },
        focusLastTab(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom29.getLastTriggerEl(ctx2)) == null ? void 0 : _a8.focus();
          });
        },
        focusNextTab(ctx2) {
          if (!ctx2.focusedValue) return;
          const triggerEl = dom29.getNextTriggerEl(ctx2, ctx2.focusedValue);
          raf(() => {
            if (ctx2.composite) {
              triggerEl == null ? void 0 : triggerEl.focus();
            } else if ((triggerEl == null ? void 0 : triggerEl.dataset.value) != null) {
              set23.focusedValue(ctx2, triggerEl.dataset.value);
            }
          });
        },
        focusPrevTab(ctx2) {
          if (!ctx2.focusedValue) return;
          const triggerEl = dom29.getPrevTriggerEl(ctx2, ctx2.focusedValue);
          raf(() => {
            if (ctx2.composite) {
              triggerEl == null ? void 0 : triggerEl.focus();
            } else if ((triggerEl == null ? void 0 : triggerEl.dataset.value) != null) {
              set23.focusedValue(ctx2, triggerEl.dataset.value);
            }
          });
        },
        checkRenderedElements(ctx2) {
          ctx2.indicatorState.rendered = !!dom29.getIndicatorEl(ctx2);
        },
        syncTabIndex(ctx2) {
          raf(() => {
            const contentEl = dom29.getSelectedContentEl(ctx2);
            if (!contentEl) return;
            const focusables = getFocusables(contentEl);
            if (focusables.length > 0) {
              contentEl.removeAttribute("tabindex");
            } else {
              contentEl.setAttribute("tabindex", "0");
            }
          });
        },
        cleanupObserver(ctx2) {
          var _a8;
          (_a8 = ctx2.indicatorCleanup) == null ? void 0 : _a8.call(ctx2);
        },
        allowIndicatorTransition(ctx2) {
          ctx2.indicatorState.transition = true;
        },
        setIndicatorRect(ctx2, evt) {
          const value = evt.id ?? ctx2.value;
          if (!ctx2.indicatorState.rendered || !value) return;
          const triggerEl = dom29.getTriggerEl(ctx2, value);
          if (!triggerEl) return;
          ctx2.indicatorState.rect = dom29.getRectById(ctx2, value);
          nextTick(() => {
            ctx2.indicatorState.transition = false;
          });
        },
        syncSsr(ctx2) {
          ctx2.ssr = false;
        },
        syncIndicatorRect(ctx2) {
          var _a8;
          (_a8 = ctx2.indicatorCleanup) == null ? void 0 : _a8.call(ctx2);
          const value = ctx2.value;
          if (!ctx2.indicatorState.rendered || !value) return;
          const triggerEl = dom29.getSelectedTriggerEl(ctx2);
          if (!triggerEl) return;
          ctx2.indicatorCleanup = trackElementRect(triggerEl, {
            getRect(el) {
              return dom29.getOffsetRect(el);
            },
            onChange(rect) {
              ctx2.indicatorState.rect = dom29.resolveRect(rect);
              nextTick(() => {
                ctx2.indicatorState.transition = false;
              });
            }
          });
        },
        navigateIfNeeded(ctx2) {
          const triggerEl = dom29.getSelectedTriggerEl(ctx2);
          if (!isAnchorElement(triggerEl)) return;
          ctx2.navigate({ value: ctx2.value, node: triggerEl });
        }
      }
    }
  );
}
var invoke16 = {
  change: (ctx) => {
    var _a8;
    if (ctx.value == null) return;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value: ctx.value });
  },
  focusChange: (ctx) => {
    var _a8;
    if (ctx.focusedValue == null) return;
    (_a8 = ctx.onFocusChange) == null ? void 0 : _a8.call(ctx, { focusedValue: ctx.focusedValue });
  }
};
var set23 = {
  value: (ctx, value) => {
    if (isEqual(value, ctx.value)) return;
    ctx.value = value;
    invoke16.change(ctx);
  },
  focusedValue: (ctx, value) => {
    if (isEqual(value, ctx.focusedValue)) return;
    ctx.focusedValue = value;
    invoke16.focusChange(ctx);
  }
};
var props26 = createProps()([
  "activationMode",
  "composite",
  "deselectable",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "loopFocus",
  "navigate",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "translations",
  "value"
]);
var splitProps26 = createSplitProps(props26);
var triggerProps = createProps()(["disabled", "value"]);
var splitTriggerProps = createSplitProps(triggerProps);
var contentProps = createProps()(["value"]);
var splitContentProps = createSplitProps(contentProps);

// node_modules/@ark-ui/react/dist/components/tabs/use-tabs.js
var import_react715 = __toESM(require_react(), 1);
var useTabs = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react715.useId)(),
    dir,
    getRootNode,
    value: props34.defaultValue,
    ...props34
  };
  const context = {
    ...initialContext,
    value: props34.value,
    onValueChange: useEvent(props34.onValueChange, { sync: true }),
    onFocusChange: useEvent(props34.onFocusChange)
  };
  const [state2, send] = useMachine(machine30(initialContext), { context });
  return connect30(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/tabs/tabs-root.js
var TabsRoot = (0, import_react717.forwardRef)((props34, ref2) => {
  const [renderStrategyProps, tabsProps] = splitRenderStrategyProps(props34);
  const [useTabsProps, localprops] = createSplitProps2()(tabsProps, [
    "activationMode",
    "composite",
    "defaultValue",
    "deselectable",
    "id",
    "ids",
    "loopFocus",
    "navigate",
    "onFocusChange",
    "onValueChange",
    "orientation",
    "translations",
    "value"
  ]);
  const tabs = useTabs(useTabsProps);
  const mergedProps = mergeProps2(tabs.getRootProps(), localprops);
  return (0, import_jsx_runtime331.jsx)(TabsProvider, { value: tabs, children: (0, import_jsx_runtime331.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime331.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
TabsRoot.displayName = "TabsRoot";

// node_modules/@ark-ui/react/dist/components/tabs/tabs-root-provider.js
var import_jsx_runtime332 = __toESM(require_jsx_runtime(), 1);
var import_react719 = __toESM(require_react(), 1);
var TabsRootProvider = (0, import_react719.forwardRef)((props34, ref2) => {
  const [renderStrategyProps, tabsProps] = splitRenderStrategyProps(props34);
  const [{ value: tabs }, localprops] = createSplitProps2()(tabsProps, ["value"]);
  const mergedProps = mergeProps2(tabs.getRootProps(), localprops);
  return (0, import_jsx_runtime332.jsx)(TabsProvider, { value: tabs, children: (0, import_jsx_runtime332.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime332.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
TabsRootProvider.displayName = "TabsRootProvider";

// node_modules/@ark-ui/react/dist/components/tabs/tabs.js
var tabs_exports = {};
__export(tabs_exports, {
  Content: () => TabContent,
  Context: () => TabsContext,
  Indicator: () => TabIndicator,
  List: () => TabList,
  Root: () => TabsRoot,
  RootProvider: () => TabsRootProvider,
  Trigger: () => TabTrigger
});

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-clear-trigger.js
var import_jsx_runtime333 = __toESM(require_jsx_runtime(), 1);
var import_react721 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tags-input/use-tags-input-context.js
var [TagsInputProvider, useTagsInputContext] = createContext3({
  name: "TagsInputContext",
  hookName: "useTagsInputContext",
  providerName: "<TagsInputProvider />"
});

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-clear-trigger.js
var TagsInputClearTrigger = (0, import_react721.forwardRef)(
  (props34, ref2) => {
    const tagsInput = useTagsInputContext();
    const mergedProps = mergeProps2(tagsInput.getClearTriggerProps(), props34);
    return (0, import_jsx_runtime333.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
TagsInputClearTrigger.displayName = "TagsInputClearTrigger";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-control.js
var import_jsx_runtime334 = __toESM(require_jsx_runtime(), 1);
var import_react723 = __toESM(require_react(), 1);
var TagsInputControl = (0, import_react723.forwardRef)((props34, ref2) => {
  const tagsInput = useTagsInputContext();
  const mergedProps = mergeProps2(tagsInput.getControlProps(), props34);
  return (0, import_jsx_runtime334.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TagsInputControl.displayName = "TagsInputControl";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-hidden-input.js
var import_jsx_runtime335 = __toESM(require_jsx_runtime(), 1);
var import_react725 = __toESM(require_react(), 1);
var TagsInputHiddenInput = (0, import_react725.forwardRef)(
  (props34, ref2) => {
    const tagsInput = useTagsInputContext();
    const mergedProps = mergeProps2(tagsInput.getHiddenInputProps(), props34);
    const field = useFieldContext();
    return (0, import_jsx_runtime335.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
TagsInputHiddenInput.displayName = "TagsInputHiddenInput";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-input.js
var import_jsx_runtime336 = __toESM(require_jsx_runtime(), 1);
var import_react727 = __toESM(require_react(), 1);
var TagsInputInput = (0, import_react727.forwardRef)((props34, ref2) => {
  const tagsInput = useTagsInputContext();
  const mergedProps = mergeProps2(tagsInput.getInputProps(), props34);
  return (0, import_jsx_runtime336.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
TagsInputInput.displayName = "TagsInputInput";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-item.js
var import_jsx_runtime337 = __toESM(require_jsx_runtime(), 1);
var import_react729 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tags-input/use-tags-input-item-context.js
var [TagsInputItemProvider, useTagsInputItemContext] = createContext3({
  name: "TagsInputItemContext",
  hookName: "useTagsInputItemContext",
  providerName: "<TagsInputItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/tags-input/use-tags-input-item-props-context.js
var [TagsInputItemPropsProvider, useTagsInputItemPropsContext] = createContext3({
  name: "TagsInputItemPropsContext",
  hookName: "useTagsInputItemPropsContext",
  providerName: "<TagsInputItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-item.js
var TagsInputItem = (0, import_react729.forwardRef)((props34, ref2) => {
  const [itemProps12, localProps] = createSplitProps2()(props34, [
    "index",
    "disabled",
    "value"
  ]);
  const tagsInput = useTagsInputContext();
  const mergedProps = mergeProps2(tagsInput.getItemProps(itemProps12), localProps);
  const tagsInputItem = tagsInput.getItemState(itemProps12);
  return (0, import_jsx_runtime337.jsx)(TagsInputItemPropsProvider, { value: itemProps12, children: (0, import_jsx_runtime337.jsx)(TagsInputItemProvider, { value: tagsInputItem, children: (0, import_jsx_runtime337.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
TagsInputItem.displayName = "TagsInputItem";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-item-delete-trigger.js
var import_jsx_runtime338 = __toESM(require_jsx_runtime(), 1);
var import_react731 = __toESM(require_react(), 1);
var TagsInputItemDeleteTrigger = (0, import_react731.forwardRef)((props34, ref2) => {
  const tagsInput = useTagsInputContext();
  const itemProps12 = useTagsInputItemPropsContext();
  const mergedProps = mergeProps2(tagsInput.getItemDeleteTriggerProps(itemProps12), props34);
  return (0, import_jsx_runtime338.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
TagsInputItemDeleteTrigger.displayName = "TagsInputItemDeleteTrigger";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-item-input.js
var import_jsx_runtime339 = __toESM(require_jsx_runtime(), 1);
var import_react733 = __toESM(require_react(), 1);
var TagsInputItemInput = (0, import_react733.forwardRef)(
  (props34, ref2) => {
    const tagsInput = useTagsInputContext();
    const itemProps12 = useTagsInputItemPropsContext();
    const mergedProps = mergeProps2(tagsInput.getItemInputProps(itemProps12), props34);
    return (0, import_jsx_runtime339.jsx)(ark.input, { ...mergedProps, ref: ref2 });
  }
);
TagsInputItemInput.displayName = "TagsInputItemInput";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-item-preview.js
var import_jsx_runtime340 = __toESM(require_jsx_runtime(), 1);
var import_react735 = __toESM(require_react(), 1);
var TagsInputItemPreview = (0, import_react735.forwardRef)(
  (props34, ref2) => {
    const tagsInput = useTagsInputContext();
    const itemProps12 = useTagsInputItemPropsContext();
    const mergedProps = mergeProps2(tagsInput.getItemPreviewProps(itemProps12), props34);
    return (0, import_jsx_runtime340.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
TagsInputItemPreview.displayName = "TagsInputItemPreview";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-item-text.js
var import_jsx_runtime341 = __toESM(require_jsx_runtime(), 1);
var import_react737 = __toESM(require_react(), 1);
var TagsInputItemText = (0, import_react737.forwardRef)(
  (props34, ref2) => {
    const tagsInput = useTagsInputContext();
    const itemProps12 = useTagsInputItemPropsContext();
    const mergedProps = mergeProps2(tagsInput.getItemTextProps(itemProps12), props34);
    return (0, import_jsx_runtime341.jsx)(ark.span, { ...mergedProps, ref: ref2 });
  }
);
TagsInputItemText.displayName = "TagsInputItemText";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-label.js
var import_jsx_runtime342 = __toESM(require_jsx_runtime(), 1);
var import_react739 = __toESM(require_react(), 1);
var TagsInputLabel = (0, import_react739.forwardRef)((props34, ref2) => {
  const tagsInput = useTagsInputContext();
  const mergedProps = mergeProps2(tagsInput.getLabelProps(), props34);
  return (0, import_jsx_runtime342.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
TagsInputLabel.displayName = "TagsInputLabel";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-root.js
var import_jsx_runtime343 = __toESM(require_jsx_runtime(), 1);
var import_react743 = __toESM(require_react(), 1);

// node_modules/@zag-js/tags-input/dist/index.mjs
var anatomy30 = createAnatomy("tagsInput").parts(
  "root",
  "label",
  "control",
  "input",
  "clearTrigger",
  "item",
  "itemPreview",
  "itemInput",
  "itemText",
  "itemDeleteTrigger"
);
var parts33 = anatomy30.build();
var dom30 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `tags-input:${ctx.id}`;
  },
  getInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.input) ?? `tags-input:${ctx.id}:input`;
  },
  getClearTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.clearBtn) ?? `tags-input:${ctx.id}:clear-btn`;
  },
  getHiddenInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `tags-input:${ctx.id}:hidden-input`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `tags-input:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `tags-input:${ctx.id}:control`;
  },
  getItemId: (ctx, opt) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, opt)) ?? `tags-input:${ctx.id}:tag:${opt.value}:${opt.index}`;
  },
  getItemDeleteTriggerId: (ctx, opt) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemDeleteTrigger) == null ? void 0 : _b7.call(_a8, opt)) ?? `${dom30.getItemId(ctx, opt)}:delete-btn`;
  },
  getItemInputId: (ctx, opt) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemInput) == null ? void 0 : _b7.call(_a8, opt)) ?? `${dom30.getItemId(ctx, opt)}:input`;
  },
  getEditInputId: (ctx) => `${ctx.editedTagId}:input`,
  getTagInputEl: (ctx, opt) => dom30.getById(ctx, dom30.getItemInputId(ctx, opt)),
  getRootEl: (ctx) => dom30.getById(ctx, dom30.getRootId(ctx)),
  getInputEl: (ctx) => dom30.getById(ctx, dom30.getInputId(ctx)),
  getHiddenInputEl: (ctx) => dom30.getById(ctx, dom30.getHiddenInputId(ctx)),
  getEditInputEl: (ctx) => dom30.getById(ctx, dom30.getEditInputId(ctx)),
  getTagElements: (ctx) => queryAll(dom30.getRootEl(ctx), `[data-part=item-preview]:not([data-disabled])`),
  getFirstEl: (ctx) => dom30.getTagElements(ctx)[0],
  getLastEl: (ctx) => dom30.getTagElements(ctx)[dom30.getTagElements(ctx).length - 1],
  getPrevEl: (ctx, id) => prevById(dom30.getTagElements(ctx), id, false),
  getNextEl: (ctx, id) => nextById(dom30.getTagElements(ctx), id, false),
  getTagElAtIndex: (ctx, index) => dom30.getTagElements(ctx)[index],
  getIndexOfId: (ctx, id) => indexOfId(dom30.getTagElements(ctx), id),
  isInputFocused: (ctx) => dom30.getDoc(ctx).activeElement === dom30.getInputEl(ctx),
  getHighlightedTagValue: (ctx) => {
    if (!ctx.highlightedTagId) return null;
    const tagEl = dom30.getById(ctx, ctx.highlightedTagId);
    return (tagEl == null ? void 0 : tagEl.dataset.value) ?? null;
  },
  setHoverIntent: (el) => {
    const tagEl = el.closest("[data-part=item-preview]");
    if (!tagEl) return;
    tagEl.dataset.deleteIntent = "";
  },
  clearHoverIntent: (el) => {
    const tagEl = el.closest("[data-part=item-preview]");
    if (!tagEl) return;
    delete tagEl.dataset.deleteIntent;
  },
  dispatchInputEvent(ctx) {
    const inputEl = dom30.getHiddenInputEl(ctx);
    if (!inputEl) return;
    dispatchInputValueEvent(inputEl, { value: ctx.valueAsString });
  }
});
function connect31(state2, send, normalize3) {
  const interactive = state2.context.isInteractive;
  const disabled = state2.context.disabled;
  const readOnly = state2.context.readOnly;
  const invalid = state2.context.invalid || state2.context.isOverflowing;
  const translations = state2.context.translations;
  const focused = state2.hasTag("focused");
  const editingTag = state2.matches("editing:tag");
  const empty2 = state2.context.count === 0;
  function getItemState(options) {
    const id = dom30.getItemId(state2.context, options);
    return {
      id,
      editing: editingTag && state2.context.editedTagId === id,
      highlighted: id === state2.context.highlightedTagId,
      disabled: Boolean(options.disabled || disabled)
    };
  }
  return {
    empty: empty2,
    inputValue: state2.context.trimmedInputValue,
    value: state2.context.value,
    valueAsString: state2.context.valueAsString,
    count: state2.context.count,
    atMax: state2.context.isAtMax,
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    clearValue(id) {
      if (id) {
        send({ type: "CLEAR_TAG", id });
      } else {
        send("CLEAR_VALUE");
      }
    },
    addValue(value) {
      send({ type: "ADD_TAG", value });
    },
    setValueAtIndex(index, value) {
      send({ type: "SET_VALUE_AT_INDEX", index, value });
    },
    setInputValue(value) {
      send({ type: "SET_INPUT_VALUE", value });
    },
    clearInputValue() {
      send({ type: "SET_INPUT_VALUE", value: "" });
    },
    focus() {
      var _a8;
      (_a8 = dom30.getInputEl(state2.context)) == null ? void 0 : _a8.focus();
    },
    getItemState,
    getRootProps() {
      return normalize3.element({
        dir: state2.context.dir,
        ...parts33.root.attrs,
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused),
        "data-empty": dataAttr(empty2),
        id: dom30.getRootId(state2.context),
        onPointerDown() {
          if (!interactive) return;
          send("POINTER_DOWN");
        }
      });
    },
    getLabelProps() {
      return normalize3.label({
        ...parts33.label.attrs,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        id: dom30.getLabelId(state2.context),
        dir: state2.context.dir,
        htmlFor: dom30.getInputId(state2.context)
      });
    },
    getControlProps() {
      return normalize3.element({
        id: dom30.getControlId(state2.context),
        ...parts33.control.attrs,
        dir: state2.context.dir,
        tabIndex: readOnly ? 0 : void 0,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused)
      });
    },
    getInputProps() {
      return normalize3.input({
        ...parts33.input.attrs,
        dir: state2.context.dir,
        "data-invalid": dataAttr(invalid),
        "aria-invalid": ariaAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        maxLength: state2.context.maxLength,
        id: dom30.getInputId(state2.context),
        defaultValue: state2.context.inputValue,
        autoComplete: "off",
        autoCorrect: "off",
        autoCapitalize: "none",
        disabled: disabled || readOnly,
        onInput(event) {
          const evt = getNativeEvent(event);
          const value = event.currentTarget.value;
          if (evt.inputType === "insertFromPaste") {
            send({ type: "PASTE", value });
            return;
          }
          if (endsWith(value, state2.context.delimiter)) {
            send("DELIMITER_KEY");
            return;
          }
          send({ type: "TYPE", value, key: evt.inputType });
        },
        onFocus() {
          send("FOCUS");
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          const target = event.currentTarget;
          const isCombobox = target.getAttribute("role") === "combobox";
          const isExpanded = target.ariaExpanded === "true";
          const keyMap2 = {
            ArrowDown() {
              send("ARROW_DOWN");
            },
            ArrowLeft() {
              if (isCombobox && isExpanded) return;
              send("ARROW_LEFT");
            },
            ArrowRight(event2) {
              if (state2.context.highlightedTagId) {
                event2.preventDefault();
              }
              if (isCombobox && isExpanded) return;
              send("ARROW_RIGHT");
            },
            Escape(event2) {
              event2.preventDefault();
              send("ESCAPE");
            },
            Backspace() {
              send("BACKSPACE");
            },
            Delete() {
              send("DELETE");
            },
            Enter(event2) {
              if (isCombobox && isExpanded) return;
              send("ENTER");
              event2.preventDefault();
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            exec2(event);
            return;
          }
        }
      });
    },
    getHiddenInputProps() {
      return normalize3.input({
        type: "text",
        hidden: true,
        name: state2.context.name,
        form: state2.context.form,
        disabled,
        readOnly,
        required: state2.context.required,
        id: dom30.getHiddenInputId(state2.context),
        defaultValue: state2.context.valueAsString
      });
    },
    getItemProps(props210) {
      return normalize3.element({
        ...parts33.item.attrs,
        dir: state2.context.dir,
        "data-value": props210.value,
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemPreviewProps(props210) {
      const itemState = getItemState(props210);
      return normalize3.element({
        ...parts33.itemPreview.attrs,
        id: itemState.id,
        dir: state2.context.dir,
        hidden: itemState.editing,
        "data-value": props210.value,
        "data-disabled": dataAttr(disabled),
        "data-highlighted": dataAttr(itemState.highlighted),
        onPointerDown(event) {
          if (!interactive || itemState.disabled) return;
          event.preventDefault();
          send({ type: "POINTER_DOWN_TAG", id: itemState.id });
        },
        onDoubleClick() {
          if (!interactive || itemState.disabled) return;
          send({ type: "DOUBLE_CLICK_TAG", id: itemState.id });
        }
      });
    },
    getItemTextProps(props210) {
      const itemState = getItemState(props210);
      return normalize3.element({
        ...parts33.itemText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-highlighted": dataAttr(itemState.highlighted)
      });
    },
    getItemInputProps(props210) {
      const itemState = getItemState(props210);
      return normalize3.input({
        ...parts33.itemInput.attrs,
        dir: state2.context.dir,
        "aria-label": translations.tagEdited(props210.value),
        "aria-hidden": true,
        disabled,
        id: dom30.getItemInputId(state2.context, props210),
        tabIndex: -1,
        hidden: !itemState.editing,
        defaultValue: itemState.editing ? state2.context.editedTagValue : "",
        onInput(event) {
          send({ type: "TAG_INPUT_TYPE", value: event.currentTarget.value });
        },
        onBlur(event) {
          send({ type: "TAG_INPUT_BLUR", target: event.relatedTarget, id: itemState.id });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          const keyMap2 = {
            Enter() {
              send("TAG_INPUT_ENTER");
            },
            Escape() {
              send("TAG_INPUT_ESCAPE");
            }
          };
          const exec2 = keyMap2[event.key];
          if (exec2) {
            event.preventDefault();
            exec2(event);
          }
        }
      });
    },
    getItemDeleteTriggerProps(props210) {
      const id = dom30.getItemId(state2.context, props210);
      return normalize3.button({
        ...parts33.itemDeleteTrigger.attrs,
        dir: state2.context.dir,
        id: dom30.getItemDeleteTriggerId(state2.context, props210),
        type: "button",
        disabled,
        "aria-label": translations.deleteTagTriggerLabel(props210.value),
        tabIndex: -1,
        onPointerDown(event) {
          if (!interactive) {
            event.preventDefault();
          }
        },
        onPointerMove(event) {
          if (!interactive) return;
          dom30.setHoverIntent(event.currentTarget);
        },
        onPointerLeave(event) {
          if (!interactive) return;
          dom30.clearHoverIntent(event.currentTarget);
        },
        onClick() {
          if (!interactive) return;
          send({ type: "CLICK_DELETE_TAG", id });
        }
      });
    },
    getClearTriggerProps() {
      return normalize3.button({
        ...parts33.clearTrigger.attrs,
        dir: state2.context.dir,
        id: dom30.getClearTriggerId(state2.context),
        type: "button",
        "data-readonly": dataAttr(readOnly),
        disabled,
        "aria-label": translations.clearTriggerLabel,
        hidden: empty2,
        onClick() {
          if (!interactive) return;
          send("CLEAR_VALUE");
        }
      });
    }
  };
}
function endsWith(str, del) {
  if (!del) return false;
  if (typeof del === "string") return str.endsWith(del);
  return new RegExp(`${del.source}$`).test(str);
}
var { and: and10, not: not12, or: or4 } = guards;
function machine31(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "tags-input",
      initial: ctx.autoFocus ? "focused:input" : "idle",
      context: {
        inputValue: "",
        editedTagValue: "",
        editedTagId: null,
        highlightedTagId: null,
        value: [],
        dir: "ltr",
        max: Infinity,
        blurBehavior: void 0,
        addOnPaste: false,
        editable: true,
        validate: () => true,
        delimiter: ",",
        disabled: false,
        readOnly: false,
        ...ctx,
        liveRegion: null,
        log: { current: null, prev: null },
        fieldsetDisabled: false,
        translations: {
          clearTriggerLabel: "Clear all tags",
          deleteTagTriggerLabel: (value) => `Delete tag ${value}`,
          tagAdded: (value) => `Added tag ${value}`,
          tagsPasted: (values) => `Pasted ${values.length} tags`,
          tagEdited: (value) => `Editing tag ${value}. Press enter to save or escape to cancel.`,
          tagUpdated: (value) => `Tag update to ${value}`,
          tagDeleted: (value) => `Tag ${value} deleted`,
          tagSelected: (value) => `Tag ${value} selected. Press enter to edit, delete or backspace to remove.`,
          ...ctx.translations
        }
      },
      computed: {
        count: (ctx2) => ctx2.value.length,
        valueAsString: (ctx2) => JSON.stringify(ctx2.value),
        trimmedInputValue: (ctx2) => ctx2.inputValue.trim(),
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.readOnly || ctx2.isDisabled),
        isAtMax: (ctx2) => ctx2.count === ctx2.max,
        isOverflowing: (ctx2) => ctx2.count > ctx2.max
      },
      watch: {
        highlightedTagId: "logHighlightedTag",
        isOverflowing: "invokeOnInvalid",
        log: "announceLog",
        inputValue: "syncInputValue",
        editedTagValue: "syncEditedTagInputValue"
      },
      activities: ["trackLiveRegion", "trackFormControlState"],
      exit: ["clearLog"],
      on: {
        DOUBLE_CLICK_TAG: {
          internal: true,
          guard: "isTagEditable",
          target: "editing:tag",
          actions: ["setEditedId", "initializeEditedTagValue"]
        },
        POINTER_DOWN_TAG: {
          internal: true,
          target: "navigating:tag",
          actions: ["highlightTag", "focusInput"]
        },
        CLICK_DELETE_TAG: {
          target: "focused:input",
          actions: ["deleteTag"]
        },
        SET_INPUT_VALUE: {
          actions: ["setInputValue"]
        },
        SET_VALUE: {
          actions: ["setValue"]
        },
        CLEAR_TAG: {
          actions: ["deleteTag"]
        },
        SET_VALUE_AT_INDEX: {
          actions: ["setValueAtIndex"]
        },
        CLEAR_VALUE: {
          actions: ["clearTags", "clearInputValue", "focusInput"]
        },
        ADD_TAG: {
          actions: ["addTag"]
        },
        INSERT_TAG: {
          // (!isAtMax || allowOverflow) && !inputValueIsEmpty
          guard: and10(or4(not12("isAtMax"), "allowOverflow"), not12("isInputValueEmpty")),
          actions: ["addTag", "clearInputValue"]
        },
        EXTERNAL_BLUR: [
          { guard: "addOnBlur", actions: "raiseInsertTagEvent" },
          { guard: "clearOnBlur", actions: "clearInputValue" }
        ]
      },
      states: {
        idle: {
          on: {
            FOCUS: "focused:input",
            POINTER_DOWN: {
              guard: not12("hasHighlightedTag"),
              target: "focused:input"
            }
          }
        },
        "focused:input": {
          tags: ["focused"],
          entry: ["focusInput", "clearHighlightedId"],
          activities: ["trackInteractOutside"],
          on: {
            TYPE: {
              actions: "setInputValue"
            },
            BLUR: [
              {
                guard: "addOnBlur",
                target: "idle",
                actions: "raiseInsertTagEvent"
              },
              {
                guard: "clearOnBlur",
                target: "idle",
                actions: "clearInputValue"
              },
              { target: "idle" }
            ],
            ENTER: {
              actions: ["raiseInsertTagEvent"]
            },
            DELIMITER_KEY: {
              actions: ["raiseInsertTagEvent"]
            },
            ARROW_LEFT: {
              guard: and10("hasTags", "isInputCaretAtStart"),
              target: "navigating:tag",
              actions: "highlightLastTag"
            },
            BACKSPACE: {
              target: "navigating:tag",
              guard: and10("hasTags", "isInputCaretAtStart"),
              actions: "highlightLastTag"
            },
            DELETE: {
              guard: "hasHighlightedTag",
              actions: ["deleteHighlightedTag", "highlightTagAtIndex"]
            },
            PASTE: [
              {
                guard: "addOnPaste",
                actions: ["setInputValue", "addTagFromPaste"]
              },
              {
                actions: "setInputValue"
              }
            ]
          }
        },
        "navigating:tag": {
          tags: ["focused"],
          activities: ["trackInteractOutside"],
          on: {
            ARROW_RIGHT: [
              {
                guard: and10("hasTags", "isInputCaretAtStart", not12("isLastTagHighlighted")),
                actions: "highlightNextTag"
              },
              { target: "focused:input" }
            ],
            ARROW_LEFT: {
              actions: "highlightPrevTag"
            },
            BLUR: {
              target: "idle",
              actions: "clearHighlightedId"
            },
            ENTER: {
              guard: and10("isTagEditable", "hasHighlightedTag"),
              target: "editing:tag",
              actions: ["setEditedId", "initializeEditedTagValue", "focusEditedTagInput"]
            },
            ARROW_DOWN: "focused:input",
            ESCAPE: "focused:input",
            TYPE: {
              target: "focused:input",
              actions: "setInputValue"
            },
            BACKSPACE: [
              {
                guard: "isFirstTagHighlighted",
                actions: ["deleteHighlightedTag", "highlightFirstTag"]
              },
              {
                guard: "hasHighlightedTag",
                actions: ["deleteHighlightedTag", "highlightPrevTag"]
              },
              {
                actions: ["highlightLastTag"]
              }
            ],
            DELETE: {
              target: "focused:input",
              actions: ["deleteHighlightedTag", "highlightTagAtIndex"]
            },
            PASTE: [
              {
                guard: "addOnPaste",
                target: "focused:input",
                actions: ["setInputValue", "addTagFromPaste"]
              },
              {
                target: "focused:input",
                actions: "setInputValue"
              }
            ]
          }
        },
        "editing:tag": {
          tags: ["editing", "focused"],
          entry: "focusEditedTagInput",
          activities: ["autoResize"],
          on: {
            TAG_INPUT_TYPE: {
              actions: "setEditedTagValue"
            },
            TAG_INPUT_ESCAPE: {
              target: "navigating:tag",
              actions: ["clearEditedTagValue", "focusInput", "clearEditedId", "highlightTagAtIndex"]
            },
            TAG_INPUT_BLUR: [
              {
                guard: "isInputRelatedTarget",
                target: "navigating:tag",
                actions: ["clearEditedTagValue", "clearHighlightedId", "clearEditedId"]
              },
              {
                target: "idle",
                actions: ["clearEditedTagValue", "clearHighlightedId", "clearEditedId", "raiseExternalBlurEvent"]
              }
            ],
            TAG_INPUT_ENTER: [
              {
                guard: "isEditedTagEmpty",
                target: "navigating:tag",
                actions: ["deleteHighlightedTag", "focusInput", "clearEditedId", "highlightTagAtIndex"]
              },
              {
                target: "navigating:tag",
                actions: ["submitEditedTagValue", "focusInput", "clearEditedId", "highlightTagAtIndex"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isInputRelatedTarget: (ctx2, evt) => evt.relatedTarget === dom30.getInputEl(ctx2),
        isAtMax: (ctx2) => ctx2.isAtMax,
        hasHighlightedTag: (ctx2) => ctx2.highlightedTagId !== null,
        isFirstTagHighlighted: (ctx2) => {
          const firstItemId = dom30.getItemId(ctx2, { value: ctx2.value[0], index: 0 });
          return firstItemId === ctx2.highlightedTagId;
        },
        isEditedTagEmpty: (ctx2) => ctx2.editedTagValue.trim() === "",
        isLastTagHighlighted: (ctx2) => {
          const lastIndex = ctx2.value.length - 1;
          const lastItemId = dom30.getItemId(ctx2, { value: ctx2.value[lastIndex], index: lastIndex });
          return lastItemId === ctx2.highlightedTagId;
        },
        isInputValueEmpty: (ctx2) => ctx2.trimmedInputValue.length === 0,
        hasTags: (ctx2) => ctx2.value.length > 0,
        allowOverflow: (ctx2) => !!ctx2.allowOverflow,
        autoFocus: (ctx2) => !!ctx2.autoFocus,
        addOnBlur: (ctx2) => ctx2.blurBehavior === "add",
        clearOnBlur: (ctx2) => ctx2.blurBehavior === "clear",
        addOnPaste: (ctx2) => !!ctx2.addOnPaste,
        isTagEditable: (ctx2) => !!ctx2.editable,
        isInputCaretAtStart(ctx2) {
          const input = dom30.getInputEl(ctx2);
          if (!input) return false;
          try {
            return input.selectionStart === 0 && input.selectionEnd === 0;
          } catch {
            return input.value === "";
          }
        }
      },
      activities: {
        trackInteractOutside(ctx2, _evt, { send }) {
          return trackInteractOutside(dom30.getInputEl(ctx2), {
            exclude(target) {
              return contains(dom30.getRootEl(ctx2), target);
            },
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onInteractOutside(event) {
              var _a8;
              (_a8 = ctx2.onInteractOutside) == null ? void 0 : _a8.call(ctx2, event);
              if (event.defaultPrevented) return;
              send({ type: "BLUR", src: "interact-outside" });
            }
          });
        },
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl(dom30.getHiddenInputEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "SET_VALUE", value: initialContext.value, src: "form-reset" });
            }
          });
        },
        autoResize(ctx2) {
          if (!ctx2.editedTagValue || ctx2.idx == null || !ctx2.editable) return;
          const input = dom30.getTagInputEl(ctx2, { value: ctx2.editedTagValue, index: ctx2.idx });
          return autoResizeInput(input);
        },
        trackLiveRegion(ctx2) {
          ctx2.liveRegion = createLiveRegion({
            level: "assertive",
            document: dom30.getDoc(ctx2)
          });
          return () => {
            var _a8;
            return (_a8 = ctx2.liveRegion) == null ? void 0 : _a8.destroy();
          };
        }
      },
      actions: {
        raiseInsertTagEvent(_, __, { self: self2 }) {
          self2.send("INSERT_TAG");
        },
        raiseExternalBlurEvent(_, evt, { self: self2 }) {
          self2.send({ type: "EXTERNAL_BLUR", id: evt.id });
        },
        dispatchChangeEvent(ctx2) {
          dom30.dispatchInputEvent(ctx2);
        },
        highlightNextTag(ctx2) {
          if (ctx2.highlightedTagId == null) return;
          const next3 = dom30.getNextEl(ctx2, ctx2.highlightedTagId);
          set24.highlightedId(ctx2, (next3 == null ? void 0 : next3.id) ?? null);
        },
        highlightFirstTag(ctx2) {
          raf(() => {
            const first2 = dom30.getFirstEl(ctx2);
            set24.highlightedId(ctx2, (first2 == null ? void 0 : first2.id) ?? null);
          });
        },
        highlightLastTag(ctx2) {
          const last2 = dom30.getLastEl(ctx2);
          set24.highlightedId(ctx2, (last2 == null ? void 0 : last2.id) ?? null);
        },
        highlightPrevTag(ctx2) {
          if (ctx2.highlightedTagId == null) return;
          const prev3 = dom30.getPrevEl(ctx2, ctx2.highlightedTagId);
          set24.highlightedId(ctx2, (prev3 == null ? void 0 : prev3.id) ?? null);
        },
        highlightTag(ctx2, evt) {
          set24.highlightedId(ctx2, evt.id);
        },
        highlightTagAtIndex(ctx2) {
          raf(() => {
            if (ctx2.idx == null) return;
            const tagEl = dom30.getTagElAtIndex(ctx2, ctx2.idx);
            if (tagEl == null) return;
            set24.highlightedId(ctx2, tagEl.id);
            ctx2.idx = void 0;
          });
        },
        deleteTag(ctx2, evt) {
          const index = dom30.getIndexOfId(ctx2, evt.id);
          const value = ctx2.value[index];
          ctx2.log.prev = ctx2.log.current;
          ctx2.log.current = { type: "delete", value };
          set24.value(ctx2, removeAt(ctx2.value, index));
        },
        deleteHighlightedTag(ctx2) {
          if (ctx2.highlightedTagId == null) return;
          const index = dom30.getIndexOfId(ctx2, ctx2.highlightedTagId);
          ctx2.idx = index;
          const value = ctx2.value[index];
          ctx2.log.prev = ctx2.log.current;
          ctx2.log.current = { type: "delete", value };
          set24.value(ctx2, removeAt(ctx2.value, index));
        },
        setEditedId(ctx2, evt) {
          ctx2.editedTagId = evt.id ?? ctx2.highlightedTagId;
          ctx2.idx = dom30.getIndexOfId(ctx2, ctx2.editedTagId);
        },
        clearEditedId(ctx2) {
          ctx2.editedTagId = null;
        },
        clearEditedTagValue(ctx2) {
          ctx2.editedTagValue = "";
        },
        setEditedTagValue(ctx2, evt) {
          ctx2.editedTagValue = evt.value;
        },
        submitEditedTagValue(ctx2) {
          if (!ctx2.editedTagId) return;
          const index = dom30.getIndexOfId(ctx2, ctx2.editedTagId);
          set24.valueAtIndex(ctx2, index, ctx2.editedTagValue ?? "");
          ctx2.log.prev = ctx2.log.current;
          ctx2.log.current = { type: "update", value: ctx2.editedTagValue };
        },
        setValueAtIndex(ctx2, evt) {
          if (evt.value) {
            ctx2.value[evt.index] = evt.value;
            ctx2.log.prev = ctx2.log.current;
            ctx2.log.current = { type: "update", value: evt.value };
          } else {
            warn("You need to provide a value for the tag");
          }
        },
        initializeEditedTagValue(ctx2) {
          if (!ctx2.editedTagId) return;
          const index = dom30.getIndexOfId(ctx2, ctx2.editedTagId);
          ctx2.editedTagValue = ctx2.value[index];
        },
        focusEditedTagInput(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom30.getEditInputEl(ctx2)) == null ? void 0 : _a8.select();
          });
        },
        setInputValue(ctx2, evt) {
          set24.inputValue(ctx2, evt.value);
        },
        clearHighlightedId(ctx2) {
          ctx2.highlightedTagId = null;
        },
        focusInput(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom30.getInputEl(ctx2)) == null ? void 0 : _a8.focus();
          });
        },
        clearInputValue(ctx2) {
          raf(() => {
            set24.inputValue(ctx2, "");
          });
        },
        syncInputValue(ctx2) {
          const inputEl = dom30.getInputEl(ctx2);
          dom30.setValue(inputEl, ctx2.inputValue);
        },
        syncEditedTagInputValue(ctx2, evt) {
          const id = ctx2.editedTagId || ctx2.highlightedTagId || evt.id;
          if (id == null) return;
          const editTagInputEl = dom30.getById(ctx2, `${id}:input`);
          dom30.setValue(editTagInputEl, ctx2.editedTagValue);
        },
        addTag(ctx2, evt) {
          var _a8, _b7;
          const value = evt.value ?? ctx2.trimmedInputValue;
          const guard = (_a8 = ctx2.validate) == null ? void 0 : _a8.call(ctx2, { inputValue: value, value: Array.from(ctx2.value) });
          if (guard) {
            const nextValue = uniq(ctx2.value.concat(value));
            set24.value(ctx2, nextValue);
            ctx2.log.prev = ctx2.log.current;
            ctx2.log.current = { type: "add", value };
          } else {
            (_b7 = ctx2.onValueInvalid) == null ? void 0 : _b7.call(ctx2, { reason: "invalidTag" });
          }
        },
        addTagFromPaste(ctx2) {
          raf(() => {
            var _a8, _b7;
            const value = ctx2.trimmedInputValue;
            const guard = (_a8 = ctx2.validate) == null ? void 0 : _a8.call(ctx2, { inputValue: value, value: Array.from(ctx2.value) });
            if (guard) {
              const trimmedValue = ctx2.delimiter ? value.split(ctx2.delimiter).map((v) => v.trim()) : [value];
              const nextValue = uniq(ctx2.value.concat(...trimmedValue));
              set24.value(ctx2, nextValue);
              ctx2.log.prev = ctx2.log.current;
              ctx2.log.current = { type: "paste", values: trimmedValue };
            } else {
              (_b7 = ctx2.onValueInvalid) == null ? void 0 : _b7.call(ctx2, { reason: "invalidTag" });
            }
            set24.inputValue(ctx2, "");
          });
        },
        clearTags(ctx2) {
          set24.value(ctx2, []);
          ctx2.log.prev = ctx2.log.current;
          ctx2.log.current = { type: "clear" };
        },
        setValue(ctx2, evt) {
          set24.value(ctx2, evt.value);
        },
        invokeOnInvalid(ctx2) {
          var _a8;
          if (ctx2.isOverflowing) {
            (_a8 = ctx2.onValueInvalid) == null ? void 0 : _a8.call(ctx2, { reason: "rangeOverflow" });
          }
        },
        clearLog(ctx2) {
          ctx2.log = { prev: null, current: null };
        },
        logHighlightedTag(ctx2) {
          if (ctx2.highlightedTagId == null) return;
          const index = dom30.getIndexOfId(ctx2, ctx2.highlightedTagId);
          ctx2.log.prev = ctx2.log.current;
          ctx2.log.current = { type: "select", value: ctx2.value[index] };
        },
        // queue logs with screen reader and get it announced
        announceLog(ctx2) {
          if (!ctx2.log.current || ctx2.liveRegion == null) return;
          const region = ctx2.liveRegion;
          const { current, prev: prev3 } = ctx2.log;
          let msg;
          switch (current.type) {
            case "add":
              msg = ctx2.translations.tagAdded(current.value);
              break;
            case "delete":
              msg = ctx2.translations.tagDeleted(current.value);
              break;
            case "update":
              msg = ctx2.translations.tagUpdated(current.value);
              break;
            case "paste":
              msg = ctx2.translations.tagsPasted(current.values);
              break;
            case "select":
              msg = ctx2.translations.tagSelected(current.value);
              if ((prev3 == null ? void 0 : prev3.type) === "delete") {
                msg = `${ctx2.translations.tagDeleted(prev3.value)}. ${msg}`;
              } else if ((prev3 == null ? void 0 : prev3.type) === "update") {
                msg = `${ctx2.translations.tagUpdated(prev3.value)}. ${msg}`;
              }
              break;
          }
          if (msg) region.announce(msg);
        }
      }
    }
  );
}
var invoke17 = {
  change: (ctx) => {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value: Array.from(ctx.value) });
    dom30.dispatchInputEvent(ctx);
  },
  highlightChange: (ctx) => {
    var _a8;
    const highlightedValue = dom30.getHighlightedTagValue(ctx);
    (_a8 = ctx.onHighlightChange) == null ? void 0 : _a8.call(ctx, { highlightedValue });
  },
  valueChange: (ctx) => {
    var _a8;
    (_a8 = ctx.onInputValueChange) == null ? void 0 : _a8.call(ctx, { inputValue: ctx.inputValue });
  }
};
var set24 = {
  value: (ctx, value) => {
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke17.change(ctx);
  },
  valueAtIndex: (ctx, index, value) => {
    if (isEqual(ctx.value[index], value)) return;
    ctx.value[index] = value;
    invoke17.change(ctx);
  },
  highlightedId: (ctx, id) => {
    if (isEqual(ctx.highlightedTagId, id)) return;
    ctx.highlightedTagId = id;
    invoke17.highlightChange(ctx);
  },
  inputValue: (ctx, value) => {
    if (isEqual(ctx.inputValue, value)) return;
    ctx.inputValue = value;
    invoke17.valueChange(ctx);
  }
};
var props27 = createProps()([
  "addOnPaste",
  "allowOverflow",
  "autoFocus",
  "blurBehavior",
  "delimiter",
  "dir",
  "disabled",
  "editable",
  "form",
  "getRootNode",
  "id",
  "ids",
  "inputValue",
  "invalid",
  "max",
  "maxLength",
  "name",
  "onFocusOutside",
  "onHighlightChange",
  "onInputValueChange",
  "onInteractOutside",
  "onPointerDownOutside",
  "onValueChange",
  "onValueInvalid",
  "required",
  "readOnly",
  "translations",
  "validate",
  "value"
]);
var splitProps27 = createSplitProps(props27);
var itemProps9 = createProps()(["index", "disabled", "value"]);
var splitItemProps9 = createSplitProps(itemProps9);

// node_modules/@ark-ui/react/dist/components/tags-input/use-tags-input.js
var import_react741 = __toESM(require_react(), 1);
var useTagsInput = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react741.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    invalid: field == null ? void 0 : field.invalid,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    getRootNode,
    value: props34.defaultValue,
    ...props34
  };
  const context = {
    ...initialContext,
    value: props34.value,
    onValueChange: useEvent(props34.onValueChange, { sync: true }),
    onValueInvalid: useEvent(props34.onValueInvalid),
    onHighlightChange: useEvent(props34.onHighlightChange)
  };
  const [state2, send] = useMachine(machine31(initialContext), { context });
  return connect31(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-root.js
var TagsInputRoot = (0, import_react743.forwardRef)((props34, ref2) => {
  const [useTagsInputProps, localProps] = createSplitProps2()(props34, [
    "addOnPaste",
    "allowOverflow",
    "autoFocus",
    "blurBehavior",
    "defaultValue",
    "delimiter",
    "disabled",
    "editable",
    "form",
    "id",
    "ids",
    "inputValue",
    "invalid",
    "max",
    "maxLength",
    "name",
    "onFocusOutside",
    "onHighlightChange",
    "onInputValueChange",
    "onInteractOutside",
    "onPointerDownOutside",
    "onValueChange",
    "onValueInvalid",
    "readOnly",
    "required",
    "translations",
    "validate",
    "value"
  ]);
  const tagsInput = useTagsInput(useTagsInputProps);
  const mergedProps = mergeProps2(tagsInput.getRootProps(), localProps);
  return (0, import_jsx_runtime343.jsx)(TagsInputProvider, { value: tagsInput, children: (0, import_jsx_runtime343.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
TagsInputRoot.displayName = "TagsInputRoot";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-root-provider.js
var import_jsx_runtime344 = __toESM(require_jsx_runtime(), 1);
var import_react745 = __toESM(require_react(), 1);
var TagsInputRootProvider = (0, import_react745.forwardRef)(
  (props34, ref2) => {
    const [{ value: tagsInput }, localProps] = createSplitProps2()(props34, [
      "value"
    ]);
    const mergedProps = mergeProps2(tagsInput.getRootProps(), localProps);
    return (0, import_jsx_runtime344.jsx)(TagsInputProvider, { value: tagsInput, children: (0, import_jsx_runtime344.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
TagsInputRootProvider.displayName = "TagsInputRootProvider";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-cell.js
var import_jsx_runtime345 = __toESM(require_jsx_runtime(), 1);
var import_react747 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/time-picker/use-time-picker-column-props-context.js
var [TimePickerColumnPropsProvider, useTimePickerColumnPropsContext] = createContext3({
  name: "TimePickerColumnPropsContext",
  hookName: "useTimePickerColumnPropsContext",
  providerName: "<TimePickerColumnPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/time-picker/use-time-picker-context.js
var [TimePickerProvider, useTimePickerContext] = createContext3({
  name: "TimePickerContext",
  hookName: "useTimePickerContext",
  providerName: "<TimePickerProvider />"
});

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-cell.js
var TimePickerCell = (0, import_react747.forwardRef)((props34, ref2) => {
  const [cellProps, localProps] = createSplitProps2()(props34, ["value"]);
  const timePicker = useTimePickerContext();
  const columnProps = useTimePickerColumnPropsContext();
  const unitToPropsMap = {
    hour: () => timePicker.getHourCellProps(cellProps),
    minute: () => timePicker.getMinuteCellProps(cellProps),
    second: () => timePicker.getSecondCellProps(cellProps),
    period: () => timePicker.getPeriodCellProps(cellProps)
  };
  const mergedProps = mergeProps2(unitToPropsMap[columnProps.unit](), localProps);
  return (0, import_jsx_runtime345.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
TimePickerCell.displayName = "TimePickerCell";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-clear-trigger.js
var import_jsx_runtime346 = __toESM(require_jsx_runtime(), 1);
var import_react749 = __toESM(require_react(), 1);
var TimePickerClearTrigger = (0, import_react749.forwardRef)(
  (props34, ref2) => {
    const timePicker = useTimePickerContext();
    const mergedProps = mergeProps2(timePicker.getClearTriggerProps(), props34);
    return (0, import_jsx_runtime346.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
TimePickerClearTrigger.displayName = "TimePickerClearTrigger";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-column.js
var import_jsx_runtime347 = __toESM(require_jsx_runtime(), 1);
var import_react751 = __toESM(require_react(), 1);
var TimePickerColumn = (0, import_react751.forwardRef)((props34, ref2) => {
  const [columnProps, localProps] = createSplitProps2()(props34, ["unit"]);
  const timePicker = useTimePickerContext();
  const mergedProps = mergeProps2(timePicker.getColumnProps(columnProps), localProps);
  return (0, import_jsx_runtime347.jsx)(TimePickerColumnPropsProvider, { value: columnProps, children: (0, import_jsx_runtime347.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
TimePickerColumn.displayName = "TimePickerColumn";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-content.js
var import_jsx_runtime348 = __toESM(require_jsx_runtime(), 1);
var import_react753 = __toESM(require_react(), 1);
var TimePickerContent = (0, import_react753.forwardRef)(
  (props34, ref2) => {
    const timePicker = useTimePickerContext();
    const presence = usePresenceContext();
    const mergedProps = mergeProps2(timePicker.getContentProps(), presence.getPresenceProps(), props34);
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime348.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
  }
);
TimePickerContent.displayName = "TimePickerContent";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-control.js
var import_jsx_runtime349 = __toESM(require_jsx_runtime(), 1);
var import_react755 = __toESM(require_react(), 1);
var TimePickerControl = (0, import_react755.forwardRef)(
  (props34, ref2) => {
    const timePicker = useTimePickerContext();
    const mergedProps = mergeProps2(timePicker.getControlProps(), props34);
    return (0, import_jsx_runtime349.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
TimePickerControl.displayName = "TimePickerControl";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-input.js
var import_jsx_runtime350 = __toESM(require_jsx_runtime(), 1);
var import_react757 = __toESM(require_react(), 1);
var TimePickerInput = (0, import_react757.forwardRef)((props34, ref2) => {
  const timePicker = useTimePickerContext();
  const mergedProps = mergeProps2(timePicker.getInputProps(), props34);
  return (0, import_jsx_runtime350.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
TimePickerInput.displayName = "TimePickerInput";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-label.js
var import_jsx_runtime351 = __toESM(require_jsx_runtime(), 1);
var import_react759 = __toESM(require_react(), 1);
var TimePickerLabel = (0, import_react759.forwardRef)((props34, ref2) => {
  const timePicker = useTimePickerContext();
  const mergedProps = mergeProps2(timePicker.getLabelProps(), props34);
  return (0, import_jsx_runtime351.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
TimePickerLabel.displayName = "TimePickerLabel";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-positioner.js
var import_jsx_runtime352 = __toESM(require_jsx_runtime(), 1);
var import_react761 = __toESM(require_react(), 1);
var TimePickerPositioner = (0, import_react761.forwardRef)(
  (props34, ref2) => {
    const timePicker = useTimePickerContext();
    const mergedProps = mergeProps2(timePicker.getPositionerProps(), props34);
    const presence = usePresenceContext();
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime352.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
TimePickerPositioner.displayName = "TimePickerPositioner";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-root.js
var import_jsx_runtime353 = __toESM(require_jsx_runtime(), 1);
var import_react765 = __toESM(require_react(), 1);

// node_modules/@zag-js/time-picker/dist/index.mjs
var anatomy31 = createAnatomy("time-picker").parts(
  "cell",
  "clearTrigger",
  "column",
  "content",
  "control",
  "input",
  "label",
  "positioner",
  "root",
  "spacer",
  "trigger"
);
var parts34 = anatomy31.build();
var dom31 = createScope({
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `time-picker:${ctx.id}:content`;
  },
  getColumnId: (ctx, unit) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.column) == null ? void 0 : _b7.call(_a8, unit)) ?? `time-picker:${ctx.id}:column:${unit}`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `time-picker:${ctx.id}:control`;
  },
  getClearTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.clearTrigger) ?? `time-picker:${ctx.id}:clear-trigger`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `time-picker:${ctx.id}:positioner`;
  },
  getInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.input) ?? `time-picker:${ctx.id}:input`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `time-picker:${ctx.id}:trigger`;
  },
  getContentEl: (ctx) => dom31.getById(ctx, dom31.getContentId(ctx)),
  getColumnEl: (ctx, unit) => query(dom31.getContentEl(ctx), `[data-part=column][data-unit=${unit}]`),
  getColumnEls: (ctx) => queryAll(dom31.getContentEl(ctx), `[data-part=column]:not([hidden])`),
  getColumnCellEls: (ctx, unit) => queryAll(dom31.getColumnEl(ctx, unit), `[data-part=cell]`),
  getControlEl: (ctx) => dom31.getById(ctx, dom31.getControlId(ctx)),
  getClearTriggerEl: (ctx) => dom31.getById(ctx, dom31.getClearTriggerId(ctx)),
  getPositionerEl: (ctx) => dom31.getById(ctx, dom31.getPositionerId(ctx)),
  getInputEl: (ctx) => dom31.getById(ctx, dom31.getInputId(ctx)),
  getTriggerEl: (ctx) => dom31.getById(ctx, dom31.getTriggerId(ctx)),
  getFocusedCell: (ctx) => query(dom31.getContentEl(ctx), `[data-part=cell][data-focus]`),
  getInitialFocusCell: (ctx, unit) => {
    const contentEl = dom31.getContentEl(ctx);
    let cellEl = query(contentEl, `[data-part=cell][data-unit=${unit}][aria-current]`);
    cellEl || (cellEl = query(contentEl, `[data-part=cell][data-unit=${unit}][data-now]`));
    cellEl || (cellEl = query(contentEl, `[data-part=cell][data-unit=${unit}]`));
    return cellEl;
  },
  getColumnUnit: (el) => el.dataset.unit,
  getCellValue: (el) => {
    const value = el == null ? void 0 : el.dataset.value;
    return (el == null ? void 0 : el.dataset.unit) === "period" ? value : Number(value ?? "0");
  }
});
function getCurrentTime() {
  const now = /* @__PURE__ */ new Date();
  return new $35ea8db9cb2ccb90$export$680ea196effce5f(now.getHours(), now.getMinutes(), now.getSeconds());
}
var padStart = (value) => value.toString().padStart(2, "0");
function getStringifiedValue(ctx) {
  if (!ctx.value) return "";
  let hourValue = ctx.value.hour;
  if (ctx.hour12 && hourValue === 0) {
    hourValue = 12;
  } else if (ctx.hour12 && hourValue > 12) {
    hourValue -= 12;
  }
  let result = `${padStart(hourValue)}:${padStart(ctx.value.minute)}`;
  if (ctx.allowSeconds) {
    const second = padStart(ctx.value.second);
    result += `:${second}`;
  }
  if (ctx.hour12 && ctx.period) {
    result += ` ${ctx.period.toUpperCase()}`;
  }
  return result;
}
var TIME_REX = /(\d{1,2}):(\d{1,2})(?::(\d{1,2}))?\s?(AM|PM|am|pm)?/;
function getTimeValue(ctx, value) {
  const match22 = value.match(TIME_REX);
  if (!match22) return;
  let [, hourString, minuteString, secondString, periodString] = match22;
  let hour = parseInt(hourString);
  const minute = parseInt(minuteString);
  const second = secondString ? parseInt(secondString) : void 0;
  if (!is12HourFormat(ctx.locale) && ctx.period) {
    return { time: new $35ea8db9cb2ccb90$export$680ea196effce5f(hour, minute, second), period: ctx.period };
  }
  let period = periodString ? periodString.toLowerCase() : "am";
  if (hour > 11) {
    period = "pm";
  } else if (period === "pm") {
    hour += 12;
  }
  return { time: new $35ea8db9cb2ccb90$export$680ea196effce5f(hour, minute, second), period };
}
function get12HourFormatPeriodHour(hour, period) {
  if (!period) return hour;
  return period === "pm" ? hour + 12 : hour;
}
function getHourPeriod(hour, locale) {
  if (hour === void 0 || !is12HourFormat(locale)) return null;
  return hour > 11 ? "pm" : "am";
}
function is12HourFormat(locale) {
  return new Intl.DateTimeFormat(locale, { hour: "numeric" }).formatToParts(/* @__PURE__ */ new Date()).some((part) => part.type === "dayPeriod");
}
function getInputPlaceholder2(ctx) {
  if (ctx.placeholder) return ctx.placeholder;
  const secondsPart = ctx.allowSeconds ? ":ss" : "";
  const periodPart = is12HourFormat(ctx.locale) ? " aa" : "";
  return `hh:mm${secondsPart}${periodPart}`;
}
function clampTime(value, min4, max4) {
  let time = value;
  if (min4 && min4.compare(value) > 0) {
    time = min4.copy();
  } else if (max4 && max4.compare(value) < 0) {
    time = max4.copy();
  }
  return time;
}
function connect32(state2, send, normalize3) {
  const disabled = state2.context.disabled;
  const readOnly = state2.context.readOnly;
  const locale = state2.context.locale;
  const hour12 = is12HourFormat(locale);
  const min4 = state2.context.min;
  const max4 = state2.context.max;
  const steps = state2.context.steps;
  const focused = state2.matches("focused");
  const open = state2.hasTag("open");
  const value = state2.context.value;
  const valueAsString = state2.context.valueAsString;
  const currentTime = state2.context.currentTime;
  const currentPlacement = state2.context.currentPlacement;
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: state2.context.currentPlacement
  });
  return {
    focused,
    open,
    value,
    valueAsString,
    hour12,
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    setUnitValue(unit, value2) {
      send({ type: "UNIT.SET", unit, value: value2 });
    },
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    clearValue() {
      send("VALUE.CLEAR");
    },
    getHours() {
      const length2 = hour12 ? 12 : 24;
      const arr = Array.from({ length: length2 }, (_, i) => i);
      const step = steps == null ? void 0 : steps.hour;
      const hours = step != null ? arr.filter((hour) => hour % step === 0) : arr;
      return hours.map((value2) => ({ label: hour12 && value2 === 0 ? "12" : padStart(value2), value: value2 }));
    },
    getMinutes() {
      const arr = Array.from({ length: 60 }, (_, i) => i);
      const step = steps == null ? void 0 : steps.minute;
      const minutes = step != null ? arr.filter((minute) => minute % step === 0) : arr;
      return minutes.map((value2) => ({ label: padStart(value2), value: value2 }));
    },
    getSeconds() {
      const arr = Array.from({ length: 60 }, (_, i) => i);
      const step = steps == null ? void 0 : steps.second;
      const seconds = step != null ? arr.filter((second) => second % step === 0) : arr;
      return seconds.map((value2) => ({ label: padStart(value2), value: value2 }));
    },
    getRootProps() {
      return normalize3.element({
        ...parts34.root.attrs,
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getLabelProps() {
      return normalize3.label({
        ...parts34.label.attrs,
        dir: state2.context.dir,
        htmlFor: dom31.getInputId(state2.context),
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getControlProps() {
      return normalize3.element({
        ...parts34.control.attrs,
        dir: state2.context.dir,
        id: dom31.getControlId(state2.context),
        "data-disabled": dataAttr(disabled)
      });
    },
    getInputProps() {
      return normalize3.input({
        ...parts34.input.attrs,
        dir: state2.context.dir,
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: "false",
        id: dom31.getInputId(state2.context),
        name: state2.context.name,
        defaultValue: valueAsString,
        placeholder: getInputPlaceholder2(state2.context),
        disabled,
        readOnly,
        onFocus() {
          send("INPUT.FOCUS");
        },
        onBlur(event) {
          send({ type: "INPUT.BLUR", value: event.currentTarget.value });
        },
        onKeyDown(event) {
          if (isComposingEvent(event)) return;
          if (event.key !== "Enter") return;
          send({ type: "INPUT.ENTER", value: event.currentTarget.value });
          event.preventDefault();
        }
      });
    },
    getTriggerProps() {
      return normalize3.button({
        ...parts34.trigger.attrs,
        id: dom31.getTriggerId(state2.context),
        type: "button",
        "data-placement": state2.context.currentPlacement,
        disabled,
        "data-readonly": dataAttr(readOnly),
        "aria-label": open ? "Close calendar" : "Open calendar",
        "aria-controls": dom31.getContentId(state2.context),
        "data-state": open ? "open" : "closed",
        onClick(event) {
          if (event.defaultPrevented) return;
          send("TRIGGER.CLICK");
        }
      });
    },
    getClearTriggerProps() {
      return normalize3.button({
        ...parts34.clearTrigger.attrs,
        id: dom31.getClearTriggerId(state2.context),
        type: "button",
        hidden: !state2.context.value,
        disabled,
        "data-readonly": dataAttr(readOnly),
        "aria-label": "Clear time",
        onClick(event) {
          if (event.defaultPrevented) return;
          send("VALUE.CLEAR");
        }
      });
    },
    getPositionerProps() {
      return normalize3.element({
        ...parts34.positioner.attrs,
        dir: state2.context.dir,
        id: dom31.getPositionerId(state2.context),
        style: popperStyles.floating
      });
    },
    getSpacerProps() {
      return normalize3.element({
        ...parts34.spacer.attrs
      });
    },
    getContentProps() {
      return normalize3.element({
        ...parts34.content.attrs,
        dir: state2.context.dir,
        id: dom31.getContentId(state2.context),
        hidden: !open,
        tabIndex: 0,
        role: "application",
        "data-state": open ? "open" : "closed",
        "data-placement": currentPlacement,
        "aria-roledescription": "timepicker",
        "aria-label": "timepicker",
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "CONTENT.ARROW_UP" });
            },
            ArrowDown() {
              send({ type: "CONTENT.ARROW_DOWN" });
            },
            ArrowLeft() {
              send({ type: "CONTENT.ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "CONTENT.ARROW_RIGHT" });
            },
            Enter() {
              send({ type: "CONTENT.ENTER" });
            },
            // prevent tabbing out of the time picker
            Tab() {
            },
            Escape() {
              if (!state2.context.disableLayer) return;
              send({ type: "CONTENT.ESCAPE" });
            }
          };
          const exec2 = keyMap2[getEventKey(event, state2.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        }
      });
    },
    getColumnProps(props210) {
      const hidden = props210.unit === "second" && !state2.context.allowSeconds || props210.unit === "period" && !hour12;
      return normalize3.element({
        ...parts34.column.attrs,
        id: dom31.getColumnId(state2.context, props210.unit),
        "data-unit": props210.unit,
        "data-focus": dataAttr(state2.context.focusedColumn === props210.unit),
        hidden
      });
    },
    getHourCellProps(props210) {
      var _a8;
      const hour = props210.value;
      const isSelectable = !(min4 && get12HourFormatPeriodHour(hour, state2.context.period) < min4.hour || max4 && get12HourFormatPeriodHour(hour, state2.context.period) > max4.hour);
      const isSelected = ((_a8 = state2.context.value) == null ? void 0 : _a8.hour) === get12HourFormatPeriodHour(hour, state2.context.period);
      const isFocused = state2.context.focusedColumn === "hour" && state2.context.focusedValue === hour;
      const currentHour = hour12 && currentTime ? (currentTime == null ? void 0 : currentTime.hour) % 12 : currentTime == null ? void 0 : currentTime.hour;
      const isCurrent = currentHour === hour || hour === 12 && currentHour === 0;
      return normalize3.button({
        ...parts34.cell.attrs,
        type: "button",
        "aria-disabled": ariaAttr(!isSelectable),
        "data-disabled": dataAttr(!isSelectable),
        "aria-current": ariaAttr(isSelected),
        "data-selected": dataAttr(isSelected),
        "data-now": dataAttr(isCurrent),
        "data-focus": dataAttr(isFocused),
        "aria-label": `${hour} hours`,
        "data-value": hour,
        "data-unit": "hour",
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!isSelectable) return;
          send({ type: "UNIT.CLICK", unit: "hour", value: hour });
        }
      });
    },
    getMinuteCellProps(props210) {
      var _a8;
      const minute = props210.value;
      const { value: value2 } = state2.context;
      const minMinute = min4 == null ? void 0 : min4.set({ second: 0 });
      const maxMinute = max4 == null ? void 0 : max4.set({ second: 0 });
      const isSelectable = !(minMinute && value2 && minMinute.compare(value2.set({ minute })) > 0 || maxMinute && value2 && maxMinute.compare(value2.set({ minute })) < 0);
      const isSelected = ((_a8 = state2.context.value) == null ? void 0 : _a8.minute) === minute;
      const isCurrent = (currentTime == null ? void 0 : currentTime.minute) === minute;
      const isFocused = state2.context.focusedColumn === "minute" && state2.context.focusedValue === minute;
      return normalize3.button({
        ...parts34.cell.attrs,
        type: "button",
        "aria-disabled": ariaAttr(!isSelectable),
        "data-disabled": dataAttr(!isSelectable),
        "aria-current": ariaAttr(isSelected),
        "data-selected": dataAttr(isSelected),
        "aria-label": `${minute} minutes`,
        "data-value": minute,
        "data-now": dataAttr(isCurrent),
        "data-focus": dataAttr(isFocused),
        "data-unit": "minute",
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!isSelectable) return;
          send({ type: "UNIT.CLICK", unit: "minute", value: minute });
        }
      });
    },
    getSecondCellProps(props210) {
      var _a8;
      const second = props210.value;
      const isSelectable = !(min4 && (value == null ? void 0 : value.minute) && min4.compare(value.set({ second })) > 0 || max4 && (value == null ? void 0 : value.minute) && max4.compare(value.set({ second })) < 0);
      const isSelected = ((_a8 = state2.context.value) == null ? void 0 : _a8.second) === second;
      const isCurrent = (currentTime == null ? void 0 : currentTime.second) === second;
      const isFocused = state2.context.focusedColumn === "second" && state2.context.focusedValue === second;
      return normalize3.button({
        ...parts34.cell.attrs,
        type: "button",
        "aria-disabled": ariaAttr(!isSelectable),
        "data-disabled": dataAttr(!isSelectable),
        "aria-current": ariaAttr(isSelected),
        "data-selected": dataAttr(isSelected),
        "aria-label": `${second} seconds`,
        "data-value": second,
        "data-unit": "second",
        "data-focus": dataAttr(isFocused),
        "data-now": dataAttr(isCurrent),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!isSelectable) return;
          send({ type: "UNIT.CLICK", unit: "second", value: second });
        }
      });
    },
    getPeriodCellProps(props210) {
      const isSelected = state2.context.period === props210.value;
      const currentPeriod = getHourPeriod(currentTime == null ? void 0 : currentTime.hour, state2.context.locale);
      const isCurrent = currentPeriod === props210.value;
      const isFocused = state2.context.focusedColumn === "period" && state2.context.focusedValue === props210.value;
      return normalize3.button({
        ...parts34.cell.attrs,
        type: "button",
        "aria-current": ariaAttr(isSelected),
        "data-selected": dataAttr(isSelected),
        "data-focus": dataAttr(isFocused),
        "data-now": dataAttr(isCurrent),
        "aria-label": props210.value,
        "data-value": props210.value,
        "data-unit": "period",
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "UNIT.CLICK", unit: "period", value: props210.value });
        }
      });
    }
  };
}
var { and: and11 } = guards;
function machine32(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "time-picker",
      initial: ctx.open ? "open" : "idle",
      context: {
        value: null,
        locale: "en-US",
        ...ctx,
        focusedColumn: "hour",
        focusedValue: null,
        currentTime: null,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        }
      },
      computed: {
        valueAsString: (ctx2) => getStringifiedValue(ctx2),
        hour12: (ctx2) => is12HourFormat(ctx2.locale),
        period: (ctx2) => {
          var _a8;
          return getHourPeriod((_a8 = ctx2.value) == null ? void 0 : _a8.hour, ctx2.locale);
        }
      },
      watch: {
        open: ["toggleVisibility"],
        value: ["syncInputElement"],
        period: ["syncInputElement"],
        focusedColumn: ["syncFocusedValue"],
        focusedValue: ["focusCell"]
      },
      on: {
        "VALUE.CLEAR": {
          actions: ["clearValue"]
        },
        "VALUE.SET": {
          actions: ["setValue"]
        },
        "UNIT.SET": {
          actions: ["setUnitValue"]
        }
      },
      states: {
        idle: {
          tags: ["closed"],
          on: {
            "INPUT.FOCUS": {
              target: "focused"
            },
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["invokeOnOpen"]
            }
          }
        },
        focused: {
          tags: ["closed"],
          on: {
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            "INPUT.ENTER": {
              actions: ["setInputValue", "clampTimeValue"]
            },
            "INPUT.BLUR": {
              target: "idle",
              actions: ["setInputValue", "clampTimeValue"]
            },
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["invokeOnOpen"]
            }
          }
        },
        open: {
          tags: ["open"],
          entry: ["setCurrentTime", "scrollColumnsToTop", "focusHourColumn"],
          exit: ["resetFocusedCell"],
          activities: ["computePlacement", "trackDismissableElement"],
          on: {
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose"]
              }
            ],
            "INPUT.ENTER": {
              actions: ["setInputValue", "clampTimeValue"]
            },
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            "CONTROLLED.CLOSE": [
              {
                guard: and11("shouldRestoreFocus", "isInteractOutsideEvent"),
                target: "focused",
                actions: ["focusTriggerElement"]
              },
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["focusInputElement"]
              },
              {
                target: "idle"
              }
            ],
            "CONTENT.ESCAPE": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose", "focusInputElement"]
              }
            ],
            INTERACT_OUTSIDE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["invokeOnClose", "focusTriggerElement"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            "POSITIONING.SET": {
              actions: ["reposition"]
            },
            "UNIT.CLICK": {
              actions: ["setFocusedValue", "setFocusedColumn", "setUnitValue"]
            },
            "CONTENT.ARROW_UP": {
              actions: ["focusPreviousCell"]
            },
            "CONTENT.ARROW_DOWN": {
              actions: ["focusNextCell"]
            },
            "CONTENT.ARROW_LEFT": {
              actions: ["focusPreviousColumnCell"]
            },
            "CONTENT.ARROW_RIGHT": {
              actions: ["focusNextColumnCell"]
            },
            "CONTENT.ENTER": {
              actions: ["selectFocusedCell", "focusNextColumnCell"]
            }
          }
        }
      }
    },
    {
      guards: {
        shouldRestoreFocus: (ctx2) => !!ctx2.restoreFocus,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        isInteractOutsideEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "INTERACT_OUTSIDE";
        }
      },
      activities: {
        computePlacement(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const anchorEl = () => dom31.getControlEl(ctx2);
          const positionerEl = () => dom31.getPositionerEl(ctx2);
          return getPlacement(anchorEl, positionerEl, {
            defer: true,
            ...ctx2.positioning,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          if (ctx2.disableLayer) return;
          return trackDismissableElement(dom31.getContentEl(ctx2), {
            defer: true,
            exclude: [dom31.getTriggerEl(ctx2), dom31.getClearTriggerEl(ctx2)],
            onEscapeKeyDown(event) {
              event.preventDefault();
              ctx2.restoreFocus = true;
              send({ type: "CONTENT.ESCAPE" });
            },
            onInteractOutside(event) {
              ctx2.restoreFocus = !event.detail.focusable;
            },
            onDismiss() {
              send({ type: "INTERACT_OUTSIDE" });
            }
          });
        }
      },
      actions: {
        reposition(ctx2, evt) {
          const positionerEl = () => dom31.getPositionerEl(ctx2);
          getPlacement(dom31.getTriggerEl(ctx2), positionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        setInputValue(ctx2, evt) {
          const timeValue = getTimeValue(ctx2, evt.value);
          if (!timeValue) return;
          set25.value(ctx2, timeValue.time);
        },
        syncInputElement(ctx2) {
          const inputEl = dom31.getInputEl(ctx2);
          if (!inputEl) return;
          inputEl.value = ctx2.valueAsString;
        },
        setUnitValue(ctx2, evt) {
          const { unit, value } = evt;
          const current = ctx2.value ?? ctx2.currentTime ?? new $35ea8db9cb2ccb90$export$680ea196effce5f(0);
          const nextTime = match3(unit, {
            hour: () => current.set({ hour: ctx2.hour12 ? value + 12 : value }),
            minute: () => current.set({ minute: value }),
            second: () => current.set({ second: value }),
            period: () => {
              if (!ctx2.value) return;
              const diff = value === "pm" ? 12 : 0;
              return ctx2.value.set({ hour: ctx2.value.hour % 12 + diff });
            }
          });
          if (!nextTime) return;
          set25.value(ctx2, nextTime);
        },
        setValue(ctx2, evt) {
          if (!(evt.value instanceof $35ea8db9cb2ccb90$export$680ea196effce5f)) return;
          set25.value(ctx2, evt.value);
        },
        clearValue(ctx2) {
          set25.value(ctx2, null);
        },
        setFocusedValue(ctx2, evt) {
          set25.focusedValue(ctx2, evt.value);
        },
        setFocusedColumn(ctx2, evt) {
          set25.focusedColumn(ctx2, evt.unit);
        },
        resetFocusedCell(ctx2) {
          set25.focusedColumn(ctx2, "hour");
          set25.focusedValue(ctx2, null);
        },
        clampTimeValue(ctx2) {
          if (!ctx2.value) return;
          const nextTime = clampTime(ctx2.value, ctx2.min, ctx2.max);
          set25.value(ctx2, nextTime);
        },
        setCurrentTime(ctx2) {
          ctx2.currentTime = getCurrentTime();
        },
        scrollColumnsToTop(ctx2) {
          raf(() => {
            const columnEls = dom31.getColumnEls(ctx2);
            for (const columnEl of columnEls) {
              const cellEl = dom31.getInitialFocusCell(ctx2, columnEl.dataset.unit);
              if (!cellEl) continue;
              columnEl.scrollTop = cellEl.offsetTop - 4;
            }
          });
        },
        focusTriggerElement(ctx2) {
          var _a8;
          (_a8 = dom31.getTriggerEl(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
        },
        focusInputElement(ctx2) {
          var _a8;
          (_a8 = dom31.getInputEl(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
        },
        focusHourColumn(ctx2) {
          raf(() => {
            const hourEl = dom31.getInitialFocusCell(ctx2, "hour");
            if (!hourEl) return;
            set25.focusedValue(ctx2, dom31.getCellValue(hourEl));
          });
        },
        focusPreviousCell(ctx2) {
          raf(() => {
            const cells = dom31.getColumnCellEls(ctx2, ctx2.focusedColumn);
            const focusedEl = dom31.getFocusedCell(ctx2);
            const focusedIndex = focusedEl ? cells.indexOf(focusedEl) : -1;
            const prevCell = prev2(cells, focusedIndex, { loop: false });
            if (!prevCell) return;
            set25.focusedValue(ctx2, dom31.getCellValue(prevCell));
          });
        },
        focusNextCell(ctx2) {
          raf(() => {
            const cells = dom31.getColumnCellEls(ctx2, ctx2.focusedColumn);
            const focusedEl = dom31.getFocusedCell(ctx2);
            const focusedIndex = focusedEl ? cells.indexOf(focusedEl) : -1;
            const nextCell = next2(cells, focusedIndex, { loop: false });
            if (!nextCell) return;
            set25.focusedValue(ctx2, dom31.getCellValue(nextCell));
          });
        },
        selectFocusedCell(ctx2) {
          const current = ctx2.value ?? ctx2.currentTime ?? new $35ea8db9cb2ccb90$export$680ea196effce5f(0);
          let value = ctx2.focusedValue;
          let column2 = ctx2.focusedColumn;
          if (column2 === "hour" && ctx2.hour12) {
            value = ctx2.hour12 ? value + 12 : value;
          } else if (ctx2.focusedColumn === "period") {
            column2 = "hour";
            const diff = value === "pm" ? 12 : 0;
            value = current.hour % 12 + diff;
          }
          const nextTime = current.set({ [column2]: value });
          set25.value(ctx2, nextTime);
        },
        focusPreviousColumnCell(ctx2) {
          raf(() => {
            const columns = dom31.getColumnEls(ctx2);
            const currentColumnEl = dom31.getColumnEl(ctx2, ctx2.focusedColumn);
            const focusedIndex = columns.indexOf(currentColumnEl);
            const prevColumnEl = prev2(columns, focusedIndex, { loop: false });
            if (!prevColumnEl) return;
            set25.focusedColumn(ctx2, dom31.getColumnUnit(prevColumnEl));
          });
        },
        focusNextColumnCell(ctx2) {
          raf(() => {
            const columns = dom31.getColumnEls(ctx2);
            const currentColumnEl = dom31.getColumnEl(ctx2, ctx2.focusedColumn);
            const focusedIndex = columns.indexOf(currentColumnEl);
            const nextColumnEl = next2(columns, focusedIndex, { loop: false });
            if (!nextColumnEl) return;
            set25.focusedColumn(ctx2, dom31.getColumnUnit(nextColumnEl));
          });
        },
        focusCell(ctx2) {
          queueMicrotask(() => {
            const cellEl = dom31.getFocusedCell(ctx2);
            cellEl == null ? void 0 : cellEl.focus();
          });
        },
        syncFocusedValue(ctx2) {
          if (ctx2.focusedValue === null) return;
          queueMicrotask(() => {
            const cellEl = dom31.getInitialFocusCell(ctx2, ctx2.focusedColumn);
            set25.focusedValue(ctx2, dom31.getCellValue(cellEl));
          });
        }
      },
      compareFns: {
        value: isTimeEqual
      }
    }
  );
}
var isTimeEqual = (a2, b2) => {
  return (a2 == null ? void 0 : a2.toString()) === (b2 == null ? void 0 : b2.toString());
};
var invoke18 = {
  change(ctx) {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, {
      value: ctx.value,
      valueAsString: ctx.valueAsString
    });
  },
  focusChange(ctx) {
    var _a8;
    (_a8 = ctx.onFocusChange) == null ? void 0 : _a8.call(ctx, {
      value: ctx.value,
      valueAsString: ctx.valueAsString,
      focusedValue: ctx.focusedValue,
      focusedUnit: ctx.focusedColumn
    });
  }
};
var set25 = {
  value(ctx, value) {
    if (isTimeEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke18.change(ctx);
  },
  focusedValue(ctx, value) {
    if (isEqual(ctx.focusedValue, value)) return;
    ctx.focusedValue = value;
    invoke18.focusChange(ctx);
  },
  focusedColumn(ctx, column2) {
    if (ctx.focusedColumn === column2) return;
    ctx.focusedColumn = column2;
  }
};
var props28 = createProps()([
  "dir",
  "disabled",
  "disableLayer",
  "getRootNode",
  "id",
  "ids",
  "locale",
  "max",
  "min",
  "name",
  "onFocusChange",
  "onOpenChange",
  "onValueChange",
  "open.controlled",
  "open",
  "placeholder",
  "positioning",
  "readOnly",
  "steps",
  "value",
  "allowSeconds"
]);
var splitProps28 = createSplitProps(props28);

// node_modules/@ark-ui/react/dist/components/time-picker/use-time-picker.js
var import_react763 = __toESM(require_react(), 1);
var useTimePicker = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react763.useId)(),
    dir,
    getRootNode,
    open: props34.defaultOpen,
    "open.controlled": props34.open !== void 0,
    value: props34.defaultValue,
    ...props34
  };
  const context = {
    ...initialContext,
    value: props34.value,
    onValueChange: useEvent(props34.onValueChange),
    onFocusChange: useEvent(props34.onFocusChange),
    onOpenChange: useEvent(props34.onOpenChange)
  };
  const [state2, send] = useMachine(machine32(initialContext), { context });
  return connect32(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-root.js
var TimePickerRoot = (0, import_react765.forwardRef)((props34, ref2) => {
  const [presenceProps, timePickerProps] = splitPresenceProps(props34);
  const [useTimePickerProps, localProps] = createSplitProps2()(timePickerProps, [
    "allowSeconds",
    "defaultOpen",
    "defaultValue",
    "disableLayer",
    "disabled",
    "id",
    "ids",
    "locale",
    "max",
    "min",
    "name",
    "onFocusChange",
    "onOpenChange",
    "onValueChange",
    "open",
    "placeholder",
    "positioning",
    "readOnly",
    "steps",
    "value"
  ]);
  const timePicker = useTimePicker(useTimePickerProps);
  const presence = usePresence(mergeProps2({ present: timePicker.open }, presenceProps));
  const mergedProps = mergeProps2(timePicker.getRootProps(), localProps);
  return (0, import_jsx_runtime353.jsx)(TimePickerProvider, { value: timePicker, children: (0, import_jsx_runtime353.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime353.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
TimePickerRoot.displayName = "TimePickerRoot";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-root-provider.js
var import_jsx_runtime354 = __toESM(require_jsx_runtime(), 1);
var import_react767 = __toESM(require_react(), 1);
var TimePickerRootProvider = (0, import_react767.forwardRef)(
  (props34, ref2) => {
    const [presenceProps, timePickerProps] = splitPresenceProps(props34);
    const [{ value: timePicker }, localProps] = createSplitProps2()(
      timePickerProps,
      ["value"]
    );
    const presence = usePresence(mergeProps2({ present: timePicker.open }, presenceProps));
    const mergedProps = mergeProps2(timePicker.getRootProps(), localProps);
    return (0, import_jsx_runtime354.jsx)(TimePickerProvider, { value: timePicker, children: (0, import_jsx_runtime354.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime354.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
  }
);
TimePickerRootProvider.displayName = "TimePickerRootProvider";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-spacer.js
var import_jsx_runtime355 = __toESM(require_jsx_runtime(), 1);
var import_react769 = __toESM(require_react(), 1);
var TimePickerSpacer = (0, import_react769.forwardRef)((props34, ref2) => {
  const timePicker = useTimePickerContext();
  const mergedProps = mergeProps2(timePicker.getSpacerProps(), props34);
  return (0, import_jsx_runtime355.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TimePickerSpacer.displayName = "TimePickerSpacer";

// node_modules/@ark-ui/react/dist/components/time-picker/time-picker-trigger.js
var import_jsx_runtime356 = __toESM(require_jsx_runtime(), 1);
var import_react771 = __toESM(require_react(), 1);
var TimePickerTrigger = (0, import_react771.forwardRef)(
  (props34, ref2) => {
    const timePicker = useTimePickerContext();
    const mergedProps = mergeProps2(timePicker.getTriggerProps(), props34);
    return (0, import_jsx_runtime356.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
TimePickerTrigger.displayName = "TimePickerTrigger";

// node_modules/@ark-ui/react/dist/components/timer/timer-action-trigger.js
var import_jsx_runtime357 = __toESM(require_jsx_runtime(), 1);
var import_react773 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/timer/use-timer-context.js
var [TimerProvider, useTimerContext] = createContext3({
  name: "TimerContext",
  hookName: "useTimerContext",
  providerName: "<TimerProvider />"
});

// node_modules/@ark-ui/react/dist/components/timer/timer-action-trigger.js
var TimerActionTrigger = (0, import_react773.forwardRef)(
  (props34, ref2) => {
    const timer = useTimerContext();
    const mergedProps = mergeProps2(timer.getActionTriggerProps(props34), props34);
    return (0, import_jsx_runtime357.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
TimerActionTrigger.displayName = "TimerActionTrigger";

// node_modules/@ark-ui/react/dist/components/timer/timer-area.js
var import_jsx_runtime358 = __toESM(require_jsx_runtime(), 1);
var import_react775 = __toESM(require_react(), 1);
var TimerArea = (0, import_react775.forwardRef)((props34, ref2) => {
  const timer = useTimerContext();
  const mergedProps = mergeProps2(timer.getAreaProps(), props34);
  return (0, import_jsx_runtime358.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TimerArea.displayName = "TimerArea";

// node_modules/@ark-ui/react/dist/components/timer/timer-control.js
var import_jsx_runtime359 = __toESM(require_jsx_runtime(), 1);
var import_react777 = __toESM(require_react(), 1);
var TimerControl = (0, import_react777.forwardRef)((props34, ref2) => {
  const timer = useTimerContext();
  const mergedProps = mergeProps2(timer.getControlProps(), props34);
  return (0, import_jsx_runtime359.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TimerControl.displayName = "TimerControl";

// node_modules/@ark-ui/react/dist/components/timer/timer-item.js
var import_jsx_runtime360 = __toESM(require_jsx_runtime(), 1);
var import_react779 = __toESM(require_react(), 1);
var TimerItem = (0, import_react779.forwardRef)((props34, ref2) => {
  const [itemProps12, localProps] = createSplitProps2()(props34, ["type"]);
  const timer = useTimerContext();
  const mergedProps = mergeProps2(timer.getItemProps(itemProps12), localProps);
  return (0, import_jsx_runtime360.jsx)(ark.div, { ...mergedProps, ref: ref2, children: timer.formattedTime[itemProps12.type] });
});
TimerItem.displayName = "TimerItem";

// node_modules/@ark-ui/react/dist/components/timer/timer-root.js
var import_jsx_runtime361 = __toESM(require_jsx_runtime(), 1);
var import_react783 = __toESM(require_react(), 1);

// node_modules/@zag-js/timer/dist/index.mjs
var anatomy32 = createAnatomy("timer").parts(
  "root",
  "area",
  "control",
  "item",
  "itemValue",
  "itemLabel",
  "actionTrigger",
  "separator"
);
var parts35 = anatomy32.build();
var dom32 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `timer:${ctx.id}:root`;
  },
  getAreaId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.area) ?? `timer:${ctx.id}:area`;
  },
  getAreaEl: (ctx) => dom32.getById(ctx, dom32.getAreaId(ctx))
});
var validActions = /* @__PURE__ */ new Set(["start", "pause", "resume", "reset"]);
function connect33(state2, send, normalize3) {
  const running = state2.matches("running");
  const paused = state2.matches("paused");
  const time = state2.context.time;
  const formattedTime = state2.context.formattedTime;
  const progressPercent = state2.context.progressPercent;
  return {
    running,
    paused,
    time,
    formattedTime,
    progressPercent,
    start() {
      send("START");
    },
    pause() {
      send("PAUSE");
    },
    resume() {
      send("RESUME");
    },
    reset() {
      send("RESET");
    },
    restart() {
      send("RESTART");
    },
    getRootProps() {
      return normalize3.element({
        id: dom32.getRootId(state2.context),
        ...parts35.root.attrs
      });
    },
    getAreaProps() {
      return normalize3.element({
        role: "timer",
        id: dom32.getAreaId(state2.context),
        "aria-label": `${time.days} days ${formattedTime.hours}:${formattedTime.minutes}:${formattedTime.seconds}`,
        "aria-atomic": true,
        ...parts35.area.attrs
      });
    },
    getControlProps() {
      return normalize3.element({
        ...parts35.control.attrs
      });
    },
    getItemProps(props210) {
      const value = time[props210.type];
      return normalize3.element({
        ...parts35.item.attrs,
        "data-type": props210.type,
        style: {
          "--value": value
        }
      });
    },
    getItemLabelProps(props210) {
      return normalize3.element({
        ...parts35.itemLabel.attrs,
        "data-type": props210.type
      });
    },
    getItemValueProps(props210) {
      return normalize3.element({
        ...parts35.itemValue.attrs,
        "data-type": props210.type
      });
    },
    getSeparatorProps() {
      return normalize3.element({
        "aria-hidden": true,
        ...parts35.separator.attrs
      });
    },
    getActionTriggerProps(props210) {
      if (!validActions.has(props210.action)) {
        throw new Error(
          `[zag-js] Invalid action: ${props210.action}. Must be one of: ${Array.from(validActions).join(", ")}`
        );
      }
      return normalize3.button({
        ...parts35.actionTrigger.attrs,
        hidden: (() => {
          switch (props210.action) {
            case "start":
              return running || paused;
            case "pause":
              return !running;
            case "reset":
              return !running && !paused;
            case "resume":
              return !paused;
            default:
              return;
          }
        })(),
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          send(props210.action.toUpperCase());
        }
      });
    }
  };
}
function machine33(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "timer",
      initial: ctx.autoStart ? "running" : "idle",
      context: {
        interval: 250,
        ...ctx,
        currentMs: ctx.startMs ?? 0
      },
      on: {
        RESTART: {
          target: "running",
          actions: "resetTime"
        }
      },
      computed: {
        time: (ctx2) => msToTime(ctx2.currentMs),
        formattedTime: (ctx2) => formatTime(ctx2.time),
        progressPercent: (ctx2) => {
          const targetMs = ctx2.targetMs;
          if (targetMs == null) return 0;
          return toPercent(ctx2.currentMs, ctx2.startMs ?? 0, targetMs);
        }
      },
      states: {
        idle: {
          on: {
            START: "running",
            RESET: { actions: "resetTime" }
          }
        },
        running: {
          every: {
            TICK_INTERVAL: ["sendTickEvent"]
          },
          on: {
            PAUSE: "paused",
            TICK: [
              {
                target: "idle",
                guard: "hasReachedTarget",
                actions: ["invokeOnComplete"]
              },
              {
                actions: ["updateTime", "invokeOnTick"]
              }
            ],
            RESET: { actions: "resetTime" }
          }
        },
        paused: {
          on: {
            RESUME: "running",
            RESET: {
              target: "idle",
              actions: "resetTime"
            }
          }
        }
      }
    },
    {
      delays: {
        TICK_INTERVAL: (ctx2) => ctx2.interval
      },
      actions: {
        updateTime(ctx2) {
          const sign3 = ctx2.countdown ? -1 : 1;
          ctx2.currentMs = ctx2.currentMs + sign3 * ctx2.interval;
        },
        sendTickEvent(_ctx, _evt, { send }) {
          send({ type: "TICK" });
        },
        resetTime(ctx2) {
          ctx2.currentMs = ctx2.startMs ?? 0;
        },
        invokeOnTick(ctx2) {
          var _a8;
          (_a8 = ctx2.onTick) == null ? void 0 : _a8.call(ctx2, {
            value: ctx2.currentMs,
            time: ctx2.time,
            formattedTime: ctx2.formattedTime
          });
        },
        invokeOnComplete(ctx2) {
          var _a8;
          (_a8 = ctx2.onComplete) == null ? void 0 : _a8.call(ctx2);
        }
      },
      guards: {
        hasReachedTarget: (ctx2) => {
          let targetMs = ctx2.targetMs;
          if (targetMs == null && ctx2.countdown) targetMs = 0;
          if (targetMs == null) return false;
          return ctx2.currentMs === targetMs;
        }
      }
    }
  );
}
function msToTime(ms) {
  const milliseconds = ms % 1e3;
  const seconds = Math.floor(ms / 1e3) % 60;
  const minutes = Math.floor(ms / (1e3 * 60)) % 60;
  const hours = Math.floor(ms / (1e3 * 60 * 60)) % 24;
  const days = Math.floor(ms / (1e3 * 60 * 60 * 24));
  return {
    days,
    hours,
    minutes,
    seconds,
    milliseconds
  };
}
function toPercent(value, minValue, maxValue2) {
  return (value - minValue) / (maxValue2 - minValue);
}
function padStart2(num, size3 = 2) {
  return num.toString().padStart(size3, "0");
}
function formatTime(time) {
  const { days, hours, minutes, seconds } = time;
  return {
    days: padStart2(days),
    hours: padStart2(hours),
    minutes: padStart2(minutes),
    seconds: padStart2(seconds),
    milliseconds: time.milliseconds.toString()
  };
}
var props29 = createProps()([
  "autoStart",
  "countdown",
  "getRootNode",
  "id",
  "ids",
  "interval",
  "onComplete",
  "onTick",
  "startMs",
  "targetMs"
]);
var splitProps29 = createSplitProps(props29);

// node_modules/@ark-ui/react/dist/components/timer/use-timer.js
var import_react781 = __toESM(require_react(), 1);
var useTimer = (props34 = {}) => {
  const env = useEnvironmentContext();
  const initialContext = {
    id: (0, import_react781.useId)(),
    getRootNode: env.getRootNode,
    ...props34
  };
  const context = {
    ...initialContext,
    onComplete: useEvent(props34.onComplete),
    onTick: useEvent(props34.onTick)
  };
  const [state2, send] = useMachine(machine33(initialContext), { context });
  return connect33(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/timer/timer-root.js
var TimerRoot = (0, import_react783.forwardRef)((props34, ref2) => {
  const [useTimerProps, localProps] = createSplitProps2()(props34, [
    "id",
    "ids",
    "autoStart",
    "interval",
    "countdown",
    "startMs",
    "targetMs",
    "onComplete",
    "onTick"
  ]);
  const timer = useTimer(useTimerProps);
  const mergedProps = mergeProps2(timer.getRootProps(), localProps);
  return (0, import_jsx_runtime361.jsx)(TimerProvider, { value: timer, children: (0, import_jsx_runtime361.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
TimerRoot.displayName = "TimerRoot";

// node_modules/@ark-ui/react/dist/components/timer/timer-root-provider.js
var import_jsx_runtime362 = __toESM(require_jsx_runtime(), 1);
var import_react785 = __toESM(require_react(), 1);
var TimerRootProvider = (0, import_react785.forwardRef)(
  (props34, ref2) => {
    const [{ value: timer }, localProps] = createSplitProps2()(props34, ["value"]);
    const mergedProps = mergeProps2(timer.getRootProps(), localProps);
    return (0, import_jsx_runtime362.jsx)(TimerProvider, { value: timer, children: (0, import_jsx_runtime362.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
TimerRootProvider.displayName = "TimerRootProvider";

// node_modules/@ark-ui/react/dist/components/timer/timer-separator.js
var import_jsx_runtime363 = __toESM(require_jsx_runtime(), 1);
var import_react787 = __toESM(require_react(), 1);
var TimerSeparator = (0, import_react787.forwardRef)((props34, ref2) => {
  const timer = useTimerContext();
  const mergedProps = mergeProps2(timer.getSeparatorProps(), props34);
  return (0, import_jsx_runtime363.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TimerSeparator.displayName = "TimerSeparator";

// node_modules/@zag-js/toast/dist/index.mjs
var anatomy33 = createAnatomy("toast").parts(
  "group",
  "root",
  "title",
  "description",
  "actionTrigger",
  "closeTrigger"
);
var parts36 = anatomy33.build();
var dom33 = createScope({
  getRegionId: (placement) => `toast-group:${placement}`,
  getRegionEl: (ctx, placement) => dom33.getById(ctx, `toast-group:${placement}`),
  getRootId: (ctx) => `toast:${ctx.id}`,
  getRootEl: (ctx) => dom33.getById(ctx, dom33.getRootId(ctx)),
  getTitleId: (ctx) => `toast:${ctx.id}:title`,
  getDescriptionId: (ctx) => `toast:${ctx.id}:description`,
  getCloseTriggerId: (ctx) => `toast${ctx.id}:close`
});
function getToastsByPlacement(toasts, placement) {
  return toasts.filter((toast) => toast.state.context.placement === placement);
}
var defaultTimeouts = {
  info: 5e3,
  error: 5e3,
  success: 2e3,
  loading: Infinity,
  DEFAULT: 5e3
};
function getToastDuration(duration, type) {
  return duration ?? defaultTimeouts[type] ?? defaultTimeouts.DEFAULT;
}
function getGroupPlacementStyle(ctx, placement) {
  var _a8;
  const offset3 = ctx.offsets;
  const computedOffset = typeof offset3 === "string" ? { left: offset3, right: offset3, bottom: offset3, top: offset3 } : offset3;
  const rtl = ctx.dir === "rtl";
  const computedPlacement = placement.replace("-start", rtl ? "-right" : "-left").replace("-end", rtl ? "-left" : "-right");
  const isRighty = computedPlacement.includes("right");
  const isLefty = computedPlacement.includes("left");
  const styles = {
    position: "fixed",
    pointerEvents: ctx.count > 0 ? void 0 : "none",
    display: "flex",
    flexDirection: "column",
    "--gap": `${ctx.gap}px`,
    "--first-height": `${((_a8 = ctx.heights[0]) == null ? void 0 : _a8.height) || 0}px`,
    zIndex: MAX_Z_INDEX
  };
  let alignItems = "center";
  if (isRighty) alignItems = "flex-end";
  if (isLefty) alignItems = "flex-start";
  styles.alignItems = alignItems;
  if (computedPlacement.includes("top")) {
    const offset22 = computedOffset.top;
    styles.top = `max(env(safe-area-inset-top, 0px), ${offset22})`;
  }
  if (computedPlacement.includes("bottom")) {
    const offset22 = computedOffset.bottom;
    styles.bottom = `max(env(safe-area-inset-bottom, 0px), ${offset22})`;
  }
  if (!computedPlacement.includes("left")) {
    const offset22 = computedOffset.right;
    styles.insetInlineEnd = `calc(env(safe-area-inset-right, 0px) + ${offset22})`;
  }
  if (!computedPlacement.includes("right")) {
    const offset22 = computedOffset.left;
    styles.insetInlineStart = `calc(env(safe-area-inset-left, 0px) + ${offset22})`;
  }
  return styles;
}
function getPlacementStyle(ctx, visible) {
  const [side] = ctx.placement.split("-");
  const sibling = !ctx.frontmost;
  const overlap = !ctx.stacked;
  const styles = {
    position: "absolute",
    pointerEvents: "auto",
    "--opacity": "0",
    "--remove-delay": `${ctx.removeDelay}ms`,
    "--duration": `${ctx.type === "loading" ? Number.MAX_SAFE_INTEGER : ctx.duration}ms`,
    "--initial-height": `${ctx.height}px`,
    "--offset": `${ctx.offset}px`,
    "--index": ctx.index,
    "--z-index": ctx.zIndex,
    "--lift-amount": "calc(var(--lift) * var(--gap))",
    "--y": "100%",
    "--x": "0"
  };
  const assign2 = (overrides) => Object.assign(styles, overrides);
  if (side === "top") {
    assign2({
      top: "0",
      "--sign": "-1",
      "--y": "-100%",
      "--lift": "1"
    });
  } else if (side === "bottom") {
    assign2({
      bottom: "0",
      "--sign": "1",
      "--y": "100%",
      "--lift": "-1"
    });
  }
  if (ctx.mounted) {
    assign2({
      "--y": "0",
      "--opacity": "1"
    });
    if (ctx.stacked) {
      assign2({
        "--y": "calc(var(--lift) * var(--offset))",
        "--height": "var(--initial-height)"
      });
    }
  }
  if (!visible) {
    assign2({
      "--opacity": "0",
      pointerEvents: "none"
    });
  }
  if (sibling && overlap) {
    assign2({
      "--base-scale": "var(--index) * 0.05 + 1",
      "--y": "calc(var(--lift-amount) * var(--index))",
      "--scale": "calc(-1 * var(--base-scale))",
      "--height": "var(--first-height)"
    });
    if (!visible) {
      assign2({
        "--y": "calc(var(--sign) * 40%)"
      });
    }
  }
  if (sibling && ctx.stacked && !visible) {
    assign2({
      "--y": "calc(var(--lift) * var(--offset) + var(--lift) * -100%)"
    });
  }
  if (ctx.frontmost && !visible) {
    assign2({
      "--y": "calc(var(--lift) * -100%)"
    });
  }
  return styles;
}
function getGhostBeforeStyle(ctx, visible) {
  const styles = {
    position: "absolute",
    inset: "0",
    scale: "1 2",
    pointerEvents: visible ? "none" : "auto"
  };
  const assign2 = (overrides) => Object.assign(styles, overrides);
  if (ctx.frontmost && !visible) {
    assign2({
      height: "calc(var(--initial-height) + 80%)"
    });
  }
  return styles;
}
function getGhostAfterStyle(_ctx, _visible) {
  return {
    position: "absolute",
    left: "0",
    height: "calc(var(--gap) + 2px)",
    bottom: "100%",
    width: "100%"
  };
}
function groupConnect(serviceOrState, send, normalize3) {
  function getState() {
    const result = isMachine(serviceOrState) ? serviceOrState.getState() : serviceOrState;
    return result;
  }
  function getToastsByPlacementImpl(placement) {
    return getToastsByPlacement(getState().context.toasts, placement);
  }
  function isVisible(id) {
    const toasts = getState().context.toasts;
    if (!toasts.length) return false;
    return !!toasts.find((toast) => toast.id == id);
  }
  function create(options) {
    const uid = `toast:${uuid()}`;
    const id = options.id ? options.id : uid;
    if (isVisible(id)) return id;
    send({ type: "ADD_TOAST", toast: { ...options, id } });
    return id;
  }
  function update(id, options) {
    if (!isVisible(id)) return id;
    send({ type: "UPDATE_TOAST", id, toast: options });
    return id;
  }
  function upsert(options) {
    const { id } = options;
    const visible = id ? isVisible(id) : false;
    if (visible && id != null) {
      return update(id, options);
    } else {
      return create(options);
    }
  }
  function dismiss(id) {
    if (id == null) {
      send("DISMISS_ALL");
    } else if (isVisible(id)) {
      send({ type: "DISMISS_TOAST", id });
    }
  }
  return {
    getCount() {
      return getState().context.count;
    },
    getPlacements() {
      const toasts = getState().context.toasts;
      const placements2 = toasts.map((toast) => toast.state.context.placement);
      return Array.from(new Set(placements2));
    },
    getToastsByPlacement: getToastsByPlacementImpl,
    isVisible,
    create,
    update,
    upsert,
    dismiss,
    remove(id) {
      if (id == null) {
        send("REMOVE_ALL");
      } else if (isVisible(id)) {
        send({ type: "REMOVE_TOAST", id });
      }
    },
    dismissByPlacement(placement) {
      const toasts = getToastsByPlacementImpl(placement);
      toasts.forEach((toast) => dismiss(toast.id));
    },
    loading(options) {
      return upsert({ ...options, type: "loading" });
    },
    success(options) {
      return upsert({ ...options, type: "success" });
    },
    error(options) {
      return upsert({ ...options, type: "error" });
    },
    promise(promise, options, shared = {}) {
      const id = upsert({ ...shared, ...options.loading, type: "loading" });
      runIfFn(promise).then((response) => {
        const successOptions = runIfFn(options.success, response);
        upsert({ ...shared, ...successOptions, id, type: "success" });
      }).catch((error) => {
        const errorOptions = runIfFn(options.error, error);
        upsert({ ...shared, ...errorOptions, id, type: "error" });
      }).finally(() => {
        var _a8;
        (_a8 = options.finally) == null ? void 0 : _a8.call(options);
      });
      return id;
    },
    pause(id) {
      if (id == null) {
        send("PAUSE_ALL");
      } else if (isVisible(id)) {
        send({ type: "PAUSE_TOAST", id });
      }
    },
    resume(id) {
      if (id == null) {
        send("RESUME_ALL");
      } else if (isVisible(id)) {
        send({ type: "RESUME_TOAST", id });
      }
    },
    getGroupProps(options) {
      const { placement, label = "Notifications" } = options;
      const state2 = getState();
      const hotkeyLabel = state2.context.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
      const [side, align = "center"] = placement.split("-");
      return normalize3.element({
        ...parts36.group.attrs,
        dir: state2.context.dir,
        tabIndex: -1,
        "aria-label": `${placement} ${label} ${hotkeyLabel}`,
        id: dom33.getRegionId(placement),
        "data-placement": placement,
        "data-side": side,
        "data-align": align,
        "aria-live": "polite",
        role: "region",
        style: getGroupPlacementStyle(state2.context, placement),
        onMouseMove() {
          send({ type: "REGION.POINTER_ENTER", placement });
        },
        onMouseLeave() {
          send({ type: "REGION.POINTER_LEAVE", placement });
        },
        onFocus(event) {
          send({ type: "REGION.FOCUS", target: event.relatedTarget });
        },
        onBlur(event) {
          if (state2.context.isFocusWithin && !contains(event.currentTarget, event.relatedTarget)) {
            send({ type: "REGION.BLUR" });
          }
        }
      });
    },
    subscribe(fn) {
      const state2 = getState();
      return subscribe(state2.context.toasts, () => {
        const toasts = getToastsByPlacementImpl(state2.context.placement);
        const contexts = toasts.map((toast) => toast.getState().context);
        fn(contexts);
      });
    }
  };
}
var { not: not13, and: and12, or: or5 } = guards;
function createToastMachine(options) {
  const { type = "info", duration, id = "1", placement = "bottom", removeDelay = 200, ...restProps } = options;
  const ctx = compact2(restProps);
  const computedDuration = getToastDuration(duration, type);
  return createMachine(
    {
      id,
      context: {
        id,
        type,
        remaining: computedDuration,
        duration: computedDuration,
        removeDelay,
        createdAt: Date.now(),
        placement,
        ...ctx,
        height: 0,
        offset: 0,
        frontmost: false,
        mounted: false,
        index: -1,
        zIndex: 0
      },
      initial: type === "loading" ? "visible:persist" : "visible",
      on: {
        UPDATE: [
          {
            guard: and12("hasTypeChanged", "isChangingToLoading"),
            target: "visible:persist",
            actions: ["setContext"]
          },
          {
            guard: or5("hasDurationChanged", "hasTypeChanged"),
            target: "visible:updating",
            actions: ["setContext"]
          },
          {
            actions: ["setContext"]
          }
        ],
        MEASURE: {
          actions: ["measureHeight"]
        }
      },
      entry: ["invokeOnVisible"],
      activities: ["trackHeight"],
      states: {
        "visible:updating": {
          tags: ["visible", "updating"],
          after: {
            0: "visible"
          }
        },
        "visible:persist": {
          tags: ["visible", "paused"],
          on: {
            RESUME: {
              guard: not13("isLoadingType"),
              target: "visible",
              actions: ["setCreatedAt"]
            },
            DISMISS: "dismissing"
          }
        },
        visible: {
          tags: ["visible"],
          after: {
            VISIBLE_DURATION: "dismissing"
          },
          on: {
            DISMISS: "dismissing",
            PAUSE: {
              target: "visible:persist",
              actions: "setRemainingDuration"
            }
          }
        },
        dismissing: {
          entry: "invokeOnDismiss",
          after: {
            REMOVE_DELAY: {
              target: "unmounted",
              actions: "notifyParentToRemove"
            }
          }
        },
        unmounted: {
          entry: "invokeOnUnmount",
          type: "final"
        }
      }
    },
    {
      activities: {
        trackHeight(ctx2, _evt, { self: self2 }) {
          let cleanup;
          raf(() => {
            const rootEl = dom33.getRootEl(ctx2);
            if (!rootEl) return;
            ctx2.mounted = true;
            const ghosts = queryAll(rootEl, "[data-ghost]");
            warn(
              ghosts.length !== 2,
              "[toast] No ghost element found in toast. Render the `ghostBefore` and `ghostAfter` elements"
            );
            const syncHeight = () => {
              const originalHeight = rootEl.style.height;
              rootEl.style.height = "auto";
              const newHeight = rootEl.getBoundingClientRect().height;
              rootEl.style.height = originalHeight;
              ctx2.height = newHeight;
              self2.sendParent({ type: "UPDATE_HEIGHT", id: self2.id, height: newHeight, placement: ctx2.placement });
            };
            syncHeight();
            const win = dom33.getWin(ctx2);
            const observer = new win.MutationObserver(syncHeight);
            observer.observe(rootEl, { childList: true, subtree: true, characterData: true });
            cleanup = () => observer.disconnect();
          });
          return () => cleanup == null ? void 0 : cleanup();
        }
      },
      guards: {
        isChangingToLoading: (_, evt) => {
          var _a8;
          return ((_a8 = evt.toast) == null ? void 0 : _a8.type) === "loading";
        },
        isLoadingType: (ctx2) => ctx2.type === "loading",
        hasTypeChanged: (ctx2, evt) => {
          var _a8;
          return ((_a8 = evt.toast) == null ? void 0 : _a8.type) != null && evt.toast.type !== ctx2.type;
        },
        hasDurationChanged: (ctx2, evt) => {
          var _a8;
          return ((_a8 = evt.toast) == null ? void 0 : _a8.duration) != null && evt.toast.duration !== ctx2.duration;
        }
      },
      delays: {
        VISIBLE_DURATION: (ctx2) => ctx2.remaining,
        REMOVE_DELAY: (ctx2) => ctx2.removeDelay
      },
      actions: {
        measureHeight(ctx2, _evt, { self: self2 }) {
          raf(() => {
            const rootEl = dom33.getRootEl(ctx2);
            if (!rootEl) return;
            ctx2.mounted = true;
            const originalHeight = rootEl.style.height;
            rootEl.style.height = "auto";
            const newHeight = rootEl.getBoundingClientRect().height;
            rootEl.style.height = originalHeight;
            ctx2.height = newHeight;
            self2.sendParent({ type: "UPDATE_HEIGHT", id: self2.id, height: newHeight, placement: ctx2.placement });
          });
        },
        setRemainingDuration(ctx2) {
          ctx2.remaining -= Date.now() - ctx2.createdAt;
        },
        setCreatedAt(ctx2) {
          ctx2.createdAt = Date.now();
        },
        notifyParentToRemove(_ctx, _evt, { self: self2 }) {
          self2.sendParent({ type: "REMOVE_TOAST", id: self2.id });
        },
        invokeOnDismiss(ctx2) {
          var _a8;
          (_a8 = ctx2.onStatusChange) == null ? void 0 : _a8.call(ctx2, { status: "dismissing" });
        },
        invokeOnUnmount(ctx2) {
          var _a8;
          (_a8 = ctx2.onStatusChange) == null ? void 0 : _a8.call(ctx2, { status: "unmounted" });
        },
        invokeOnVisible(ctx2) {
          var _a8;
          (_a8 = ctx2.onStatusChange) == null ? void 0 : _a8.call(ctx2, { status: "visible" });
        },
        setContext(ctx2, evt) {
          var _a8, _b7;
          const duration2 = (_a8 = evt.toast) == null ? void 0 : _a8.duration;
          const type2 = ((_b7 = evt.toast) == null ? void 0 : _b7.type) ?? ctx2.type;
          const computedDuration2 = getToastDuration(duration2, type2);
          Object.assign(ctx2, {
            ...evt.toast,
            duration: computedDuration2,
            remaining: computedDuration2
          });
        }
      }
    }
  );
}
function groupMachine(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "toaster",
      initial: ctx.overlap ? "overlap" : "stack",
      context: {
        dir: "ltr",
        max: Number.MAX_SAFE_INTEGER,
        gap: 16,
        pauseOnPageIdle: false,
        hotkey: ["altKey", "KeyT"],
        offsets: "1rem",
        placement: "bottom",
        removeDelay: 200,
        ...ctx,
        toasts: [],
        lastFocusedEl: null,
        isFocusWithin: false,
        heights: []
      },
      computed: {
        count: (ctx2) => ctx2.toasts.length
      },
      activities: ["trackDocumentVisibility", "trackHotKeyPress"],
      watch: {
        toasts: ["collapsedIfEmpty", "setDismissableBranch"]
      },
      exit: ["removeToasts", "clearDismissableBranch", "clearLastFocusedEl"],
      on: {
        PAUSE_TOAST: {
          actions: ["pauseToast"]
        },
        PAUSE_ALL: {
          actions: ["pauseToasts"]
        },
        RESUME_TOAST: {
          actions: ["resumeToast"]
        },
        RESUME_ALL: {
          actions: ["resumeToasts"]
        },
        ADD_TOAST: {
          guard: "isWithinRange",
          actions: ["createToast", "syncToastIndex"]
        },
        UPDATE_TOAST: {
          actions: ["updateToast"]
        },
        DISMISS_TOAST: {
          actions: ["dismissToast"]
        },
        DISMISS_ALL: {
          actions: ["dismissToasts"]
        },
        REMOVE_TOAST: {
          actions: ["removeToast", "syncToastIndex", "syncToastOffset"]
        },
        REMOVE_ALL: {
          actions: ["removeToasts"]
        },
        UPDATE_HEIGHT: {
          actions: ["syncHeights", "syncToastOffset"]
        },
        "DOC.HOTKEY": {
          actions: ["focusRegionEl"]
        },
        "REGION.BLUR": [
          {
            guard: "isOverlapping",
            target: "overlap",
            actions: ["resumeToasts", "restoreLastFocusedEl"]
          },
          {
            actions: ["resumeToasts", "restoreLastFocusedEl"]
          }
        ]
      },
      states: {
        stack: {
          entry: ["expandToasts"],
          on: {
            "REGION.POINTER_LEAVE": [
              {
                guard: "isOverlapping",
                target: "overlap",
                actions: ["resumeToasts"]
              },
              {
                actions: ["resumeToasts"]
              }
            ],
            "REGION.OVERLAP": {
              target: "overlap"
            },
            "REGION.FOCUS": {
              actions: ["setLastFocusedEl", "pauseToasts"]
            },
            "REGION.POINTER_ENTER": {
              actions: ["pauseToasts"]
            }
          }
        },
        overlap: {
          entry: ["collapseToasts"],
          on: {
            "REGION.STACK": {
              target: "stack"
            },
            "REGION.POINTER_ENTER": {
              target: "stack",
              actions: ["pauseToasts"]
            },
            "REGION.FOCUS": {
              target: "stack",
              actions: ["setLastFocusedEl", "pauseToasts"]
            }
          }
        }
      }
    },
    {
      guards: {
        isWithinRange: (ctx2) => ctx2.toasts.length < ctx2.max,
        isOverlapping: (ctx2) => !!ctx2.overlap
      },
      activities: {
        trackHotKeyPress(ctx2, _evt, { send }) {
          const handleKeyDown = (event) => {
            const isHotkeyPressed = ctx2.hotkey.every((key) => event[key] || event.code === key);
            if (!isHotkeyPressed) return;
            send({ type: "DOC.HOTKEY" });
          };
          return addDomEvent(document, "keydown", handleKeyDown, { capture: true });
        },
        trackDocumentVisibility(ctx2, _evt, { send }) {
          if (!ctx2.pauseOnPageIdle) return;
          const doc = dom33.getDoc(ctx2);
          return addDomEvent(doc, "visibilitychange", () => {
            send(doc.visibilityState === "hidden" ? "PAUSE_ALL" : "RESUME_ALL");
          });
        }
      },
      actions: {
        setDismissableBranch(ctx2) {
          var _a8;
          const currentToasts = getToastsByPlacement(ctx2.toasts, ctx2.placement);
          const hasToasts = currentToasts.length > 0;
          if (!hasToasts) {
            (_a8 = ctx2._cleanup) == null ? void 0 : _a8.call(ctx2);
            return;
          }
          if (hasToasts && ctx2._cleanup) {
            return;
          }
          const groupEl = () => dom33.getRegionEl(ctx2, ctx2.placement);
          ctx2._cleanup = trackDismissableBranch(groupEl, { defer: true });
        },
        clearDismissableBranch(ctx2) {
          var _a8;
          (_a8 = ctx2._cleanup) == null ? void 0 : _a8.call(ctx2);
        },
        focusRegionEl(ctx2) {
          queueMicrotask(() => {
            var _a8;
            (_a8 = dom33.getRegionEl(ctx2, ctx2.placement)) == null ? void 0 : _a8.focus();
          });
        },
        expandToasts(ctx2) {
          each(ctx2, (toast) => {
            toast.state.context.stacked = true;
          });
        },
        collapseToasts(ctx2) {
          each(ctx2, (toast) => {
            toast.state.context.stacked = false;
          });
        },
        collapsedIfEmpty(ctx2, _evt, { send }) {
          if (!ctx2.overlap || ctx2.toasts.length > 1) return;
          send("REGION.OVERLAP");
        },
        pauseToast(_ctx, evt, { self: self2 }) {
          self2.sendChild("PAUSE", evt.id);
        },
        pauseToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("PAUSE"));
        },
        resumeToast(_ctx, evt, { self: self2 }) {
          self2.sendChild("RESUME", evt.id);
        },
        resumeToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("RESUME"));
        },
        measureToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("MEASURE"));
        },
        createToast(ctx2, evt, { self: self2, getState }) {
          const options = {
            placement: ctx2.placement,
            duration: ctx2.duration,
            removeDelay: ctx2.removeDelay,
            ...evt.toast,
            dir: ctx2.dir,
            getRootNode: ctx2.getRootNode,
            stacked: getState().matches("stack")
          };
          const toast = createToastMachine(options);
          const actor = self2.spawn(toast);
          ctx2.toasts = [actor, ...ctx2.toasts];
        },
        updateToast(_ctx, evt, { self: self2 }) {
          self2.sendChild({ type: "UPDATE", toast: evt.toast }, evt.id);
        },
        dismissToast(_ctx, evt, { self: self2 }) {
          self2.sendChild("DISMISS", evt.id);
        },
        dismissToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("DISMISS"));
        },
        removeToast(ctx2, evt, { self: self2 }) {
          self2.stopChild(evt.id);
          ctx2.toasts = ctx2.toasts.filter((toast) => toast.id !== evt.id);
          ctx2.heights = ctx2.heights.filter((height) => height.id !== evt.id);
        },
        removeToasts(ctx2, _evt, { self: self2 }) {
          ctx2.toasts.forEach((toast) => self2.stopChild(toast.id));
          ctx2.toasts = [];
          ctx2.heights = [];
        },
        syncHeights(ctx2, evt) {
          const existing = ctx2.heights.find((height) => height.id === evt.id);
          if (existing) {
            existing.height = evt.height;
            existing.placement = evt.placement;
          } else {
            const newHeight = { id: evt.id, height: evt.height, placement: evt.placement };
            ctx2.heights = [newHeight, ...ctx2.heights];
          }
        },
        syncToastIndex(ctx2) {
          each(ctx2, (toast, index, toasts) => {
            toast.state.context.index = index;
            toast.state.context.frontmost = index === 0;
            toast.state.context.zIndex = toasts.length - index;
          });
        },
        syncToastOffset(ctx2, evt) {
          const placement = evt.placement ?? ctx2.placement;
          each({ ...ctx2, placement }, (toast) => {
            const heightIndex = Math.max(
              ctx2.heights.findIndex((height) => height.id === toast.id),
              0
            );
            const toastsHeightBefore = ctx2.heights.reduce((prev3, curr, reducerIndex) => {
              if (reducerIndex >= heightIndex) return prev3;
              return prev3 + curr.height;
            }, 0);
            toast.state.context.offset = heightIndex * ctx2.gap + toastsHeightBefore;
          });
        },
        setLastFocusedEl(ctx2, evt) {
          if (ctx2.isFocusWithin || !evt.target) return;
          ctx2.isFocusWithin = true;
          ctx2.lastFocusedEl = ref(evt.target);
        },
        restoreLastFocusedEl(ctx2) {
          ctx2.isFocusWithin = false;
          if (!ctx2.lastFocusedEl) return;
          ctx2.lastFocusedEl.focus({ preventScroll: true });
          ctx2.lastFocusedEl = null;
        },
        clearLastFocusedEl(ctx2) {
          if (!ctx2.lastFocusedEl) return;
          ctx2.lastFocusedEl.focus({ preventScroll: true });
          ctx2.lastFocusedEl = null;
          ctx2.isFocusWithin = false;
        }
      }
    }
  );
}
function each(ctx, fn) {
  const currentToasts = getToastsByPlacement(ctx.toasts, ctx.placement);
  currentToasts.forEach(fn);
}
function connect34(state2, send, normalize3) {
  const visible = state2.hasTag("visible");
  const paused = state2.hasTag("paused");
  const placement = state2.context.placement;
  const type = state2.context.type;
  const [side, align = "center"] = placement.split("-");
  return {
    type,
    title: state2.context.title,
    description: state2.context.description,
    placement,
    visible,
    paused,
    pause() {
      send("PAUSE");
    },
    resume() {
      send("RESUME");
    },
    dismiss() {
      send("DISMISS");
    },
    getRootProps() {
      return normalize3.element({
        ...parts36.root.attrs,
        dir: state2.context.dir,
        id: dom33.getRootId(state2.context),
        "data-state": visible ? "open" : "closed",
        "data-type": type,
        "data-placement": placement,
        "data-align": align,
        "data-side": side,
        "data-mounted": dataAttr(state2.context.mounted),
        "data-paused": dataAttr(paused),
        "data-first": dataAttr(state2.context.frontmost),
        "data-sibling": dataAttr(!state2.context.frontmost),
        "data-stack": dataAttr(state2.context.stacked),
        "data-overlap": dataAttr(!state2.context.stacked),
        role: "status",
        "aria-atomic": "true",
        "aria-describedby": state2.context.description ? dom33.getDescriptionId(state2.context) : void 0,
        "aria-labelledby": state2.context.title ? dom33.getTitleId(state2.context) : void 0,
        tabIndex: 0,
        style: getPlacementStyle(state2.context, visible),
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (event.key == "Escape") {
            send("DISMISS");
            event.preventDefault();
          }
        }
      });
    },
    /* Leave a ghost div to avoid setting hover to false when transitioning out */
    getGhostBeforeProps() {
      return normalize3.element({
        "data-ghost": "before",
        style: getGhostBeforeStyle(state2.context, visible)
      });
    },
    /* Needed to avoid setting hover to false when in between toasts */
    getGhostAfterProps() {
      return normalize3.element({
        "data-ghost": "after",
        style: getGhostAfterStyle()
      });
    },
    getTitleProps() {
      return normalize3.element({
        ...parts36.title.attrs,
        id: dom33.getTitleId(state2.context)
      });
    },
    getDescriptionProps() {
      return normalize3.element({
        ...parts36.description.attrs,
        id: dom33.getDescriptionId(state2.context)
      });
    },
    getActionTriggerProps() {
      return normalize3.button({
        ...parts36.actionTrigger.attrs,
        type: "button",
        onClick(event) {
          var _a8, _b7;
          if (event.defaultPrevented) return;
          (_b7 = (_a8 = state2.context.action) == null ? void 0 : _a8.onClick) == null ? void 0 : _b7.call(_a8);
          send("DISMISS");
        }
      });
    },
    getCloseTriggerProps() {
      return normalize3.button({
        id: dom33.getCloseTriggerId(state2.context),
        ...parts36.closeTrigger.attrs,
        type: "button",
        "aria-label": "Dismiss notification",
        onClick(event) {
          if (event.defaultPrevented) return;
          send("DISMISS");
        }
      });
    }
  };
}
var group = {
  connect: groupConnect,
  machine: groupMachine
};

// node_modules/@ark-ui/react/dist/components/toast/create-toaster.js
var createToaster = (props34) => {
  const machine38 = group.machine({ id: "1", ...props34 });
  const api = group.connect(machine38, machine38.send, normalizeProps);
  return { ...api, machine: machine38 };
};

// node_modules/@ark-ui/react/dist/components/toast/toast-action-trigger.js
var import_jsx_runtime364 = __toESM(require_jsx_runtime(), 1);
var import_react790 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/toast/use-toast-context.js
var [ToastProvider, useToastContext] = createContext3({
  name: "ToastContext",
  hookName: "useToastContext",
  providerName: "<ToastProvider />"
});

// node_modules/@ark-ui/react/dist/components/toast/toast-action-trigger.js
var ToastActionTrigger = (0, import_react790.forwardRef)(
  (props34, ref2) => {
    const toast = useToastContext();
    const mergedProps = mergeProps2(toast.getActionTriggerProps(), props34);
    return (0, import_jsx_runtime364.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
ToastActionTrigger.displayName = "ToastActionTrigger";

// node_modules/@ark-ui/react/dist/components/toast/toast-close-trigger.js
var import_jsx_runtime365 = __toESM(require_jsx_runtime(), 1);
var import_react792 = __toESM(require_react(), 1);
var ToastCloseTrigger = (0, import_react792.forwardRef)(
  (props34, ref2) => {
    const toast = useToastContext();
    const mergedProps = mergeProps2(toast.getCloseTriggerProps(), props34);
    return (0, import_jsx_runtime365.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
ToastCloseTrigger.displayName = "ToastCloseTrigger";

// node_modules/@ark-ui/react/dist/components/toast/toast-context.js
var ToastContext = (props34) => props34.children(useToastContext());

// node_modules/@ark-ui/react/dist/components/toast/toast-description.js
var import_jsx_runtime366 = __toESM(require_jsx_runtime(), 1);
var import_react794 = __toESM(require_react(), 1);
var ToastDescription = (0, import_react794.forwardRef)((props34, ref2) => {
  const toast = useToastContext();
  const mergedProps = mergeProps2(toast.getDescriptionProps(), props34);
  return (0, import_jsx_runtime366.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ToastDescription.displayName = "ToastDescription";

// node_modules/@ark-ui/react/dist/components/toast/toast-root.js
var import_jsx_runtime367 = __toESM(require_jsx_runtime(), 1);
var import_react796 = __toESM(require_react(), 1);
var ToastRoot = (0, import_react796.forwardRef)((props34, ref2) => {
  const toast = useToastContext();
  const mergedProps = mergeProps2(toast.getRootProps(), props34);
  return (0, import_jsx_runtime367.jsxs)("div", { ...mergedProps, ref: ref2, children: [
    (0, import_jsx_runtime367.jsx)("div", { ...toast.getGhostBeforeProps() }),
    props34.children,
    (0, import_jsx_runtime367.jsx)("div", { ...toast.getGhostAfterProps() })
  ] });
});
ToastRoot.displayName = "ToastRoot";

// node_modules/@ark-ui/react/dist/components/toast/toast-title.js
var import_jsx_runtime368 = __toESM(require_jsx_runtime(), 1);
var import_react798 = __toESM(require_react(), 1);
var ToastTitle = (0, import_react798.forwardRef)((props34, ref2) => {
  const toast = useToastContext();
  const mergedProps = mergeProps2(toast.getTitleProps(), props34);
  return (0, import_jsx_runtime368.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ToastTitle.displayName = "ToastTitle";

// node_modules/@ark-ui/react/dist/components/toast/toaster.js
var import_jsx_runtime369 = __toESM(require_jsx_runtime(), 1);
var import_react800 = __toESM(require_react(), 1);
var Toaster = (0, import_react800.forwardRef)((props34, ref2) => {
  const { toaster, children, ...rest } = props34;
  const [state2, send] = useMachine(toaster.machine);
  const placement = state2.context.placement;
  const api = group.connect(state2, send, normalizeProps);
  const toasts = api.getToastsByPlacement(placement);
  const mergedProps = mergeProps2(api.getGroupProps({ placement }), rest);
  return (0, import_jsx_runtime369.jsx)(ark.div, { ...mergedProps, ref: ref2, children: toasts.map((toast2) => (0, import_jsx_runtime369.jsx)(ToastActor, { value: toast2, children: (ctx) => children(ctx) }, toast2.id)) });
});
Toaster.displayName = "Toaster";
var ToastActor = (props34) => {
  const [state2, send] = useActor(props34.value);
  const api = connect34(state2, send, normalizeProps);
  return (0, import_jsx_runtime369.jsx)(ToastProvider, { value: api, children: props34.children(state2.context) });
};

// node_modules/@ark-ui/react/dist/components/toast/toast.js
var toast_exports = {};
__export(toast_exports, {
  ActionTrigger: () => ToastActionTrigger,
  CloseTrigger: () => ToastCloseTrigger,
  Context: () => ToastContext,
  Description: () => ToastDescription,
  Root: () => ToastRoot,
  Title: () => ToastTitle
});

// node_modules/@ark-ui/react/dist/components/toggle/toggle.js
var toggle_exports = {};
__export(toggle_exports, {
  Context: () => ToggleContext,
  Indicator: () => ToggleIndicator,
  Root: () => ToggleRoot,
  toggleAnatomy: () => toggleAnatomy
});

// node_modules/@ark-ui/react/dist/components/toggle/use-toggle-context.js
var [ToggleProvider, useToggleContext] = createContext3({
  name: "ToggleContext",
  hookName: "useToggleContext",
  providerName: "<ToggleProvider />"
});

// node_modules/@ark-ui/react/dist/components/toggle/toggle-context.js
var ToggleContext = (props34) => props34.children(useToggleContext());

// node_modules/@ark-ui/react/dist/components/toggle/toggle-indicator.js
var import_jsx_runtime370 = __toESM(require_jsx_runtime(), 1);
var import_react802 = __toESM(require_react(), 1);
var ToggleIndicator = (0, import_react802.forwardRef)((props34, ref2) => {
  const { children, fallback: fallback4, ...restProps } = props34;
  const toggle = useToggleContext();
  const mergedProps = mergeProps2(toggle.getIndicatorProps(), restProps);
  return (0, import_jsx_runtime370.jsx)(ark.div, { ...mergedProps, ref: ref2, children: toggle.pressed ? children : fallback4 });
});
ToggleIndicator.displayName = "ToggleIndicator";

// node_modules/@ark-ui/react/dist/components/toggle/toggle-root.js
var import_jsx_runtime371 = __toESM(require_jsx_runtime(), 1);
var import_react804 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/toggle/toggle.anatomy.js
var toggleAnatomy = createAnatomy("toggle", ["root", "indicator"]);
var parts37 = toggleAnatomy.build();

// node_modules/@ark-ui/react/dist/components/toggle/use-toggle.js
function useToggle(props34) {
  const { defaultPressed, pressed, onPressedChange, disabled } = props34;
  const [pressedState, setPressedState] = useControllableState2({
    defaultValue: !!defaultPressed,
    value: pressed,
    onChange: onPressedChange
  });
  return {
    pressed: pressedState,
    disabled: !!disabled,
    setPressed: setPressedState,
    getRootProps() {
      return {
        ...parts37.root.attrs,
        type: "button",
        disabled,
        "aria-pressed": pressedState,
        "data-state": pressedState ? "on" : "off",
        "data-pressed": dataAttr(pressedState),
        "data-disabled": dataAttr(disabled),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          setPressedState(!pressedState);
        }
      };
    },
    getIndicatorProps() {
      return {
        ...parts37.indicator.attrs,
        "data-disabled": dataAttr(disabled),
        "data-pressed": dataAttr(pressedState),
        "data-state": pressedState ? "on" : "off"
      };
    }
  };
}

// node_modules/@ark-ui/react/dist/components/toggle/toggle-root.js
var ToggleRoot = (0, import_react804.forwardRef)((props34, ref2) => {
  const [useToggleProps, localProps] = createSplitProps2()(props34, [
    "pressed",
    "defaultPressed",
    "disabled",
    "onPressedChange"
  ]);
  const toggle = useToggle(useToggleProps);
  const mergedProps = mergeProps2(toggle.getRootProps(), localProps);
  return (0, import_jsx_runtime371.jsx)(ToggleProvider, { value: toggle, children: (0, import_jsx_runtime371.jsx)(ark.button, { ...mergedProps, ref: ref2 }) });
});
ToggleRoot.displayName = "ToggleRoot";

// node_modules/@ark-ui/react/dist/components/toggle-group/use-toggle-group-context.js
var [ToggleGroupProvider, useToggleGroupContext] = createContext3({
  name: "ToggleGroupContext",
  hookName: "useToggleGroupContext",
  providerName: "<ToggleGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/toggle-group/toggle-group-item.js
var import_jsx_runtime372 = __toESM(require_jsx_runtime(), 1);
var import_react806 = __toESM(require_react(), 1);
var ToggleGroupItem = (0, import_react806.forwardRef)((props34, ref2) => {
  const [itemProps12, localProps] = createSplitProps2()(props34, ["value", "disabled"]);
  const toggleGroup = useToggleGroupContext();
  const mergedProps = mergeProps2(toggleGroup.getItemProps(itemProps12), localProps);
  return (0, import_jsx_runtime372.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
ToggleGroupItem.displayName = "ToggleGroupItem";

// node_modules/@ark-ui/react/dist/components/toggle-group/toggle-group-root.js
var import_jsx_runtime373 = __toESM(require_jsx_runtime(), 1);
var import_react810 = __toESM(require_react(), 1);

// node_modules/@zag-js/toggle-group/dist/index.mjs
var anatomy34 = createAnatomy("toggle-group").parts("root", "item");
var parts38 = anatomy34.build();
var dom34 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `toggle-group:${ctx.id}`;
  },
  getItemId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, value)) ?? `toggle-group:${ctx.id}:${value}`;
  },
  getRootEl: (ctx) => dom34.getById(ctx, dom34.getRootId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom34.getRootId(ctx));
    const selector = `[data-ownedby='${ownerId}']:not([data-disabled])`;
    return queryAll(dom34.getRootEl(ctx), selector);
  },
  getFirstEl: (ctx) => first(dom34.getElements(ctx)),
  getLastEl: (ctx) => last(dom34.getElements(ctx)),
  getNextEl: (ctx, id) => nextById(dom34.getElements(ctx), id, ctx.currentLoopFocus),
  getPrevEl: (ctx, id) => prevById(dom34.getElements(ctx), id, ctx.currentLoopFocus)
});
function connect35(state2, send, normalize3) {
  const value = state2.context.value;
  const disabled = state2.context.disabled;
  const isSingle = !state2.context.multiple;
  const rovingFocus = state2.context.rovingFocus;
  const isHorizontal = state2.context.orientation === "horizontal";
  function getItemState(props210) {
    const id = dom34.getItemId(state2.context, props210.value);
    return {
      id,
      disabled: Boolean(props210.disabled || disabled),
      pressed: !!value.includes(props210.value),
      focused: state2.context.focusedId === id
    };
  }
  return {
    value,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    getRootProps() {
      return normalize3.element({
        ...parts38.root.attrs,
        id: dom34.getRootId(state2.context),
        dir: state2.context.dir,
        role: isSingle ? "radiogroup" : "group",
        tabIndex: state2.context.isTabbingBackward ? -1 : 0,
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-focus": dataAttr(state2.context.focusedId != null),
        style: { outline: "none" },
        onMouseDown() {
          if (disabled) return;
          send("ROOT.MOUSE_DOWN");
        },
        onFocus(event) {
          if (disabled) return;
          const evt = event.nativeEvent || event;
          if (!isSelfTarget(evt) || !!state2.context.isClickFocus || state2.context.isTabbingBackward) return;
          send("ROOT.FOCUS");
        },
        onBlur() {
          if (disabled) return;
          send("ROOT.BLUR");
        }
      });
    },
    getItemState,
    getItemProps(props210) {
      const itemState = getItemState(props210);
      const rovingTabIndex = itemState.focused ? 0 : -1;
      return normalize3.button({
        ...parts38.item.attrs,
        id: itemState.id,
        type: "button",
        "data-ownedby": dom34.getRootId(state2.context),
        "data-focus": dataAttr(itemState.focused),
        disabled: itemState.disabled,
        tabIndex: rovingFocus ? rovingTabIndex : void 0,
        // radio
        role: isSingle ? "radio" : void 0,
        "aria-checked": isSingle ? itemState.pressed : void 0,
        "aria-pressed": isSingle ? void 0 : itemState.pressed,
        //
        "data-disabled": dataAttr(itemState.disabled),
        "data-orientation": state2.context.orientation,
        dir: state2.context.dir,
        "data-state": itemState.pressed ? "on" : "off",
        onFocus() {
          if (itemState.disabled) return;
          send({ type: "TOGGLE.FOCUS", id: itemState.id });
        },
        onClick(event) {
          if (itemState.disabled) return;
          send({ type: "TOGGLE.CLICK", id: itemState.id, value: props210.value });
          if (isSafari()) {
            event.currentTarget.focus({ preventScroll: true });
          }
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!isSelfTarget(event)) return;
          if (itemState.disabled) return;
          const keyMap2 = {
            Tab(event2) {
              const isShiftTab = event2.shiftKey;
              send({ type: "TOGGLE.SHIFT_TAB", isShiftTab });
            },
            ArrowLeft() {
              if (!rovingFocus || !isHorizontal) return;
              send("TOGGLE.FOCUS_PREV");
            },
            ArrowRight() {
              if (!rovingFocus || !isHorizontal) return;
              send("TOGGLE.FOCUS_NEXT");
            },
            ArrowUp() {
              if (!rovingFocus || isHorizontal) return;
              send("TOGGLE.FOCUS_PREV");
            },
            ArrowDown() {
              if (!rovingFocus || isHorizontal) return;
              send("TOGGLE.FOCUS_NEXT");
            },
            Home() {
              if (!rovingFocus) return;
              send("TOGGLE.FOCUS_FIRST");
            },
            End() {
              if (!rovingFocus) return;
              send("TOGGLE.FOCUS_LAST");
            }
          };
          const exec2 = keyMap2[getEventKey(event)];
          if (exec2) {
            exec2(event);
            if (event.key !== "Tab") event.preventDefault();
          }
        }
      });
    }
  };
}
var { not: not14, and: and13 } = guards;
function machine34(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "toggle-group",
      initial: "idle",
      context: {
        value: [],
        disabled: false,
        orientation: "horizontal",
        rovingFocus: true,
        loopFocus: true,
        ...ctx,
        focusedId: null,
        isTabbingBackward: false,
        isClickFocus: false,
        isWithinToolbar: false
      },
      computed: {
        currentLoopFocus: (ctx2) => ctx2.loopFocus && !ctx2.isWithinToolbar
      },
      entry: ["checkIfWithinToolbar"],
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        },
        "TOGGLE.CLICK": {
          actions: ["setValue"]
        },
        "ROOT.MOUSE_DOWN": {
          actions: ["setClickFocus"]
        }
      },
      states: {
        idle: {
          on: {
            "ROOT.FOCUS": {
              target: "focused",
              guard: not14(and13("isClickFocus", "isTabbingBackward")),
              actions: ["focusFirstToggle", "clearClickFocus"]
            },
            "TOGGLE.FOCUS": {
              target: "focused",
              actions: ["setFocusedId"]
            }
          }
        },
        focused: {
          on: {
            "ROOT.BLUR": {
              target: "idle",
              actions: ["clearIsTabbingBackward"]
            },
            "TOGGLE.FOCUS": {
              actions: ["setFocusedId"]
            },
            "TOGGLE.FOCUS_NEXT": {
              actions: ["focusNextToggle"]
            },
            "TOGGLE.FOCUS_PREV": {
              actions: ["focusPrevToggle"]
            },
            "TOGGLE.FOCUS_FIRST": {
              actions: ["focusFirstToggle"]
            },
            "TOGGLE.FOCUS_LAST": {
              actions: ["focusLastToggle"]
            },
            "TOGGLE.SHIFT_TAB": {
              target: "idle",
              actions: ["setIsTabbingBackward"]
            }
          }
        }
      }
    },
    {
      guards: {
        isClickFocus: (ctx2) => ctx2.isClickFocus,
        isTabbingBackward: (ctx2) => ctx2.isTabbingBackward
      },
      actions: {
        setIsTabbingBackward(ctx2) {
          ctx2.isTabbingBackward = true;
        },
        clearIsTabbingBackward(ctx2) {
          ctx2.isTabbingBackward = false;
        },
        setClickFocus(ctx2) {
          ctx2.isClickFocus = true;
        },
        clearClickFocus(ctx2) {
          ctx2.isClickFocus = false;
        },
        checkIfWithinToolbar(ctx2) {
          var _a8;
          const closestToolbar = (_a8 = dom34.getRootEl(ctx2)) == null ? void 0 : _a8.closest("[role=toolbar]");
          ctx2.isWithinToolbar = !!closestToolbar;
        },
        setFocusedId(ctx2, evt) {
          ctx2.focusedId = evt.id;
        },
        clearFocusedId(ctx2) {
          ctx2.focusedId = null;
        },
        setValue(ctx2, evt) {
          if (!evt.value) return;
          let next3 = Array.from(ctx2.value);
          if (ctx2.multiple) {
            next3 = next3.includes(evt.value) ? remove(next3, evt.value) : add(next3, evt.value);
          } else {
            next3 = isEqual(ctx2.value, [evt.value]) ? [] : [evt.value];
          }
          set26.value(ctx2, next3);
        },
        focusNextToggle(ctx2) {
          raf(() => {
            var _a8;
            if (!ctx2.focusedId) return;
            (_a8 = dom34.getNextEl(ctx2, ctx2.focusedId)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        focusPrevToggle(ctx2) {
          raf(() => {
            var _a8;
            if (!ctx2.focusedId) return;
            (_a8 = dom34.getPrevEl(ctx2, ctx2.focusedId)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        focusFirstToggle(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom34.getFirstEl(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        focusLastToggle(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom34.getLastEl(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        }
      }
    }
  );
}
var invoke19 = {
  change(ctx) {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value: Array.from(ctx.value) });
  }
};
var set26 = {
  value(ctx, value) {
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke19.change(ctx);
  }
};
var props30 = createProps()([
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "loopFocus",
  "multiple",
  "onValueChange",
  "orientation",
  "rovingFocus",
  "value"
]);
var splitProps30 = createSplitProps(props30);
var itemProps10 = createProps()(["value", "disabled"]);
var splitItemProps10 = createSplitProps(itemProps10);

// node_modules/@ark-ui/react/dist/components/toggle-group/use-toggle-group.js
var import_react808 = __toESM(require_react(), 1);
var useToggleGroup = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react808.useId)(),
    dir,
    getRootNode,
    value: props34.defaultValue,
    ...props34
  };
  const context = {
    ...initialContext,
    value: props34.value,
    onValueChange: useEvent(props34.onValueChange, { sync: true })
  };
  const [state2, send] = useMachine(machine34(initialContext), {
    context
  });
  return connect35(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/toggle-group/toggle-group-root.js
var ToggleGroupRoot = (0, import_react810.forwardRef)((props34, ref2) => {
  const [useToggleGroupProps, localProps] = createSplitProps2()(props34, [
    "defaultValue",
    "disabled",
    "id",
    "ids",
    "loopFocus",
    "multiple",
    "onValueChange",
    "orientation",
    "rovingFocus",
    "value"
  ]);
  const togglegroup = useToggleGroup(useToggleGroupProps);
  const mergedProps = mergeProps2(togglegroup.getRootProps(), localProps);
  return (0, import_jsx_runtime373.jsx)(ToggleGroupProvider, { value: togglegroup, children: (0, import_jsx_runtime373.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
ToggleGroupRoot.displayName = "ToggleGroupRoot";

// node_modules/@ark-ui/react/dist/components/toggle-group/toggle-group-root-provider.js
var import_jsx_runtime374 = __toESM(require_jsx_runtime(), 1);
var import_react812 = __toESM(require_react(), 1);
var ToggleGroupRootProvider = (0, import_react812.forwardRef)(
  (props34, ref2) => {
    const [{ value: toggleGroup }, localProps] = createSplitProps2()(props34, [
      "value"
    ]);
    const mergedProps = mergeProps2(toggleGroup.getRootProps(), localProps);
    return (0, import_jsx_runtime374.jsx)(ToggleGroupProvider, { value: toggleGroup, children: (0, import_jsx_runtime374.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
ToggleGroupRootProvider.displayName = "ToggleGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-arrow.js
var import_jsx_runtime375 = __toESM(require_jsx_runtime(), 1);
var import_react814 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tooltip/use-tooltip-context.js
var [TooltipProvider, useTooltipContext] = createContext3({
  name: "TooltipContext",
  hookName: "useTooltipContext",
  providerName: "<TooltipProvider />"
});

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-arrow.js
var TooltipArrow = (0, import_react814.forwardRef)((props34, ref2) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps2(tooltip.getArrowProps(), props34);
  return (0, import_jsx_runtime375.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TooltipArrow.displayName = "TooltipArrow";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-arrow-tip.js
var import_jsx_runtime376 = __toESM(require_jsx_runtime(), 1);
var import_react816 = __toESM(require_react(), 1);
var TooltipArrowTip = (0, import_react816.forwardRef)((props34, ref2) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps2(tooltip.getArrowTipProps(), props34);
  return (0, import_jsx_runtime376.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TooltipArrowTip.displayName = "TooltipArrowTip";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-content.js
var import_jsx_runtime377 = __toESM(require_jsx_runtime(), 1);
var import_react818 = __toESM(require_react(), 1);
var TooltipContent = (0, import_react818.forwardRef)((props34, ref2) => {
  const tooltip = useTooltipContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(tooltip.getContentProps(), presence.getPresenceProps(), props34);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime377.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
TooltipContent.displayName = "TooltipContent";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-context.js
var TooltipContext = (props34) => props34.children(useTooltipContext());

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-positioner.js
var import_jsx_runtime378 = __toESM(require_jsx_runtime(), 1);
var import_react820 = __toESM(require_react(), 1);
var TooltipPositioner = (0, import_react820.forwardRef)(
  (props34, ref2) => {
    const tooltip = useTooltipContext();
    const mergedProps = mergeProps2(tooltip.getPositionerProps(), props34);
    const presence = usePresenceContext();
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime378.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
TooltipPositioner.displayName = "TooltipPositioner";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-root.js
var import_jsx_runtime379 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/tooltip/dist/index.mjs
var anatomy35 = createAnatomy("tooltip").parts("trigger", "arrow", "arrowTip", "positioner", "content");
var parts39 = anatomy35.build();
var dom35 = createScope({
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `tooltip:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `tooltip:${ctx.id}:content`;
  },
  getArrowId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.arrow) ?? `tooltip:${ctx.id}:arrow`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `tooltip:${ctx.id}:popper`;
  },
  getTriggerEl: (ctx) => dom35.getById(ctx, dom35.getTriggerId(ctx)),
  getContentEl: (ctx) => dom35.getById(ctx, dom35.getContentId(ctx)),
  getPositionerEl: (ctx) => dom35.getById(ctx, dom35.getPositionerId(ctx)),
  getArrowEl: (ctx) => dom35.getById(ctx, dom35.getArrowId(ctx))
});
var store = proxy({
  id: null,
  prevId: null,
  setId(val) {
    this.prevId = this.id;
    this.id = val;
  }
});
function connect36(state2, send, normalize3) {
  const id = state2.context.id;
  const hasAriaLabel = state2.context.hasAriaLabel;
  const open = state2.hasTag("open");
  const triggerId = dom35.getTriggerId(state2.context);
  const contentId = dom35.getContentId(state2.context);
  const disabled = state2.context.disabled;
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: state2.context.currentPlacement
  });
  return {
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getTriggerProps() {
      return normalize3.button({
        ...parts39.trigger.attrs,
        id: triggerId,
        dir: state2.context.dir,
        "data-expanded": dataAttr(open),
        "data-state": open ? "open" : "closed",
        "aria-describedby": open ? contentId : void 0,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (!state2.context.closeOnClick) return;
          send({ type: "CLOSE", src: "trigger.click" });
        },
        onFocus(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (state2.event.src === "trigger.pointerdown") return;
          if (!isFocusVisible()) return;
          send({ type: "OPEN", src: "trigger.focus" });
        },
        onBlur(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (id === store.id) {
            send({ type: "CLOSE", src: "trigger.blur" });
          }
        },
        onPointerDown(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (!state2.context.closeOnPointerDown) return;
          if (id === store.id) {
            send({ type: "CLOSE", src: "trigger.pointerdown" });
          }
        },
        onPointerMove(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (event.pointerType === "touch") return;
          send("POINTER_MOVE");
        },
        onPointerLeave() {
          if (disabled) return;
          send("POINTER_LEAVE");
        },
        onPointerCancel() {
          if (disabled) return;
          send("POINTER_LEAVE");
        }
      });
    },
    getArrowProps() {
      return normalize3.element({
        id: dom35.getArrowId(state2.context),
        ...parts39.arrow.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize3.element({
        ...parts39.arrowTip.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getPositionerProps() {
      return normalize3.element({
        id: dom35.getPositionerId(state2.context),
        ...parts39.positioner.attrs,
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize3.element({
        ...parts39.content.attrs,
        dir: state2.context.dir,
        hidden: !open,
        "data-state": open ? "open" : "closed",
        role: hasAriaLabel ? void 0 : "tooltip",
        id: hasAriaLabel ? void 0 : contentId,
        "data-placement": state2.context.currentPlacement,
        onPointerEnter() {
          send("CONTENT.POINTER_MOVE");
        },
        onPointerLeave() {
          send("CONTENT.POINTER_LEAVE");
        },
        style: {
          pointerEvents: state2.context.interactive ? "auto" : "none"
        }
      });
    }
  };
}
var { and: and14, not: not15 } = guards;
function machine35(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "tooltip",
      initial: ctx.open ? "open" : "closed",
      activities: ["trackFocusVisible"],
      context: {
        openDelay: 1e3,
        closeDelay: 500,
        closeOnPointerDown: true,
        closeOnEscape: true,
        interactive: false,
        closeOnScroll: true,
        closeOnClick: true,
        disabled: false,
        ...ctx,
        currentPlacement: void 0,
        hasPointerMoveOpened: false,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        }
      },
      computed: {
        hasAriaLabel: (ctx2) => !!ctx2["aria-label"]
      },
      watch: {
        disabled: ["closeIfDisabled"],
        open: ["toggleVisibility"]
      },
      states: {
        closed: {
          tags: ["closed"],
          entry: ["clearGlobalId"],
          on: {
            "CONTROLLED.OPEN": "open",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            POINTER_LEAVE: {
              actions: ["clearPointerMoveOpened"]
            },
            POINTER_MOVE: [
              {
                guard: and14("noVisibleTooltip", not15("hasPointerMoveOpened")),
                target: "opening"
              },
              {
                guard: not15("hasPointerMoveOpened"),
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ]
          }
        },
        opening: {
          tags: ["closed"],
          activities: ["trackScroll", "trackPointerlockChange"],
          after: {
            OPEN_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            POINTER_LEAVE: [
              {
                guard: "isOpenControlled",
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["clearPointerMoveOpened", "invokeOnClose", "toggleVisibility"]
              },
              {
                target: "closed",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["invokeOnClose", "toggleVisibility"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackEscapeKey", "trackScroll", "trackPointerlockChange", "trackPositioning"],
          entry: ["setGlobalId"],
          on: {
            "CONTROLLED.CLOSE": "closed",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            POINTER_LEAVE: [
              {
                guard: "isVisible",
                target: "closing",
                actions: ["clearPointerMoveOpened"]
              },
              // == group ==
              {
                guard: "isOpenControlled",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              }
            ],
            "CONTENT.POINTER_LEAVE": {
              guard: "isInteractive",
              target: "closing"
            },
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackStore", "trackPositioning"],
          after: {
            CLOSE_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          },
          on: {
            "CONTROLLED.CLOSE": "closed",
            "CONTROLLED.OPEN": "open",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            POINTER_MOVE: [
              {
                guard: "isOpenControlled",
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["setPointerMoveOpened", "invokeOnOpen", "toggleVisibility"]
              },
              {
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ],
            "CONTENT.POINTER_MOVE": {
              guard: "isInteractive",
              target: "open"
            },
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        }
      }
    },
    {
      activities: {
        trackFocusVisible(ctx2) {
          return trackFocusVisible({ root: dom35.getRootNode(ctx2) });
        },
        trackPositioning(ctx2) {
          ctx2.currentPlacement || (ctx2.currentPlacement = ctx2.positioning.placement);
          const getPositionerEl = () => dom35.getPositionerEl(ctx2);
          return getPlacement(dom35.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackPointerlockChange(ctx2, _evt, { send }) {
          const onChange = () => send({ type: "CLOSE", src: "pointerlock:change" });
          return addDomEvent(dom35.getDoc(ctx2), "pointerlockchange", onChange, false);
        },
        trackScroll(ctx2, _evt, { send }) {
          if (!ctx2.closeOnScroll) return;
          const triggerEl = dom35.getTriggerEl(ctx2);
          if (!triggerEl) return;
          const overflowParents = getOverflowAncestors(triggerEl);
          const cleanups2 = overflowParents.map((overflowParent) => {
            const onScroll = () => {
              send({ type: "CLOSE", src: "scroll" });
            };
            return addDomEvent(overflowParent, "scroll", onScroll, { passive: true, capture: true });
          });
          return () => {
            cleanups2.forEach((fn) => fn == null ? void 0 : fn());
          };
        },
        trackStore(ctx2, _evt, { send }) {
          return subscribe(store, () => {
            if (store.id !== ctx2.id) {
              send({ type: "CLOSE", src: "id.change" });
            }
          });
        },
        trackEscapeKey(ctx2, _evt, { send }) {
          if (!ctx2.closeOnEscape) return;
          const onKeyDown = (event) => {
            if (isComposingEvent(event)) return;
            if (event.key !== "Escape") return;
            event.stopPropagation();
            send({ type: "CLOSE", src: "keydown.escape" });
          };
          return addDomEvent(dom35.getDoc(ctx2), "keydown", onKeyDown, true);
        }
      },
      actions: {
        setGlobalId(ctx2) {
          store.setId(ctx2.id);
        },
        clearGlobalId(ctx2) {
          if (ctx2.id === store.id) {
            store.setId(null);
          }
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        closeIfDisabled(ctx2, _evt, { send }) {
          if (!ctx2.disabled) return;
          send({ type: "CLOSE", src: "disabled.change" });
        },
        reposition(ctx2, evt) {
          const getPositionerEl = () => dom35.getPositionerEl(ctx2);
          getPlacement(dom35.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, evt, { send }) {
          queueMicrotask(() => {
            send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
          });
        },
        setPointerMoveOpened(ctx2) {
          ctx2.hasPointerMoveOpened = true;
        },
        clearPointerMoveOpened(ctx2) {
          ctx2.hasPointerMoveOpened = false;
        }
      },
      guards: {
        noVisibleTooltip: () => store.id === null,
        isVisible: (ctx2) => ctx2.id === store.id,
        isInteractive: (ctx2) => ctx2.interactive,
        hasPointerMoveOpened: (ctx2) => !!ctx2.hasPointerMoveOpened,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      delays: {
        OPEN_DELAY: (ctx2) => ctx2.openDelay,
        CLOSE_DELAY: (ctx2) => ctx2.closeDelay
      }
    }
  );
}
var props31 = createProps()([
  "aria-label",
  "closeDelay",
  "closeOnEscape",
  "closeOnPointerDown",
  "closeOnScroll",
  "closeOnClick",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "interactive",
  "onOpenChange",
  "open.controlled",
  "open",
  "openDelay",
  "positioning"
]);
var splitProps31 = createSplitProps(props31);

// node_modules/@ark-ui/react/dist/components/tooltip/use-tooltip.js
var import_react822 = __toESM(require_react(), 1);
var useTooltip = (props34 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react822.useId)(),
    dir,
    getRootNode,
    open: props34.defaultOpen,
    "open.controlled": props34.open !== void 0,
    ...props34
  };
  const context = {
    ...initialContext,
    onOpenChange: useEvent(props34.onOpenChange, { sync: true })
  };
  const [state2, send] = useMachine(machine35(initialContext), { context });
  return connect36(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-root.js
var TooltipRoot = (props34) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props34);
  const tooltip = useTooltip(localProps);
  const presence = usePresence(mergeProps2({ present: tooltip.open }, presenceProps));
  return (0, import_jsx_runtime379.jsx)(TooltipProvider, { value: tooltip, children: (0, import_jsx_runtime379.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-root-provider.js
var import_jsx_runtime380 = __toESM(require_jsx_runtime(), 1);
var TooltipRootProvider = (props34) => {
  const [presenceProps, { value: tooltip, children }] = splitPresenceProps(props34);
  const presence = usePresence(mergeProps2({ present: tooltip.open }, presenceProps));
  return (0, import_jsx_runtime380.jsx)(TooltipProvider, { value: tooltip, children: (0, import_jsx_runtime380.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-trigger.js
var import_jsx_runtime381 = __toESM(require_jsx_runtime(), 1);
var import_react826 = __toESM(require_react(), 1);
var TooltipTrigger = (0, import_react826.forwardRef)((props34, ref2) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps2(tooltip.getTriggerProps(), props34);
  return (0, import_jsx_runtime381.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
TooltipTrigger.displayName = "TooltipTrigger";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip.js
var tooltip_exports = {};
__export(tooltip_exports, {
  Arrow: () => TooltipArrow,
  ArrowTip: () => TooltipArrowTip,
  Content: () => TooltipContent,
  Context: () => TooltipContext,
  Positioner: () => TooltipPositioner,
  Root: () => TooltipRoot,
  RootProvider: () => TooltipRootProvider,
  Trigger: () => TooltipTrigger
});

// node_modules/@ark-ui/react/dist/components/tour/tour-action-trigger.js
var import_jsx_runtime382 = __toESM(require_jsx_runtime(), 1);
var import_react828 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tour/use-tour-context.js
var [TourProvider, useTourContext] = createContext3({
  name: "TourContext",
  hookName: "useTourContext",
  providerName: "<TourProvider />"
});

// node_modules/@ark-ui/react/dist/components/tour/tour-action-trigger.js
var TourActionTrigger = (0, import_react828.forwardRef)(
  (props34, ref2) => {
    const [actionTriggerProps, localProps] = createSplitProps2()(props34, [
      "action"
    ]);
    const tour = useTourContext();
    const mergedProps = mergeProps2(tour.getActionTriggerProps(actionTriggerProps), localProps);
    return (0, import_jsx_runtime382.jsx)(ark.button, { ...mergedProps, ref: ref2, children: mergedProps.children || actionTriggerProps.action.label });
  }
);
TourActionTrigger.displayName = "TourActionTrigger";

// node_modules/@ark-ui/react/dist/components/tour/tour-arrow.js
var import_jsx_runtime383 = __toESM(require_jsx_runtime(), 1);
var import_react830 = __toESM(require_react(), 1);
var TourArrow = (0, import_react830.forwardRef)((props34, ref2) => {
  var _a8;
  const tour = useTourContext();
  const mergedProps = mergeProps2(tour.getArrowProps(), props34);
  return ((_a8 = tour.step) == null ? void 0 : _a8.arrow) ? (0, import_jsx_runtime383.jsx)(ark.div, { ...mergedProps, ref: ref2 }) : null;
});
TourArrow.displayName = "TourArrow";

// node_modules/@ark-ui/react/dist/components/tour/tour-arrow-tip.js
var import_jsx_runtime384 = __toESM(require_jsx_runtime(), 1);
var import_react832 = __toESM(require_react(), 1);
var TourArrowTip = (0, import_react832.forwardRef)((props34, ref2) => {
  const tour = useTourContext();
  const mergedProps = mergeProps2(tour.getArrowTipProps(), props34);
  return (0, import_jsx_runtime384.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TourArrowTip.displayName = "TourArrowTip";

// node_modules/@ark-ui/react/dist/components/tour/tour-backdrop.js
var import_jsx_runtime385 = __toESM(require_jsx_runtime(), 1);
var import_react834 = __toESM(require_react(), 1);
var TourBackdrop = (0, import_react834.forwardRef)((props34, ref2) => {
  var _a8;
  const tour = useTourContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const presence = usePresence({
    ...renderStrategyProps,
    present: tour.open
  });
  const mergedProps = mergeProps2(tour.getBackdropProps(), presence.getPresenceProps(), props34);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime385.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2), hidden: !((_a8 = tour.step) == null ? void 0 : _a8.backdrop) });
});
TourBackdrop.displayName = "TourBackdrop";

// node_modules/@ark-ui/react/dist/components/tour/tour-close-trigger.js
var import_jsx_runtime386 = __toESM(require_jsx_runtime(), 1);
var import_react836 = __toESM(require_react(), 1);
var TourCloseTrigger = (0, import_react836.forwardRef)(
  (props34, ref2) => {
    const tour = useTourContext();
    const mergedProps = mergeProps2(tour.getCloseTriggerProps(), props34);
    return (0, import_jsx_runtime386.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
TourCloseTrigger.displayName = "TourCloseTrigger";

// node_modules/@ark-ui/react/dist/components/tour/tour-content.js
var import_jsx_runtime387 = __toESM(require_jsx_runtime(), 1);
var import_react838 = __toESM(require_react(), 1);
var TourContent = (0, import_react838.forwardRef)((props34, ref2) => {
  const tour = useTourContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(tour.getContentProps(), presence.getPresenceProps(), props34);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime387.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
TourContent.displayName = "TourContent";

// node_modules/@ark-ui/react/dist/components/tour/tour-control.js
var import_jsx_runtime388 = __toESM(require_jsx_runtime(), 1);
var import_react839 = __toESM(require_react(), 1);

// node_modules/@zag-js/tour/dist/index.mjs
var anatomy36 = createAnatomy("tour").parts(
  "content",
  "actionTrigger",
  "closeTrigger",
  "progressText",
  "title",
  "description",
  "positioner",
  "arrow",
  "arrowTip",
  "backdrop",
  "spotlight"
);
var parts40 = anatomy36.build();
var dom36 = createScope({
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `tour-positioner-${ctx.id}`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `tour-content-${ctx.id}`;
  },
  getTitleId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.title) ?? `tour-title-${ctx.id}`;
  },
  getDescriptionId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.description) ?? `tour-desc-${ctx.id}`;
  },
  getArrowId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.arrow) ?? `tour-arrow-${ctx.id}`;
  },
  getBackdropId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.backdrop) ?? `tour-backdrop-${ctx.id}`;
  },
  getContentEl: (ctx) => dom36.getById(ctx, dom36.getContentId(ctx)),
  getPositionerEl: (ctx) => dom36.getById(ctx, dom36.getPositionerId(ctx)),
  getBackdropEl: (ctx) => dom36.getById(ctx, dom36.getBackdropId(ctx))
});
var { and: and15 } = guards;
var props32 = createProps()([
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "keyboardNavigation",
  "onFocusOutside",
  "onInteractOutside",
  "onPointerDownOutside",
  "onStatusChange",
  "onStepChange",
  "preventInteraction",
  "spotlightOffset",
  "spotlightRadius",
  "stepId",
  "steps",
  "translations"
]);
var splitProps32 = createSplitProps(props32);

// node_modules/@ark-ui/react/dist/components/tour/tour.anatomy.js
var tourAnatomy = anatomy36.extendWith("control");

// node_modules/@ark-ui/react/dist/components/tour/tour-control.js
var TourControl = (0, import_react839.forwardRef)((props34, ref2) => (0, import_jsx_runtime388.jsx)(ark.div, { ...tourAnatomy.build().control.attrs, ...props34, ref: ref2 }));
TourControl.displayName = "TourControl";

// node_modules/@ark-ui/react/dist/components/tour/tour-description.js
var import_jsx_runtime389 = __toESM(require_jsx_runtime(), 1);
var import_react841 = __toESM(require_react(), 1);
var TourDescription = (0, import_react841.forwardRef)((props34, ref2) => {
  var _a8;
  const tour = useTourContext();
  const mergedProps = mergeProps2(tour.getDescriptionProps(), props34);
  return (0, import_jsx_runtime389.jsx)(ark.div, { ...mergedProps, ref: ref2, children: mergedProps.children || ((_a8 = tour.step) == null ? void 0 : _a8.description) });
});
TourDescription.displayName = "TourDescription";

// node_modules/@ark-ui/react/dist/components/tour/tour-positioner.js
var import_jsx_runtime390 = __toESM(require_jsx_runtime(), 1);
var import_react843 = __toESM(require_react(), 1);
var TourPositioner = (0, import_react843.forwardRef)((props34, ref2) => {
  const tour = useTourContext();
  const mergedProps = mergeProps2(tour.getPositionerProps(), props34);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime390.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TourPositioner.displayName = "TourPositioner";

// node_modules/@ark-ui/react/dist/components/tour/tour-progress-text.js
var import_jsx_runtime391 = __toESM(require_jsx_runtime(), 1);
var import_react845 = __toESM(require_react(), 1);
var TourProgressText = (0, import_react845.forwardRef)((props34, ref2) => {
  const tour = useTourContext();
  const mergedProps = mergeProps2(tour.getProgressTextProps(), props34);
  return (0, import_jsx_runtime391.jsx)(ark.div, { ...mergedProps, ref: ref2, children: mergedProps.children || tour.getProgressText() });
});
TourProgressText.displayName = "TourProgressText";

// node_modules/@ark-ui/react/dist/components/tour/tour-root.js
var import_jsx_runtime392 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/tour/tour-spotlight.js
var import_jsx_runtime393 = __toESM(require_jsx_runtime(), 1);
var import_react848 = __toESM(require_react(), 1);
var TourSpotlight = (0, import_react848.forwardRef)((props34, ref2) => {
  var _a8, _b7;
  const tour = useTourContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const presence = usePresence({
    ...renderStrategyProps,
    present: tour.open
  });
  const mergedProps = mergeProps2(tour.getSpotlightProps(), presence.getPresenceProps(), props34);
  const hidden = !tour.open || !((_b7 = (_a8 = tour.step) == null ? void 0 : _a8.target) == null ? void 0 : _b7.call(_a8));
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime393.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2), hidden });
});
TourSpotlight.displayName = "TourSpotlight";

// node_modules/@ark-ui/react/dist/components/tour/tour-title.js
var import_jsx_runtime394 = __toESM(require_jsx_runtime(), 1);
var import_react850 = __toESM(require_react(), 1);
var TourTitle = (0, import_react850.forwardRef)((props34, ref2) => {
  var _a8;
  const tour = useTourContext();
  const mergedProps = mergeProps2(tour.getTitleProps(), props34);
  return (0, import_jsx_runtime394.jsx)(ark.h2, { ...mergedProps, ref: ref2, children: mergedProps.children || ((_a8 = tour.step) == null ? void 0 : _a8.title) });
});
TourTitle.displayName = "TourTitle";

// node_modules/@ark-ui/react/dist/components/tour/use-tour.js
var import_react852 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch.js
var import_jsx_runtime395 = __toESM(require_jsx_runtime(), 1);
var import_react854 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tree-view/use-tree-view-context.js
var [TreeViewProvider, useTreeViewContext] = createContext3({
  name: "TreeViewContext",
  hookName: "useTreeViewContext",
  providerName: "<TreeViewProvider />"
});

// node_modules/@ark-ui/react/dist/components/tree-view/use-tree-view-node-props-context.js
var [TreeViewNodePropsProvider, useTreeViewNodePropsContext] = createContext3({
  name: "TreeViewNodePropsContext",
  hookName: "useTreeViewNodePropsContext",
  providerName: "<TreeViewItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch.js
var TreeViewBranch = (0, import_react854.forwardRef)((props34, ref2) => {
  const treeView = useTreeViewContext();
  const nodeProps = useTreeViewNodePropsContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const node2 = treeView.getNodeState(nodeProps);
  const mergedProps = mergeProps2(treeView.getBranchProps(nodeProps), props34);
  const branchContentProps = treeView.getBranchContentProps(nodeProps);
  return (0, import_jsx_runtime395.jsx)(
    CollapsibleRoot,
    {
      ref: ref2,
      open: node2.expanded,
      ids: { content: branchContentProps.id },
      ...renderStrategyProps,
      ...mergedProps
    }
  );
});
TreeViewBranch.displayName = "TreeViewBranch";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch-content.js
var import_jsx_runtime396 = __toESM(require_jsx_runtime(), 1);
var import_react856 = __toESM(require_react(), 1);
var splitVisibilityProps2 = createSplitProps2();
var TreeViewBranchContent = (0, import_react856.forwardRef)(
  (props34, ref2) => {
    const treeView = useTreeViewContext();
    const nodeProps = useTreeViewNodePropsContext();
    const contentProps2 = treeView.getBranchContentProps(nodeProps);
    const [, branchContentProps] = splitVisibilityProps2(contentProps2, ["hidden", "data-state"]);
    const mergedProps = mergeProps2(branchContentProps, props34);
    return (0, import_jsx_runtime396.jsx)(CollapsibleContent, { ref: ref2, ...mergedProps });
  }
);
TreeViewBranchContent.displayName = "TreeViewBranchContent";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch-control.js
var import_jsx_runtime397 = __toESM(require_jsx_runtime(), 1);
var import_react858 = __toESM(require_react(), 1);
var TreeViewBranchControl = (0, import_react858.forwardRef)(
  (props34, ref2) => {
    const treeView = useTreeViewContext();
    const nodeProps = useTreeViewNodePropsContext();
    const mergedProps = mergeProps2(treeView.getBranchControlProps(nodeProps), props34);
    return (0, import_jsx_runtime397.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
TreeViewBranchControl.displayName = "TreeViewBranchControl";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch-indent-guide.js
var import_jsx_runtime398 = __toESM(require_jsx_runtime(), 1);
var import_react860 = __toESM(require_react(), 1);
var TreeViewBranchIndentGuide = (0, import_react860.forwardRef)(
  (props34, ref2) => {
    const treeView = useTreeViewContext();
    const nodeProps = useTreeViewNodePropsContext();
    const mergedProps = mergeProps2(treeView.getBranchIndentGuideProps(nodeProps), props34);
    return (0, import_jsx_runtime398.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
TreeViewBranchIndentGuide.displayName = "TreeViewBranchIndentGuide";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch-indicator.js
var import_jsx_runtime399 = __toESM(require_jsx_runtime(), 1);
var import_react862 = __toESM(require_react(), 1);
var TreeViewBranchIndicator = (0, import_react862.forwardRef)(
  (props34, ref2) => {
    const treeView = useTreeViewContext();
    const nodeProps = useTreeViewNodePropsContext();
    const mergedProps = mergeProps2(treeView.getBranchIndicatorProps(nodeProps), props34);
    return (0, import_jsx_runtime399.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
TreeViewBranchIndicator.displayName = "TreeViewBranchIndicator";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch-text.js
var import_jsx_runtime400 = __toESM(require_jsx_runtime(), 1);
var import_react864 = __toESM(require_react(), 1);
var TreeViewBranchText = (0, import_react864.forwardRef)(
  (props34, ref2) => {
    const treeView = useTreeViewContext();
    const nodeProps = useTreeViewNodePropsContext();
    const mergedProps = mergeProps2(treeView.getBranchTextProps(nodeProps), props34);
    return (0, import_jsx_runtime400.jsx)(ark.span, { ...mergedProps, ref: ref2 });
  }
);
TreeViewBranchText.displayName = "TreeViewBranchText";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch-trigger.js
var import_jsx_runtime401 = __toESM(require_jsx_runtime(), 1);
var import_react866 = __toESM(require_react(), 1);
var TreeViewBranchTrigger = (0, import_react866.forwardRef)(
  (props34, ref2) => {
    const treeView = useTreeViewContext();
    const nodeProps = useTreeViewNodePropsContext();
    const mergedProps = mergeProps2(treeView.getBranchTriggerProps(nodeProps), props34);
    return (0, import_jsx_runtime401.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
TreeViewBranchTrigger.displayName = "TreeViewBranchTrigger";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-item.js
var import_jsx_runtime402 = __toESM(require_jsx_runtime(), 1);
var import_react868 = __toESM(require_react(), 1);
var TreeViewItem = (0, import_react868.forwardRef)((props34, ref2) => {
  const treeView = useTreeViewContext();
  const nodeProps = useTreeViewNodePropsContext();
  const mergedProps = mergeProps2(treeView.getItemProps(nodeProps), props34);
  return (0, import_jsx_runtime402.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TreeViewItem.displayName = "TreeViewItem";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-item-indicator.js
var import_jsx_runtime403 = __toESM(require_jsx_runtime(), 1);
var import_react870 = __toESM(require_react(), 1);
var TreeViewItemIndicator = (0, import_react870.forwardRef)(
  (props34, ref2) => {
    const treeView = useTreeViewContext();
    const nodeProps = useTreeViewNodePropsContext();
    const mergedProps = mergeProps2(treeView.getItemIndicatorProps(nodeProps), props34);
    return (0, import_jsx_runtime403.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
TreeViewItemIndicator.displayName = "TreeViewItemIndicator";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-item-text.js
var import_jsx_runtime404 = __toESM(require_jsx_runtime(), 1);
var import_react872 = __toESM(require_react(), 1);
var TreeViewItemText = (0, import_react872.forwardRef)((props34, ref2) => {
  const treeView = useTreeViewContext();
  const nodeProps = useTreeViewNodePropsContext();
  const mergedProps = mergeProps2(treeView.getItemTextProps(nodeProps), props34);
  return (0, import_jsx_runtime404.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
TreeViewItemText.displayName = "TreeViewItemText";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-label.js
var import_jsx_runtime405 = __toESM(require_jsx_runtime(), 1);
var import_react874 = __toESM(require_react(), 1);
var TreeViewLabel = (0, import_react874.forwardRef)((props34, ref2) => {
  const treeView = useTreeViewContext();
  const mergedProps = mergeProps2(treeView.getLabelProps(), props34);
  return (0, import_jsx_runtime405.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
TreeViewLabel.displayName = "TreeViewLabel";

// node_modules/@ark-ui/react/dist/components/tree-view/use-tree-view-node-context.js
var [TreeViewNodeProvider, useTreeViewNodeContext] = createContext3(
  {
    name: "TreeViewNodeContext",
    hookName: "useTreeViewNodeContext",
    providerName: "<TreeViewNodeProvider />"
  }
);

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-node-provider.js
var import_jsx_runtime406 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-root.js
var import_jsx_runtime407 = __toESM(require_jsx_runtime(), 1);
var import_react878 = __toESM(require_react(), 1);

// node_modules/@zag-js/tree-view/dist/index.mjs
var anatomy37 = createAnatomy("tree-view").parts(
  "root",
  "label",
  "tree",
  "item",
  "itemIndicator",
  "itemText",
  "branch",
  "branchControl",
  "branchTrigger",
  "branchContent",
  "branchText",
  "branchIndicator",
  "branchIndentGuide"
);
var parts41 = anatomy37.build();
var collection3 = (options) => {
  return ref(new TreeCollection(options));
};
collection3.empty = () => {
  return ref(new TreeCollection({ rootNode: { children: [] } }));
};
function skipFn(ctx) {
  return function skip({ indexPath }) {
    const paths = ctx.collection.getValuePath(indexPath).slice(0, -1);
    return paths.some((value) => !ctx.expandedValue.includes(value));
  };
}
function getVisibleNodes(ctx) {
  const nodes = [];
  ctx.collection.visit({
    skip: skipFn(ctx),
    onEnter: (node2, indexPath) => {
      nodes.push({ node: node2, indexPath });
    }
  });
  return nodes;
}
var dom37 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `tree:${ctx.id}:root`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `tree:${ctx.id}:label`;
  },
  getNodeId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.node) == null ? void 0 : _b7.call(_a8, value)) ?? `tree:${ctx.id}:node:${value}`;
  },
  getTreeId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.tree) ?? `tree:${ctx.id}:tree`;
  },
  getTreeEl: (ctx) => dom37.getById(ctx, dom37.getTreeId(ctx)),
  focusNode: (ctx, value) => {
    var _a8;
    if (value == null) return;
    const nodeId = dom37.getNodeId(ctx, value);
    (_a8 = dom37.getById(ctx, nodeId)) == null ? void 0 : _a8.focus({ preventScroll: true });
  },
  getMatchingNode(ctx, key) {
    const nodes = getVisibleNodes(ctx);
    const elements = nodes.map(({ node: node2 }) => ({
      textContent: ctx.collection.stringifyNode(node2),
      id: ctx.collection.getNodeValue(node2)
    }));
    return getByTypeahead(elements, {
      state: ctx.typeaheadState,
      key,
      activeId: ctx.focusedValue
    });
  }
});
function connect38(state2, send, normalize3) {
  const collection22 = state2.context.collection;
  const expandedValue = Array.from(state2.context.expandedValue);
  const selectedValue = Array.from(state2.context.selectedValue);
  const isTypingAhead = state2.context.isTypingAhead;
  const focusedValue = state2.context.focusedValue;
  function getNodeState(props210) {
    const { node: node2, indexPath } = props210;
    const value = collection22.getNodeValue(node2);
    return {
      value,
      valuePath: collection22.getValuePath(indexPath),
      disabled: Boolean(node2.disabled),
      focused: focusedValue == null ? isEqual(indexPath, [0]) : focusedValue === value,
      selected: selectedValue.includes(value),
      expanded: expandedValue.includes(value),
      depth: indexPath.length,
      isBranch: collection22.isBranchNode(node2)
    };
  }
  return {
    collection: collection22,
    expandedValue,
    selectedValue,
    expand(value) {
      if (!value) return send({ type: "EXPANDED.ALL" });
      const _expandedValue = uniq(expandedValue.concat(...value));
      send({ type: "EXPANDED.SET", value: _expandedValue, src: "expand" });
    },
    collapse(value) {
      if (!value) return send({ type: "EXPANDED.SET", value: [], src: "collapseAll" });
      const _expandedValue = uniq(remove(expandedValue, ...value));
      send({ type: "EXPANDED.SET", value: _expandedValue, src: "collapse" });
    },
    deselect(value) {
      if (!value) return send({ type: "SELECTED.SET", value: [], src: "deselectAll" });
      const _selectedValue = uniq(remove(selectedValue, ...value));
      send({ type: "SELECTED.SET", value: _selectedValue, src: "deselect" });
    },
    select(value) {
      if (!value) return send({ type: "SELECTED.ALL" });
      const nextValue = [];
      if (state2.context.selectionMode === "single") {
        if (value.length > 0) nextValue.push(value[value.length - 1]);
      } else {
        nextValue.push(...selectedValue, ...value);
      }
      send({ type: "SELECTED.SET", value: nextValue, src: "select" });
    },
    getVisibleNodes() {
      return getVisibleNodes(state2.context);
    },
    focus(value) {
      dom37.focusNode(state2.context, value);
    },
    selectParent(value) {
      const parentNode = collection22.getParentNode(value);
      if (!parentNode) return;
      const _selectedValue = add(selectedValue, collection22.getNodeValue(parentNode));
      send({ type: "SELECTED.SET", value: _selectedValue, src: "select.parent" });
    },
    expandParent(value) {
      const parentNode = collection22.getParentNode(value);
      if (!parentNode) return;
      const _expandedValue = add(expandedValue, collection22.getNodeValue(parentNode));
      send({ type: "EXPANDED.SET", value: _expandedValue, src: "expand.parent" });
    },
    setExpandedValue(value) {
      const _expandedValue = uniq(value);
      send({ type: "EXPANDED.SET", value: _expandedValue });
    },
    setSelectedValue(value) {
      const _selectedValue = uniq(value);
      send({ type: "SELECTED.SET", value: _selectedValue });
    },
    getRootProps() {
      return normalize3.element({
        ...parts41.root.attrs,
        id: dom37.getRootId(state2.context),
        dir: state2.context.dir
      });
    },
    getLabelProps() {
      return normalize3.element({
        ...parts41.label.attrs,
        id: dom37.getLabelId(state2.context),
        dir: state2.context.dir
      });
    },
    getTreeProps() {
      return normalize3.element({
        ...parts41.tree.attrs,
        id: dom37.getTreeId(state2.context),
        dir: state2.context.dir,
        role: "tree",
        "aria-label": "Tree View",
        "aria-labelledby": dom37.getLabelId(state2.context),
        "aria-multiselectable": state2.context.selectionMode === "multiple" || void 0,
        tabIndex: -1,
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          const target = getEventTarget(event);
          if (isEditableElement(target)) return;
          const node2 = target == null ? void 0 : target.closest("[data-part=branch-control], [data-part=item]");
          if (!node2) return;
          const nodeId = node2.dataset.value;
          if (nodeId == null) {
            console.warn(`[zag-js/tree-view] Node id not found for node`, node2);
            return;
          }
          const isBranchNode = node2.matches("[data-part=branch-control]");
          const keyMap2 = {
            ArrowDown(event2) {
              if (isModifierKey(event2)) return;
              event2.preventDefault();
              send({ type: "NODE.ARROW_DOWN", id: nodeId, shiftKey: event2.shiftKey });
            },
            ArrowUp(event2) {
              if (isModifierKey(event2)) return;
              event2.preventDefault();
              send({ type: "NODE.ARROW_UP", id: nodeId, shiftKey: event2.shiftKey });
            },
            ArrowLeft(event2) {
              if (isModifierKey(event2) || node2.dataset.disabled) return;
              event2.preventDefault();
              send({ type: isBranchNode ? "BRANCH_NODE.ARROW_LEFT" : "NODE.ARROW_LEFT", id: nodeId });
            },
            ArrowRight(event2) {
              if (!isBranchNode || node2.dataset.disabled) return;
              event2.preventDefault();
              send({ type: "BRANCH_NODE.ARROW_RIGHT", id: nodeId });
            },
            Home(event2) {
              if (isModifierKey(event2)) return;
              event2.preventDefault();
              send({ type: "NODE.HOME", id: nodeId, shiftKey: event2.shiftKey });
            },
            End(event2) {
              if (isModifierKey(event2)) return;
              event2.preventDefault();
              send({ type: "NODE.END", id: nodeId, shiftKey: event2.shiftKey });
            },
            Space(event2) {
              var _a8;
              if (node2.dataset.disabled) return;
              if (isTypingAhead) {
                send({ type: "TREE.TYPEAHEAD", key: event2.key });
              } else {
                (_a8 = keyMap2.Enter) == null ? void 0 : _a8.call(keyMap2, event2);
              }
            },
            Enter(event2) {
              if (node2.dataset.disabled) return;
              const isLink = target == null ? void 0 : target.closest("a[href]");
              if (!isLink) event2.preventDefault();
              send({ type: isBranchNode ? "BRANCH_NODE.CLICK" : "NODE.CLICK", id: nodeId, src: "keyboard" });
            },
            "*"(event2) {
              if (node2.dataset.disabled) return;
              event2.preventDefault();
              send({ type: "SIBLINGS.EXPAND", id: nodeId });
            },
            a(event2) {
              if (!event2.metaKey || node2.dataset.disabled) return;
              event2.preventDefault();
              send({ type: "SELECTED.ALL", moveFocus: true });
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            exec2(event);
            return;
          }
          if (!state2.context.typeahead) return;
          const isValidTypeahead = event.key.length === 1 && !isModifierKey(event);
          if (!isValidTypeahead) return;
          send({ type: "TREE.TYPEAHEAD", key: event.key, id: nodeId });
          event.preventDefault();
        }
      });
    },
    getNodeState,
    getItemProps(props210) {
      const itemState = getNodeState(props210);
      return normalize3.element({
        ...parts41.item.attrs,
        id: dom37.getNodeId(state2.context, itemState.value),
        dir: state2.context.dir,
        "data-ownedby": dom37.getTreeId(state2.context),
        "data-path": props210.indexPath.join("/"),
        "data-value": itemState.value,
        tabIndex: itemState.focused ? 0 : -1,
        "data-focus": dataAttr(itemState.focused),
        role: "treeitem",
        "aria-current": itemState.selected ? "true" : void 0,
        "aria-selected": itemState.disabled ? void 0 : itemState.selected,
        "data-selected": dataAttr(itemState.selected),
        "aria-disabled": itemState.disabled,
        "data-disabled": dataAttr(itemState.disabled),
        "aria-level": itemState.depth,
        "data-depth": itemState.depth,
        style: {
          "--depth": itemState.depth
        },
        onFocus(event) {
          event.stopPropagation();
          send({ type: "NODE.FOCUS", id: itemState.value });
        },
        onClick(event) {
          if (itemState.disabled) return;
          const isMetaKey = event.metaKey || event.ctrlKey;
          send({ type: "NODE.CLICK", id: itemState.value, shiftKey: event.shiftKey, ctrlKey: isMetaKey });
          event.stopPropagation();
          const isLink = event.currentTarget.matches("a[href]");
          if (!isLink) event.preventDefault();
        }
      });
    },
    getItemTextProps(props210) {
      const itemState = getNodeState(props210);
      return normalize3.element({
        ...parts41.itemText.attrs,
        "data-disabled": dataAttr(itemState.disabled),
        "data-selected": dataAttr(itemState.selected),
        "data-focus": dataAttr(itemState.focused)
      });
    },
    getItemIndicatorProps(props210) {
      const itemState = getNodeState(props210);
      return normalize3.element({
        ...parts41.itemIndicator.attrs,
        "aria-hidden": true,
        "data-disabled": dataAttr(itemState.disabled),
        "data-selected": dataAttr(itemState.selected),
        "data-focus": dataAttr(itemState.focused),
        hidden: !itemState.selected
      });
    },
    getBranchProps(props210) {
      const nodeState = getNodeState(props210);
      return normalize3.element({
        ...parts41.branch.attrs,
        "data-depth": nodeState.depth,
        dir: state2.context.dir,
        "data-branch": nodeState.value,
        role: "treeitem",
        "data-ownedby": dom37.getTreeId(state2.context),
        "data-value": nodeState.value,
        "aria-level": nodeState.depth,
        "aria-selected": nodeState.disabled ? void 0 : nodeState.selected,
        "data-path": props210.indexPath.join("/"),
        "data-selected": dataAttr(nodeState.selected),
        "aria-expanded": nodeState.expanded,
        "data-state": nodeState.expanded ? "open" : "closed",
        "aria-disabled": nodeState.disabled,
        "data-disabled": dataAttr(nodeState.disabled),
        style: {
          "--depth": nodeState.depth
        }
      });
    },
    getBranchIndicatorProps(props210) {
      const nodeState = getNodeState(props210);
      return normalize3.element({
        ...parts41.branchIndicator.attrs,
        "aria-hidden": true,
        "data-state": nodeState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(nodeState.disabled),
        "data-selected": dataAttr(nodeState.selected),
        "data-focus": dataAttr(nodeState.focused)
      });
    },
    getBranchTriggerProps(props210) {
      const nodeState = getNodeState(props210);
      return normalize3.element({
        ...parts41.branchTrigger.attrs,
        role: "button",
        dir: state2.context.dir,
        "data-disabled": dataAttr(nodeState.disabled),
        "data-state": nodeState.expanded ? "open" : "closed",
        "data-value": nodeState.value,
        onClick(event) {
          if (nodeState.disabled) return;
          send({ type: "BRANCH_TOGGLE.CLICK", id: nodeState.value });
          event.stopPropagation();
        }
      });
    },
    getBranchControlProps(props210) {
      const nodeState = getNodeState(props210);
      return normalize3.element({
        ...parts41.branchControl.attrs,
        role: "button",
        id: dom37.getNodeId(state2.context, nodeState.value),
        dir: state2.context.dir,
        tabIndex: nodeState.focused ? 0 : -1,
        "data-path": props210.indexPath.join("/"),
        "data-state": nodeState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(nodeState.disabled),
        "data-selected": dataAttr(nodeState.selected),
        "data-focus": dataAttr(nodeState.focused),
        "data-value": nodeState.value,
        "data-depth": nodeState.depth,
        onFocus(event) {
          send({ type: "NODE.FOCUS", id: nodeState.value });
          event.stopPropagation();
        },
        onClick(event) {
          if (nodeState.disabled) return;
          const isMetaKey = event.metaKey || event.ctrlKey;
          send({ type: "BRANCH_NODE.CLICK", id: nodeState.value, shiftKey: event.shiftKey, ctrlKey: isMetaKey });
          event.stopPropagation();
        }
      });
    },
    getBranchTextProps(props210) {
      const nodeState = getNodeState(props210);
      return normalize3.element({
        ...parts41.branchText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(nodeState.disabled),
        "data-state": nodeState.expanded ? "open" : "closed"
      });
    },
    getBranchContentProps(props210) {
      const nodeState = getNodeState(props210);
      return normalize3.element({
        ...parts41.branchContent.attrs,
        role: "group",
        dir: state2.context.dir,
        "data-state": nodeState.expanded ? "open" : "closed",
        "data-depth": nodeState.depth,
        "data-path": props210.indexPath.join("/"),
        "data-value": nodeState.value,
        hidden: !nodeState.expanded
      });
    },
    getBranchIndentGuideProps(props210) {
      const nodeState = getNodeState(props210);
      return normalize3.element({
        ...parts41.branchIndentGuide.attrs,
        "data-depth": nodeState.depth
      });
    }
  };
}
var { and: and16 } = guards;
function machine37(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "tree-view",
      initial: "idle",
      context: {
        expandedValue: [],
        selectedValue: [],
        focusedValue: null,
        expandOnClick: true,
        selectionMode: "single",
        typeahead: true,
        ...ctx,
        collection: ctx.collection ?? collection3.empty(),
        typeaheadState: getByTypeahead.defaultOptions
      },
      computed: {
        isMultipleSelection: (ctx2) => ctx2.selectionMode === "multiple"
      },
      on: {
        "EXPANDED.SET": {
          actions: ["setExpanded"]
        },
        "SELECTED.SET": {
          actions: ["setSelected"]
        },
        "SELECTED.ALL": [
          {
            guard: and16("isMultipleSelection", "moveFocus"),
            actions: ["selectAllNodes", "focusTreeLastNode"]
          },
          {
            guard: "isMultipleSelection",
            actions: ["selectAllNodes"]
          }
        ],
        "EXPANDED.ALL": {
          actions: ["expandAllBranches"]
        }
      },
      states: {
        idle: {
          on: {
            "NODE.FOCUS": {
              actions: ["setFocusedNode"]
            },
            "NODE.ARROW_DOWN": [
              {
                guard: and16("isShiftKey", "isMultipleSelection"),
                actions: ["focusTreeNextNode", "extendSelectionToNextNode"]
              },
              {
                actions: ["focusTreeNextNode"]
              }
            ],
            "NODE.ARROW_UP": [
              {
                guard: and16("isShiftKey", "isMultipleSelection"),
                actions: ["focusTreePrevNode", "extendSelectionToPrevNode"]
              },
              {
                actions: ["focusTreePrevNode"]
              }
            ],
            "NODE.ARROW_LEFT": {
              actions: ["focusBranchNode"]
            },
            "BRANCH_NODE.ARROW_LEFT": [
              {
                guard: "isBranchExpanded",
                actions: ["collapseBranch"]
              },
              {
                actions: ["focusBranchNode"]
              }
            ],
            "BRANCH_NODE.ARROW_RIGHT": [
              {
                guard: and16("isBranchFocused", "isBranchExpanded"),
                actions: ["focusBranchFirstNode"]
              },
              {
                actions: ["expandBranch"]
              }
            ],
            "SIBLINGS.EXPAND": {
              actions: ["expandSiblingBranches"]
            },
            "NODE.HOME": [
              {
                guard: and16("isShiftKey", "isMultipleSelection"),
                actions: ["extendSelectionToFirstNode", "focusTreeFirstNode"]
              },
              {
                actions: ["focusTreeFirstNode"]
              }
            ],
            "NODE.END": [
              {
                guard: and16("isShiftKey", "isMultipleSelection"),
                actions: ["extendSelectionToLastNode", "focusTreeLastNode"]
              },
              {
                actions: ["focusTreeLastNode"]
              }
            ],
            "NODE.CLICK": [
              {
                guard: and16("isCtrlKey", "isMultipleSelection"),
                actions: ["toggleNodeSelection"]
              },
              {
                guard: and16("isShiftKey", "isMultipleSelection"),
                actions: ["extendSelectionToNode"]
              },
              {
                actions: ["selectNode"]
              }
            ],
            "BRANCH_NODE.CLICK": [
              {
                guard: and16("isCtrlKey", "isMultipleSelection"),
                actions: ["toggleNodeSelection"]
              },
              {
                guard: and16("isShiftKey", "isMultipleSelection"),
                actions: ["extendSelectionToNode"]
              },
              {
                guard: "openOnClick",
                actions: ["selectNode", "toggleBranchNode"]
              },
              {
                actions: ["selectNode"]
              }
            ],
            "BRANCH_TOGGLE.CLICK": {
              actions: ["toggleBranchNode"]
            },
            "TREE.TYPEAHEAD": {
              actions: ["focusMatchedNode"]
            }
          }
        }
      }
    },
    {
      guards: {
        isBranchFocused: (ctx2, evt) => ctx2.focusedValue === evt.id,
        isBranchExpanded: (ctx2, evt) => ctx2.expandedValue.includes(evt.id),
        isShiftKey: (_ctx, evt) => evt.shiftKey,
        isCtrlKey: (_ctx, evt) => evt.ctrlKey,
        hasSelectedItems: (ctx2) => ctx2.selectedValue.length > 0,
        isMultipleSelection: (ctx2) => ctx2.isMultipleSelection,
        moveFocus: (_ctx, evt) => !!evt.moveFocus,
        openOnClick: (ctx2) => !!ctx2.expandOnClick
      },
      actions: {
        selectNode(ctx2, evt) {
          set27.selected(ctx2, [evt.id]);
        },
        setFocusedNode(ctx2, evt) {
          set27.focused(ctx2, evt.id);
        },
        clearFocusedNode(ctx2) {
          set27.focused(ctx2, null);
        },
        clearSelectedItem(ctx2) {
          set27.selected(ctx2, []);
        },
        toggleBranchNode(ctx2, evt) {
          set27.expanded(ctx2, addOrRemove(ctx2.expandedValue, evt.id));
        },
        expandBranch(ctx2, evt) {
          set27.expanded(ctx2, add(ctx2.expandedValue, evt.id));
        },
        collapseBranch(ctx2, evt) {
          set27.expanded(ctx2, remove(ctx2.expandedValue, evt.id));
        },
        setExpanded(ctx2, evt) {
          set27.expanded(ctx2, evt.value);
        },
        setSelected(ctx2, evt) {
          set27.selected(ctx2, evt.value);
        },
        focusTreeFirstNode(ctx2) {
          const firstNode = ctx2.collection.getFirstNode();
          const firstValue = ctx2.collection.getNodeValue(firstNode);
          dom37.focusNode(ctx2, firstValue);
        },
        focusTreeLastNode(ctx2) {
          const lastNode = ctx2.collection.getLastNode();
          const lastValue = ctx2.collection.getNodeValue(lastNode);
          dom37.focusNode(ctx2, lastValue);
        },
        focusBranchFirstNode(ctx2, evt) {
          const branchNode = ctx2.collection.findNode(evt.id);
          const firstNode = ctx2.collection.getFirstNode(branchNode);
          const firstValue = ctx2.collection.getNodeValue(firstNode);
          dom37.focusNode(ctx2, firstValue);
        },
        focusTreeNextNode(ctx2, evt) {
          let nextNode = ctx2.collection.getNextNode(evt.id, { skip: skipFn(ctx2) });
          nextNode = nextNode ?? ctx2.collection.getFirstNode();
          const nextValue = ctx2.collection.getNodeValue(nextNode);
          dom37.focusNode(ctx2, nextValue);
        },
        focusTreePrevNode(ctx2, evt) {
          let prevNode = ctx2.collection.getPreviousNode(evt.id, { skip: skipFn(ctx2) });
          prevNode = prevNode ?? ctx2.collection.getLastNode();
          const prevValue = ctx2.collection.getNodeValue(prevNode);
          dom37.focusNode(ctx2, prevValue);
        },
        focusBranchNode(ctx2, evt) {
          const parentNode = ctx2.collection.getParentNode(evt.id);
          const parentValue = parentNode ? ctx2.collection.getNodeValue(parentNode) : void 0;
          dom37.focusNode(ctx2, parentValue);
        },
        selectAllNodes(ctx2) {
          set27.selected(ctx2, ctx2.collection.getValues());
        },
        focusMatchedNode(ctx2, evt) {
          const node2 = dom37.getMatchingNode(ctx2, evt.key);
          dom37.focusNode(ctx2, node2 == null ? void 0 : node2.id);
        },
        toggleNodeSelection(ctx2, evt) {
          const selectedValue = addOrRemove(ctx2.selectedValue, evt.id);
          set27.selected(ctx2, selectedValue);
        },
        expandAllBranches(ctx2) {
          const nextValue = ctx2.collection.getBranchValues();
          set27.expanded(ctx2, nextValue);
        },
        expandSiblingBranches(ctx2, evt) {
          const indexPath = ctx2.collection.getIndexPath(evt.id);
          if (!indexPath) return;
          const nodes = ctx2.collection.getSiblingNodes(indexPath);
          const values = nodes.map((node2) => ctx2.collection.getNodeValue(node2));
          set27.expanded(ctx2, uniq(values));
        },
        extendSelectionToNode(ctx2, evt) {
          const anchorValue = first(ctx2.selectedValue) || ctx2.collection.getNodeValue(ctx2.collection.getFirstNode());
          const targetValue = evt.id;
          let values = [anchorValue, targetValue];
          let hits = 0;
          const visibleNodes = getVisibleNodes(ctx2);
          visibleNodes.forEach(({ node: node2 }) => {
            const nodeValue = ctx2.collection.getNodeValue(node2);
            if (hits === 1) values.push(nodeValue);
            if (nodeValue === anchorValue || nodeValue === targetValue) hits++;
          });
          set27.selected(ctx2, uniq(values));
        },
        extendSelectionToNextNode(ctx2, evt) {
          const nextNode = ctx2.collection.getNextNode(evt.id, { skip: skipFn(ctx2) });
          if (!nextNode) return;
          const values = new Set(ctx2.selectedValue);
          const nextValue = ctx2.collection.getNodeValue(nextNode);
          if (nextValue == null) return;
          if (values.has(evt.id) && values.has(nextValue)) {
            values.delete(evt.id);
          } else if (!values.has(nextValue)) {
            values.add(nextValue);
          }
          set27.selected(ctx2, Array.from(values));
        },
        extendSelectionToPrevNode(ctx2, evt) {
          const prevNode = ctx2.collection.getPreviousNode(evt.id, { skip: skipFn(ctx2) });
          if (!prevNode) return;
          const values = new Set(ctx2.selectedValue);
          const prevValue = ctx2.collection.getNodeValue(prevNode);
          if (prevValue == null) return;
          if (values.has(evt.id) && values.has(prevValue)) {
            values.delete(evt.id);
          } else if (!values.has(prevValue)) {
            values.add(prevValue);
          }
          set27.selected(ctx2, Array.from(values));
        },
        extendSelectionToFirstNode(ctx2) {
          const currentSelection = first(ctx2.selectedValue);
          const values = [];
          ctx2.collection.visit({
            skip: skipFn(ctx2),
            onEnter: (node2) => {
              const nodeValue = ctx2.collection.getNodeValue(node2);
              values.push(nodeValue);
              if (nodeValue === currentSelection) {
                return "stop";
              }
            }
          });
          set27.selected(ctx2, values);
        },
        extendSelectionToLastNode(ctx2) {
          const currentSelection = first(ctx2.selectedValue);
          const values = [];
          let current = false;
          ctx2.collection.visit({
            skip: skipFn(ctx2),
            onEnter: (node2) => {
              const nodeValue = ctx2.collection.getNodeValue(node2);
              if (nodeValue === currentSelection) current = true;
              if (current) values.push(nodeValue);
            }
          });
          set27.selected(ctx2, values);
        }
      }
    }
  );
}
var invoke20 = {
  focusChange(ctx) {
    var _a8;
    (_a8 = ctx.onFocusChange) == null ? void 0 : _a8.call(ctx, { focusedValue: ctx.focusedValue });
  },
  expandedChange(ctx) {
    var _a8;
    (_a8 = ctx.onExpandedChange) == null ? void 0 : _a8.call(ctx, {
      expandedValue: Array.from(ctx.expandedValue),
      focusedValue: ctx.focusedValue
    });
  },
  selectionChange(ctx) {
    var _a8;
    (_a8 = ctx.onSelectionChange) == null ? void 0 : _a8.call(ctx, {
      selectedValue: Array.from(ctx.selectedValue),
      focusedValue: ctx.focusedValue
    });
  }
};
var set27 = {
  selected(ctx, value) {
    if (isEqual(ctx.selectedValue, value)) return;
    ctx.selectedValue = value;
    invoke20.selectionChange(ctx);
  },
  focused(ctx, value) {
    if (isEqual(ctx.focusedValue, value)) return;
    ctx.focusedValue = value;
    invoke20.focusChange(ctx);
  },
  expanded(ctx, value) {
    if (isEqual(ctx.expandedValue, value)) return;
    ctx.expandedValue = value;
    invoke20.expandedChange(ctx);
  }
};
var props33 = createProps()([
  "ids",
  "collection",
  "dir",
  "expandedValue",
  "expandOnClick",
  "focusedValue",
  "getRootNode",
  "id",
  "onExpandedChange",
  "onFocusChange",
  "onSelectionChange",
  "selectedValue",
  "selectionMode",
  "typeahead"
]);
var splitProps33 = createSplitProps(props33);
var itemProps11 = createProps()(["node", "indexPath"]);
var splitItemProps11 = createSplitProps(itemProps11);

// node_modules/@ark-ui/react/dist/components/tree-view/use-tree-view.js
var import_react876 = __toESM(require_react(), 1);
var useTreeView = (props34) => {
  const { collection: collection4, ...treeViewProps } = props34;
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const initialContext = {
    id: (0, import_react876.useId)(),
    dir: locale.dir,
    getRootNode: environment.getRootNode,
    selectedValue: props34.defaultSelectedValue,
    expandedValue: props34.defaultExpandedValue,
    collection: collection4,
    ...treeViewProps
  };
  const context = (() => {
    const { collection: _, ...restProps } = initialContext;
    return {
      ...restProps,
      selectedValue: props34.selectedValue,
      expandedValue: props34.expandedValue,
      onFocusChange: useEvent(props34.onFocusChange),
      onExpandedChange: useEvent(props34.onExpandedChange, { sync: true }),
      onSelectionChange: useEvent(props34.onSelectionChange, { sync: true })
    };
  })();
  const [state2, send, service] = useMachine(machine37(initialContext), {
    context
  });
  (0, import_react876.useEffect)(() => {
    service.setContext({ collection: collection4 });
  }, [collection4]);
  return connect38(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-root.js
var TreeViewImpl = (props34, ref2) => {
  const [renderStrategyProps, treeViewProps] = splitRenderStrategyProps(props34);
  const [useTreeViewProps, localProps] = createSplitProps2()(treeViewProps, [
    "collection",
    "defaultExpandedValue",
    "defaultSelectedValue",
    "expandedValue",
    "expandOnClick",
    "focusedValue",
    "id",
    "ids",
    "onExpandedChange",
    "onFocusChange",
    "onSelectionChange",
    "selectedValue",
    "selectionMode",
    "typeahead"
  ]);
  const treeView = useTreeView(useTreeViewProps);
  const mergedProps = mergeProps2(treeView.getRootProps(), localProps);
  return (0, import_jsx_runtime407.jsx)(TreeViewProvider, { value: treeView, children: (0, import_jsx_runtime407.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime407.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
};
var TreeViewRoot = (0, import_react878.forwardRef)(TreeViewImpl);

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-root-provider.js
var import_jsx_runtime408 = __toESM(require_jsx_runtime(), 1);
var import_react880 = __toESM(require_react(), 1);
var TreeViewImpl2 = (props34, ref2) => {
  const [renderStrategyProps, treeViewProps] = splitRenderStrategyProps(props34);
  const [{ value: treeView }, localProps] = createSplitProps2()(
    treeViewProps,
    ["value"]
  );
  const mergedProps = mergeProps2(treeView.getRootProps(), localProps);
  return (0, import_jsx_runtime408.jsx)(TreeViewProvider, { value: treeView, children: (0, import_jsx_runtime408.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime408.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
};
var TreeViewRootProvider = (0, import_react880.forwardRef)(TreeViewImpl2);

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-tree.js
var import_jsx_runtime409 = __toESM(require_jsx_runtime(), 1);
var import_react882 = __toESM(require_react(), 1);
var TreeViewTree = (0, import_react882.forwardRef)((props34, ref2) => {
  const treeView = useTreeViewContext();
  const mergedProps = mergeProps2(treeView.getTreeProps(), props34);
  return (0, import_jsx_runtime409.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TreeViewTree.displayName = "TreeViewTree";

// node_modules/@ark-ui/react/dist/providers/locale/locale-provider.js
var import_jsx_runtime410 = __toESM(require_jsx_runtime(), 1);
var LocaleProvider = (props34) => {
  const { children, locale } = props34;
  const context = {
    locale,
    dir: isRTL(locale) ? "rtl" : "ltr"
  };
  return (0, import_jsx_runtime410.jsx)(LocaleContextProvider, { value: context, children });
};

// node_modules/@chakra-ui/react/dist/esm/hooks/use-element-rect.js
var import_react884 = __toESM(require_react(), 1);
function useElementRect() {
  const ref2 = (0, import_react884.useRef)(null);
  const [rect, setRect] = (0, import_react884.useState)(null);
  const env = useEnvironmentContext();
  (0, import_react884.useEffect)(() => {
    const node2 = ref2.current;
    if (!node2) return;
    const handleResize = () => {
      setRect(node2.getBoundingClientRect());
    };
    const win = env.getWindow();
    if (!win) return;
    const observer = new win.ResizeObserver(handleResize);
    observer.observe(node2);
    return () => observer.disconnect();
  }, [env]);
  return { ref: ref2, rect };
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-force-update.js
var import_react885 = __toESM(require_react(), 1);
function useForceUpdate() {
  return (0, import_react885.useReducer)((x) => x + 1, 0)[1];
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-live-ref.js
var import_react886 = __toESM(require_react(), 1);
function useLiveRef(value) {
  const ref2 = (0, import_react886.useRef)(value);
  ref2.current = value;
  return ref2;
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-previous.js
var import_react887 = __toESM(require_react(), 1);
function usePrevious(value) {
  const ref2 = (0, import_react887.useRef)();
  (0, import_react887.useEffect)(() => {
    ref2.current = value;
  }, [value]);
  return ref2.current;
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-safe-layout-effect.js
var import_react888 = __toESM(require_react(), 1);
var useSafeLayoutEffect3 = typeof (globalThis == null ? void 0 : globalThis.document) !== "undefined" ? import_react888.useLayoutEffect : import_react888.useEffect;

// node_modules/@chakra-ui/react/dist/esm/hooks/use-update-effect.js
var import_react889 = __toESM(require_react(), 1);
var useUpdateEffect2 = (effect, deps) => {
  const renderCycleRef = (0, import_react889.useRef)(false);
  const effectCycleRef = (0, import_react889.useRef)(false);
  (0, import_react889.useEffect)(() => {
    const isMounted = renderCycleRef.current;
    const shouldRun = isMounted && effectCycleRef.current;
    if (shouldRun) {
      return effect();
    }
    effectCycleRef.current = true;
  }, deps);
  (0, import_react889.useEffect)(() => {
    renderCycleRef.current = true;
    return () => {
      renderCycleRef.current = false;
    };
  }, []);
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/color-mix.js
var colorMix = (value, token2) => {
  var _a8;
  if (!value || typeof value !== "string") {
    return { invalid: true, value };
  }
  const [rawColor, rawOpacity] = value.split("/");
  if (!rawColor || !rawOpacity || rawColor === "currentBg") {
    return { invalid: true, value: rawColor };
  }
  const colorToken = token2(`colors.${rawColor}`);
  const opacityToken = (_a8 = token2.raw(`opacity.${rawOpacity}`)) == null ? void 0 : _a8.value;
  if (!opacityToken && isNaN(Number(rawOpacity))) {
    return { invalid: true, value: rawColor };
  }
  const percent = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
  const color = colorToken ?? rawColor;
  return {
    invalid: false,
    color,
    value: `color-mix(in srgb, ${color} ${percent}, transparent)`
  };
};
var createColorMixTransform = (prop) => (value, args) => {
  const mix = args.utils.colorMix(value);
  if (mix.invalid) return { [prop]: value };
  const cssVar2 = "--mix-" + prop;
  return {
    [cssVar2]: mix.value,
    [prop]: `var(${cssVar2}, ${mix.color})`
  };
};

// node_modules/@chakra-ui/react/dist/esm/utils/clone.js
function clone2(obj) {
  if (obj === null || typeof obj !== "object") return obj;
  if (Array.isArray(obj)) return obj.map((prop) => clone2(prop));
  const _clone = Object.create(Object.getPrototypeOf(obj));
  for (const key of Object.keys(obj)) {
    _clone[key] = clone2(obj[key]);
  }
  return _clone;
}

// node_modules/@chakra-ui/react/dist/esm/utils/merge.js
function merge2(target, source) {
  if (source == null) return target;
  for (const key of Object.keys(source)) {
    if (source[key] === void 0 || key === "__proto__") continue;
    if (!isObject(target[key]) && isObject(source[key])) {
      Object.assign(target, { [key]: source[key] });
    } else if (target[key] && isObject(source[key])) {
      merge2(target[key], source[key]);
    } else if (Array.isArray(source[key]) && Array.isArray(target[key])) {
      let i = 0;
      for (; i < source[key].length; i++) {
        if (isObject(target[key][i]) && isObject(source[key][i])) {
          merge2(target[key][i], source[key][i]);
        } else {
          target[key][i] = source[key][i];
        }
      }
    } else {
      Object.assign(target, { [key]: source[key] });
    }
  }
  return target;
}
function mergeWith(target, ...sources) {
  for (const source of sources) {
    merge2(target, source);
  }
  return target;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/config.js
var defineConditions = (v) => v;
var defineRecipe = (v) => v;
var defineSlotRecipe = (v) => v;
var defineKeyframes = (v) => v;
var defineGlobalStyles = (v) => v;
var defineStyle = (v) => v;
var defineTextStyles = (v) => v;
var defineAnimationStyles = (v) => v;
var defineLayerStyles = (v) => v;
function createProxy3() {
  const identity = (v) => v;
  return new Proxy(identity, {
    get() {
      return identity;
    }
  });
}
var defineTokens = createProxy3();
var defineSemanticTokens = createProxy3();
var defineConfig = (v) => v;
var mergeConfigs = (...configs) => {
  return mergeWith({}, ...configs.map(clone2));
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/css-var.js
var escRegex = /[^a-zA-Z0-9_\u0081-\uffff-]/g;
function esc(string) {
  return `${string}`.replace(escRegex, (s) => `\\${s}`);
}
var dashCaseRegex = /[A-Z]/g;
function dashCase(string) {
  return string.replace(dashCaseRegex, (match5) => `-${match5.toLowerCase()}`);
}
function cssVar(name, options = {}) {
  const { fallback: fallback4 = "", prefix: prefix3 = "" } = options;
  const variable = dashCase(["-", prefix3, esc(name)].filter(Boolean).join("-"));
  return {
    var: variable,
    ref: `var(${variable}${fallback4 ? `, ${fallback4}` : ""})`
  };
}

// node_modules/@chakra-ui/react/dist/esm/preset-base.js
var isCssVar2 = (v) => /^var\(--.+\)$/.test(v);
var wrap4 = (str, v) => v != null ? `${str}(${v})` : v;
var deg = (v) => {
  if (isCssVar2(v) || v == null) return v;
  const unitless = typeof v === "string" && !v.endsWith("deg");
  return typeof v === "number" || unitless ? `${v}deg` : v;
};
var createFocusRing = (selector) => {
  return {
    values: ["outside", "inside", "mixed", "none"],
    transform(value, { token: token2 }) {
      const focusRingColor = token2("colors.colorPalette.focusRing");
      const styles = {
        inside: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineOffset: "0px",
            outlineWidth: "var(--focus-ring-width, 1px)",
            outlineColor: "var(--focus-ring-color)",
            outlineStyle: "var(--focus-ring-style, solid)",
            borderColor: "var(--focus-ring-color)"
          }
        },
        outside: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineWidth: "var(--focus-ring-width, 2px)",
            outlineOffset: "var(--focus-ring-offset, 2px)",
            outlineStyle: "var(--focus-ring-style, solid)",
            outlineColor: "var(--focus-ring-color)"
          }
        },
        mixed: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineWidth: "var(--focus-ring-width, 3px)",
            outlineStyle: "var(--focus-ring-style, solid)",
            outlineColor: "color-mix(in srgb, var(--focus-ring-color), transparent 60%)",
            borderColor: "var(--focus-ring-color)"
          }
        },
        none: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outline: "none"
          }
        }
      };
      return styles[value] ?? {};
    }
  };
};
var divideColor = createColorMixTransform("borderColor");
var createTransition = (value) => {
  return {
    transition: value,
    transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
    transitionDuration: "150ms"
  };
};
var defaultConditions = defineConditions({
  hover: [
    "@media (hover: hover)",
    "&:is(:hover, [data-hover]):not(:disabled, [data-disabled])"
  ],
  active: "&:is(:active, [data-active]):not(:disabled, [data-disabled], [data-state=open])",
  focus: "&:is(:focus, [data-focus])",
  focusWithin: "&:is(:focus-within, [data-focus-within])",
  focusVisible: "&:is(:focus-visible, [data-focus-visible])",
  disabled: "&:is(:disabled, [disabled], [data-disabled], [aria-disabled=true])",
  visited: "&:visited",
  target: "&:target",
  readOnly: "&:is([data-readonly], [aria-readonly=true], [readonly])",
  readWrite: "&:read-write",
  empty: "&:is(:empty, [data-empty])",
  checked: "&:is(:checked, [data-checked], [aria-checked=true], [data-state=checked])",
  enabled: "&:enabled",
  expanded: "&:is([aria-expanded=true], [data-expanded], [data-state=expanded])",
  highlighted: "&[data-highlighted]",
  complete: "&[data-complete]",
  incomplete: "&[data-incomplete]",
  dragging: "&[data-dragging]",
  before: "&::before",
  after: "&::after",
  firstLetter: "&::first-letter",
  firstLine: "&::first-line",
  marker: "&::marker",
  selection: "&::selection",
  file: "&::file-selector-button",
  backdrop: "&::backdrop",
  first: "&:first-of-type",
  last: "&:last-of-type",
  notFirst: "&:not(:first-of-type)",
  notLast: "&:not(:last-of-type)",
  only: "&:only-child",
  even: "&:nth-of-type(even)",
  odd: "&:nth-of-type(odd)",
  peerFocus: ".peer:is(:focus, [data-focus]) ~ &",
  peerHover: ".peer:is(:hover, [data-hover]):not(:disabled, [data-disabled]) ~ &",
  peerActive: ".peer:is(:active, [data-active]):not(:disabled, [data-disabled]) ~ &",
  peerFocusWithin: ".peer:focus-within ~ &",
  peerFocusVisible: ".peer:is(:focus-visible, [data-focus-visible]) ~ &",
  peerDisabled: ".peer:is(:disabled, [disabled], [data-disabled]) ~ &",
  peerChecked: ".peer:is(:checked, [data-checked], [aria-checked=true], [data-state=checked]) ~ &",
  peerInvalid: ".peer:is(:invalid, [data-invalid], [aria-invalid=true]) ~ &",
  peerExpanded: ".peer:is([aria-expanded=true], [data-expanded], [data-state=expanded]) ~ &",
  peerPlaceholderShown: ".peer:placeholder-shown ~ &",
  groupFocus: ".group:is(:focus, [data-focus]) &",
  groupHover: ".group:is(:hover, [data-hover]):not(:disabled, [data-disabled]) &",
  groupActive: ".group:is(:active, [data-active]):not(:disabled, [data-disabled]) &",
  groupFocusWithin: ".group:focus-within &",
  groupFocusVisible: ".group:is(:focus-visible, [data-focus-visible]) &",
  groupDisabled: ".group:is(:disabled, [disabled], [data-disabled]) &",
  groupChecked: ".group:is(:checked, [data-checked], [aria-checked=true], [data-state=checked]) &",
  groupExpanded: ".group:is([aria-expanded=true], [data-expanded], [data-state=expanded]) &",
  groupInvalid: ".group:invalid &",
  indeterminate: "&:is(:indeterminate, [data-indeterminate], [aria-checked=mixed], [data-state=indeterminate])",
  required: "&:is([data-required], [aria-required=true])",
  valid: "&:is([data-valid], [data-state=valid])",
  invalid: "&:is([data-invalid], [aria-invalid=true], [data-state=invalid])",
  autofill: "&:autofill",
  inRange: "&:is(:in-range, [data-in-range])",
  outOfRange: "&:is(:out-of-range, [data-outside-range])",
  placeholder: "&::placeholder, &[data-placeholder]",
  placeholderShown: "&:is(:placeholder-shown, [data-placeholder-shown])",
  pressed: "&:is([aria-pressed=true], [data-pressed])",
  selected: "&:is([aria-selected=true], [data-selected])",
  grabbed: "&:is([aria-grabbed=true], [data-grabbed])",
  underValue: "&[data-state=under-value]",
  overValue: "&[data-state=over-value]",
  atValue: "&[data-state=at-value]",
  default: "&:default",
  optional: "&:optional",
  open: "&:is([open], [data-open], [data-state=open])",
  closed: "&:is([closed], [data-closed], [data-state=closed])",
  fullscreen: "&is(:fullscreen, [data-fullscreen])",
  loading: "&:is([data-loading], [aria-busy=true])",
  hidden: "&:is([hidden], [data-hidden])",
  current: "&[data-current]",
  currentPage: "&[aria-current=page]",
  currentStep: "&[aria-current=step]",
  today: "&[data-today]",
  unavailable: "&[data-unavailable]",
  rangeStart: "&[data-range-start]",
  rangeEnd: "&[data-range-end]",
  now: "&[data-now]",
  topmost: "&[data-topmost]",
  motionReduce: "@media (prefers-reduced-motion: reduce)",
  motionSafe: "@media (prefers-reduced-motion: no-preference)",
  print: "@media print",
  landscape: "@media (orientation: landscape)",
  portrait: "@media (orientation: portrait)",
  dark: ".dark &, .dark .chakra-theme:not(.light) &",
  light: ":root &, .light &",
  osDark: "@media (prefers-color-scheme: dark)",
  osLight: "@media (prefers-color-scheme: light)",
  highContrast: "@media (forced-colors: active)",
  lessContrast: "@media (prefers-contrast: less)",
  moreContrast: "@media (prefers-contrast: more)",
  ltr: "[dir=ltr] &",
  rtl: "[dir=rtl] &",
  scrollbar: "&::-webkit-scrollbar",
  scrollbarThumb: "&::-webkit-scrollbar-thumb",
  scrollbarTrack: "&::-webkit-scrollbar-track",
  horizontal: "&[data-orientation=horizontal]",
  vertical: "&[data-orientation=vertical]",
  icon: "& :where(svg)",
  starting: "@starting-style"
});
var currentBgVar = cssVar("bg-currentcolor");
var isCurrentBgVar = (value) => value === currentBgVar.ref || value === "currentBg";
var colorValues = (theme) => ({
  ...theme("colors"),
  currentBg: currentBgVar
});
var defaultBaseConfig = defineConfig({
  conditions: defaultConditions,
  utilities: {
    // background
    background: {
      values: colorValues,
      shorthand: ["bg"],
      transform(value, args) {
        if (isCurrentBgVar(args.raw)) return { background: currentBgVar.ref };
        const styleObj = createColorMixTransform("background")(value, args);
        return { ...styleObj, [currentBgVar.var]: styleObj == null ? void 0 : styleObj.background };
      }
    },
    backgroundColor: {
      values: colorValues,
      shorthand: ["bgColor"],
      transform(value, args) {
        if (isCurrentBgVar(args.raw))
          return { backgroundColor: currentBgVar.ref };
        const styleObj = createColorMixTransform("backgroundColor")(value, args);
        return {
          ...styleObj,
          [currentBgVar.var]: styleObj == null ? void 0 : styleObj.backgroundColor
        };
      }
    },
    backgroundSize: { shorthand: ["bgSize"] },
    backgroundPosition: { shorthand: ["bgPos"] },
    backgroundRepeat: { shorthand: ["bgRepeat"] },
    backgroundAttachment: { shorthand: ["bgAttachment"] },
    backgroundClip: {
      shorthand: ["bgClip"],
      values: ["text"],
      transform(value) {
        return value === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: value };
      }
    },
    backgroundGradient: {
      shorthand: ["bgGradient"],
      values(theme) {
        return {
          ...theme("gradients"),
          "to-t": "linear-gradient(to top, var(--gradient))",
          "to-tr": "linear-gradient(to top right, var(--gradient))",
          "to-r": "linear-gradient(to right, var(--gradient))",
          "to-br": "linear-gradient(to bottom right, var(--gradient))",
          "to-b": "linear-gradient(to bottom, var(--gradient))",
          "to-bl": "linear-gradient(to bottom left, var(--gradient))",
          "to-l": "linear-gradient(to left, var(--gradient))",
          "to-tl": "linear-gradient(to top left, var(--gradient))"
        };
      },
      transform(value) {
        return {
          "--gradient-stops": "var(--gradient-from), var(--gradient-to)",
          "--gradient": "var(--gradient-via-stops, var(--gradient-stops))",
          backgroundImage: value
        };
      }
    },
    gradientFrom: {
      values: colorValues,
      transform: createColorMixTransform("--gradient-from")
    },
    gradientTo: {
      values: colorValues,
      transform: createColorMixTransform("--gradient-to")
    },
    gradientVia: {
      values: colorValues,
      transform(value, args) {
        const styles = createColorMixTransform("--gradient-via")(value, args);
        return {
          ...styles,
          "--gradient-via-stops": "var(--gradient-from), var(--gradient-via), var(--gradient-to)"
        };
      }
    },
    backgroundImage: {
      values(theme) {
        return { ...theme("gradients"), ...theme("assets") };
      },
      shorthand: ["bgImg", "bgImage"]
    },
    // border
    border: { values: "borders" },
    borderTop: { values: "borders" },
    borderLeft: { values: "borders" },
    borderBlockStart: { values: "borders" },
    borderRight: { values: "borders" },
    borderInlineEnd: { values: "borders" },
    borderBottom: { values: "borders" },
    borderBlockEnd: { values: "borders" },
    borderInlineStart: { values: "borders", shorthand: ["borderStart"] },
    borderInline: { values: "borders", shorthand: ["borderX"] },
    borderBlock: { values: "borders", shorthand: ["borderY"] },
    // border colors
    borderColor: {
      values: colorValues,
      transform: createColorMixTransform("borderColor")
    },
    borderTopColor: {
      values: colorValues,
      transform: createColorMixTransform("borderTopColor")
    },
    borderBlockStartColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBlockStartColor")
    },
    borderBottomColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBottomColor")
    },
    borderBlockEndColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBlockEndColor")
    },
    borderLeftColor: {
      values: colorValues,
      transform: createColorMixTransform("borderLeftColor")
    },
    borderInlineStartColor: {
      values: colorValues,
      shorthand: ["borderStartColor"],
      transform: createColorMixTransform("borderInlineStartColor")
    },
    borderRightColor: {
      values: colorValues,
      transform: createColorMixTransform("borderRightColor")
    },
    borderInlineEndColor: {
      values: colorValues,
      shorthand: ["borderEndColor"],
      transform: createColorMixTransform("borderInlineEndColor")
    },
    // border styles
    borderStyle: { values: "borderStyles" },
    borderTopStyle: { values: "borderStyles" },
    borderBlockStartStyle: { values: "borderStyles" },
    borderBottomStyle: { values: "borderStyles" },
    borderBlockEndStyle: {
      values: "borderStyles"
    },
    borderInlineStartStyle: {
      values: "borderStyles",
      shorthand: ["borderStartStyle"]
    },
    borderInlineEndStyle: {
      values: "borderStyles",
      shorthand: ["borderEndStyle"]
    },
    borderLeftStyle: { values: "borderStyles" },
    borderRightStyle: { values: "borderStyles" },
    // border radius
    borderRadius: { values: "radii", shorthand: ["rounded"] },
    borderTopLeftRadius: { values: "radii", shorthand: ["roundedTopLeft"] },
    borderStartStartRadius: {
      values: "radii",
      shorthand: ["roundedStartStart", "borderTopStartRadius"]
    },
    borderEndStartRadius: {
      values: "radii",
      shorthand: ["roundedEndStart", "borderBottomStartRadius"]
    },
    borderTopRightRadius: {
      values: "radii",
      shorthand: ["roundedTopRight"]
    },
    borderStartEndRadius: {
      values: "radii",
      shorthand: ["roundedStartEnd", "borderTopEndRadius"]
    },
    borderEndEndRadius: {
      values: "radii",
      shorthand: ["roundedEndEnd", "borderBottomEndRadius"]
    },
    borderBottomLeftRadius: {
      values: "radii",
      shorthand: ["roundedBottomLeft"]
    },
    borderBottomRightRadius: {
      values: "radii",
      shorthand: ["roundedBottomRight"]
    },
    borderInlineStartRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedStart", "borderStartRadius"],
      transform: (value) => ({
        borderStartStartRadius: value,
        borderEndStartRadius: value
      })
    },
    borderInlineEndRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedEnd", "borderEndRadius"],
      transform: (value) => ({
        borderStartEndRadius: value,
        borderEndEndRadius: value
      })
    },
    borderTopRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedTop"],
      transform: (value) => ({
        borderTopLeftRadius: value,
        borderTopRightRadius: value
      })
    },
    borderBottomRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedBottom"],
      transform: (value) => ({
        borderBottomLeftRadius: value,
        borderBottomRightRadius: value
      })
    },
    borderLeftRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedLeft"],
      transform: (value) => ({
        borderTopLeftRadius: value,
        borderBottomLeftRadius: value
      })
    },
    borderRightRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedRight"],
      transform: (value) => ({
        borderTopRightRadius: value,
        borderBottomRightRadius: value
      })
    },
    borderWidth: { values: "borderWidths" },
    borderBlockStartWidth: { values: "borderWidths" },
    borderTopWidth: { values: "borderWidths" },
    borderBottomWidth: { values: "borderWidths" },
    borderBlockEndWidth: { values: "borderWidths" },
    borderRightWidth: { values: "borderWidths" },
    borderInlineWidth: {
      values: "borderWidths",
      shorthand: ["borderXWidth"]
    },
    borderInlineStartWidth: {
      values: "borderWidths",
      shorthand: ["borderStartWidth"]
    },
    borderInlineEndWidth: {
      values: "borderWidths",
      shorthand: ["borderEndWidth"]
    },
    borderLeftWidth: { values: "borderWidths" },
    borderBlockWidth: {
      values: "borderWidths",
      shorthand: ["borderYWidth"]
    },
    // colors
    color: {
      values: colorValues,
      transform: createColorMixTransform("color")
    },
    fill: {
      values: colorValues,
      transform: createColorMixTransform("fill")
    },
    stroke: {
      values: colorValues,
      transform: createColorMixTransform("stroke")
    },
    accentColor: {
      values: colorValues,
      transform: createColorMixTransform("accentColor")
    },
    // divide
    divideX: {
      values: { type: "string" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderInlineStartWidth: value,
            borderInlineEndWidth: "0px"
          }
        };
      }
    },
    divideY: {
      values: { type: "string" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderTopWidth: value,
            borderBottomWidth: "0px"
          }
        };
      }
    },
    divideColor: {
      values: colorValues,
      transform(value, args) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": divideColor(
            value,
            args
          )
        };
      }
    },
    divideStyle: {
      property: "borderStyle",
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderStyle: value
          }
        };
      }
    },
    // effects
    boxShadow: { values: "shadows", shorthand: ["shadow"] },
    boxShadowColor: {
      values: colorValues,
      transform: createColorMixTransform("--shadow-color"),
      shorthand: ["shadowColor"]
    },
    mixBlendMode: { shorthand: ["blendMode"] },
    backgroundBlendMode: { shorthand: ["bgBlendMode"] },
    opacity: { values: "opacity" },
    // filters
    filter: {
      transform(v) {
        if (v !== "auto") {
          return { filter: v };
        }
        return {
          filter: `var(--blur) var(--brightness) var(--contrast) var(--grayscale) var(--hue-rotate) var(--invert) var(--saturate) var(--sepia) var(--drop-shadow)`
        };
      }
    },
    blur: {
      values: "blurs",
      transform: (v) => ({ "--blur": wrap4("blur", v) })
    },
    brightness: {
      transform: (v) => ({ "--brightness": wrap4("brightness", v) })
    },
    contrast: {
      transform: (v) => ({ "--contrast": wrap4("contrast", v) })
    },
    grayscale: {
      transform: (v) => ({ "--grayscale": wrap4("grayscale", v) })
    },
    hueRotate: {
      transform: (v) => ({ "--hue-rotate": wrap4("hue-rotate", deg(v)) })
    },
    invert: { transform: (v) => ({ "--invert": wrap4("invert", v) }) },
    saturate: {
      transform: (v) => ({ "--saturate": wrap4("saturate", v) })
    },
    sepia: { transform: (v) => ({ "--sepia": wrap4("sepia", v) }) },
    dropShadow: {
      transform: (v) => ({ "--drop-shadow": wrap4("drop-shadow", v) })
    },
    // backdrop filters
    backdropFilter: {
      transform(v) {
        if (v !== "auto") {
          return { backdropFilter: v };
        }
        return {
          backdropFilter: `var(--backdrop-blur) var(--backdrop-brightness) var(--backdrop-contrast) var(--backdrop-grayscale) var(--backdrop-hue-rotate) var(--backdrop-invert) var(--backdrop-opacity) var(--backdrop-saturate) var(--backdrop-sepia)`
        };
      }
    },
    backdropBlur: {
      values: "blurs",
      transform: (v) => ({ "--backdrop-blur": wrap4("blur", v) })
    },
    backdropBrightness: {
      transform: (v) => ({
        "--backdrop-brightness": wrap4("brightness", v)
      })
    },
    backdropContrast: {
      transform: (v) => ({ "--backdrop-contrast": wrap4("contrast", v) })
    },
    backdropGrayscale: {
      transform: (v) => ({
        "--backdrop-grayscale": wrap4("grayscale", v)
      })
    },
    backdropHueRotate: {
      transform: (v) => ({
        "--backdrop-hue-rotate": wrap4("hue-rotate", deg(v))
      })
    },
    backdropInvert: {
      transform: (v) => ({ "--backdrop-invert": wrap4("invert", v) })
    },
    backdropOpacity: {
      transform: (v) => ({ "--backdrop-opacity": wrap4("opacity", v) })
    },
    backdropSaturate: {
      transform: (v) => ({ "--backdrop-saturate": wrap4("saturate", v) })
    },
    backdropSepia: {
      transform: (v) => ({ "--backdrop-sepia": wrap4("sepia", v) })
    },
    // flexbox
    flexBasis: { values: "sizes" },
    gap: { values: "spacing" },
    rowGap: { values: "spacing", shorthand: ["gapY"] },
    columnGap: { values: "spacing", shorthand: ["gapX"] },
    flexDirection: { shorthand: ["flexDir"] },
    // grid
    gridGap: { values: "spacing" },
    gridColumnGap: { values: "spacing" },
    gridRowGap: { values: "spacing" },
    // interactivity
    outlineColor: {
      values: colorValues,
      transform: createColorMixTransform("outlineColor")
    },
    focusRing: createFocusRing("&:is(:focus, [data-focus])"),
    focusVisibleRing: createFocusRing(
      "&:is(:focus-visible, [data-focus-visible])"
    ),
    focusRingColor: {
      values: colorValues,
      transform: createColorMixTransform("--focus-ring-color")
    },
    focusRingOffset: {
      values: "spacing",
      transform: (v) => ({ "--focus-ring-offset": v })
    },
    focusRingWidth: {
      values: "borderWidths",
      property: "outlineWidth",
      transform: (v) => ({ "--focus-ring-width": v })
    },
    focusRingStyle: {
      values: "borderStyles",
      property: "outlineStyle",
      transform: (v) => ({ "--focus-ring-style": v })
    },
    // layout
    aspectRatio: { values: "aspectRatios" },
    width: { values: "sizes", shorthand: ["w"] },
    inlineSize: { values: "sizes" },
    height: { values: "sizes", shorthand: ["h"] },
    blockSize: { values: "sizes" },
    boxSize: {
      values: "sizes",
      property: "width",
      transform: (v) => ({ width: v, height: v })
    },
    minWidth: { values: "sizes", shorthand: ["minW"] },
    minInlineSize: { values: "sizes" },
    minHeight: { values: "sizes", shorthand: ["minH"] },
    minBlockSize: { values: "sizes" },
    maxWidth: { values: "sizes", shorthand: ["maxW"] },
    maxInlineSize: { values: "sizes" },
    maxHeight: { values: "sizes", shorthand: ["maxH"] },
    maxBlockSize: { values: "sizes" },
    hideFrom: {
      values: "breakpoints",
      //@ts-ignore
      transform: (value, { raw, token: token2 }) => {
        const bp = token2.raw(`breakpoints.${raw}`);
        const media = bp ? `@breakpoint ${raw}` : `@media screen and (min-width: ${value})`;
        return {
          [media]: { display: "none" }
        };
      }
    },
    hideBelow: {
      values: "breakpoints",
      //@ts-ignore
      transform(value, { raw, token: token2 }) {
        const bp = token2.raw(`breakpoints.${raw}`);
        const media = bp ? `@breakpoint ${raw}Down` : `@media screen and (max-width: ${value})`;
        return {
          [media]: {
            display: "none"
          }
        };
      }
    },
    // scroll
    overscrollBehavior: { shorthand: ["overscroll"] },
    overscrollBehaviorX: { shorthand: ["overscrollX"] },
    overscrollBehaviorY: { shorthand: ["overscrollY"] },
    scrollbar: {
      values: ["visible", "hidden"],
      transform(v) {
        switch (v) {
          case "visible":
            return {
              msOverflowStyle: "auto",
              scrollbarWidth: "auto",
              "&::-webkit-scrollbar": { display: "block" }
            };
          case "hidden":
            return {
              msOverflowStyle: "none",
              scrollbarWidth: "none",
              "&::-webkit-scrollbar": { display: "none" }
            };
          default:
            return {};
        }
      }
    },
    scrollbarColor: {
      values: colorValues,
      transform: createColorMixTransform("scrollbarColor")
    },
    scrollbarGutter: { values: "spacing" },
    scrollbarWidth: { values: "sizes" },
    // scroll margin
    scrollMargin: { values: "spacing" },
    scrollMarginTop: { values: "spacing" },
    scrollMarginBottom: { values: "spacing" },
    scrollMarginLeft: { values: "spacing" },
    scrollMarginRight: { values: "spacing" },
    scrollMarginX: {
      values: "spacing",
      transform: (v) => ({ scrollMarginLeft: v, scrollMarginRight: v })
    },
    scrollMarginY: {
      values: "spacing",
      transform: (v) => ({ scrollMarginTop: v, scrollMarginBottom: v })
    },
    // scroll padding
    scrollPadding: { values: "spacing" },
    scrollPaddingTop: { values: "spacing" },
    scrollPaddingBottom: { values: "spacing" },
    scrollPaddingLeft: { values: "spacing" },
    scrollPaddingRight: { values: "spacing" },
    scrollPaddingInline: { values: "spacing", shorthand: ["scrollPaddingX"] },
    scrollPaddingBlock: { values: "spacing", shorthand: ["scrollPaddingY"] },
    // scroll snap
    scrollSnapType: {
      values: {
        none: "none",
        x: "x var(--scroll-snap-strictness)",
        y: "y var(--scroll-snap-strictness)",
        both: "both var(--scroll-snap-strictness)"
      }
    },
    scrollSnapStrictness: {
      values: ["mandatory", "proximity"],
      transform: (v) => ({ "--scroll-snap-strictness": v })
    },
    scrollSnapMargin: { values: "spacing" },
    scrollSnapMarginTop: { values: "spacing" },
    scrollSnapMarginBottom: { values: "spacing" },
    scrollSnapMarginLeft: { values: "spacing" },
    scrollSnapMarginRight: { values: "spacing" },
    // list
    listStylePosition: { shorthand: ["listStylePos"] },
    listStyleImage: { values: "assets", shorthand: ["listStyleImg"] },
    // position
    position: { shorthand: ["pos"] },
    zIndex: { values: "zIndex" },
    inset: { values: "spacing" },
    insetInline: { values: "spacing", shorthand: ["insetX"] },
    insetBlock: { values: "spacing", shorthand: ["insetY"] },
    top: { values: "spacing" },
    insetBlockStart: { values: "spacing" },
    bottom: { values: "spacing" },
    insetBlockEnd: { values: "spacing" },
    left: { values: "spacing" },
    right: { values: "spacing" },
    insetInlineStart: {
      values: "spacing",
      shorthand: ["insetStart"]
    },
    insetInlineEnd: {
      values: "spacing",
      shorthand: ["insetEnd"]
    },
    // shadow / ring
    ring: {
      transform(value) {
        return {
          "--ring-offset-shadow": `var(--ring-inset) 0 0 0 var(--ring-offset-width) var(--ring-offset-color)`,
          "--ring-shadow": `var(--ring-inset) 0 0 0 calc(var(--ring-width) + var(--ring-offset-width)) var(--ring-color)`,
          "--ring-width": value,
          boxShadow: "var(--ring-offset-shadow), var(--ring-shadow), var(--shadow, 0 0 #0000)"
        };
      }
    },
    ringColor: {
      values: colorValues,
      transform: createColorMixTransform("--ring-color")
    },
    ringOffset: {
      transform: (value) => ({ "--ring-offset-width": value })
    },
    ringOffsetColor: {
      values: colorValues,
      transform: createColorMixTransform("--ring-offset-color")
    },
    ringInset: {
      transform: (v) => ({ "--ring-inset": v })
    },
    // margin
    margin: { values: "spacing", shorthand: ["m"] },
    marginTop: { values: "spacing", shorthand: ["mt"] },
    marginBlockStart: { values: "spacing" },
    marginRight: { values: "spacing", shorthand: ["mr"] },
    marginBottom: { values: "spacing", shorthand: ["mb"] },
    marginBlockEnd: { values: "spacing" },
    marginLeft: { values: "spacing", shorthand: ["ml"] },
    marginInlineStart: { values: "spacing", shorthand: ["ms", "marginStart"] },
    marginInlineEnd: { values: "spacing", shorthand: ["me", "marginEnd"] },
    marginInline: { values: "spacing", shorthand: ["mx", "marginX"] },
    marginBlock: { values: "spacing", shorthand: ["my", "marginY"] },
    // padding
    padding: { values: "spacing", shorthand: ["p"] },
    paddingTop: { values: "spacing", shorthand: ["pt"] },
    paddingRight: { values: "spacing", shorthand: ["pr"] },
    paddingBottom: { values: "spacing", shorthand: ["pb"] },
    paddingBlockStart: { values: "spacing" },
    paddingBlockEnd: { values: "spacing" },
    paddingLeft: { values: "spacing", shorthand: ["pl"] },
    paddingInlineStart: {
      values: "spacing",
      shorthand: ["ps", "paddingStart"]
    },
    paddingInlineEnd: { values: "spacing", shorthand: ["pe", "paddingEnd"] },
    paddingInline: { values: "spacing", shorthand: ["px", "paddingX"] },
    paddingBlock: { values: "spacing", shorthand: ["py", "paddingY"] },
    // text decoration
    textDecoration: { shorthand: ["textDecor"] },
    textDecorationColor: {
      values: colorValues,
      transform: createColorMixTransform("textDecorationColor")
    },
    textShadow: { values: "shadows" },
    // transform
    transform: {
      transform: (value) => {
        let v = value;
        if (value === "auto") {
          v = `translateX(var(--translate-x, 0)) translateY(var(--translate-y, 0)) rotate(var(--rotate, 0)) scaleX(var(--scale-x, 1)) scaleY(var(--scale-y, 1)) skewX(var(--skew-x, 0)) skewY(var(--skew-y, 0))`;
        }
        if (value === "auto-gpu") {
          v = `translate3d(var(--translate-x, 0), var(--translate-y, 0), 0) rotate(var(--rotate, 0)) scaleX(var(--scale-x, 1)) scaleY(var(--scale-y, 1)) skewX(var(--skew-x, 0)) skewY(var(--skew-y, 0))`;
        }
        return { transform: v };
      }
    },
    skewX: { transform: (v) => ({ "--skew-x": deg(v) }) },
    skewY: { transform: (v) => ({ "--skew-y": deg(v) }) },
    scaleX: { transform: (v) => ({ "--scale-x": v }) },
    scaleY: { transform: (v) => ({ "--scale-y": v }) },
    scale: {
      transform(value) {
        if (value !== "auto") return { scale: value };
        return {
          scale: `var(--scale-x, 1) var(--scale-y, 1)`
        };
      }
    },
    spaceXReverse: {
      values: { type: "boolean" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            "--space-x-reverse": value ? "1" : void 0
          }
        };
      }
    },
    spaceX: {
      property: "marginInlineStart",
      values: "spacing",
      transform: (v) => ({
        "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
          "--space-x-reverse": "0",
          marginInlineStart: `calc(${v} * calc(1 - var(--space-x-reverse)))`,
          marginInlineEnd: `calc(${v} * var(--space-x-reverse))`
        }
      })
    },
    spaceYReverse: {
      values: { type: "boolean" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            "--space-y-reverse": value ? "1" : void 0
          }
        };
      }
    },
    spaceY: {
      property: "marginTop",
      values: "spacing",
      transform: (v) => ({
        "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
          "--space-y-reverse": "0",
          marginTop: `calc(${v} * calc(1 - var(--space-y-reverse)))`,
          marginBottom: `calc(${v} * var(--space-y-reverse))`
        }
      })
    },
    rotate: {
      transform(value) {
        if (value !== "auto") return { rotate: deg(value) };
        return {
          rotate: `var(--rotate-x, 0) var(--rotate-y, 0) var(--rotate-z, 0)`
        };
      }
    },
    rotateX: {
      transform(value) {
        return { "--rotate-x": deg(value) };
      }
    },
    rotateY: {
      transform(value) {
        return { "--rotate-y": deg(value) };
      }
    },
    // transform / translate
    translate: {
      transform(value) {
        if (value !== "auto") return { translate: value };
        return {
          translate: `var(--translate-x) var(--translate-y)`
        };
      }
    },
    translateX: {
      values: "spacing",
      transform: (v) => ({ "--translate-x": v })
    },
    translateY: {
      values: "spacing",
      transform: (v) => ({ "--translate-y": v })
    },
    // transition
    transition: {
      values: [
        "all",
        "common",
        "colors",
        "opacity",
        "position",
        "backgrounds",
        "size",
        "shadow",
        "transform"
      ],
      transform(value) {
        switch (value) {
          case "all":
            return createTransition("all");
          case "position":
            return createTransition(
              "left, right, top, bottom, inset-inline, inset-block"
            );
          case "colors":
            return createTransition(
              "color, background-color, border-color, text-decoration-color, fill, stroke"
            );
          case "opacity":
            return createTransition("opacity");
          case "shadow":
            return createTransition("box-shadow");
          case "transform":
            return createTransition("transform");
          case "size":
            return createTransition("width, height");
          case "backgrounds":
            return createTransition(
              "background, background-color, background-image, background-position"
            );
          case "common":
            return createTransition(
              "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter"
            );
          default:
            return { transition: value };
        }
      }
    },
    transitionDuration: { values: "durations" },
    transitionProperty: {
      values: {
        common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, translate, transform",
        colors: "background-color, border-color, color, fill, stroke",
        size: "width, height",
        position: "left, right, top, bottom, inset-inline, inset-block",
        background: "background, background-color, background-image, background-position"
      }
    },
    transitionTimingFunction: { values: "easings" },
    // animation
    animation: { values: "animations" },
    animationDuration: { values: "durations" },
    animationDelay: { values: "durations" },
    animationTimingFunction: { values: "easings" },
    // typography
    fontFamily: { values: "fonts" },
    fontSize: { values: "fontSizes" },
    fontWeight: { values: "fontWeights" },
    lineHeight: { values: "lineHeights" },
    letterSpacing: { values: "letterSpacings" },
    textIndent: { values: "spacing" },
    truncate: {
      values: { type: "boolean" },
      transform(value) {
        if (value === true) {
          return {
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
          };
        }
        return {};
      }
    },
    lineClamp: {
      transform(value) {
        if (value === "none") {
          return {
            WebkitLineClamp: "unset"
          };
        }
        return {
          overflow: "hidden",
          display: "-webkit-box",
          WebkitLineClamp: value,
          WebkitBoxOrient: "vertical",
          textWrap: "wrap"
        };
      }
    },
    // helpers
    srOnly: {
      values: { type: "boolean" },
      transform(value) {
        return srMapping[value] || {};
      }
    },
    debug: {
      values: { type: "boolean" },
      transform(value) {
        if (!value) return {};
        return {
          outline: "1px solid blue !important",
          "& > *": {
            outline: "1px solid red !important"
          }
        };
      }
    },
    caretColor: {
      values: colorValues,
      transform: createColorMixTransform("caretColor")
    },
    cursor: { values: "cursor" }
  }
});
var srMapping = {
  true: {
    position: "absolute",
    width: "1px",
    height: "1px",
    padding: "0",
    margin: "-1px",
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    borderWidth: "0"
  },
  false: {
    position: "static",
    width: "auto",
    height: "auto",
    padding: "0",
    margin: "0",
    overflow: "visible",
    clip: "auto",
    whiteSpace: "normal"
  }
};

// node_modules/@pandacss/is-valid-prop/dist/index.mjs
var userGeneratedStr = "";
var userGenerated = userGeneratedStr.split(",");
var cssPropertiesStr = "WebkitAppearance,WebkitBorderBefore,WebkitBorderBeforeColor,WebkitBorderBeforeStyle,WebkitBorderBeforeWidth,WebkitBoxReflect,WebkitLineClamp,WebkitMask,WebkitMaskAttachment,WebkitMaskClip,WebkitMaskComposite,WebkitMaskImage,WebkitMaskOrigin,WebkitMaskPosition,WebkitMaskPositionX,WebkitMaskPositionY,WebkitMaskRepeat,WebkitMaskRepeatX,WebkitMaskRepeatY,WebkitMaskSize,WebkitOverflowScrolling,WebkitTapHighlightColor,WebkitTextFillColor,WebkitTextStroke,WebkitTextStrokeColor,WebkitTextStrokeWidth,WebkitTouchCallout,WebkitUserModify,accentColor,alignContent,alignItems,alignSelf,alignTracks,all,animation,animationComposition,animationDelay,animationDirection,animationDuration,animationFillMode,animationIterationCount,animationName,animationPlayState,animationRange,animationRangeEnd,animationRangeStart,animationTimingFunction,animationTimeline,appearance,aspectRatio,azimuth,backdropFilter,backfaceVisibility,background,backgroundAttachment,backgroundBlendMode,backgroundClip,backgroundColor,backgroundImage,backgroundOrigin,backgroundPosition,backgroundPositionX,backgroundPositionY,backgroundRepeat,backgroundSize,blockSize,border,borderBlock,borderBlockColor,borderBlockStyle,borderBlockWidth,borderBlockEnd,borderBlockEndColor,borderBlockEndStyle,borderBlockEndWidth,borderBlockStart,borderBlockStartColor,borderBlockStartStyle,borderBlockStartWidth,borderBottom,borderBottomColor,borderBottomLeftRadius,borderBottomRightRadius,borderBottomStyle,borderBottomWidth,borderCollapse,borderColor,borderEndEndRadius,borderEndStartRadius,borderImage,borderImageOutset,borderImageRepeat,borderImageSlice,borderImageSource,borderImageWidth,borderInline,borderInlineEnd,borderInlineColor,borderInlineStyle,borderInlineWidth,borderInlineEndColor,borderInlineEndStyle,borderInlineEndWidth,borderInlineStart,borderInlineStartColor,borderInlineStartStyle,borderInlineStartWidth,borderLeft,borderLeftColor,borderLeftStyle,borderLeftWidth,borderRadius,borderRight,borderRightColor,borderRightStyle,borderRightWidth,borderSpacing,borderStartEndRadius,borderStartStartRadius,borderStyle,borderTop,borderTopColor,borderTopLeftRadius,borderTopRightRadius,borderTopStyle,borderTopWidth,borderWidth,bottom,boxAlign,boxDecorationBreak,boxDirection,boxFlex,boxFlexGroup,boxLines,boxOrdinalGroup,boxOrient,boxPack,boxShadow,boxSizing,breakAfter,breakBefore,breakInside,captionSide,caret,caretColor,caretShape,clear,clip,clipPath,color,colorScheme,columnCount,columnFill,columnGap,columnRule,columnRuleColor,columnRuleStyle,columnRuleWidth,columnSpan,columnWidth,columns,contain,containIntrinsicSize,containIntrinsicBlockSize,containIntrinsicHeight,containIntrinsicInlineSize,containIntrinsicWidth,container,containerName,containerType,content,contentVisibility,counterIncrement,counterReset,counterSet,cursor,direction,display,emptyCells,filter,flex,flexBasis,flexDirection,flexFlow,flexGrow,flexShrink,flexWrap,float,font,fontFamily,fontFeatureSettings,fontKerning,fontLanguageOverride,fontOpticalSizing,fontPalette,fontVariationSettings,fontSize,fontSizeAdjust,fontSmooth,fontStretch,fontStyle,fontSynthesis,fontSynthesisPosition,fontSynthesisSmallCaps,fontSynthesisStyle,fontSynthesisWeight,fontVariant,fontVariantAlternates,fontVariantCaps,fontVariantEastAsian,fontVariantEmoji,fontVariantLigatures,fontVariantNumeric,fontVariantPosition,fontWeight,forcedColorAdjust,gap,grid,gridArea,gridAutoColumns,gridAutoFlow,gridAutoRows,gridColumn,gridColumnEnd,gridColumnGap,gridColumnStart,gridGap,gridRow,gridRowEnd,gridRowGap,gridRowStart,gridTemplate,gridTemplateAreas,gridTemplateColumns,gridTemplateRows,hangingPunctuation,height,hyphenateCharacter,hyphenateLimitChars,hyphens,imageOrientation,imageRendering,imageResolution,imeMode,initialLetter,initialLetterAlign,inlineSize,inputSecurity,inset,insetBlock,insetBlockEnd,insetBlockStart,insetInline,insetInlineEnd,insetInlineStart,isolation,justifyContent,justifyItems,justifySelf,justifyTracks,left,letterSpacing,lineBreak,lineClamp,lineHeight,lineHeightStep,listStyle,listStyleImage,listStylePosition,listStyleType,margin,marginBlock,marginBlockEnd,marginBlockStart,marginBottom,marginInline,marginInlineEnd,marginInlineStart,marginLeft,marginRight,marginTop,marginTrim,mask,maskBorder,maskBorderMode,maskBorderOutset,maskBorderRepeat,maskBorderSlice,maskBorderSource,maskBorderWidth,maskClip,maskComposite,maskImage,maskMode,maskOrigin,maskPosition,maskRepeat,maskSize,maskType,masonryAutoFlow,mathDepth,mathShift,mathStyle,maxBlockSize,maxHeight,maxInlineSize,maxLines,maxWidth,minBlockSize,minHeight,minInlineSize,minWidth,mixBlendMode,objectFit,objectPosition,offset,offsetAnchor,offsetDistance,offsetPath,offsetPosition,offsetRotate,opacity,order,orphans,outline,outlineColor,outlineOffset,outlineStyle,outlineWidth,overflow,overflowAnchor,overflowBlock,overflowClipBox,overflowClipMargin,overflowInline,overflowWrap,overflowX,overflowY,overlay,overscrollBehavior,overscrollBehaviorBlock,overscrollBehaviorInline,overscrollBehaviorX,overscrollBehaviorY,padding,paddingBlock,paddingBlockEnd,paddingBlockStart,paddingBottom,paddingInline,paddingInlineEnd,paddingInlineStart,paddingLeft,paddingRight,paddingTop,page,pageBreakAfter,pageBreakBefore,pageBreakInside,paintOrder,perspective,perspectiveOrigin,placeContent,placeItems,placeSelf,pointerEvents,position,printColorAdjust,quotes,resize,right,rotate,rowGap,rubyAlign,rubyMerge,rubyPosition,scale,scrollbarColor,scrollbarGutter,scrollbarWidth,scrollBehavior,scrollMargin,scrollMarginBlock,scrollMarginBlockStart,scrollMarginBlockEnd,scrollMarginBottom,scrollMarginInline,scrollMarginInlineStart,scrollMarginInlineEnd,scrollMarginLeft,scrollMarginRight,scrollMarginTop,scrollPadding,scrollPaddingBlock,scrollPaddingBlockStart,scrollPaddingBlockEnd,scrollPaddingBottom,scrollPaddingInline,scrollPaddingInlineStart,scrollPaddingInlineEnd,scrollPaddingLeft,scrollPaddingRight,scrollPaddingTop,scrollSnapAlign,scrollSnapCoordinate,scrollSnapDestination,scrollSnapPointsX,scrollSnapPointsY,scrollSnapStop,scrollSnapType,scrollSnapTypeX,scrollSnapTypeY,scrollTimeline,scrollTimelineAxis,scrollTimelineName,shapeImageThreshold,shapeMargin,shapeOutside,tabSize,tableLayout,textAlign,textAlignLast,textCombineUpright,textDecoration,textDecorationColor,textDecorationLine,textDecorationSkip,textDecorationSkipInk,textDecorationStyle,textDecorationThickness,textEmphasis,textEmphasisColor,textEmphasisPosition,textEmphasisStyle,textIndent,textJustify,textOrientation,textOverflow,textRendering,textShadow,textSizeAdjust,textTransform,textUnderlineOffset,textUnderlinePosition,textWrap,timelineScope,top,touchAction,transform,transformBox,transformOrigin,transformStyle,transition,transitionBehavior,transitionDelay,transitionDuration,transitionProperty,transitionTimingFunction,translate,unicodeBidi,userSelect,verticalAlign,viewTimeline,viewTimelineAxis,viewTimelineInset,viewTimelineName,viewTransitionName,visibility,whiteSpace,whiteSpaceCollapse,widows,width,willChange,wordBreak,wordSpacing,wordWrap,writingMode,zIndex,zoom,alignmentBaseline,baselineShift,clipRule,colorInterpolation,colorRendering,dominantBaseline,fill,fillOpacity,fillRule,floodColor,floodOpacity,glyphOrientationVertical,lightingColor,marker,markerEnd,markerMid,markerStart,shapeRendering,stopColor,stopOpacity,stroke,strokeDasharray,strokeDashoffset,strokeLinecap,strokeLinejoin,strokeMiterlimit,strokeOpacity,strokeWidth,textAnchor,vectorEffect";
var allCssProperties = cssPropertiesStr.split(",").concat(userGenerated);
var properties = new Map(allCssProperties.map((prop) => [prop, true]));
function memo2(fn) {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (arg) => {
    if (cache2[arg] === void 0)
      cache2[arg] = fn(arg);
    return cache2[arg];
  };
}
var cssPropertySelectorRegex = /&|@/;
var isCssProperty = memo2((prop) => {
  return properties.has(prop) || prop.startsWith("--") || cssPropertySelectorRegex.test(prop);
});

// node_modules/@chakra-ui/react/dist/esm/utils/walk-object.js
var isNotNullish = (element) => element != null;
function walkObject(target, predicate, options = {}) {
  const { stop, getKey } = options;
  function inner(value, path = []) {
    if (isObject(value) || Array.isArray(value)) {
      const result = {};
      for (const [prop, child] of Object.entries(value)) {
        const key = (getKey == null ? void 0 : getKey(prop, child)) ?? prop;
        const childPath = [...path, key];
        if (stop == null ? void 0 : stop(value, childPath)) {
          return predicate(value, path);
        }
        const next3 = inner(child, childPath);
        if (isNotNullish(next3)) {
          result[key] = next3;
        }
      }
      return result;
    }
    return predicate(value, path);
  }
  return inner(target);
}
function mapObject(obj, fn) {
  if (Array.isArray(obj)) return obj.map((value) => fn(value));
  if (!isObject(obj)) {
    if (obj !== null && obj !== void 0) return fn(obj);
    else return obj;
  }
  return walkObject(obj, (value) => fn(value));
}

// node_modules/@chakra-ui/react/dist/esm/utils/flatten.js
function flatten(values, stop) {
  const result = {};
  walkObject(
    values,
    (token2, paths) => {
      if (token2) {
        result[paths.join(".")] = token2.value;
      }
    },
    { stop }
  );
  return result;
}

// node_modules/@chakra-ui/react/dist/esm/utils/memo.js
var import_fast_safe_stringify = __toESM(require_fast_safe_stringify(), 1);
var memo3 = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  function get(...args) {
    const key = args.map((v) => (0, import_fast_safe_stringify.default)(v)).join("|");
    if (cache2[key] === void 0) cache2[key] = fn(...args);
    return cache2[key];
  }
  return get;
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/unit-conversion.js
var BASE_FONT_SIZE = 16;
var UNIT_PX = "px";
var UNIT_EM = "em";
var UNIT_REM = "rem";
function getUnit(value = "") {
  const DIGIT_REGEX = new RegExp(String.raw`-?\d+(?:\.\d+|\d*)`);
  const UNIT_REGEX = new RegExp(`${UNIT_PX}|${UNIT_EM}|${UNIT_REM}`);
  const unit = value.match(
    new RegExp(`${DIGIT_REGEX.source}(${UNIT_REGEX.source})`)
  );
  return unit == null ? void 0 : unit[1];
}
function toPx(value = "") {
  if (typeof value === "number") {
    return `${value}px`;
  }
  const unit = getUnit(value);
  if (!unit) return value;
  if (unit === UNIT_PX) {
    return value;
  }
  if (unit === UNIT_EM || unit === UNIT_REM) {
    return `${parseFloat(value) * BASE_FONT_SIZE}${UNIT_PX}`;
  }
}
function toRem(value = "") {
  const unit = getUnit(value);
  if (!unit) return value;
  if (unit === UNIT_REM) {
    return value;
  }
  if (unit === UNIT_EM) {
    return `${parseFloat(value)}${UNIT_REM}`;
  }
  if (unit === UNIT_PX) {
    return `${parseFloat(value) / BASE_FONT_SIZE}${UNIT_REM}`;
  }
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/breakpoints.js
var capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
function createBreakpoints(breakpoints2) {
  const sorted = sort(breakpoints2);
  const values = Object.fromEntries(sorted);
  function get(name) {
    return values[name];
  }
  function only(name) {
    return build(get(name));
  }
  function getRanges() {
    const breakpoints22 = Object.keys(values);
    const permuations = getPermutations(breakpoints22);
    const results = breakpoints22.flatMap((name) => {
      const value = get(name);
      const down2 = [
        `${name}Down`,
        build({ max: adjust(value.min) })
      ];
      const up2 = [name, build({ min: value.min })];
      const _only = [`${name}Only`, only(name)];
      return [up2, _only, down2];
    }).filter(([, value]) => value !== "").concat(
      permuations.map(([min4, max4]) => {
        const minValue = get(min4);
        const maxValue2 = get(max4);
        return [
          `${min4}To${capitalize(max4)}`,
          build({ min: minValue.min, max: adjust(maxValue2.min) })
        ];
      })
    );
    return Object.fromEntries(results);
  }
  function toConditions() {
    const ranges = getRanges();
    return Object.fromEntries(Object.entries(ranges));
  }
  const conditions = toConditions();
  const getCondition = (key) => {
    return conditions[key];
  };
  function keys() {
    return ["base", ...Object.keys(values)];
  }
  function up(name) {
    return build({ min: get(name).min });
  }
  function down(name) {
    return build({ max: adjust(get(name).min) });
  }
  return {
    values: Object.values(values),
    only,
    keys,
    conditions,
    getCondition,
    up,
    down
  };
}
function adjust(value) {
  const computedMax = parseFloat(toPx(value) ?? "") - 0.04;
  return toRem(`${computedMax}px`);
}
function sort(breakpoints2) {
  const entries = Object.entries(breakpoints2).sort(([, minA], [, minB]) => {
    return parseInt(minA, 10) < parseInt(minB, 10) ? -1 : 1;
  });
  return entries.map(([name, min4], index, entries2) => {
    var _a8;
    let max4 = null;
    if (index <= entries2.length - 1) {
      max4 = (_a8 = entries2[index + 1]) == null ? void 0 : _a8[1];
    }
    if (max4 != null) {
      max4 = adjust(max4);
    }
    return [name, { name, min: toRem(min4), max: max4 }];
  });
}
function getPermutations(values) {
  const result = [];
  values.forEach((current, index) => {
    let idx = index;
    idx++;
    let next3 = values[idx];
    while (next3) {
      result.push([current, next3]);
      idx++;
      next3 = values[idx];
    }
  });
  return result;
}
function build({ min: min4, max: max4 }) {
  if (min4 == null && max4 == null) return "";
  return [
    "@media screen",
    min4 && `(min-width: ${min4})`,
    max4 && `(max-width: ${max4})`
  ].filter(Boolean).join(" and ");
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/conditions.js
var mapEntries = (obj, fn) => {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => fn(key, value))
  );
};
var createConditions = (options) => {
  const { breakpoints: breakpoints2, conditions: conds = {} } = options;
  const conditions = mapEntries(conds, (key, value) => [`_${key}`, value]);
  const values = Object.assign({}, conditions, breakpoints2.conditions);
  function keys() {
    return Object.keys(values);
  }
  function has2(key) {
    return keys().includes(key) || /^@|&|&$/.test(key) || key.startsWith("_");
  }
  function sort2(paths) {
    return paths.filter((v) => v !== "base").sort((a2, b2) => {
      const aa = has2(a2);
      const bb = has2(b2);
      if (aa && !bb) return 1;
      if (!aa && bb) return -1;
      return 0;
    });
  }
  function expandAtRule(key) {
    if (!key.startsWith("@breakpoint")) return key;
    return breakpoints2.getCondition(key.replace("@breakpoint ", ""));
  }
  function resolve(key) {
    return Reflect.get(values, key) || key;
  }
  return {
    keys,
    sort: sort2,
    has: has2,
    resolve,
    breakpoints: breakpoints2.keys(),
    expandAtRule
  };
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/sort-at-params.js
var createMediaQueryRegex = (dimension) => ({
  minMax: new RegExp(
    `(!?\\(\\s*min(-device-)?-${dimension})(.|
)+\\(\\s*max(-device)?-${dimension}`,
    "i"
  ),
  min: new RegExp(`\\(\\s*min(-device)?-${dimension}`, "i"),
  maxMin: new RegExp(
    `(!?\\(\\s*max(-device)?-${dimension})(.|
)+\\(\\s*min(-device)?-${dimension}`,
    "i"
  ),
  max: new RegExp(`\\(\\s*max(-device)?-${dimension}`, "i")
});
var widthRegex = createMediaQueryRegex("width");
var heightRegex = createMediaQueryRegex("height");
var createQueryTester = (regexSet) => ({
  isMin: _testQuery(regexSet.minMax, regexSet.maxMin, regexSet.min),
  isMax: _testQuery(regexSet.maxMin, regexSet.minMax, regexSet.max)
});
var { isMin: isMinWidth, isMax: isMaxWidth } = createQueryTester(widthRegex);
var { isMin: isMinHeight, isMax: isMaxHeight } = createQueryTester(heightRegex);
var isPrint = /print/i;
var isPrintOnly = /^print$/i;
var isLength = /(-?\d*\.?\d+)(ch|em|ex|px|rem)/;
var lengthExec = /(\d)/;
var maxValue = Number.MAX_VALUE;
var multipliers = { ch: 8.8984375, em: 16, rem: 16, ex: 8.296875, px: 1 };
function getQueryLength(query2) {
  const length2 = isLength.exec(query2) || (isMinWidth(query2) || isMinHeight(query2) ? lengthExec.exec(query2) : null);
  if (!length2) return maxValue;
  if (length2[0] === "0") return 0;
  const number = parseFloat(length2[1]);
  const unit = length2[2];
  return number * (multipliers[unit] || 1);
}
function _testQuery(doubleTestTrue, doubleTestFalse, singleTest) {
  return (query2) => doubleTestTrue.test(query2) || !doubleTestFalse.test(query2) && singleTest.test(query2);
}
function _testIsPrint(a2, b2) {
  const isPrintA = isPrint.test(a2), isPrintOnlyA = isPrintOnly.test(a2);
  const isPrintB = isPrint.test(b2), isPrintOnlyB = isPrintOnly.test(b2);
  if (isPrintA && isPrintB) {
    if (!isPrintOnlyA && isPrintOnlyB) return 1;
    if (isPrintOnlyA && !isPrintOnlyB) return -1;
    return a2.localeCompare(b2);
  }
  return isPrintA ? 1 : isPrintB ? -1 : null;
}
var sortAtParams = memo3((a2, b2) => {
  const testIsPrint = _testIsPrint(a2, b2);
  if (testIsPrint !== null) return testIsPrint;
  const minA = isMinWidth(a2) || isMinHeight(a2), maxA = isMaxWidth(a2) || isMaxHeight(a2);
  const minB = isMinWidth(b2) || isMinHeight(b2), maxB = isMaxWidth(b2) || isMaxHeight(b2);
  if (minA && maxB) return -1;
  if (maxA && minB) return 1;
  const lengthA = getQueryLength(a2), lengthB = getQueryLength(b2);
  if (lengthA === maxValue && lengthB === maxValue) return a2.localeCompare(b2);
  if (lengthA === maxValue) return 1;
  if (lengthB === maxValue) return -1;
  if (lengthA !== lengthB) {
    return lengthA > lengthB ? maxA ? -1 : 1 : maxA ? 1 : -1;
  }
  return a2.localeCompare(b2);
});

// node_modules/@chakra-ui/react/dist/esm/styled-system/sort-at-rules.js
function sortQueries(queries) {
  return queries.sort(([a2], [b2]) => sortAtParams(a2, b2));
}
function sortAtRules(obj) {
  const mediaQueries = [];
  const containerQueries = [];
  const rest = {};
  for (const [key, value] of Object.entries(obj)) {
    if (key.startsWith("@media")) {
      mediaQueries.push([key, value]);
    } else if (key.startsWith("@container")) {
      containerQueries.push([key, value]);
    } else if (isObject(value)) {
      rest[key] = sortAtRules(value);
    } else {
      rest[key] = value;
    }
  }
  const sortedMediaQueries = sortQueries(mediaQueries);
  const sortedContainerQueries = sortQueries(containerQueries);
  return {
    ...rest,
    ...Object.fromEntries(sortedMediaQueries),
    ...Object.fromEntries(sortedContainerQueries)
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/css.js
var importantRegex = /\s*!(important)?/i;
var isImportant = (v) => isString(v) ? importantRegex.test(v) : false;
var withoutImportant = (v) => isString(v) ? v.replace(importantRegex, "").trim() : v;
function createCssFn(context) {
  const { transform: transform2, conditions, normalize: normalize3 } = context;
  const mergeFn = mergeCss(context);
  return memo3(function cssFn(...styleArgs) {
    const styles = mergeFn(...styleArgs);
    const normalized = normalize3(styles);
    const result = /* @__PURE__ */ Object.create(null);
    walkObject(normalized, (value, paths) => {
      const important = isImportant(value);
      if (value == null) return;
      const [prop, ...selectors] = conditions.sort(paths).map(conditions.resolve);
      if (important) {
        value = withoutImportant(value);
      }
      let transformed = transform2(prop, value) ?? /* @__PURE__ */ Object.create(null);
      transformed = walkObject(
        transformed,
        (v) => isString(v) && important ? `${v} !important` : v,
        { getKey: (prop2) => conditions.expandAtRule(prop2) }
      );
      mergeByPath(result, selectors.flat(), transformed);
    });
    return sortAtRules(result);
  });
}
function mergeByPath(target, paths, value) {
  let acc = target;
  for (const path of paths) {
    if (!path) continue;
    if (!acc[path]) acc[path] = /* @__PURE__ */ Object.create(null);
    acc = acc[path];
  }
  mergeWith(acc, value);
}
function compactFn(...styles) {
  return styles.filter(
    (style) => isObject(style) && Object.keys(compact(style)).length > 0
  );
}
function mergeCss(ctx) {
  function resolve(styles) {
    const comp = compactFn(...styles);
    if (comp.length === 1) return comp;
    return comp.map((style) => ctx.normalize(style));
  }
  return memo3(function mergeFn(...styles) {
    return mergeWith({}, ...resolve(styles));
  });
}

// node_modules/@chakra-ui/react/dist/esm/utils/omit.js
function omit(object, keysToOmit = []) {
  const clone3 = Object.assign({}, object);
  for (const key of keysToOmit) {
    if (key in clone3) {
      delete clone3[key];
    }
  }
  return clone3;
}

// node_modules/@chakra-ui/react/dist/esm/utils/uniq.js
var uniq3 = (...items) => {
  const _items = items.filter(Boolean);
  return Array.from(new Set(_items));
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/cva.js
var defaults = (conf) => ({
  base: {},
  variants: {},
  defaultVariants: {},
  compoundVariants: [],
  ...conf
});
function createRecipeFn(options) {
  const { css: css2, conditions, normalize: normalize3, layers } = options;
  function cva(config = {}) {
    const { base, variants: variants3, defaultVariants: defaultVariants3, compoundVariants } = defaults(config);
    const getVariantCss = createCssFn({
      conditions,
      normalize: normalize3,
      transform(prop, value) {
        var _a8;
        return (_a8 = variants3[prop]) == null ? void 0 : _a8[value];
      }
    });
    const resolve = (props34 = {}) => {
      const variantSelections = normalize3({
        ...defaultVariants3,
        ...compact(props34)
      });
      let variantCss = { ...base };
      mergeWith(variantCss, getVariantCss(variantSelections));
      const compoundVariantCss = getCompoundVariantCss(
        compoundVariants,
        variantSelections
      );
      return layers.wrap("recipes", css2(variantCss, compoundVariantCss));
    };
    const variantKeys = Object.keys(variants3);
    const splitVariantProps = (props34) => {
      const restProps = omit(props34, ["recipe"]);
      const [recipeProps, localProps] = splitProps(restProps, variantKeys);
      if (!variantKeys.includes("colorPalette")) {
        recipeProps.colorPalette = props34.colorPalette || defaultVariants3.colorPalette;
      }
      if (variantKeys.includes("orientation")) {
        localProps.orientation = props34.orientation;
      }
      return [recipeProps, localProps];
    };
    const variantMap = Object.fromEntries(
      Object.entries(variants3).map(([key, value]) => [
        key,
        Object.keys(value)
      ])
    );
    const cvaFn = (props34) => css2(resolve(props34));
    return Object.assign(cvaFn, {
      className: config.className,
      __cva__: true,
      variantMap,
      variantKeys,
      raw: resolve,
      config,
      splitVariantProps,
      merge(other) {
        return cva(mergeCva2(options)(this, other));
      }
    });
  }
  function getCompoundVariantCss(cvs, vm) {
    let result = {};
    cvs.forEach((cv) => {
      const isMatching = Object.entries(cv).every(([key, value]) => {
        if (key === "css") return true;
        const values = Array.isArray(value) ? value : [value];
        return values.some((value2) => vm[key] === value2);
      });
      if (isMatching) {
        result = css2(result, cv.css);
      }
    });
    return result;
  }
  return cva;
}
function mergeCva2(opts) {
  const { css: css2 } = opts;
  return function mergeCva22(cvaA, cvaB) {
    const override = defaults(cvaB.config);
    const variantKeys = uniq3(cvaA.variantKeys, Object.keys(cvaB.variants));
    const base = css2(cvaA.base, override.base);
    const variants3 = Object.fromEntries(
      variantKeys.map((key) => [
        key,
        css2(cvaA.config.variants[key], override.variants[key])
      ])
    );
    const defaultVariants3 = mergeWith(
      cvaA.config.defaultVariants,
      override.defaultVariants
    );
    const compoundVariants = [
      ...cvaA.compoundVariants,
      ...override.compoundVariants
    ];
    const className = cx(cvaA.className, cvaB.className);
    return {
      className,
      base,
      variants: variants3,
      defaultVariants: defaultVariants3,
      compoundVariants
    };
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/layers.js
var defaultLayers = {
  reset: "reset",
  base: "base",
  tokens: "tokens",
  recipes: "recipes"
};
var layerOrder = {
  reset: 0,
  base: 1,
  tokens: 2,
  recipes: 3
};
function createLayers(config) {
  const layers = config.layers ?? defaultLayers;
  const values = Object.values(layers);
  const names = values.sort((a2, b2) => layerOrder[a2] - layerOrder[b2]);
  return {
    names,
    atRule: `@layer ${names.join(", ")};`,
    wrap(layer, styles) {
      if (config.disableLayers) return styles;
      const params = layers[layer];
      return { [`@layer ${params}`]: styles };
    }
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/normalize.js
function createNormalizeFn(context) {
  const { utility, normalize: normalize3 } = context;
  const { hasShorthand, resolveShorthand } = utility;
  return function(styles) {
    return walkObject(styles, normalize3, {
      stop: (value) => Array.isArray(value),
      getKey: hasShorthand ? resolveShorthand : void 0
    });
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/preflight.js
function createPreflight(options) {
  const { preflight } = options;
  if (!preflight) return {};
  const { scope = "", level = "parent" } = isObject(preflight) ? preflight : {};
  let selector = "";
  if (scope && level === "parent") {
    selector = `${scope} `;
  } else if (scope && level === "element") {
    selector = `&${scope}`;
  }
  const scoped = {
    "*": {
      margin: "0px",
      padding: "0px",
      font: "inherit",
      wordWrap: "break-word",
      WebkitTapHighlightColor: "transparent"
    },
    "*, *::before, *::after, *::backdrop": {
      boxSizing: "border-box",
      borderWidth: "0px",
      borderStyle: "solid",
      borderColor: "var(--global-color-border, currentColor)"
    },
    hr: {
      height: "0px",
      color: "inherit",
      borderTopWidth: "1px"
    },
    body: {
      minHeight: "100dvh",
      position: "relative"
    },
    img: {
      borderStyle: "none"
    },
    "img, svg, video, canvas, audio, iframe, embed, object": {
      display: "block",
      verticalAlign: "middle"
    },
    iframe: { border: "none" },
    "img, video": { maxWidth: "100%", height: "auto" },
    "p, h1, h2, h3, h4, h5, h6": { overflowWrap: "break-word" },
    "ol, ul": { listStyle: "none" },
    "code, kbd, pre, samp": { fontSize: "1em" },
    "button, [type='button'], [type='reset'], [type='submit']": {
      WebkitAppearance: "button",
      backgroundColor: "transparent",
      backgroundImage: "none"
    },
    "button, input, optgroup, select, textarea": { color: "inherit" },
    "button, select": { textTransform: "none" },
    table: {
      textIndent: "0px",
      borderColor: "inherit",
      borderCollapse: "collapse"
    },
    "*::placeholder": {
      opacity: "unset",
      color: "#9ca3af",
      userSelect: "none"
    },
    textarea: {
      resize: "vertical"
    },
    summary: {
      display: "list-item"
    },
    small: {
      fontSize: "80%"
    },
    "sub, sup": {
      fontSize: "75%",
      lineHeight: 0,
      position: "relative",
      verticalAlign: "baseline"
    },
    sub: {
      bottom: "-0.25em"
    },
    sup: {
      top: "-0.5em"
    },
    dialog: {
      padding: "0px"
    },
    a: {
      color: "inherit",
      textDecoration: "inherit"
    },
    "abbr:where([title])": {
      textDecoration: "underline dotted"
    },
    "b, strong": {
      fontWeight: "bolder"
    },
    "code, kbd, samp, pre": {
      fontSize: "1em",
      "--font-mono-fallback": "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New'",
      fontFamily: "var(--global-font-mono, var(--font-mono-fallback))"
    },
    'input[type="text"], input[type="email"], input[type="search"], input[type="password"]': {
      WebkitAppearance: "none",
      MozAppearance: "none"
    },
    "input[type='search']": {
      WebkitAppearance: "textfield",
      outlineOffset: "-2px"
    },
    "::-webkit-search-decoration, ::-webkit-search-cancel-button": {
      WebkitAppearance: "none"
    },
    "::-webkit-file-upload-button": {
      WebkitAppearance: "button",
      font: "inherit"
    },
    'input[type="number"]::-webkit-inner-spin-button, input[type="number"]::-webkit-outer-spin-button': {
      height: "auto"
    },
    "input[type='number']": {
      MozAppearance: "textfield"
    },
    ":-moz-ui-invalid": {
      boxShadow: "none"
    },
    ":-moz-focusring": {
      outline: "auto"
    },
    "[hidden]:where(:not([hidden='until-found']))": {
      display: "none !important"
    }
  };
  const preflightCss = {
    [scope || "html"]: {
      lineHeight: 1.5,
      "--font-fallback": "ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'",
      WebkitTextSizeAdjust: "100%",
      WebkitFontSmoothing: "antialiased",
      MozOsxFontSmoothing: "grayscale",
      textRendering: "optimizeLegibility",
      touchAction: "manipulation",
      MozTabSize: "4",
      tabSize: "4",
      fontFamily: "var(--global-font-body, var(--font-fallback))"
    }
  };
  if (level === "element") {
    const modified = Object.entries(scoped).reduce((acc, [k, v]) => {
      acc[k] = { [selector]: v };
      return acc;
    }, {});
    Object.assign(preflightCss, modified);
  } else if (selector) {
    preflightCss[selector] = scoped;
  } else {
    Object.assign(preflightCss, scoped);
  }
  return preflightCss;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/serialize.js
function createSerializeFn(options) {
  const { conditions, isValidProperty } = options;
  return function serialize3(styles) {
    return walkObject(styles, (value) => value, {
      getKey: (prop, value) => {
        if (!isObject(value)) return prop;
        if (!conditions.has(prop) && !isValidProperty(prop)) {
          return parseSelectors(prop).map((s) => "&" + s).join(", ");
        }
        return prop;
      }
    });
  };
}
function parseSelectors(selector) {
  const result = [];
  let parenCount = 0;
  let currentSelector = "";
  let inEscape = false;
  for (let i = 0; i < selector.length; i++) {
    const char2 = selector[i];
    if (char2 === "\\" && !inEscape) {
      inEscape = true;
      currentSelector += char2;
      continue;
    }
    if (inEscape) {
      inEscape = false;
      currentSelector += char2;
      continue;
    }
    if (char2 === "(") {
      parenCount++;
    } else if (char2 === ")") {
      parenCount--;
    }
    if (char2 === "," && parenCount === 0) {
      result.push(currentSelector.trim());
      currentSelector = "";
    } else {
      currentSelector += char2;
    }
  }
  if (currentSelector) {
    result.push(currentSelector.trim());
  }
  return result;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/sva.js
var getSlotRecipes = (config = {}) => {
  const init = (slot) => {
    var _a8;
    return {
      base: ((_a8 = config.base) == null ? void 0 : _a8[slot]) ?? {},
      variants: {},
      defaultVariants: config.defaultVariants ?? {},
      compoundVariants: config.compoundVariants ? getSlotCompoundVariant(config.compoundVariants, slot) : []
    };
  };
  const slots = config.slots ?? [];
  const entries = slots.map((slot) => [slot, init(slot)]);
  for (const [variantsKey, variantsSpec] of Object.entries(
    config.variants ?? {}
  )) {
    for (const [variantKey, variantSpec] of Object.entries(
      variantsSpec
    )) {
      entries.forEach(([slot, slotRecipe]) => {
        var _a8;
        (_a8 = slotRecipe.variants)[variantsKey] ?? (_a8[variantsKey] = {});
        slotRecipe.variants[variantsKey][variantKey] = variantSpec[slot] ?? {};
      });
    }
  }
  return Object.fromEntries(entries);
};
var getSlotCompoundVariant = (compoundVariants, slotName) => compoundVariants.filter((compoundVariant) => compoundVariant.css[slotName]).map((compoundVariant) => ({
  ...compoundVariant,
  css: compoundVariant.css[slotName]
}));
function createSlotRecipeFn(options) {
  const { cva } = options;
  return function sva(config = {}) {
    const slots = Object.entries(getSlotRecipes(config)).map(
      ([slot, slotCva]) => [slot, cva(slotCva)]
    );
    function svaFn(props34) {
      const result = slots.map(([slot, cvaFn]) => [slot, cvaFn(props34)]);
      return Object.fromEntries(result);
    }
    const variants3 = config.variants ?? {};
    const variantKeys = Object.keys(variants3);
    function splitVariantProps(props34) {
      var _a8;
      const restProps = omit(props34, ["recipe"]);
      const [recipeProps, localProps] = splitProps(restProps, variantKeys);
      if (!variantKeys.includes("colorPalette")) {
        recipeProps.colorPalette = props34.colorPalette || ((_a8 = config.defaultVariants) == null ? void 0 : _a8.colorPalette);
      }
      if (variantKeys.includes("orientation")) {
        localProps.orientation = props34.orientation;
      }
      return [recipeProps, localProps];
    }
    const variantMap = Object.fromEntries(
      Object.entries(variants3).map(([key, value]) => [key, Object.keys(value)])
    );
    let classNameMap = {};
    if (config.className) {
      classNameMap = Object.fromEntries(
        config.slots.map((slot) => [
          slot,
          `${config.className}__${slot}`
        ])
      );
    }
    return Object.assign(svaFn, {
      variantMap,
      variantKeys,
      splitVariantProps,
      classNameMap
    });
  };
}

// node_modules/@chakra-ui/react/dist/esm/utils/create-props.js
var createProps2 = () => (props34) => Array.from(new Set(props34));

// node_modules/@chakra-ui/react/dist/esm/styled-system/esc.js
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|^-|[^\x80-\uFFFF\w-]/g;
var fcssescape = function(ch, asCodePoint) {
  if (!asCodePoint) return "\\" + ch;
  if (ch === "\0") return "�";
  if (ch === "-" && ch.length === 1) return "\\-";
  return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16);
};
var esc2 = (sel) => {
  return (sel + "").replace(rcssescape, fcssescape);
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/expand-reference.js
var expandTokenReferences = (str, resolve) => {
  let expanded = "";
  let index = 0;
  let state2 = "char";
  let tokenPath = "";
  let fallback4 = "";
  const currentStates = [];
  while (index < str.length) {
    const char2 = str[index];
    if (char2 === "{") {
      const endIndex = str.indexOf("}", index);
      if (endIndex === -1) {
        break;
      }
      const path = str.slice(index + 1, endIndex);
      const resolved = resolve(path);
      expanded += resolved ?? path;
      index = endIndex + 1;
      continue;
    }
    if (state2 === "token") {
      if (char2 === ",") {
        if (str[index] === "") {
          index++;
        }
        state2 = "fallback";
        currentStates.push(state2);
        const resolved = resolve(tokenPath);
        if (resolved == null ? void 0 : resolved.endsWith(")")) {
          expanded += resolved.slice(0, -1);
        }
        tokenPath = "";
        fallback4 = "";
        continue;
      }
    }
    if (state2 === "fallback") {
      const nextFallback = fallback4 + char2;
      if (nextFallback === ", var(") {
        const innerEndIndex = cssVarParser(str.slice(index + 1));
        const endIndex = innerEndIndex + index + 1;
        const cssVar2 = str.slice(index + 1, endIndex);
        if (endIndex === -1) {
          break;
        }
        expanded += ", var(" + cssVar2 + ")";
        index = endIndex + 1;
        state2 = currentStates.pop() ?? state2;
        fallback4 = "";
        continue;
      }
    }
    if (state2 === "token" || state2 === "fallback") {
      index++;
      if (char2 === ")") {
        state2 = currentStates.pop() ?? state2 ?? "char";
        fallback4 += char2;
        const resolved = tokenPath ? resolve(tokenPath) ?? esc2(tokenPath) : tokenPath;
        if (fallback4) {
          fallback4 = fallback4.slice(1).trim();
          if (!fallback4.startsWith("token(") && fallback4.endsWith(")")) {
            fallback4 = fallback4.slice(0, -1);
          }
          if (fallback4.includes("token(")) {
            const parsed = expandTokenReferences(fallback4, resolve);
            if (parsed) {
              fallback4 = parsed.slice(0, -1);
            }
          } else if (fallback4) {
            const resolvedFallback = resolve(fallback4);
            if (resolvedFallback) {
              fallback4 = resolvedFallback;
            }
          }
        }
        const lastChar = expanded.at(-1);
        if (fallback4) {
          if (lastChar == null ? void 0 : lastChar.trim()) {
            expanded += resolved.slice(0, -1) + (", " + fallback4 + ")");
          } else {
            expanded += fallback4;
          }
        } else {
          expanded += resolved || ")";
        }
        tokenPath = "";
        fallback4 = "";
        state2 = "char";
        continue;
      }
      if (state2 === "token") {
        tokenPath += char2;
      }
      if (state2 === "fallback") {
        fallback4 += char2;
      }
      continue;
    }
    const tokenIndex = str.indexOf("token(", index);
    if (tokenIndex !== -1) {
      const innerTokenIndex = tokenIndex + "token(".length;
      expanded += str.slice(index, tokenIndex);
      index = innerTokenIndex;
      state2 = "token";
      currentStates.push(state2);
      continue;
    }
    expanded += char2;
    index++;
  }
  return expanded;
};
var cssVarParser = (str) => {
  let index = 0;
  const openedParenthesises = ["("];
  while (index < str.length) {
    const char2 = str[index];
    if (char2 === "(") {
      openedParenthesises.push(char2);
    } else if (char2 === ")") {
      openedParenthesises.pop();
      if (openedParenthesises.length === 0) {
        return index;
      }
    }
    index++;
  }
  return index;
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/map-to-json.js
function mapToJson(map2) {
  const obj = {};
  map2.forEach((value, key) => {
    if (value instanceof Map) {
      obj[key] = Object.fromEntries(value);
    } else {
      obj[key] = value;
    }
  });
  return obj;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/references.js
var REFERENCE_REGEX = /({([^}]*)})/g;
var CURLY_REGEX = /[{}]/g;
var TOKEN_PATH_REGEX = /\w+\.\w+/;
var getReferences = (value) => {
  if (!isString(value)) return [];
  const matches = value.match(REFERENCE_REGEX);
  if (!matches) return [];
  return matches.map((match5) => match5.replace(CURLY_REGEX, "")).map((value2) => value2.trim());
};
var hasReference = (value) => REFERENCE_REGEX.test(value);
function expandReferences(token2) {
  var _a8, _b7, _c6;
  if (!((_a8 = token2.extensions) == null ? void 0 : _a8.references)) {
    return ((_c6 = (_b7 = token2.extensions) == null ? void 0 : _b7.cssVar) == null ? void 0 : _c6.ref) ?? token2.value;
  }
  const references = token2.extensions.references ?? {};
  token2.value = Object.keys(references).reduce((valueStr, key) => {
    const referenceToken = references[key];
    if (referenceToken.extensions.conditions) {
      return valueStr;
    }
    const value = expandReferences(referenceToken);
    return valueStr.replace(`{${key}}`, value);
  }, token2.value);
  delete token2.extensions.references;
  return token2.value;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/calc.js
function resolveReference(operand) {
  if (isObject(operand) && operand.reference) {
    return operand.reference;
  }
  return String(operand);
}
var toExpression = (operator, ...operands) => operands.map(resolveReference).join(` ${operator} `).replace(/calc/g, "");
var add2 = (...operands) => `calc(${toExpression("+", ...operands)})`;
var subtract = (...operands) => `calc(${toExpression("-", ...operands)})`;
var multiply = (...operands) => `calc(${toExpression("*", ...operands)})`;
var divide = (...operands) => `calc(${toExpression("/", ...operands)})`;
var negate = (x) => {
  const value = resolveReference(x);
  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  }
  return multiply(value, -1);
};
var calc = Object.assign(
  (x) => ({
    add: (...operands) => calc(add2(x, ...operands)),
    subtract: (...operands) => calc(subtract(x, ...operands)),
    multiply: (...operands) => calc(multiply(x, ...operands)),
    divide: (...operands) => calc(divide(x, ...operands)),
    negate: () => calc(negate(x)),
    toString: () => x.toString()
  }),
  {
    add: add2,
    subtract,
    multiply,
    divide,
    negate
  }
);

// node_modules/@chakra-ui/react/dist/esm/styled-system/token-middleware.js
var addNegativeTokens = {
  enforce: "pre",
  transform(dictionary) {
    const { prefix: prefix3, allTokens, formatCssVar, formatTokenName, registerToken } = dictionary;
    const tokens = allTokens.filter(
      ({ extensions }) => extensions.category === "spacing"
    );
    tokens.forEach((token2) => {
      const originalPath = token2.path.slice();
      const originalVar = formatCssVar(originalPath, prefix3);
      if (isString(token2.value) && token2.value === "0rem") {
        return;
      }
      const nextToken = structuredClone(token2);
      Object.assign(nextToken.extensions, {
        negative: true,
        prop: `-${token2.extensions.prop}`,
        originalPath
      });
      nextToken.value = calc.negate(originalVar.ref);
      const lastPath = nextToken.path[nextToken.path.length - 1];
      if (lastPath != null) {
        nextToken.path[nextToken.path.length - 1] = `-${lastPath}`;
      }
      if (nextToken.path) {
        nextToken.name = formatTokenName(nextToken.path);
      }
      registerToken(nextToken);
    });
  }
};
var units = /* @__PURE__ */ new Set([
  "spacing",
  "sizes",
  "borderWidths",
  "fontSizes",
  "radii"
]);
var addPixelUnit = {
  enforce: "post",
  transform(dictionary) {
    const tokens = dictionary.allTokens.filter((token2) => {
      return units.has(token2.extensions.category) && !token2.extensions.negative;
    });
    tokens.forEach((token2) => {
      Object.assign(token2.extensions, {
        pixelValue: toPx(token2.value)
      });
    });
  }
};
var addVirtualPalette = {
  enforce: "post",
  transform(dictionary) {
    const { allTokens, registerToken, formatTokenName } = dictionary;
    const tokens = allTokens.filter(
      ({ extensions }) => extensions.category === "colors"
    );
    const keys = /* @__PURE__ */ new Map();
    const colorPalettes = /* @__PURE__ */ new Map();
    tokens.forEach((token2) => {
      const { colorPalette } = token2.extensions;
      if (!colorPalette) return;
      colorPalette.keys.forEach((keyPath) => {
        keys.set(formatTokenName(keyPath), keyPath);
      });
      colorPalette.roots.forEach((colorPaletteRoot) => {
        var _a8;
        const name = formatTokenName(colorPaletteRoot);
        const colorPaletteList = colorPalettes.get(name) || [];
        colorPaletteList.push(token2);
        colorPalettes.set(name, colorPaletteList);
        if (token2.extensions.default && colorPaletteRoot.length === 1) {
          const keyPath = (_a8 = colorPalette.keys[0]) == null ? void 0 : _a8.filter(Boolean);
          if (!keyPath.length) return;
          const path = colorPaletteRoot.concat(keyPath);
          keys.set(formatTokenName(path), []);
        }
      });
    });
    keys.forEach((segments) => {
      const path = ["colors", "colorPalette", ...segments].filter(Boolean);
      const name = formatTokenName(path);
      const prop = formatTokenName(path.slice(1));
      const token2 = {
        name,
        value: name,
        originalValue: name,
        path,
        extensions: {
          condition: "base",
          originalPath: path,
          category: "colors",
          prop,
          virtual: true
        }
      };
      registerToken(token2, "pre");
    });
  }
};
var removeEmptyTokens = {
  enforce: "post",
  transform(dictionary) {
    dictionary.allTokens = dictionary.allTokens.filter(
      (token2) => token2.value !== ""
    );
  }
};
var tokenMiddlewares = [
  addNegativeTokens,
  addVirtualPalette,
  addPixelUnit,
  removeEmptyTokens
];

// node_modules/@chakra-ui/react/dist/esm/styled-system/token-transforms.js
var addCssVariables = {
  type: "extensions",
  enforce: "pre",
  name: "tokens/css-var",
  transform(token2, dictionary) {
    const { prefix: prefix3, formatCssVar } = dictionary;
    const { negative, originalPath } = token2.extensions;
    const path = negative ? originalPath : token2.path;
    return {
      cssVar: formatCssVar(path.filter(Boolean), prefix3)
    };
  }
};
var addConditionalCssVariables = {
  enforce: "post",
  type: "value",
  name: "tokens/conditionals",
  transform(token2, dictionary) {
    const { prefix: prefix3, formatCssVar } = dictionary;
    const refs = getReferences(token2.value);
    if (!refs.length) return token2.value;
    refs.forEach((ref2) => {
      const variable = formatCssVar(ref2.split("."), prefix3);
      token2.value = token2.value.replace(`{${variable.ref}}`, variable);
    });
    return token2.value;
  }
};
var addColorPalette = {
  type: "extensions",
  enforce: "pre",
  name: "tokens/colors/colorPalette",
  match(token2) {
    return token2.extensions.category === "colors" && !token2.extensions.virtual;
  },
  transform(token2, dict) {
    let path = token2.path.slice();
    path.pop();
    path.shift();
    if (path.length === 0) {
      const newPath = [...token2.path];
      newPath.shift();
      path = newPath;
    }
    if (path.length === 0) {
      return {};
    }
    const roots = path.reduce((acc, _, i, arr) => {
      const next3 = arr.slice(0, i + 1);
      acc.push(next3);
      return acc;
    }, []);
    const root = path[0];
    const value = dict.formatTokenName(path);
    const keys = token2.path.slice(token2.path.indexOf(root) + 1).reduce((acc, _, i, arr) => {
      acc.push(arr.slice(i));
      return acc;
    }, []);
    if (keys.length === 0) {
      keys.push([""]);
    }
    return {
      colorPalette: { value, roots, keys }
    };
  }
};
var tokenTransforms = [
  addCssVariables,
  addConditionalCssVariables,
  addColorPalette
];

// node_modules/@chakra-ui/react/dist/esm/styled-system/token-dictionary.js
var isToken = (value) => {
  return isObject(value) && Object.prototype.hasOwnProperty.call(value, "value");
};
function expandBreakpoints(breakpoints2) {
  if (!breakpoints2) return { breakpoints: {}, sizes: {} };
  return {
    breakpoints: mapObject(breakpoints2, (value) => ({ value })),
    sizes: Object.fromEntries(
      Object.entries(breakpoints2).map(([key, value]) => [
        `breakpoint-${key}`,
        { value }
      ])
    )
  };
}
function createTokenDictionary(options) {
  const {
    prefix: prefix3 = "",
    tokens = {},
    semanticTokens = {},
    breakpoints: breakpoints2 = {}
  } = options;
  const formatTokenName = (path) => path.join(".");
  const formatCssVar = (path, prefix22) => cssVar(path.join("-"), { prefix: prefix22 });
  const allTokens = [];
  const tokenNameMap = /* @__PURE__ */ new Map();
  const conditionMap = /* @__PURE__ */ new Map();
  const cssVarMap = /* @__PURE__ */ new Map();
  const colorPaletteMap = /* @__PURE__ */ new Map();
  const flatMap2 = /* @__PURE__ */ new Map();
  const byCategory = /* @__PURE__ */ new Map();
  const categoryMap = /* @__PURE__ */ new Map();
  const transforms = /* @__PURE__ */ new Map();
  const middlewares = [];
  function registerToken(token2, phase) {
    allTokens.push(token2);
    tokenNameMap.set(token2.name, token2);
    if (phase) {
      transforms.forEach((fn) => {
        if (fn.enforce === phase) transformToken(fn, token2);
      });
    }
  }
  const breakpointTokens = expandBreakpoints(breakpoints2);
  const computedTokens = compact({
    ...tokens,
    breakpoints: breakpointTokens.breakpoints,
    sizes: {
      ...tokens.sizes,
      ...breakpointTokens.sizes
    }
  });
  function registerTokens() {
    walkObject(
      computedTokens,
      (entry, path) => {
        const isDefault = path.includes("DEFAULT");
        path = filterDefault(path);
        const category = path[0];
        const name = formatTokenName(path);
        const t = isString(entry) ? { value: entry } : entry;
        const token2 = {
          value: t.value,
          originalValue: t.value,
          name,
          path,
          extensions: {
            condition: "base",
            originalPath: path,
            category,
            prop: formatTokenName(path.slice(1))
          }
        };
        if (isDefault) {
          token2.extensions.default = true;
        }
        registerToken(token2);
      },
      { stop: isToken }
    );
    walkObject(
      semanticTokens,
      (entry, path) => {
        const isDefault = path.includes("DEFAULT");
        path = filterBaseCondition(filterDefault(path));
        const category = path[0];
        const name = formatTokenName(path);
        const t = isString(entry.value) ? { value: { base: entry.value } } : entry;
        const token2 = {
          value: t.value.base || "",
          originalValue: t.value.base || "",
          name,
          path,
          extensions: {
            originalPath: path,
            category,
            conditions: t.value,
            condition: "base",
            prop: formatTokenName(path.slice(1))
          }
        };
        if (isDefault) {
          token2.extensions.default = true;
        }
        registerToken(token2);
      },
      { stop: isToken }
    );
  }
  function getByName(name) {
    return tokenNameMap.get(name);
  }
  function buildConditionMap(token2) {
    const { condition } = token2.extensions;
    if (!condition) return;
    if (!conditionMap.has(condition)) {
      conditionMap.set(condition, /* @__PURE__ */ new Set());
    }
    conditionMap.get(condition).add(token2);
  }
  function buildCategoryMap(token2) {
    const { category, prop } = token2.extensions;
    if (!category) return;
    if (!categoryMap.has(category)) {
      categoryMap.set(category, /* @__PURE__ */ new Map());
    }
    categoryMap.get(category).set(prop, token2);
  }
  function buildCssVars(token2) {
    const { condition, negative, virtual, cssVar: cssVar2 } = token2.extensions;
    if (negative || virtual || !condition || !cssVar2) return;
    if (!cssVarMap.has(condition)) {
      cssVarMap.set(condition, /* @__PURE__ */ new Map());
    }
    cssVarMap.get(condition).set(cssVar2.var, token2.value);
  }
  function buildFlatMap(token2) {
    const { category, prop, cssVar: cssVar2, negative } = token2.extensions;
    if (!category) return;
    if (!byCategory.has(category)) {
      byCategory.set(category, /* @__PURE__ */ new Map());
    }
    const value = negative ? token2.extensions.conditions ? token2.originalValue : token2.value : cssVar2.ref;
    byCategory.get(category).set(prop, value);
    flatMap2.set([category, prop].join("."), value);
  }
  function buildColorPalette(token2) {
    const { colorPalette, virtual, default: isDefault } = token2.extensions;
    if (!colorPalette || virtual) return;
    colorPalette.roots.forEach((root) => {
      var _a8;
      const name = formatTokenName(root);
      if (!colorPaletteMap.has(name)) {
        colorPaletteMap.set(name, /* @__PURE__ */ new Map());
      }
      const virtualPath = replaceRootWithColorPalette(
        [...token2.path],
        [...root]
      );
      const virtualName = formatTokenName(virtualPath);
      const virtualToken = getByName(virtualName);
      if (!virtualToken || !virtualToken.extensions.cssVar) return;
      const { var: virtualVar } = virtualToken.extensions.cssVar;
      colorPaletteMap.get(name).set(virtualVar, token2.extensions.cssVar.ref);
      if (isDefault && root.length === 1) {
        const colorPaletteName = formatTokenName(["colors", "colorPalette"]);
        const colorPaletteToken = getByName(colorPaletteName);
        if (!colorPaletteToken) return;
        const name2 = formatTokenName(token2.path);
        const virtualToken2 = getByName(name2);
        if (!virtualToken2) return;
        const keyPath = (_a8 = colorPalette.keys[0]) == null ? void 0 : _a8.filter(Boolean);
        if (!keyPath.length) return;
        const computedName = formatTokenName(root.concat(keyPath));
        if (!colorPaletteMap.has(computedName)) {
          colorPaletteMap.set(computedName, /* @__PURE__ */ new Map());
        }
        colorPaletteMap.get(computedName).set(
          colorPaletteToken.extensions.cssVar.var,
          virtualToken2.extensions.cssVar.ref
        );
      }
    });
  }
  let byCategoryJson = {};
  function setupViews() {
    allTokens.forEach((token2) => {
      buildConditionMap(token2);
      buildCategoryMap(token2);
      buildCssVars(token2);
      buildFlatMap(token2);
      buildColorPalette(token2);
    });
    byCategoryJson = mapToJson(byCategory);
  }
  const colorMix2 = (value, tokenFn) => {
    var _a8;
    if (!value || typeof value !== "string") return { invalid: true, value };
    const [colorPath, rawOpacity] = value.split("/");
    if (!colorPath || !rawOpacity) {
      return { invalid: true, value: colorPath };
    }
    const colorToken = tokenFn(colorPath);
    const opacityToken = (_a8 = getByName(`opacity.${rawOpacity}`)) == null ? void 0 : _a8.value;
    if (!opacityToken && isNaN(Number(rawOpacity))) {
      return { invalid: true, value: colorPath };
    }
    const percent = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
    const color = colorToken ?? colorPath;
    return {
      invalid: false,
      color,
      value: `color-mix(in srgb, ${color} ${percent}, transparent)`
    };
  };
  const getVar = memo3((value, fallback4) => {
    return flatMap2.get(value) ?? fallback4;
  });
  const getCategoryValues = memo3((category) => {
    return byCategoryJson[category] || null;
  });
  const expandReferenceInValue = memo3((value) => {
    return expandTokenReferences(value, (path) => {
      if (!path) return;
      if (path.includes("/")) {
        const mix = colorMix2(path, (v) => getVar(v));
        if (mix.invalid) {
          throw new Error("Invalid color mix at " + path + ": " + mix.value);
        }
        return mix.value;
      }
      const resolved = getVar(path);
      if (resolved) return resolved;
      return TOKEN_PATH_REGEX.test(path) ? esc2(path) : path;
    });
  });
  const dictionary = {
    prefix: prefix3,
    allTokens,
    tokenMap: tokenNameMap,
    registerToken,
    getByName,
    formatTokenName,
    formatCssVar,
    flatMap: flatMap2,
    cssVarMap,
    categoryMap,
    colorPaletteMap,
    getVar,
    getCategoryValues,
    expandReferenceInValue
  };
  function registerTransform(...fns) {
    fns.forEach((fn) => {
      transforms.set(fn.name, fn);
    });
  }
  function registerMiddleware(...fns) {
    middlewares.push(...fns);
  }
  function transformToken(transform2, token2) {
    if (token2.extensions.references) return;
    if (isFunction(transform2.match) && !transform2.match(token2)) return;
    const fn = (v) => transform2.transform(v, dictionary);
    const transformed = fn(token2);
    switch (true) {
      case transform2.type === "extensions":
        Object.assign(token2.extensions, transformed);
        break;
      case transform2.type === "value":
        token2.value = transformed;
        break;
      default:
        token2[transform2.type] = transformed;
        break;
    }
  }
  function applyMiddlewares(enforce) {
    middlewares.forEach((middleware2) => {
      if (middleware2.enforce === enforce) {
        middleware2.transform(dictionary);
      }
    });
  }
  function applyTransforms(enforce) {
    transforms.forEach((transform2) => {
      if (transform2.enforce === enforce) {
        allTokens.forEach((token2) => {
          transformToken(transform2, token2);
        });
      }
    });
  }
  function addConditionalTokens() {
    allTokens.forEach((token2) => {
      const tokens2 = getConditionalTokens(token2);
      if (!tokens2 || tokens2.length === 0) return;
      tokens2.forEach((token22) => {
        registerToken(token22);
      });
    });
  }
  function getTokenReferences(value) {
    const refs = getReferences(value);
    return refs.map((ref2) => getByName(ref2)).filter(Boolean);
  }
  function addReferences() {
    allTokens.forEach((token2) => {
      if (!hasReference(token2.value)) return;
      const references = getTokenReferences(token2.value);
      token2.extensions.references = references.reduce((acc, ref2) => {
        acc[ref2.name] = ref2;
        return acc;
      }, {});
    });
  }
  function expandTokenReferences$1() {
    allTokens.forEach((token2) => {
      expandReferences(token2);
    });
  }
  function build2() {
    applyMiddlewares("pre");
    applyTransforms("pre");
    addConditionalTokens();
    addReferences();
    expandTokenReferences$1();
    applyMiddlewares("post");
    applyTransforms("post");
    setupViews();
  }
  registerTokens();
  registerTransform(...tokenTransforms);
  registerMiddleware(...tokenMiddlewares);
  build2();
  return dictionary;
}
function filterDefault(path) {
  if (path[0] === "DEFAULT") return path;
  return path.filter((item) => item !== "DEFAULT");
}
function filterBaseCondition(path) {
  return path.filter((item) => item !== "base");
}
function getConditionalTokens(token2) {
  if (!token2.extensions.conditions) return;
  const { conditions } = token2.extensions;
  const tokens = [];
  walkObject(conditions, (value, path) => {
    const nextPath = filterBaseCondition(path);
    if (!nextPath.length) return;
    const nextToken = structuredClone(token2);
    nextToken.value = value;
    nextToken.extensions.condition = nextPath.join(":");
    tokens.push(nextToken);
  });
  return tokens;
}
function replaceRootWithColorPalette(path, roots) {
  const startIndex = path.findIndex(
    (_, index) => roots.every(
      (rootElement, rootIndex) => path[index + rootIndex] === rootElement
    )
  );
  if (startIndex === -1) {
    return path;
  }
  path.splice(startIndex, roots.length);
  path.splice(startIndex, 0, "colorPalette");
  return path;
}
var tokenCategories = createProps2()([
  "aspectRatios",
  "zIndex",
  "opacity",
  "colors",
  "fonts",
  "fontSizes",
  "fontWeights",
  "lineHeights",
  "letterSpacings",
  "sizes",
  "shadows",
  "spacing",
  "radii",
  "cursor",
  "borders",
  "borderWidths",
  "borderStyles",
  "durations",
  "easings",
  "animations",
  "blurs",
  "gradients",
  "breakpoints",
  "assets"
]);

// node_modules/@chakra-ui/react/dist/esm/styled-system/utility.js
function normalize(config) {
  return config;
}
function normalizeConfig(config) {
  return Object.fromEntries(
    Object.entries(config).map(([property, propertyConfig]) => {
      return [property, normalize(propertyConfig)];
    })
  );
}
function createUtility(options) {
  const configs = normalizeConfig(options.config);
  const tokens = options.tokens;
  const shorthands = /* @__PURE__ */ new Map();
  const propValues = /* @__PURE__ */ new Map();
  function register(property, config) {
    configs[property] = normalize(config);
    assignProperty(property, config);
  }
  const assignProperty = (property, config) => {
    const values = getPropertyValues(config);
    if (!values) return;
    propValues.set(property, values);
    assignPropertyType(property, config);
  };
  const assignProperties = () => {
    for (const [prop, config] of Object.entries(configs)) {
      if (!config) continue;
      assignProperty(prop, config);
    }
  };
  const assignShorthands = () => {
    for (const [property, config] of Object.entries(configs)) {
      const { shorthand } = config ?? {};
      if (!shorthand) continue;
      const values = Array.isArray(shorthand) ? shorthand : [shorthand];
      values.forEach((name) => shorthands.set(name, property));
    }
  };
  const assignColorPaletteProperty = () => {
    const values = mapToJson(tokens.colorPaletteMap);
    register("colorPalette", {
      values: Object.keys(values),
      transform: memo3((value) => values[value])
    });
  };
  const propTypes = /* @__PURE__ */ new Map();
  const assignPropertyType = (property, config) => {
    if (!config) return;
    const values = getPropertyValues(config, (key) => `type:Tokens["${key}"]`);
    if (typeof values === "object" && values.type) {
      propTypes.set(property, /* @__PURE__ */ new Set([`type:${values.type}`]));
      return;
    }
    if (values) {
      const keys2 = new Set(Object.keys(values));
      propTypes.set(property, keys2);
    }
    const set28 = propTypes.get(property) ?? /* @__PURE__ */ new Set();
    if (config.property) {
      propTypes.set(property, set28.add(`CssProperties["${config.property}"]`));
    }
  };
  const assignPropertyTypes = () => {
    for (const [property, propertyConfig] of Object.entries(configs)) {
      if (!propertyConfig) continue;
      assignPropertyType(property, propertyConfig);
    }
  };
  const addPropertyType = (property, type) => {
    const set28 = propTypes.get(property) ?? /* @__PURE__ */ new Set();
    propTypes.set(property, /* @__PURE__ */ new Set([...set28, ...type]));
  };
  const getTypes = () => {
    const map2 = /* @__PURE__ */ new Map();
    for (const [prop, values] of propTypes.entries()) {
      if (values.size === 0) {
        map2.set(prop, ["string"]);
        continue;
      }
      const typeValues = Array.from(values).map((key) => {
        if (key.startsWith("CssProperties")) return key;
        if (key.startsWith("type:")) return key.replace("type:", "");
        return JSON.stringify(key);
      });
      map2.set(prop, typeValues);
    }
    return map2;
  };
  const getPropertyValues = (config, resolveFn) => {
    const { values } = config;
    const fn = (key) => {
      const value = resolveFn == null ? void 0 : resolveFn(key);
      return value ? { [value]: value } : void 0;
    };
    if (isString(values)) {
      return (fn == null ? void 0 : fn(values)) ?? tokens.getCategoryValues(values) ?? {};
    }
    if (Array.isArray(values)) {
      return values.reduce((result, value) => {
        result[value] = value;
        return result;
      }, {});
    }
    if (isFunction(values)) {
      return values(resolveFn ? fn : tokens.getCategoryValues);
    }
    return values;
  };
  const defaultTransform = memo3((prop, value) => {
    return {
      [prop]: prop.startsWith("--") ? tokens.getVar(value, value) : value
    };
  });
  const tokenFn = Object.assign(tokens.getVar, {
    raw: (path) => tokens.getByName(path)
  });
  const transform2 = memo3((prop, raw) => {
    var _a8;
    const key = resolveShorthand(prop);
    if (isString(raw) && !raw.includes("_EMO_")) {
      raw = tokens.expandReferenceInValue(raw);
    }
    const config = configs[key];
    if (!config) {
      return defaultTransform(key, raw);
    }
    const value = (_a8 = propValues.get(key)) == null ? void 0 : _a8[raw];
    if (!config.transform) {
      return defaultTransform(prop, value ?? raw);
    }
    const _colorMix = (value2) => colorMix(value2, tokenFn);
    return config.transform(value ?? raw, {
      raw,
      token: tokenFn,
      utils: { colorMix: _colorMix }
    });
  });
  function build2() {
    assignShorthands();
    assignColorPaletteProperty();
    assignProperties();
    assignPropertyTypes();
  }
  build2();
  const hasShorthand = shorthands.size > 0;
  const resolveShorthand = memo3((prop) => {
    return shorthands.get(prop) ?? prop;
  });
  const keys = () => {
    return [...Array.from(shorthands.keys()), ...Object.keys(configs)];
  };
  const instance = {
    keys,
    hasShorthand,
    transform: transform2,
    shorthands,
    resolveShorthand,
    register,
    getTypes,
    addPropertyType
  };
  return instance;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/system.js
function createSystem(...configs) {
  const config = mergeConfigs(...configs);
  const {
    theme = {},
    utilities = {},
    globalCss: globalCss2 = {},
    cssVarsRoot = ":where(:root, :host)",
    cssVarsPrefix = "chakra",
    preflight
  } = config;
  const layers = createLayers(config);
  const tokens = createTokenDictionary({
    breakpoints: theme.breakpoints,
    tokens: theme.tokens,
    semanticTokens: theme.semanticTokens,
    prefix: cssVarsPrefix
  });
  const breakpoints2 = createBreakpoints(theme.breakpoints ?? {});
  const conditions = createConditions({
    conditions: config.conditions ?? {},
    breakpoints: breakpoints2
  });
  const utility = createUtility({
    config: utilities,
    tokens
  });
  function assignComposition() {
    const { textStyles: textStyles2, layerStyles: layerStyles2, animationStyles: animationStyles2 } = theme;
    const compositions = compact({
      textStyle: textStyles2,
      layerStyle: layerStyles2,
      animationStyle: animationStyles2
    });
    for (const [key, values] of Object.entries(compositions)) {
      const flatValues = flatten(
        values ?? {},
        (v) => isObject(v) && "value" in v
      );
      utility.register(key, {
        values: Object.keys(flatValues),
        transform(value) {
          return css2(flatValues[value]);
        }
      });
    }
  }
  assignComposition();
  utility.addPropertyType("animationName", Object.keys(theme.keyframes ?? {}));
  const properties2 = /* @__PURE__ */ new Set(["css", ...utility.keys(), ...conditions.keys()]);
  const isValidProperty = memo3(
    (prop) => properties2.has(prop) || isCssProperty(prop)
  );
  const normalizeValue2 = (value) => {
    if (Array.isArray(value)) {
      return value.reduce((acc, current, index) => {
        const key = conditions.breakpoints[index];
        if (current != null) acc[key] = current;
        return acc;
      }, {});
    }
    return value;
  };
  const normalizeFn = createNormalizeFn({
    utility,
    normalize: normalizeValue2
  });
  const serialize3 = createSerializeFn({
    conditions,
    isValidProperty
  });
  const css2 = createCssFn({
    transform: utility.transform,
    conditions,
    normalize: normalizeFn
  });
  const cva = createRecipeFn({
    css: css2,
    conditions,
    normalize: normalizeFn,
    layers
  });
  const sva = createSlotRecipeFn({ cva });
  function getTokenCss() {
    const result = {};
    for (const [key, values] of tokens.cssVarMap.entries()) {
      const varsObj = Object.fromEntries(values);
      if (Object.keys(varsObj).length === 0) continue;
      const selector = key === "base" ? cssVarsRoot : conditions.resolve(key);
      const cssObject = css2(serialize3({ [selector]: varsObj }));
      mergeWith(result, cssObject);
    }
    return layers.wrap("tokens", result);
  }
  function getGlobalCss() {
    const keyframes2 = Object.fromEntries(
      Object.entries(theme.keyframes ?? {}).map(([key, value]) => [
        `@keyframes ${key}`,
        value
      ])
    );
    const result = Object.assign({}, keyframes2, css2(serialize3(globalCss2)));
    return layers.wrap("base", result);
  }
  function splitCssProps(props34) {
    return splitProps(props34, isValidProperty);
  }
  function getPreflightCss() {
    const result = createPreflight({ preflight });
    return layers.wrap("reset", result);
  }
  const tokenMap = getTokenMap(tokens);
  const tokenFn = (path, fallback4) => {
    var _a8;
    return ((_a8 = tokenMap.get(path)) == null ? void 0 : _a8.value) || fallback4;
  };
  tokenFn.var = (path, fallback4) => {
    var _a8;
    return ((_a8 = tokenMap.get(path)) == null ? void 0 : _a8.variable) || fallback4;
  };
  function getRecipe(key, fallback4) {
    var _a8;
    return ((_a8 = theme.recipes) == null ? void 0 : _a8[key]) ?? fallback4;
  }
  function getSlotRecipe(key, fallback4) {
    var _a8;
    return ((_a8 = theme.slotRecipes) == null ? void 0 : _a8[key]) ?? fallback4;
  }
  function isRecipe(key) {
    return Object.hasOwnProperty.call(theme.recipes ?? {}, key);
  }
  function isSlotRecipe(key) {
    return Object.hasOwnProperty.call(theme.slotRecipes ?? {}, key);
  }
  function hasRecipe(key) {
    return isRecipe(key) || isSlotRecipe(key);
  }
  const _global = [getPreflightCss(), getGlobalCss(), getTokenCss()];
  return {
    $$chakra: true,
    _config: config,
    _global,
    breakpoints: breakpoints2,
    tokens,
    conditions,
    utility,
    token: tokenFn,
    properties: properties2,
    layers,
    isValidProperty,
    splitCssProps,
    normalizeValue: normalizeValue2,
    getTokenCss,
    getGlobalCss,
    getPreflightCss,
    css: css2,
    cva,
    sva,
    getRecipe,
    getSlotRecipe,
    hasRecipe,
    isRecipe,
    isSlotRecipe
  };
}
function getTokenMap(tokens) {
  const map2 = /* @__PURE__ */ new Map();
  tokens.allTokens.forEach((token2) => {
    const { cssVar: cssVar2, virtual, conditions } = token2.extensions;
    const value = !!conditions || virtual ? cssVar2.ref : token2.value;
    map2.set(token2.name, { value, variable: cssVar2.ref });
  });
  return map2;
}
var isValidSystem = (mod2) => {
  return isObject(mod2) && !!Reflect.get(mod2, "$$chakra");
};

// node_modules/@chakra-ui/react/dist/esm/theme/breakpoints.js
var breakpoints = {
  sm: "480px",
  md: "768px",
  lg: "1024px",
  xl: "1280px",
  "2xl": "1536px"
};

// node_modules/@chakra-ui/react/dist/esm/theme/global-css.js
var empty = "var(--chakra-empty,/*!*/ /*!*/)";
var globalCss = defineGlobalStyles({
  "*": {
    fontFeatureSettings: '"cv11"',
    "--ring-inset": empty,
    "--ring-offset-width": "0px",
    "--ring-offset-color": "#fff",
    "--ring-color": "rgba(66, 153, 225, 0.6)",
    "--ring-offset-shadow": "0 0 #0000",
    "--ring-shadow": "0 0 #0000",
    ...Object.fromEntries(
      [
        "brightness",
        "contrast",
        "grayscale",
        "hue-rotate",
        "invert",
        "saturate",
        "sepia",
        "drop-shadow"
      ].map((prop) => [`--${prop}`, empty])
    ),
    ...Object.fromEntries(
      [
        "blur",
        "brightness",
        "contrast",
        "grayscale",
        "hue-rotate",
        "invert",
        "opacity",
        "saturate",
        "sepia"
      ].map((prop) => [`--backdrop-${prop}`, empty])
    ),
    "--global-font-mono": "fonts.mono",
    "--global-font-body": "fonts.body",
    "--global-color-border": "colors.border"
  },
  html: {
    color: "fg",
    bg: "bg",
    lineHeight: "1.5",
    colorPalette: "gray"
  },
  "*::placeholder": {
    color: "fg.muted/80"
  },
  "*::selection": {
    bg: "colorPalette.muted/80"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/layer-styles.js
var layerStyles = defineLayerStyles({
  // fill: some background color + color combination
  "fill.muted": {
    value: {
      background: "colorPalette.muted",
      color: "colorPalette.fg"
    }
  },
  "fill.subtle": {
    value: {
      background: "colorPalette.subtle",
      color: "colorPalette.fg"
    }
  },
  "fill.surface": {
    value: {
      background: "colorPalette.subtle",
      color: "colorPalette.fg",
      boxShadow: "0 0 0px 1px var(--shadow-color)",
      boxShadowColor: "colorPalette.muted"
    }
  },
  "fill.solid": {
    value: {
      background: "colorPalette.solid",
      color: "colorPalette.contrast"
    }
  },
  // outline: some border color + color combination
  "outline.subtle": {
    value: {
      color: "colorPalette.fg",
      boxShadow: "inset 0 0 0px 1px var(--shadow-color)",
      boxShadowColor: "colorPalette.subtle"
    }
  },
  "outline.solid": {
    value: {
      borderWidth: "1px",
      borderColor: "colorPalette.solid",
      color: "colorPalette.fg"
    }
  },
  // indicator: floating border color or left/bottom border
  "indicator.bottom": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        bottom: "var(--indicator-offset-y, 0)",
        insetInline: "var(--indicator-offset-x, 0)",
        height: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.top": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        top: "var(--indicator-offset-y, 0)",
        insetInline: "var(--indicator-offset-x, 0)",
        height: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.start": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        insetInlineStart: "var(--indicator-offset-x, 0)",
        insetBlock: "var(--indicator-offset-y, 0)",
        width: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.end": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        insetInlineEnd: "var(--indicator-offset-x, 0)",
        insetBlock: "var(--indicator-offset-y, 0)",
        width: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  disabled: {
    value: {
      opacity: "0.5",
      cursor: "not-allowed"
    }
  },
  none: {
    value: {}
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/motion-styles.js
var animationStyles = defineAnimationStyles({
  "slide-fade-in": {
    value: {
      transformOrigin: "var(--transform-origin)",
      "&[data-placement^=top]": {
        animationName: "slide-from-bottom, fade-in"
      },
      "&[data-placement^=bottom]": {
        animationName: "slide-from-top, fade-in"
      },
      "&[data-placement^=left]": {
        animationName: "slide-from-right, fade-in"
      },
      "&[data-placement^=right]": {
        animationName: "slide-from-left, fade-in"
      }
    }
  },
  "slide-fade-out": {
    value: {
      transformOrigin: "var(--transform-origin)",
      "&[data-placement^=top]": {
        animationName: "slide-to-bottom, fade-out"
      },
      "&[data-placement^=bottom]": {
        animationName: "slide-to-top, fade-out"
      },
      "&[data-placement^=left]": {
        animationName: "slide-to-right, fade-out"
      },
      "&[data-placement^=right]": {
        animationName: "slide-to-left, fade-out"
      }
    }
  },
  "scale-fade-in": {
    value: {
      transformOrigin: "var(--transform-origin)",
      animationName: "scale-in, fade-in"
    }
  },
  "scale-fade-out": {
    value: {
      transformOrigin: "var(--transform-origin)",
      animationName: "scale-out, fade-out"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/badge.js
var badgeRecipe = defineRecipe({
  className: "chakra-badge",
  base: {
    display: "inline-flex",
    alignItems: "center",
    borderRadius: "l2",
    gap: "1",
    fontWeight: "medium",
    fontVariantNumeric: "tabular-nums",
    whiteSpace: "nowrap",
    userSelect: "none"
  },
  variants: {
    variant: {
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast"
      },
      subtle: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg"
      },
      outline: {
        color: "colorPalette.fg",
        shadow: "inset 0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted"
      },
      surface: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        shadow: "inset 0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted"
      },
      plain: {
        color: "colorPalette.fg"
      }
    },
    size: {
      xs: {
        textStyle: "2xs",
        px: "1",
        minH: "4"
      },
      sm: {
        textStyle: "xs",
        px: "1.5",
        minH: "5"
      },
      md: {
        textStyle: "sm",
        px: "2",
        minH: "6"
      },
      lg: {
        textStyle: "sm",
        px: "2.5",
        minH: "7"
      }
    }
  },
  defaultVariants: {
    variant: "subtle",
    size: "sm"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/button.js
var buttonRecipe = defineRecipe({
  className: "chakra-button",
  base: {
    display: "inline-flex",
    appearance: "none",
    alignItems: "center",
    justifyContent: "center",
    userSelect: "none",
    position: "relative",
    borderRadius: "l2",
    whiteSpace: "nowrap",
    verticalAlign: "middle",
    borderWidth: "1px",
    borderColor: "transparent",
    cursor: "button",
    flexShrink: "0",
    outline: "0",
    lineHeight: "1.2",
    isolation: "isolate",
    fontWeight: "medium",
    transitionProperty: "common",
    transitionDuration: "moderate",
    focusVisibleRing: "outside",
    _disabled: {
      layerStyle: "disabled"
    },
    _icon: {
      flexShrink: "0"
    }
  },
  variants: {
    size: {
      "2xs": {
        h: "6",
        minW: "6",
        textStyle: "xs",
        px: "2",
        gap: "1",
        _icon: {
          width: "3.5",
          height: "3.5"
        }
      },
      xs: {
        h: "8",
        minW: "8",
        textStyle: "xs",
        px: "2.5",
        gap: "1",
        _icon: {
          width: "4",
          height: "4"
        }
      },
      sm: {
        h: "9",
        minW: "9",
        px: "3.5",
        textStyle: "sm",
        gap: "2",
        _icon: {
          width: "4",
          height: "4"
        }
      },
      md: {
        h: "10",
        minW: "10",
        textStyle: "sm",
        px: "4",
        gap: "2",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      lg: {
        h: "11",
        minW: "11",
        textStyle: "md",
        px: "5",
        gap: "3",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      xl: {
        h: "12",
        minW: "12",
        textStyle: "md",
        px: "5",
        gap: "2.5",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      "2xl": {
        h: "16",
        minW: "16",
        textStyle: "lg",
        px: "7",
        gap: "3",
        _icon: {
          width: "6",
          height: "6"
        }
      }
    },
    variant: {
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast",
        _hover: {
          bg: "colorPalette.solid/90"
        },
        _expanded: {
          bg: "colorPalette.solid/90"
        }
      },
      subtle: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.muted"
        },
        _expanded: {
          bg: "colorPalette.muted"
        }
      },
      surface: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        shadow: "0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted",
        _hover: {
          bg: "colorPalette.muted"
        },
        _expanded: {
          bg: "colorPalette.muted"
        }
      },
      outline: {
        borderWidth: "1px",
        borderColor: "colorPalette.muted",
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.subtle"
        },
        _expanded: {
          bg: "colorPalette.subtle"
        }
      },
      ghost: {
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.subtle"
        },
        _expanded: {
          bg: "colorPalette.subtle"
        }
      },
      plain: {
        color: "colorPalette.fg"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkmark.js
var checkmarkRecipe = defineRecipe({
  className: "chakra-checkmark",
  base: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: "0",
    color: "white",
    borderWidth: "1px",
    borderColor: "transparent",
    borderRadius: "l1",
    focusVisibleRing: "outside",
    _icon: {
      boxSize: "full"
    },
    _invalid: {
      colorPalette: "red",
      borderColor: "border.error"
    },
    _disabled: {
      opacity: "0.5"
    }
  },
  variants: {
    size: {
      xs: {
        boxSize: "3"
      },
      sm: {
        boxSize: "4"
      },
      md: {
        boxSize: "5",
        p: "0.5"
      },
      lg: {
        boxSize: "6",
        p: "0.5"
      }
    },
    variant: {
      solid: {
        borderColor: "border",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast",
          borderColor: "colorPalette.solid"
        }
      },
      outline: {
        borderColor: "border",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg",
          borderColor: "colorPalette.solid"
        }
      },
      subtle: {
        bg: "colorPalette.muted",
        borderColor: "colorPalette.muted",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg"
        }
      },
      plain: {
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg"
        }
      },
      inverted: {
        borderColor: "border",
        color: "colorPalette.fg",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          borderColor: "colorPalette.solid"
        }
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/code.js
var { variants, defaultVariants } = badgeRecipe;
var codeRecipe = defineRecipe({
  className: "chakra-code",
  base: {
    fontFamily: "mono",
    alignItems: "center",
    display: "inline-flex",
    borderRadius: "l2"
  },
  variants,
  defaultVariants
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/color-swatch.js
var colorSwatchRecipe = defineRecipe({
  className: "color-swatch",
  base: {
    boxSize: "var(--swatch-size)",
    shadow: "inset 0 0 0 1px rgba(0, 0, 0, 0.1)",
    "--checker-size": "8px",
    "--checker-bg": "colors.bg",
    "--checker-fg": "colors.bg.emphasized",
    background: "linear-gradient(var(--color), var(--color)), repeating-conic-gradient(var(--checker-fg) 0%, var(--checker-fg) 25%, var(--checker-bg) 0%, var(--checker-bg) 50%) 0% 50% / var(--checker-size) var(--checker-size) !important",
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: "0"
  },
  variants: {
    size: {
      "2xs": { "--swatch-size": "sizes.3.5" },
      xs: { "--swatch-size": "sizes.4" },
      sm: { "--swatch-size": "sizes.4.5" },
      md: { "--swatch-size": "sizes.5" },
      lg: { "--swatch-size": "sizes.6" },
      xl: { "--swatch-size": "sizes.7" },
      "2xl": { "--swatch-size": "sizes.8" },
      inherit: { "--swatch-size": "inherit" },
      full: { "--swatch-size": "100%" }
    },
    shape: {
      square: { borderRadius: "none" },
      circle: { borderRadius: "full" },
      rounded: { borderRadius: "l1" }
    }
  },
  defaultVariants: {
    size: "md",
    shape: "rounded"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/container.js
var containerRecipe = defineRecipe({
  className: "chakra-container",
  base: {
    position: "relative",
    maxWidth: "8xl",
    w: "100%",
    mx: "auto",
    px: { base: "4", md: "6", lg: "8" }
  },
  variants: {
    centerContent: {
      true: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center"
      }
    },
    fluid: {
      true: {
        maxWidth: "full"
      }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/heading.js
var headingRecipe = defineRecipe({
  className: "chakra-heading",
  base: {
    fontFamily: "heading",
    fontWeight: "semibold"
  },
  variants: {
    size: {
      xs: { textStyle: "xs" },
      sm: { textStyle: "sm" },
      md: { textStyle: "md" },
      lg: { textStyle: "lg" },
      xl: { textStyle: "xl" },
      "2xl": { textStyle: "2xl" },
      "3xl": { textStyle: "3xl" },
      "4xl": { textStyle: "4xl" },
      "5xl": { textStyle: "5xl" },
      "6xl": { textStyle: "6xl" },
      "7xl": { textStyle: "7xl" }
    }
  },
  defaultVariants: {
    size: "xl"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/icon.js
var iconRecipe = defineRecipe({
  className: "chakra-icon",
  base: {
    display: "inline-block",
    lineHeight: "1em",
    flexShrink: "0",
    color: "currentcolor",
    verticalAlign: "middle"
  },
  variants: {
    size: {
      inherit: {},
      xs: { boxSize: "3" },
      sm: { boxSize: "4" },
      md: { boxSize: "5" },
      lg: { boxSize: "6" },
      xl: { boxSize: "7" },
      "2xl": { boxSize: "8" }
    }
  },
  defaultVariants: {
    size: "inherit"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/input.js
var inputRecipe = defineRecipe({
  className: "chakra-input",
  base: {
    width: "100%",
    minWidth: "0",
    outline: "0",
    position: "relative",
    appearance: "none",
    textAlign: "start",
    borderRadius: "l2",
    _disabled: {
      layerStyle: "disabled"
    },
    height: "var(--input-height)",
    minW: "var(--input-height)",
    "--focus-color": "colors.colorPalette.focusRing",
    "--error-color": "colors.border.error",
    _invalid: {
      focusRingColor: "var(--error-color)",
      borderColor: "var(--error-color)"
    }
  },
  variants: {
    size: {
      "2xs": {
        textStyle: "xs",
        px: "2",
        "--input-height": "sizes.7"
      },
      xs: {
        textStyle: "xs",
        px: "2",
        "--input-height": "sizes.8"
      },
      sm: {
        textStyle: "sm",
        px: "2.5",
        "--input-height": "sizes.9"
      },
      md: {
        textStyle: "sm",
        px: "3",
        "--input-height": "sizes.10"
      },
      lg: {
        textStyle: "md",
        px: "4",
        "--input-height": "sizes.11"
      },
      xl: {
        textStyle: "md",
        px: "4.5",
        "--input-height": "sizes.12"
      },
      "2xl": {
        textStyle: "lg",
        px: "5",
        "--input-height": "sizes.16"
      }
    },
    variant: {
      outline: {
        bg: "transparent",
        borderWidth: "1px",
        borderColor: "border",
        focusVisibleRing: "inside"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.muted",
        focusVisibleRing: "inside"
      },
      flushed: {
        bg: "transparent",
        borderBottomWidth: "1px",
        borderBottomColor: "border",
        borderRadius: "0",
        px: "0",
        _focusVisible: {
          borderColor: "var(--focus-color)",
          boxShadow: "0px 1px 0px 0px var(--focus-color)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/input-addon.js
var inputAddonRecipe = defineRecipe({
  className: "chakra-input-addon",
  base: {
    flex: "0 0 auto",
    width: "auto",
    display: "flex",
    alignItems: "center",
    whiteSpace: "nowrap",
    alignSelf: "stretch",
    borderRadius: "l2"
  },
  variants: {
    size: inputRecipe.variants.size,
    variant: {
      outline: {
        borderWidth: "1px",
        borderColor: "border",
        bg: "bg.muted"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.emphasized"
      },
      flushed: {
        borderBottom: "1px solid",
        borderColor: "inherit",
        borderRadius: "0",
        px: "0",
        bg: "transparent"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/kbd.js
var kbdRecipe = defineRecipe({
  className: "chakra-kbd",
  base: {
    display: "inline-flex",
    alignItems: "center",
    fontWeight: "medium",
    fontFamily: "mono",
    flexShrink: "0",
    whiteSpace: "nowrap",
    wordSpacing: "-0.5em",
    userSelect: "none",
    px: "1",
    borderRadius: "l2"
  },
  variants: {
    variant: {
      raised: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        borderWidth: "1px",
        borderBottomWidth: "2px",
        borderColor: "colorPalette.muted"
      },
      outline: {
        borderWidth: "1px",
        color: "colorPalette.fg"
      },
      subtle: {
        bg: "colorPalette.muted",
        color: "colorPalette.fg"
      },
      plain: {
        color: "colorPalette.fg"
      }
    },
    size: {
      sm: {
        textStyle: "xs",
        height: "4.5"
      },
      md: {
        textStyle: "sm",
        height: "5"
      },
      lg: {
        textStyle: "md",
        height: "6"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "raised"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/link.js
var linkRecipe = defineRecipe({
  className: "chakra-link",
  base: {
    display: "inline-flex",
    alignItems: "center",
    outline: "none",
    gap: "1.5",
    cursor: "pointer",
    borderRadius: "l1",
    focusRing: "outside"
  },
  variants: {
    variant: {
      underline: {
        color: "colorPalette.fg",
        textDecoration: "underline",
        textUnderlineOffset: "3px",
        textDecorationColor: "currentColor/20"
      },
      plain: {
        color: "colorPalette.fg",
        _hover: {
          textDecoration: "underline",
          textUnderlineOffset: "3px",
          textDecorationColor: "currentColor/20"
        }
      }
    }
  },
  defaultVariants: {
    variant: "plain"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/mark.js
var markRecipe = defineRecipe({
  className: "chakra-mark",
  base: {
    bg: "transparent",
    color: "inherit",
    whiteSpace: "nowrap"
  },
  variants: {
    variant: {
      subtle: {
        bg: "colorPalette.subtle",
        color: "inherit"
      },
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast"
      },
      text: {
        fontWeight: "medium"
      },
      plain: {}
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/radiomark.js
var radiomarkRecipe = defineRecipe({
  className: "chakra-radiomark",
  base: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    verticalAlign: "top",
    color: "white",
    borderWidth: "1px",
    borderColor: "transparent",
    borderRadius: "full",
    cursor: "radio",
    _focusVisible: {
      outline: "2px solid",
      outlineColor: "colorPalette.focusRing",
      outlineOffset: "2px"
    },
    _invalid: {
      colorPalette: "red",
      borderColor: "red.500"
    },
    _disabled: {
      opacity: "0.5",
      cursor: "disabled"
    },
    "& .dot": {
      height: "100%",
      width: "100%",
      borderRadius: "full",
      bg: "currentColor",
      scale: "0.4"
    }
  },
  variants: {
    variant: {
      solid: {
        borderWidth: "1px",
        borderColor: "border",
        _checked: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast",
          borderColor: "colorPalette.solid"
        }
      },
      subtle: {
        borderWidth: "1px",
        bg: "colorPalette.muted",
        borderColor: "colorPalette.muted",
        color: "transparent",
        _checked: {
          color: "colorPalette.fg"
        }
      },
      outline: {
        borderWidth: "1px",
        borderColor: "inherit",
        _checked: {
          color: "colorPalette.fg",
          borderColor: "colorPalette.solid"
        },
        "& .dot": {
          scale: "0.6"
        }
      },
      inverted: {
        bg: "bg",
        borderWidth: "1px",
        borderColor: "inherit",
        _checked: {
          color: "colorPalette.solid",
          borderColor: "currentcolor"
        }
      }
    },
    size: {
      xs: {
        boxSize: "3"
      },
      sm: {
        boxSize: "4"
      },
      md: {
        boxSize: "5"
      },
      lg: {
        boxSize: "6"
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/separator.js
var separatorRecipe = defineRecipe({
  className: "chakra-separator",
  base: {
    display: "block",
    borderColor: "border"
  },
  variants: {
    variant: {
      solid: {
        borderStyle: "solid"
      },
      dashed: {
        borderStyle: "dashed"
      },
      dotted: {
        borderStyle: "dotted"
      }
    },
    orientation: {
      vertical: {
        borderInlineStartWidth: "var(--separator-thickness)"
      },
      horizontal: {
        borderTopWidth: "var(--separator-thickness)"
      }
    },
    size: {
      xs: {
        "--separator-thickness": "0.5px"
      },
      sm: {
        "--separator-thickness": "1px"
      },
      md: {
        "--separator-thickness": "2px"
      },
      lg: {
        "--separator-thickness": "3px"
      }
    }
  },
  defaultVariants: {
    size: "sm",
    variant: "solid",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/skeleton.js
var skeletonRecipe = defineRecipe({
  className: "chakra-skeleton",
  base: {},
  variants: {
    loading: {
      true: {
        borderRadius: "l2",
        boxShadow: "none",
        backgroundClip: "padding-box",
        cursor: "default",
        color: "transparent",
        pointerEvents: "none",
        userSelect: "none",
        flexShrink: "0",
        "&::before, &::after, *": {
          visibility: "hidden"
        }
      },
      false: {
        background: "unset",
        animation: "fade-in var(--fade-duration, 0.1s) ease-out !important"
      }
    },
    variant: {
      pulse: {
        background: "bg.emphasized",
        animation: "pulse",
        animationDuration: "var(--duration, 1.2s)"
      },
      shine: {
        "--animate-from": "200%",
        "--animate-to": "-200%",
        "--start-color": "colors.bg.muted",
        "--end-color": "colors.bg.emphasized",
        backgroundImage: "linear-gradient(270deg,var(--start-color),var(--end-color),var(--end-color),var(--start-color))",
        backgroundSize: "400% 100%",
        animation: "bg-position var(--duration, 5s) ease-in-out infinite"
      },
      none: {
        animation: "none"
      }
    }
  },
  defaultVariants: {
    variant: "pulse",
    loading: true
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/skip-nav-link.js
var skipNavLinkRecipe = defineRecipe({
  className: "chakra-skip-nav",
  base: {
    display: "inline-flex",
    bg: "bg.panel",
    padding: "2.5",
    borderRadius: "l2",
    fontWeight: "semibold",
    focusVisibleRing: "outside",
    textStyle: "sm",
    // visually hidden
    userSelect: "none",
    border: "0",
    height: "1px",
    width: "1px",
    margin: "-1px",
    outline: "0",
    overflow: "hidden",
    position: "absolute",
    clip: "rect(0 0 0 0)",
    _focusVisible: {
      clip: "auto",
      width: "auto",
      height: "auto",
      position: "fixed",
      top: "6",
      insetStart: "6"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/spinner.js
var spinnerRecipe = defineRecipe({
  className: "chakra-spinner",
  base: {
    display: "inline-block",
    borderColor: "currentColor",
    borderStyle: "solid",
    borderWidth: "2px",
    borderRadius: "full",
    width: "var(--spinner-size)",
    height: "var(--spinner-size)",
    animation: "spin",
    animationDuration: "slowest",
    "--spinner-track-color": "transparent",
    borderBottomColor: "var(--spinner-track-color)",
    borderInlineStartColor: "var(--spinner-track-color)"
  },
  variants: {
    size: {
      inherit: { "--spinner-size": "1em" },
      xs: { "--spinner-size": "sizes.3" },
      sm: { "--spinner-size": "sizes.4" },
      md: { "--spinner-size": "sizes.5" },
      lg: { "--spinner-size": "sizes.8" },
      xl: { "--spinner-size": "sizes.10" }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/textarea.js
var textareaRecipe = defineRecipe({
  className: "chakra-textarea",
  base: {
    width: "100%",
    minWidth: "0",
    outline: "0",
    position: "relative",
    appearance: "none",
    textAlign: "start",
    borderRadius: "l2",
    _disabled: {
      layerStyle: "disabled"
    },
    "--focus-color": "colors.colorPalette.focusRing",
    "--error-color": "colors.border.error",
    _invalid: {
      focusRingColor: "var(--error-color)",
      borderColor: "var(--error-color)"
    }
  },
  variants: {
    size: {
      xs: {
        textStyle: "xs",
        px: "2",
        py: "1.5",
        scrollPaddingBottom: "1.5"
      },
      sm: {
        textStyle: "sm",
        px: "2.5",
        py: "2",
        scrollPaddingBottom: "2"
      },
      md: {
        textStyle: "sm",
        px: "3",
        py: "2",
        scrollPaddingBottom: "2"
      },
      lg: {
        textStyle: "md",
        px: "4",
        py: "3",
        scrollPaddingBottom: "3"
      },
      xl: {
        textStyle: "md",
        px: "4.5",
        py: "3.5",
        scrollPaddingBottom: "3.5"
      }
    },
    variant: {
      outline: {
        bg: "transparent",
        borderWidth: "1px",
        borderColor: "border",
        focusVisibleRing: "inside"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.muted",
        focusVisibleRing: "inside"
      },
      flushed: {
        bg: "transparent",
        borderBottomWidth: "1px",
        borderBottomColor: "border",
        borderRadius: "0",
        px: "0",
        _focusVisible: {
          borderColor: "var(--focus-color)",
          boxShadow: "0px 1px 0px 0px var(--focus-color)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes.js
var recipes = {
  badge: badgeRecipe,
  button: buttonRecipe,
  code: codeRecipe,
  container: containerRecipe,
  heading: headingRecipe,
  input: inputRecipe,
  inputAddon: inputAddonRecipe,
  kbd: kbdRecipe,
  link: linkRecipe,
  mark: markRecipe,
  separator: separatorRecipe,
  skeleton: skeletonRecipe,
  skipNavLink: skipNavLinkRecipe,
  spinner: spinnerRecipe,
  textarea: textareaRecipe,
  icon: iconRecipe,
  checkmark: checkmarkRecipe,
  radiomark: radiomarkRecipe,
  colorSwatch: colorSwatchRecipe
};

// node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/colors.js
var semanticColors = defineSemanticTokens.colors({
  bg: {
    DEFAULT: {
      value: { _light: "{colors.white}", _dark: "{colors.black}" }
    },
    subtle: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.gray.950}" }
    },
    muted: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    inverted: {
      value: { _light: "{colors.black}", _dark: "{colors.white}" }
    },
    panel: {
      value: { _light: "{colors.white}", _dark: "{colors.gray.950}" }
    },
    error: {
      value: { _light: "{colors.red.50}", _dark: "{colors.red.950}" }
    },
    warning: {
      value: { _light: "{colors.orange.50}", _dark: "{colors.orange.950}" }
    },
    success: {
      value: { _light: "{colors.green.50}", _dark: "{colors.green.950}" }
    },
    info: {
      value: { _light: "{colors.blue.50}", _dark: "{colors.blue.950}" }
    }
  },
  fg: {
    DEFAULT: {
      value: { _light: "{colors.black}", _dark: "{colors.gray.50}" }
    },
    muted: {
      value: { _light: "{colors.gray.600}", _dark: "{colors.gray.400}" }
    },
    subtle: {
      value: { _light: "{colors.gray.400}", _dark: "{colors.gray.500}" }
    },
    inverted: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.black}" }
    },
    error: {
      value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
    },
    warning: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.300}" }
    },
    success: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.300}" }
    },
    info: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.300}" }
    }
  },
  border: {
    DEFAULT: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    muted: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    subtle: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.gray.950}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.300}", _dark: "{colors.gray.700}" }
    },
    inverted: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    },
    error: {
      value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
    },
    warning: {
      value: { _light: "{colors.orange.500}", _dark: "{colors.orange.400}" }
    },
    success: {
      value: { _light: "{colors.green.500}", _dark: "{colors.green.400}" }
    },
    info: {
      value: { _light: "{colors.blue.500}", _dark: "{colors.blue.400}" }
    }
  },
  gray: {
    contrast: {
      value: { _light: "{colors.white}", _dark: "{colors.black}" }
    },
    fg: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    },
    subtle: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    muted: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.300}", _dark: "{colors.gray.700}" }
    },
    solid: {
      value: { _light: "{colors.gray.900}", _dark: "{colors.white}" }
    },
    focusRing: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    }
  },
  red: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.red.700}", _dark: "{colors.red.300}" }
    },
    subtle: {
      value: { _light: "{colors.red.100}", _dark: "{colors.red.900}" }
    },
    muted: {
      value: { _light: "{colors.red.200}", _dark: "{colors.red.800}" }
    },
    emphasized: {
      value: { _light: "{colors.red.300}", _dark: "{colors.red.700}" }
    },
    solid: {
      value: { _light: "{colors.red.600}", _dark: "{colors.red.600}" }
    },
    focusRing: {
      value: { _light: "{colors.red.600}", _dark: "{colors.red.600}" }
    }
  },
  orange: {
    contrast: {
      value: { _light: "white", _dark: "black" }
    },
    fg: {
      value: { _light: "{colors.orange.700}", _dark: "{colors.orange.300}" }
    },
    subtle: {
      value: { _light: "{colors.orange.100}", _dark: "{colors.orange.900}" }
    },
    muted: {
      value: { _light: "{colors.orange.200}", _dark: "{colors.orange.800}" }
    },
    emphasized: {
      value: { _light: "{colors.orange.300}", _dark: "{colors.orange.700}" }
    },
    solid: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.500}" }
    },
    focusRing: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.500}" }
    }
  },
  green: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.green.700}", _dark: "{colors.green.300}" }
    },
    subtle: {
      value: { _light: "{colors.green.100}", _dark: "{colors.green.900}" }
    },
    muted: {
      value: { _light: "{colors.green.200}", _dark: "{colors.green.800}" }
    },
    emphasized: {
      value: { _light: "{colors.green.300}", _dark: "{colors.green.700}" }
    },
    solid: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.600}" }
    },
    focusRing: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.600}" }
    }
  },
  blue: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.blue.700}", _dark: "{colors.blue.300}" }
    },
    subtle: {
      value: { _light: "{colors.blue.100}", _dark: "{colors.blue.900}" }
    },
    muted: {
      value: { _light: "{colors.blue.200}", _dark: "{colors.blue.800}" }
    },
    emphasized: {
      value: { _light: "{colors.blue.300}", _dark: "{colors.blue.700}" }
    },
    solid: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.600}" }
    },
    focusRing: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.600}" }
    }
  },
  yellow: {
    contrast: {
      value: { _light: "black", _dark: "black" }
    },
    fg: {
      value: { _light: "{colors.yellow.800}", _dark: "{colors.yellow.300}" }
    },
    subtle: {
      value: { _light: "{colors.yellow.100}", _dark: "{colors.yellow.900}" }
    },
    muted: {
      value: { _light: "{colors.yellow.200}", _dark: "{colors.yellow.800}" }
    },
    emphasized: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.700}" }
    },
    solid: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.300}" }
    },
    focusRing: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.300}" }
    }
  },
  teal: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.teal.700}", _dark: "{colors.teal.300}" }
    },
    subtle: {
      value: { _light: "{colors.teal.100}", _dark: "{colors.teal.900}" }
    },
    muted: {
      value: { _light: "{colors.teal.200}", _dark: "{colors.teal.800}" }
    },
    emphasized: {
      value: { _light: "{colors.teal.300}", _dark: "{colors.teal.700}" }
    },
    solid: {
      value: { _light: "{colors.teal.600}", _dark: "{colors.teal.600}" }
    },
    focusRing: {
      value: { _light: "{colors.teal.600}", _dark: "{colors.teal.600}" }
    }
  },
  purple: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.purple.700}", _dark: "{colors.purple.300}" }
    },
    subtle: {
      value: { _light: "{colors.purple.100}", _dark: "{colors.purple.900}" }
    },
    muted: {
      value: { _light: "{colors.purple.200}", _dark: "{colors.purple.800}" }
    },
    emphasized: {
      value: { _light: "{colors.purple.300}", _dark: "{colors.purple.700}" }
    },
    solid: {
      value: { _light: "{colors.purple.600}", _dark: "{colors.purple.600}" }
    },
    focusRing: {
      value: { _light: "{colors.purple.600}", _dark: "{colors.purple.600}" }
    }
  },
  pink: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.pink.700}", _dark: "{colors.pink.300}" }
    },
    subtle: {
      value: { _light: "{colors.pink.100}", _dark: "{colors.pink.900}" }
    },
    muted: {
      value: { _light: "{colors.pink.200}", _dark: "{colors.pink.800}" }
    },
    emphasized: {
      value: { _light: "{colors.pink.300}", _dark: "{colors.pink.700}" }
    },
    solid: {
      value: { _light: "{colors.pink.600}", _dark: "{colors.pink.600}" }
    },
    focusRing: {
      value: { _light: "{colors.pink.600}", _dark: "{colors.pink.600}" }
    }
  },
  cyan: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.cyan.700}", _dark: "{colors.cyan.300}" }
    },
    subtle: {
      value: { _light: "{colors.cyan.100}", _dark: "{colors.cyan.900}" }
    },
    muted: {
      value: { _light: "{colors.cyan.200}", _dark: "{colors.cyan.800}" }
    },
    emphasized: {
      value: { _light: "{colors.cyan.300}", _dark: "{colors.cyan.700}" }
    },
    solid: {
      value: { _light: "{colors.cyan.600}", _dark: "{colors.cyan.600}" }
    },
    focusRing: {
      value: { _light: "{colors.cyan.600}", _dark: "{colors.cyan.600}" }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/radii.js
var semanticRadii = defineSemanticTokens.radii({
  l1: { value: "{radii.xs}" },
  l2: { value: "{radii.sm}" },
  l3: { value: "{radii.md}" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/shadows.js
var semanticShadows = defineSemanticTokens.shadows({
  xs: {
    value: {
      _light: "0px 1px 2px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/20}",
      _dark: "0px 1px 1px {black/64}, 0px 0px 1px inset {colors.gray.300/20}"
    }
  },
  sm: {
    value: {
      _light: "0px 2px 4px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 2px 4px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  md: {
    value: {
      _light: "0px 4px 8px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 4px 8px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  lg: {
    value: {
      _light: "0px 8px 16px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 8px 16px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  xl: {
    value: {
      _light: "0px 16px 24px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 16px 24px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  "2xl": {
    value: {
      _light: "0px 24px 40px {colors.gray.900/16}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 24px 40px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  inner: {
    value: {
      _light: "inset 0 2px 4px 0 {black/5}",
      _dark: "inset 0 2px 4px 0 black"
    }
  },
  inset: {
    value: {
      _light: "inset 0 0 0 1px {black/5}",
      _dark: "inset 0 0 0 1px {colors.gray.300/5}"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/anatomy.js
var accordionAnatomy = anatomy.extendWith("itemBody");
var actionBarAnatomy = createAnatomy("action-bar").parts(
  "positioner",
  "content",
  "separator",
  "selectionTrigger",
  "closeTrigger"
);
var alertAnatomy = createAnatomy("alert").parts(
  "title",
  "description",
  "root",
  "indicator",
  "content"
);
var breadcrumbAnatomy = createAnatomy("breadcrumb").parts(
  "link",
  "currentLink",
  "item",
  "list",
  "root",
  "ellipsis",
  "separator"
);
var blockquoteAnatomy = createAnatomy("blockquote").parts(
  "root",
  "icon",
  "content",
  "caption"
);
var cardAnatomy = createAnatomy("card").parts(
  "root",
  "header",
  "body",
  "footer",
  "title",
  "description"
);
var checkboxCardAnatomy = createAnatomy("checkbox-card", [
  "root",
  "control",
  "label",
  "description",
  "addon",
  "indicator",
  "content"
]);
var dataListAnatomy = createAnatomy("data-list").parts(
  "root",
  "item",
  "itemLabel",
  "itemValue"
);
var dialogAnatomy = anatomy10.extendWith(
  "header",
  "body",
  "footer",
  "backdrop"
);
var drawerAnatomy = anatomy10.extendWith(
  "header",
  "body",
  "footer",
  "backdrop"
);
var editableAnatomy = anatomy11.extendWith("textarea");
var emptyStateAnatomy = createAnatomy("empty-state", [
  "root",
  "content",
  "indicator",
  "title",
  "description"
]);
var fieldAnatomy2 = fieldAnatomy.extendWith("requiredIndicator");
var fieldsetAnatomy2 = fieldsetAnatomy.extendWith("content");
var fileUploadAnatomy = anatomy12.extendWith(
  "itemContent",
  "dropzoneContent"
);
var listAnatomy = createAnatomy("list").parts(
  "root",
  "item",
  "indicator"
);
var menuAnatomy = anatomy14.extendWith("itemCommand");
var nativeSelectAnatomy = createAnatomy("select").parts(
  "root",
  "field",
  "indicator"
);
var popoverAnatomy = anatomy18.extendWith(
  "header",
  "body",
  "footer"
);
var radioGroupAnatomy = anatomy21.extendWith(
  "itemAddon",
  "itemIndicator"
);
var radioCardAnatomy = radioGroupAnatomy.extendWith(
  "itemContent",
  "itemDescription"
);
var ratingGroupAnatomy = anatomy22.extendWith("itemIndicator");
var selectAnatomy = anatomy23.extendWith("indicatorGroup");
var sliderAnatomy = anatomy25.extendWith("markerIndicator");
var statAnatomy = createAnatomy("stat").parts(
  "root",
  "label",
  "helpText",
  "valueText",
  "valueUnit",
  "indicator"
);
var statusAnatomy = createAnatomy("status").parts("root", "indicator");
var stepsAnatomy = createAnatomy("steps", [
  "root",
  "list",
  "item",
  "trigger",
  "indicator",
  "separator",
  "content",
  "title",
  "description",
  "nextTrigger",
  "prevTrigger",
  "progress"
]);
var switchAnatomy = anatomy28.extendWith("indicator");
var tableAnatomy = createAnatomy("table").parts(
  "root",
  "header",
  "body",
  "row",
  "columnHeader",
  "cell",
  "footer",
  "caption"
);
var toastAnatomy = createAnatomy("toast").parts(
  "root",
  "title",
  "description",
  "indicator",
  "closeTrigger",
  "actionTrigger"
);
var tabsAnatomy = createAnatomy("tabs").parts(
  "root",
  "trigger",
  "list",
  "content",
  "contentGroup",
  "indicator"
);
var tagAnatomy = createAnatomy("tag").parts(
  "root",
  "label",
  "closeTrigger",
  "startElement",
  "endElement"
);
var timelineAnatomy = createAnatomy("timeline").parts(
  "root",
  "item",
  "content",
  "separator",
  "indicator",
  "connector",
  "title",
  "description"
);

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/accordion.js
var accordionSlotRecipe = defineSlotRecipe({
  className: "chakra-accordion",
  slots: accordionAnatomy.keys(),
  base: {
    root: {
      width: "full",
      "--accordion-radius": "radii.l2"
    },
    item: {
      overflowAnchor: "none"
    },
    itemTrigger: {
      display: "flex",
      alignItems: "center",
      textAlign: "start",
      width: "full",
      outline: "0",
      gap: "3",
      fontWeight: "medium",
      borderRadius: "var(--accordion-radius)",
      _focusVisible: {
        outline: "2px solid",
        outlineColor: "colorPalette.focusRing"
      },
      _disabled: {
        layerStyle: "disabled"
      }
    },
    itemBody: {
      pt: "var(--accordion-padding-y)",
      pb: "calc(var(--accordion-padding-y) * 2)"
    },
    itemContent: {
      overflow: "hidden",
      borderRadius: "var(--accordion-radius)",
      _open: {
        animationName: "expand-height, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "collapse-height, fade-out",
        animationDuration: "moderate"
      }
    },
    itemIndicator: {
      transition: "rotate 0.2s",
      transformOrigin: "center",
      color: "fg.subtle",
      _open: {
        rotate: "180deg"
      },
      _icon: {
        width: "1.2em",
        height: "1.2em"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        item: {
          borderBottomWidth: "1px"
        }
      },
      subtle: {
        itemTrigger: {
          px: "var(--accordion-padding-x)"
        },
        itemContent: {
          px: "var(--accordion-padding-x)"
        },
        item: {
          borderRadius: "var(--accordion-radius)",
          _open: {
            bg: "colorPalette.subtle"
          }
        }
      },
      enclosed: {
        root: {
          borderWidth: "1px",
          borderRadius: "var(--accordion-radius)",
          divideY: "1px",
          overflow: "hidden"
        },
        itemTrigger: {
          px: "var(--accordion-padding-x)"
        },
        itemContent: {
          px: "var(--accordion-padding-x)"
        },
        item: {
          _open: {
            bg: "bg.subtle"
          }
        }
      },
      plain: {}
    },
    size: {
      sm: {
        root: {
          "--accordion-padding-x": "spacing.3",
          "--accordion-padding-y": "spacing.2"
        },
        itemTrigger: {
          textStyle: "sm",
          py: "var(--accordion-padding-y)"
        }
      },
      md: {
        root: {
          "--accordion-padding-x": "spacing.4",
          "--accordion-padding-y": "spacing.2"
        },
        itemTrigger: {
          textStyle: "md",
          py: "var(--accordion-padding-y)"
        }
      },
      lg: {
        root: {
          "--accordion-padding-x": "spacing.4.5",
          "--accordion-padding-y": "spacing.2.5"
        },
        itemTrigger: {
          textStyle: "lg",
          py: "var(--accordion-padding-y)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/action-bar.js
var actionBarSlotRecipe = defineSlotRecipe({
  className: "chakra-action-bar",
  slots: actionBarAnatomy.keys(),
  base: {
    positioner: {
      position: "fixed",
      display: "flex",
      justifyContent: "center",
      pointerEvents: "none",
      insetInline: "0",
      top: "unset",
      bottom: "calc(env(safe-area-inset-bottom) + 20px)"
    },
    content: {
      bg: "bg.panel",
      shadow: "md",
      display: "flex",
      alignItems: "center",
      gap: "3",
      borderRadius: "l3",
      py: "2.5",
      px: "3",
      pointerEvents: "auto",
      // Stabilize the position of the action bar when the scrollbar is hidden
      // by using the scrollbar width to offset the position.
      translate: "calc(-1 * var(--scrollbar-width) / 2) 0px",
      _open: {
        animationName: "slide-from-bottom, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "slide-to-bottom, fade-out",
        animationDuration: "faster"
      }
    },
    separator: {
      width: "1px",
      height: "5",
      bg: "border"
    },
    selectionTrigger: {
      display: "inline-flex",
      alignItems: "center",
      gap: "2",
      alignSelf: "stretch",
      textStyle: "sm",
      px: "4",
      py: "1",
      borderRadius: "l2",
      borderWidth: "1px",
      borderStyle: "dashed"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/alert.js
var alertSlotRecipe = defineSlotRecipe({
  slots: alertAnatomy.keys(),
  className: "chakra-alert",
  base: {
    root: {
      width: "full",
      display: "flex",
      alignItems: "flex-start",
      position: "relative",
      borderRadius: "l3"
    },
    title: {
      fontWeight: "medium"
    },
    description: {
      display: "inline"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0",
      width: "1em",
      height: "1em",
      _icon: { boxSize: "full" }
    },
    content: {
      display: "flex",
      flex: "1",
      gap: "1"
    }
  },
  variants: {
    status: {
      info: {
        root: { colorPalette: "blue" }
      },
      warning: {
        root: { colorPalette: "orange" }
      },
      success: {
        root: { colorPalette: "green" }
      },
      error: {
        root: { colorPalette: "red" }
      },
      neutral: {
        root: { colorPalette: "gray" }
      }
    },
    inline: {
      true: {
        content: {
          display: "inline-flex",
          flexDirection: "row",
          alignItems: "center"
        }
      },
      false: {
        content: {
          display: "flex",
          flexDirection: "column"
        }
      }
    },
    variant: {
      subtle: {
        root: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg"
        }
      },
      surface: {
        root: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg",
          shadow: "inset 0 0 0px 1px var(--shadow-color)",
          shadowColor: "colorPalette.muted"
        },
        indicator: {
          color: "colorPalette.fg"
        }
      },
      outline: {
        root: {
          color: "colorPalette.fg",
          shadow: "inset 0 0 0px 1px var(--shadow-color)",
          shadowColor: "colorPalette.muted"
        },
        indicator: {
          color: "colorPalette.fg"
        }
      },
      solid: {
        root: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        },
        indicator: {
          color: "colorPalette.contrast"
        }
      }
    },
    size: {
      sm: {
        root: {
          gap: "2",
          px: "3",
          py: "3",
          textStyle: "xs"
        },
        indicator: {
          textStyle: "lg"
        }
      },
      md: {
        root: {
          gap: "3",
          px: "4",
          py: "4",
          textStyle: "sm"
        },
        indicator: {
          textStyle: "xl"
        }
      },
      lg: {
        root: {
          gap: "3",
          px: "4",
          py: "4",
          textStyle: "md"
        },
        indicator: {
          textStyle: "2xl"
        }
      }
    }
  },
  defaultVariants: {
    status: "info",
    variant: "subtle",
    size: "md",
    inline: false
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/avatar.js
var avatarSlotRecipe = defineSlotRecipe({
  slots: anatomy5.keys(),
  className: "chakra-avatar",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      fontWeight: "medium",
      position: "relative",
      verticalAlign: "top",
      flexShrink: "0",
      userSelect: "none",
      width: "var(--avatar-size)",
      height: "var(--avatar-size)",
      fontSize: "var(--avatar-font-size)",
      borderRadius: "var(--avatar-radius)",
      "&[data-group-item]": {
        borderWidth: "2px",
        borderColor: "bg"
      }
    },
    image: {
      width: "100%",
      height: "100%",
      objectFit: "cover",
      borderRadius: "var(--avatar-radius)"
    },
    fallback: {
      lineHeight: "1",
      textTransform: "uppercase",
      fontWeight: "medium",
      fontSize: "var(--avatar-font-size)",
      borderRadius: "var(--avatar-radius)"
    }
  },
  variants: {
    size: {
      full: {
        root: {
          "--avatar-size": "100%",
          "--avatar-font-size": "100%"
        }
      },
      "2xs": {
        root: {
          "--avatar-font-size": "fontSizes.2xs",
          "--avatar-size": "sizes.6"
        }
      },
      xs: {
        root: {
          "--avatar-font-size": "fontSizes.xs",
          "--avatar-size": "sizes.8"
        }
      },
      sm: {
        root: {
          "--avatar-font-size": "fontSizes.sm",
          "--avatar-size": "sizes.9"
        }
      },
      md: {
        root: {
          "--avatar-font-size": "fontSizes.md",
          "--avatar-size": "sizes.10"
        }
      },
      lg: {
        root: {
          "--avatar-font-size": "fontSizes.md",
          "--avatar-size": "sizes.11"
        }
      },
      xl: {
        root: {
          "--avatar-font-size": "fontSizes.lg",
          "--avatar-size": "sizes.12"
        }
      },
      "2xl": {
        root: {
          "--avatar-font-size": "fontSizes.xl",
          "--avatar-size": "sizes.16"
        }
      }
    },
    variant: {
      solid: {
        root: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        }
      },
      subtle: {
        root: {
          bg: "colorPalette.muted",
          color: "colorPalette.fg"
        }
      },
      outline: {
        root: {
          color: "colorPalette.fg",
          borderWidth: "1px",
          borderColor: "colorPalette.muted"
        }
      }
    },
    shape: {
      square: {},
      rounded: {
        root: { "--avatar-radius": "radii.l3" }
      },
      full: {
        root: { "--avatar-radius": "radii.full" }
      }
    },
    borderless: {
      true: {
        root: {
          "&[data-group-item]": {
            borderWidth: "0px"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    shape: "full",
    variant: "subtle"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/blockquote.js
var blockquoteSlotRecipe = defineSlotRecipe({
  className: "chakra-blockquote",
  slots: blockquoteAnatomy.keys(),
  base: {
    root: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      gap: "2"
    },
    caption: {
      textStyle: "sm",
      color: "fg.muted"
    },
    icon: {
      boxSize: "5"
    }
  },
  variants: {
    justify: {
      start: {
        root: {
          alignItems: "flex-start",
          textAlign: "start"
        }
      },
      center: {
        root: {
          alignItems: "center",
          textAlign: "center"
        }
      },
      end: {
        root: {
          alignItems: "flex-end",
          textAlign: "end"
        }
      }
    },
    variant: {
      subtle: {
        root: {
          paddingX: "5",
          borderStartWidth: "4px",
          borderStartColor: "colorPalette.muted"
        },
        icon: {
          color: "colorPalette.fg"
        }
      },
      solid: {
        root: {
          paddingX: "5",
          borderStartWidth: "4px",
          borderStartColor: "colorPalette.solid"
        },
        icon: {
          color: "colorPalette.solid"
        }
      },
      plain: {
        root: {
          paddingX: "5"
        },
        icon: {
          color: "colorPalette.solid"
        }
      }
    }
  },
  defaultVariants: {
    variant: "subtle",
    justify: "start"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/breadcrumb.js
var breadcrumbSlotRecipe = defineSlotRecipe({
  className: "chakra-breadcrumb",
  slots: breadcrumbAnatomy.keys(),
  base: {
    list: {
      display: "flex",
      alignItems: "center",
      wordBreak: "break-word",
      color: "fg.muted",
      listStyle: "none"
    },
    link: {
      outline: "0",
      textDecoration: "none",
      borderRadius: "l1",
      focusRing: "outside",
      display: "inline-flex",
      alignItems: "center",
      gap: "2"
    },
    item: {
      display: "inline-flex",
      alignItems: "center"
    },
    separator: {
      color: "fg.muted",
      opacity: "0.8",
      _icon: {
        boxSize: "1em"
      },
      _rtl: {
        rotate: "180deg"
      }
    },
    ellipsis: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      _icon: {
        boxSize: "1em"
      }
    }
  },
  variants: {
    variant: {
      underline: {
        link: {
          color: "colorPalette.fg",
          textDecoration: "underline",
          textUnderlineOffset: "0.2em",
          textDecorationColor: "colorPalette.muted"
        },
        currentLink: {
          color: "colorPalette.fg"
        }
      },
      plain: {
        link: {
          color: "fg.muted",
          _hover: { color: "fg" }
        },
        currentLink: {
          color: "fg"
        }
      }
    },
    size: {
      sm: {
        list: {
          gap: "1",
          textStyle: "xs"
        }
      },
      md: {
        list: {
          gap: "1.5",
          textStyle: "sm"
        }
      },
      lg: {
        list: {
          gap: "2",
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    variant: "plain",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/card.js
var cardSlotRecipe = defineSlotRecipe({
  className: "chakra-card",
  slots: cardAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      minWidth: "0",
      wordWrap: "break-word",
      borderRadius: "l3",
      color: "fg",
      textAlign: "start"
    },
    title: {
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted",
      fontSize: "sm"
    },
    header: {
      paddingInline: "var(--card-padding)",
      paddingTop: "var(--card-padding)",
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    },
    body: {
      padding: "var(--card-padding)",
      flex: "1",
      display: "flex",
      flexDirection: "column"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      gap: "2",
      paddingInline: "var(--card-padding)",
      paddingBottom: "var(--card-padding)"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          "--card-padding": "spacing.4"
        },
        title: {
          textStyle: "md"
        }
      },
      md: {
        root: {
          "--card-padding": "spacing.6"
        },
        title: {
          textStyle: "lg"
        }
      },
      lg: {
        root: {
          "--card-padding": "spacing.7"
        },
        title: {
          textStyle: "xl"
        }
      }
    },
    variant: {
      elevated: {
        root: {
          bg: "bg.panel",
          boxShadow: "md"
        }
      },
      outline: {
        root: {
          bg: "bg.panel",
          borderWidth: "1px",
          borderColor: "border"
        }
      },
      subtle: {
        root: {
          bg: "bg.muted"
        }
      }
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkbox.js
var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n;
var checkboxSlotRecipe = defineSlotRecipe({
  slots: checkboxAnatomy.keys(),
  className: "chakra-checkbox",
  base: {
    root: {
      display: "inline-flex",
      gap: "2",
      alignItems: "center",
      verticalAlign: "top",
      position: "relative"
    },
    control: checkmarkRecipe.base,
    label: {
      fontWeight: "medium",
      userSelect: "none",
      _disabled: {
        opacity: "0.5"
      }
    }
  },
  variants: {
    size: {
      xs: {
        root: { gap: "1.5" },
        label: { textStyle: "xs" },
        control: (_b = (_a = checkmarkRecipe.variants) == null ? void 0 : _a.size) == null ? void 0 : _b.xs
      },
      sm: {
        root: { gap: "2" },
        label: { textStyle: "sm" },
        control: (_d = (_c = checkmarkRecipe.variants) == null ? void 0 : _c.size) == null ? void 0 : _d.sm
      },
      md: {
        root: { gap: "2.5" },
        label: { textStyle: "sm" },
        control: (_f = (_e2 = checkmarkRecipe.variants) == null ? void 0 : _e2.size) == null ? void 0 : _f.md
      },
      lg: {
        root: { gap: "3" },
        label: { textStyle: "md" },
        control: (_h = (_g = checkmarkRecipe.variants) == null ? void 0 : _g.size) == null ? void 0 : _h.lg
      }
    },
    variant: {
      outline: {
        control: (_j = (_i = checkmarkRecipe.variants) == null ? void 0 : _i.variant) == null ? void 0 : _j.outline
      },
      solid: {
        control: (_l = (_k = checkmarkRecipe.variants) == null ? void 0 : _k.variant) == null ? void 0 : _l.solid
      },
      subtle: {
        control: (_n = (_m = checkmarkRecipe.variants) == null ? void 0 : _m.variant) == null ? void 0 : _n.subtle
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkbox-card.js
var _a2, _b2, _c2, _d2, _e3, _f2, _g2;
var checkboxCardSlotRecipe = defineSlotRecipe({
  slots: checkboxCardAnatomy.keys(),
  className: "chakra-checkbox-card",
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      userSelect: "none",
      position: "relative",
      borderRadius: "l2",
      flex: "1",
      focusVisibleRing: "outside",
      _disabled: {
        opacity: "0.8"
      },
      _invalid: {
        outline: "2px solid",
        outlineColor: "border.error"
      }
    },
    control: {
      display: "inline-flex",
      flex: "1",
      position: "relative",
      borderRadius: "inherit",
      justifyContent: "var(--checkbox-card-justify)",
      alignItems: "var(--checkbox-card-align)"
    },
    label: {
      fontWeight: "medium",
      display: "flex",
      alignItems: "center",
      gap: "2",
      flex: "1",
      _disabled: {
        opacity: "0.5"
      }
    },
    description: {
      opacity: "0.64",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    },
    addon: {
      _disabled: {
        opacity: "0.5"
      }
    },
    indicator: checkmarkRecipe.base,
    content: {
      display: "flex",
      flexDirection: "column",
      flex: "1",
      gap: "1",
      justifyContent: "var(--checkbox-card-justify)",
      alignItems: "var(--checkbox-card-align)"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        control: {
          padding: "3",
          gap: "1.5"
        },
        addon: {
          px: "3",
          py: "1.5",
          borderTopWidth: "1px"
        },
        indicator: (_a2 = checkmarkRecipe.variants) == null ? void 0 : _a2.size.sm
      },
      md: {
        root: {
          textStyle: "sm"
        },
        control: {
          padding: "4",
          gap: "2.5"
        },
        addon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        indicator: (_b2 = checkmarkRecipe.variants) == null ? void 0 : _b2.size.md
      },
      lg: {
        root: {
          textStyle: "md"
        },
        control: {
          padding: "4",
          gap: "3.5"
        },
        addon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        indicator: (_c2 = checkmarkRecipe.variants) == null ? void 0 : _c2.size.lg
      }
    },
    variant: {
      surface: {
        root: {
          borderWidth: "1px",
          borderColor: "border",
          _checked: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg",
            borderColor: "colorPalette.muted"
          },
          _disabled: {
            bg: "bg.muted"
          }
        },
        indicator: (_d2 = checkmarkRecipe.variants) == null ? void 0 : _d2.variant.solid
      },
      subtle: {
        root: {
          bg: "bg.muted"
        },
        control: {
          _checked: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          }
        },
        indicator: (_e3 = checkmarkRecipe.variants) == null ? void 0 : _e3.variant.plain
      },
      outline: {
        root: {
          borderWidth: "1px",
          borderColor: "border",
          _checked: {
            boxShadow: "0 0 0 1px var(--shadow-color)",
            boxShadowColor: "colorPalette.solid",
            borderColor: "colorPalette.solid"
          }
        },
        indicator: (_f2 = checkmarkRecipe.variants) == null ? void 0 : _f2.variant.solid
      },
      solid: {
        root: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast",
            borderColor: "colorPalette.solid"
          }
        },
        indicator: (_g2 = checkmarkRecipe.variants) == null ? void 0 : _g2.variant.inverted
      }
    },
    justify: {
      start: {
        root: { "--checkbox-card-justify": "flex-start" }
      },
      end: {
        root: { "--checkbox-card-justify": "flex-end" }
      },
      center: {
        root: { "--checkbox-card-justify": "center" }
      }
    },
    align: {
      start: {
        root: { "--checkbox-card-align": "flex-start" },
        content: { textAlign: "start" }
      },
      end: {
        root: { "--checkbox-card-align": "flex-end" },
        content: { textAlign: "end" }
      },
      center: {
        root: { "--checkbox-card-align": "center" },
        content: { textAlign: "center" }
      }
    },
    orientation: {
      vertical: {
        control: { flexDirection: "column" }
      },
      horizontal: {
        control: { flexDirection: "row" }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    align: "start",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/collapsible.js
var collapsibleSlotRecipe = defineSlotRecipe({
  slots: anatomy2.keys(),
  className: "chakra-collapsible",
  base: {
    content: {
      overflow: "hidden",
      _open: {
        animationName: "expand-height, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "collapse-height, fade-out",
        animationDuration: "moderate"
      }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/color-picker.js
var _a3, _b3, _c3, _d3, _e4, _f3, _g3, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o, _p, _q, _r;
var colorPickerSlotRecipe = defineSlotRecipe({
  className: "colorPicker",
  slots: colorPickerAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    },
    label: {
      color: "fg",
      fontWeight: "medium",
      textStyle: "sm"
    },
    valueText: {
      textAlign: "start"
    },
    control: {
      display: "flex",
      alignItems: "center",
      flexDirection: "row",
      gap: "2",
      position: "relative"
    },
    swatchTrigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexDirection: "row",
      flexShrink: "0",
      gap: "2",
      textStyle: "sm",
      minH: "var(--input-height)",
      minW: "var(--input-height)",
      px: "1",
      rounded: "l2",
      _disabled: { opacity: "0.5" },
      "--focus-color": "colors.colorPalette.focusRing",
      "&:focus-visible": {
        borderColor: "var(--focus-color)",
        outline: "1px solid var(--focus-color)"
      },
      "&[data-fit-content]": {
        "--input-height": "unset",
        px: "0",
        border: "0"
      }
    },
    content: {
      display: "flex",
      flexDirection: "column",
      bg: "bg.panel",
      borderRadius: "l3",
      boxShadow: "lg",
      width: "64",
      p: "4",
      gap: "3",
      zIndex: "dropdown",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    area: {
      height: "180px",
      borderRadius: "l2",
      overflow: "hidden"
    },
    areaThumb: {
      borderRadius: "full",
      height: "var(--thumb-size)",
      width: "var(--thumb-size)",
      borderWidth: "2px",
      borderColor: "white",
      shadow: "sm",
      focusVisibleRing: "mixed",
      focusRingColor: "white"
    },
    areaBackground: {
      height: "full"
    },
    channelSlider: {
      borderRadius: "l2",
      flex: "1"
    },
    channelSliderTrack: {
      height: "var(--slider-height)",
      borderRadius: "inherit",
      boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)"
    },
    swatchGroup: {
      display: "flex",
      flexDirection: "row",
      flexWrap: "wrap",
      gap: "2"
    },
    swatch: {
      ...colorSwatchRecipe.base,
      borderRadius: "l1"
    },
    swatchIndicator: {
      color: "white",
      rounded: "full"
    },
    channelSliderThumb: {
      borderRadius: "full",
      height: "var(--thumb-size)",
      width: "var(--thumb-size)",
      borderWidth: "2px",
      borderColor: "white",
      shadow: "sm",
      transform: "translate(-50%, -50%)",
      focusVisibleRing: "outside",
      focusRingOffset: "1px"
    },
    channelInput: {
      ...inputRecipe.base,
      "&::-webkit-inner-spin-button, &::-webkit-outer-spin-button": {
        WebkitAppearance: "none",
        margin: 0
      }
    },
    formatSelect: {
      textStyle: "xs",
      textTransform: "uppercase",
      borderWidth: "1px",
      minH: "6",
      focusRing: "inside",
      rounded: "l2"
    },
    transparencyGrid: {
      borderRadius: "l2"
    },
    view: {
      display: "flex",
      flexDirection: "column",
      gap: "2"
    }
  },
  variants: {
    size: {
      "2xs": {
        channelInput: (_b3 = (_a3 = inputRecipe.variants) == null ? void 0 : _a3.size) == null ? void 0 : _b3["2xs"],
        swatch: { "--swatch-size": "sizes.4.5" },
        trigger: { "--input-height": "sizes.7" },
        area: { "--thumb-size": "sizes.3" },
        channelSlider: {
          "--slider-height": "sizes.3",
          "--thumb-size": "sizes.3"
        }
      },
      xs: {
        channelInput: (_d3 = (_c3 = inputRecipe.variants) == null ? void 0 : _c3.size) == null ? void 0 : _d3.xs,
        swatch: { "--swatch-size": "sizes.5" },
        trigger: { "--input-height": "sizes.8" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      sm: {
        channelInput: (_f3 = (_e4 = inputRecipe.variants) == null ? void 0 : _e4.size) == null ? void 0 : _f3.sm,
        swatch: { "--swatch-size": "sizes.6" },
        trigger: { "--input-height": "sizes.9" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      md: {
        channelInput: (_h2 = (_g3 = inputRecipe.variants) == null ? void 0 : _g3.size) == null ? void 0 : _h2.md,
        swatch: { "--swatch-size": "sizes.7" },
        trigger: { "--input-height": "sizes.10" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      lg: {
        channelInput: (_j2 = (_i2 = inputRecipe.variants) == null ? void 0 : _i2.size) == null ? void 0 : _j2.lg,
        swatch: { "--swatch-size": "sizes.7" },
        trigger: { "--input-height": "sizes.11" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      xl: {
        channelInput: (_l2 = (_k2 = inputRecipe.variants) == null ? void 0 : _k2.size) == null ? void 0 : _l2.xl,
        swatch: { "--swatch-size": "sizes.8" },
        trigger: { "--input-height": "sizes.12" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      "2xl": {
        channelInput: (_n2 = (_m2 = inputRecipe.variants) == null ? void 0 : _m2.size) == null ? void 0 : _n2["2xl"],
        swatch: { "--swatch-size": "sizes.10" },
        trigger: { "--input-height": "sizes.16" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      }
    },
    variant: {
      outline: {
        channelInput: (_p = (_o = inputRecipe.variants) == null ? void 0 : _o.variant) == null ? void 0 : _p.outline,
        trigger: {
          borderWidth: "1px"
        }
      },
      subtle: {
        channelInput: (_r = (_q = inputRecipe.variants) == null ? void 0 : _q.variant) == null ? void 0 : _r.subtle,
        trigger: {
          borderWidth: "1px",
          borderColor: "transparent",
          bg: "bg.muted"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/data-list.js
var dataListSlotRecipe = defineSlotRecipe({
  slots: dataListAnatomy.keys(),
  className: "chakra-data-list",
  base: {
    itemLabel: {
      display: "flex",
      alignItems: "center",
      gap: "1"
    },
    itemValue: {
      display: "flex",
      minWidth: "0",
      flex: "1"
    }
  },
  variants: {
    orientation: {
      horizontal: {
        root: {
          display: "flex",
          flexDirection: "column"
        },
        item: {
          display: "inline-flex",
          alignItems: "center",
          gap: "4"
        },
        itemLabel: {
          minWidth: "120px"
        }
      },
      vertical: {
        root: {
          display: "flex",
          flexDirection: "column"
        },
        item: {
          display: "flex",
          flexDirection: "column",
          gap: "1"
        }
      }
    },
    size: {
      sm: {
        root: {
          gap: "3"
        },
        item: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          gap: "4"
        },
        item: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          gap: "5"
        },
        item: {
          textStyle: "md"
        }
      }
    },
    variant: {
      subtle: {
        itemLabel: {
          color: "fg.muted"
        }
      },
      bold: {
        itemLabel: {
          fontWeight: "medium"
        },
        itemValue: {
          color: "fg.muted"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    orientation: "vertical",
    variant: "subtle"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/dialog.js
var dialogSlotRecipe = defineSlotRecipe({
  slots: dialogAnatomy.keys(),
  className: "chakra-dialog",
  base: {
    backdrop: {
      bg: "blackAlpha.500",
      pos: "fixed",
      left: 0,
      top: 0,
      w: "100vw",
      h: "100dvh",
      zIndex: "modal",
      _open: {
        animationName: "fade-in",
        animationDuration: "slow"
      },
      _closed: {
        animationName: "fade-out",
        animationDuration: "moderate"
      }
    },
    positioner: {
      display: "flex",
      width: "100vw",
      height: "100dvh",
      position: "fixed",
      left: 0,
      top: 0,
      "--dialog-z-index": "zIndex.modal",
      zIndex: "calc(var(--dialog-z-index) + var(--layer-index, 0))",
      justifyContent: "center",
      overscrollBehaviorY: "none"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      borderRadius: "l3",
      textStyle: "sm",
      my: "var(--dialog-margin, var(--dialog-base-margin))",
      "--dialog-z-index": "zIndex.modal",
      zIndex: "calc(var(--dialog-z-index) + var(--layer-index, 0))",
      bg: "bg.panel",
      boxShadow: "lg",
      _open: {
        animationDuration: "moderate"
      },
      _closed: {
        animationDuration: "faster"
      }
    },
    header: {
      display: "flex",
      alignItems: "center",
      gap: "2",
      flex: 0,
      px: "6",
      pt: "6",
      pb: "4"
    },
    body: {
      flex: "1",
      px: "6",
      pt: "2",
      pb: "6"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      gap: "3",
      px: "6",
      pt: "2",
      pb: "4"
    },
    title: {
      textStyle: "lg",
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted"
    },
    closeTrigger: {
      pos: "absolute",
      top: "2",
      insetEnd: "2"
    }
  },
  variants: {
    placement: {
      center: {
        positioner: {
          alignItems: "center"
        },
        content: {
          "--dialog-base-margin": "auto",
          mx: "auto"
        }
      },
      top: {
        positioner: {
          alignItems: "flex-start"
        },
        content: {
          "--dialog-base-margin": "spacing.16",
          mx: "auto"
        }
      },
      bottom: {
        positioner: {
          alignItems: "flex-end"
        },
        content: {
          "--dialog-base-margin": "spacing.16",
          mx: "auto"
        }
      }
    },
    scrollBehavior: {
      inside: {
        positioner: {
          overflow: "hidden"
        },
        content: {
          maxH: "calc(100% - 7.5rem)"
        },
        body: {
          overflow: "auto"
        }
      },
      outside: {
        positioner: {
          overflow: "auto",
          pointerEvents: "auto"
        }
      }
    },
    size: {
      xs: {
        content: {
          maxW: "sm"
        }
      },
      sm: {
        content: {
          maxW: "md"
        }
      },
      md: {
        content: {
          maxW: "lg"
        }
      },
      lg: {
        content: {
          maxW: "2xl"
        }
      },
      xl: {
        content: {
          maxW: "4xl"
        }
      },
      cover: {
        positioner: {
          padding: "10"
        },
        content: {
          width: "100%",
          height: "100%",
          "--dialog-margin": "0"
        }
      },
      full: {
        content: {
          maxW: "100vw",
          minH: "100vh",
          "--dialog-margin": "0",
          borderRadius: "0"
        }
      }
    },
    motionPreset: {
      scale: {
        content: {
          _open: { animationName: "scale-in, fade-in" },
          _closed: { animationName: "scale-out, fade-out" }
        }
      },
      "slide-in-bottom": {
        content: {
          _open: { animationName: "slide-from-bottom, fade-in" },
          _closed: { animationName: "slide-to-bottom, fade-out" }
        }
      },
      "slide-in-top": {
        content: {
          _open: { animationName: "slide-from-top, fade-in" },
          _closed: { animationName: "slide-to-top, fade-out" }
        }
      },
      "slide-in-left": {
        content: {
          _open: { animationName: "slide-from-left, fade-in" },
          _closed: { animationName: "slide-to-left, fade-out" }
        }
      },
      "slide-in-right": {
        content: {
          _open: { animationName: "slide-from-right, fade-in" },
          _closed: { animationName: "slide-to-right, fade-out" }
        }
      },
      none: {}
    }
  },
  defaultVariants: {
    size: "md",
    scrollBehavior: "outside",
    placement: "top",
    motionPreset: "scale"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/drawer.js
var drawerSlotRecipe = defineSlotRecipe({
  slots: drawerAnatomy.keys(),
  className: "chakra-drawer",
  base: {
    backdrop: {
      bg: "blackAlpha.500",
      pos: "fixed",
      insetInlineStart: 0,
      top: 0,
      w: "100vw",
      h: "100dvh",
      zIndex: "modal",
      _open: {
        animationName: "fade-in",
        animationDuration: "slow"
      },
      _closed: {
        animationName: "fade-out",
        animationDuration: "moderate"
      }
    },
    positioner: {
      display: "flex",
      width: "100vw",
      height: "100dvh",
      position: "fixed",
      insetInlineStart: 0,
      top: 0,
      zIndex: "modal",
      overscrollBehaviorY: "none"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      zIndex: "modal",
      textStyle: "sm",
      maxH: "100dvh",
      color: "inherit",
      bg: "bg.panel",
      boxShadow: "lg",
      _open: {
        animationDuration: "slowest",
        animationTimingFunction: "ease-in-smooth"
      },
      _closed: {
        animationDuration: "slower",
        animationTimingFunction: "ease-in-smooth"
      }
    },
    header: {
      display: "flex",
      alignItems: "center",
      gap: "2",
      flex: 0,
      px: "6",
      pt: "6",
      pb: "4"
    },
    body: {
      px: "6",
      py: "2",
      flex: "1",
      overflow: "auto"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      gap: "3",
      px: "6",
      pt: "2",
      pb: "4"
    },
    title: {
      flex: "1",
      textStyle: "lg",
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted"
    },
    closeTrigger: {
      pos: "absolute",
      top: "3",
      insetEnd: "2"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          maxW: "xs"
        }
      },
      sm: {
        content: {
          maxW: "md"
        }
      },
      md: {
        content: {
          maxW: "lg"
        }
      },
      lg: {
        content: {
          maxW: "2xl"
        }
      },
      xl: {
        content: {
          maxW: "4xl"
        }
      },
      full: {
        content: {
          maxW: "100vw",
          h: "100dvh"
        }
      }
    },
    placement: {
      start: {
        positioner: {
          justifyContent: "flex-start"
        },
        content: {
          _open: {
            animationName: {
              base: "slide-from-left-full, fade-in",
              _rtl: "slide-from-right-full, fade-in"
            }
          },
          _closed: {
            animationName: {
              base: "slide-to-left-full, fade-out",
              _rtl: "slide-to-right-full, fade-out"
            }
          }
        }
      },
      end: {
        positioner: {
          justifyContent: "flex-end"
        },
        content: {
          _open: {
            animationName: {
              base: "slide-from-right-full, fade-in",
              _rtl: "slide-from-left-full, fade-in"
            }
          },
          _closed: {
            animationName: {
              base: "slide-to-right-full, fade-out",
              _rtl: "slide-to-right-full, fade-out"
            }
          }
        }
      },
      top: {
        positioner: {
          alignItems: "flex-start"
        },
        content: {
          maxW: "100%",
          _open: { animationName: "slide-from-top-full, fade-in" },
          _closed: { animationName: "slide-to-top-full, fade-out" }
        }
      },
      bottom: {
        positioner: {
          alignItems: "flex-end"
        },
        content: {
          maxW: "100%",
          _open: { animationName: "slide-from-bottom-full, fade-in" },
          _closed: { animationName: "slide-to-bottom-full, fade-out" }
        }
      }
    },
    contained: {
      true: {
        positioner: {
          padding: "4"
        },
        content: {
          borderRadius: "l3"
        }
      }
    }
  },
  defaultVariants: {
    size: "xs",
    placement: "end"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/editable.js
var sharedStyles = defineStyle({
  fontSize: "inherit",
  fontWeight: "inherit",
  textAlign: "inherit",
  bg: "transparent",
  borderRadius: "l2"
});
var editableSlotRecipe = defineSlotRecipe({
  slots: editableAnatomy.keys(),
  className: "chakra-editable",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative",
      gap: "1.5",
      width: "full"
    },
    preview: {
      ...sharedStyles,
      py: "1",
      px: "1",
      display: "inline-flex",
      alignItems: "center",
      transitionProperty: "common",
      transitionDuration: "normal",
      cursor: "text",
      _hover: {
        bg: "bg.muted"
      },
      _disabled: {
        userSelect: "none"
      }
    },
    input: {
      ...sharedStyles,
      outline: "0",
      py: "1",
      px: "1",
      transitionProperty: "common",
      transitionDuration: "normal",
      width: "full",
      focusVisibleRing: "inside",
      focusRingWidth: "2px",
      _placeholder: { opacity: 0.6 }
    },
    control: {
      display: "inline-flex",
      alignItems: "center",
      gap: "1.5"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        preview: { minH: "8" },
        input: { minH: "8" }
      },
      md: {
        root: {
          textStyle: "sm"
        },
        preview: { minH: "9" },
        input: { minH: "9" }
      },
      lg: {
        root: {
          textStyle: "md"
        },
        preview: { minH: "10" },
        input: { minH: "10" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/empty-state.js
var emptyStateSlotRecipe = defineSlotRecipe({
  slots: emptyStateAnatomy.keys(),
  className: "chakra-empty-state",
  base: {
    root: {
      width: "full"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center"
    },
    indicator: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: "fg.subtle",
      _icon: {
        boxSize: "1em"
      }
    },
    title: {
      fontWeight: "semibold"
    },
    description: {
      textStyle: "sm",
      color: "fg.muted"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          px: "4",
          py: "6"
        },
        title: {
          textStyle: "md"
        },
        content: {
          gap: "4"
        },
        indicator: {
          textStyle: "2xl"
        }
      },
      md: {
        root: {
          px: "8",
          py: "12"
        },
        title: {
          textStyle: "lg"
        },
        content: {
          gap: "6"
        },
        indicator: {
          textStyle: "4xl"
        }
      },
      lg: {
        root: {
          px: "12",
          py: "16"
        },
        title: {
          textStyle: "xl"
        },
        content: {
          gap: "8"
        },
        indicator: {
          textStyle: "6xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/field.js
var fieldSlotRecipe = defineSlotRecipe({
  className: "chakra-field",
  slots: fieldAnatomy2.keys(),
  base: {
    requiredIndicator: {
      color: "fg.error",
      lineHeight: "1"
    },
    root: {
      display: "flex",
      width: "100%",
      position: "relative",
      gap: "1.5"
    },
    label: {
      display: "flex",
      alignItems: "center",
      textAlign: "start",
      textStyle: "sm",
      fontWeight: "medium",
      gap: "1",
      userSelect: "none",
      _disabled: {
        opacity: "0.5"
      }
    },
    errorText: {
      display: "inline-flex",
      alignItems: "center",
      fontWeight: "medium",
      gap: "1",
      color: "fg.error",
      textStyle: "xs"
    },
    helperText: {
      color: "fg.muted",
      textStyle: "xs"
    }
  },
  variants: {
    orientation: {
      vertical: {
        root: {
          flexDirection: "column",
          alignItems: "flex-start"
        }
      },
      horizontal: {
        root: {
          flexDirection: "row",
          alignItems: "center",
          justifyContent: "space-between"
        },
        label: {
          flex: "0 0 var(--field-label-width, 80px)"
        }
      }
    }
  },
  defaultVariants: {
    orientation: "vertical"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/fieldset.js
var fieldsetSlotRecipe = defineSlotRecipe({
  className: "fieldset",
  slots: fieldsetAnatomy2.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      width: "full"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      width: "full"
    },
    legend: {
      color: "fg",
      fontWeight: "medium",
      _disabled: {
        opacity: "0.5"
      }
    },
    helperText: {
      color: "fg.muted",
      textStyle: "sm"
    },
    errorText: {
      display: "inline-flex",
      alignItems: "center",
      color: "fg.error",
      gap: "2",
      fontWeight: "medium",
      textStyle: "sm"
    }
  },
  variants: {
    size: {
      sm: {
        root: { spaceY: "2" },
        content: { gap: "1.5" },
        legend: { textStyle: "sm" }
      },
      md: {
        root: { spaceY: "4" },
        content: { gap: "4" },
        legend: { textStyle: "sm" }
      },
      lg: {
        root: { spaceY: "6" },
        content: { gap: "4" },
        legend: { textStyle: "md" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/file-upload.js
var fileUploadSlotRecipe = defineSlotRecipe({
  className: "chakra-file-upload",
  slots: fileUploadAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "4",
      width: "100%",
      alignItems: "flex-start"
    },
    label: {
      fontWeight: "medium",
      textStyle: "sm"
    },
    dropzone: {
      background: "bg",
      borderRadius: "l3",
      borderWidth: "2px",
      borderStyle: "dashed",
      display: "flex",
      alignItems: "center",
      flexDirection: "column",
      gap: "4",
      justifyContent: "center",
      minHeight: "2xs",
      px: "3",
      py: "2",
      transition: "backgrounds",
      focusVisibleRing: "outside",
      _hover: {
        bg: "bg.subtle"
      },
      _dragging: {
        bg: "colorPalette.subtle",
        borderStyle: "solid",
        borderColor: "colorPalette.solid"
      }
    },
    dropzoneContent: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      textAlign: "center",
      gap: "1",
      textStyle: "sm"
    },
    item: {
      textStyle: "sm",
      animationName: "fade-in",
      animationDuration: "moderate",
      background: "bg",
      borderRadius: "l2",
      borderWidth: "1px",
      width: "100%",
      display: "flex",
      alignItems: "center",
      gap: "3",
      p: "4"
    },
    itemGroup: {
      width: "100%",
      display: "flex",
      flexDirection: "column",
      gap: "3"
    },
    itemName: {
      color: "fg",
      fontWeight: "medium",
      lineClamp: "1"
    },
    itemContent: {
      display: "flex",
      flexDirection: "column",
      gap: "0.5",
      flex: "1"
    },
    itemSizeText: {
      color: "fg.muted",
      textStyle: "xs"
    },
    itemDeleteTrigger: {
      alignSelf: "flex-start"
    },
    itemPreviewImage: {
      width: "10",
      height: "10",
      objectFit: "scale-down"
    }
  },
  defaultVariants: {}
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/hover-card.js
var hoverCardSlotRecipe = defineSlotRecipe({
  className: "chakra-hover-card",
  slots: anatomy13.keys(),
  base: {
    content: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      textStyle: "sm",
      "--hovercard-bg": "colors.bg.panel",
      bg: "var(--hovercard-bg)",
      boxShadow: "lg",
      maxWidth: "80",
      borderRadius: "l3",
      zIndex: "popover",
      transformOrigin: "var(--transform-origin)",
      outline: "0",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    arrow: {
      "--arrow-size": "sizes.3",
      "--arrow-background": "var(--hovercard-bg)"
    },
    arrowTip: {
      borderTopWidth: "0.5px",
      borderInlineStartWidth: "0.5px"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          padding: "3"
        }
      },
      sm: {
        content: {
          padding: "4"
        }
      },
      md: {
        content: {
          padding: "5"
        }
      },
      lg: {
        content: {
          padding: "6"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/list.js
var listSlotRecipe = defineSlotRecipe({
  className: "chakra-list",
  slots: listAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "var(--list-gap)",
      "& :where(ul, ol)": {
        marginTop: "var(--list-gap)"
      }
    },
    item: {
      whiteSpace: "normal",
      display: "list-item"
    },
    indicator: {
      marginEnd: "2",
      minHeight: "1lh",
      flexShrink: 0,
      display: "inline-block",
      verticalAlign: "middle"
    }
  },
  variants: {
    variant: {
      marker: {
        root: {
          listStyle: "revert"
        },
        item: {
          _marker: {
            color: "fg.subtle"
          }
        }
      },
      plain: {
        item: {
          alignItems: "flex-start",
          display: "inline-flex"
        }
      }
    },
    align: {
      center: {
        item: { alignItems: "center" }
      },
      start: {
        item: { alignItems: "flex-start" }
      },
      end: {
        item: { alignItems: "flex-end" }
      }
    }
  },
  defaultVariants: {
    variant: "marker"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/menu.js
var menuSlotRecipe = defineSlotRecipe({
  className: "chakra-menu",
  slots: menuAnatomy.keys(),
  base: {
    content: {
      outline: 0,
      bg: "bg.panel",
      boxShadow: "lg",
      color: "fg",
      maxHeight: "var(--available-height)",
      "--menu-z-index": "zIndex.dropdown",
      zIndex: "calc(var(--menu-z-index) + var(--layer-index, 0))",
      borderRadius: "l2",
      overflow: "hidden",
      overflowY: "auto",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    item: {
      textDecoration: "none",
      color: "fg",
      userSelect: "none",
      borderRadius: "l1",
      width: "100%",
      display: "flex",
      cursor: "menuitem",
      alignItems: "center",
      textAlign: "start",
      position: "relative",
      flex: "0 0 auto",
      outline: 0,
      _disabled: {
        layerStyle: "disabled"
      }
    },
    itemText: {
      flex: "1"
    },
    itemGroupLabel: {
      px: "2",
      py: "1.5",
      fontWeight: "semibold",
      textStyle: "sm"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0"
    },
    itemCommand: {
      opacity: "0.6",
      textStyle: "xs",
      ms: "auto",
      ps: "4",
      letterSpacing: "widest"
    },
    separator: {
      height: "1px",
      bg: "bg.muted",
      my: "1",
      mx: "-1"
    }
  },
  variants: {
    variant: {
      subtle: {
        item: {
          _highlighted: {
            bg: "bg.emphasized/60"
          }
        }
      },
      solid: {
        item: {
          _highlighted: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast"
          }
        }
      }
    },
    size: {
      sm: {
        content: {
          minW: "8rem",
          padding: "1"
        },
        item: {
          gap: "1",
          textStyle: "xs",
          py: "1",
          px: "1.5"
        }
      },
      md: {
        content: {
          minW: "8rem",
          padding: "1.5"
        },
        item: {
          gap: "2",
          textStyle: "sm",
          py: "1.5",
          px: "2"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "subtle"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/select.js
var selectSlotRecipe = defineSlotRecipe({
  className: "chakra-select",
  slots: selectAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5",
      width: "full"
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      width: "full",
      minH: "var(--select-trigger-height)",
      px: "var(--select-trigger-padding-x)",
      borderRadius: "l2",
      userSelect: "none",
      textAlign: "start",
      focusVisibleRing: "inside",
      _placeholderShown: {
        color: "fg.muted/80"
      },
      _disabled: {
        layerStyle: "disabled"
      },
      _invalid: {
        borderColor: "border.error"
      }
    },
    indicatorGroup: {
      display: "flex",
      alignItems: "center",
      gap: "1",
      pos: "absolute",
      right: "0",
      top: "0",
      bottom: "0",
      px: "var(--select-trigger-padding-x)",
      pointerEvents: "none"
    },
    indicator: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: { base: "fg.muted", _disabled: "fg.subtle", _invalid: "fg.error" }
    },
    content: {
      background: "bg.panel",
      display: "flex",
      flexDirection: "column",
      zIndex: "dropdown",
      borderRadius: "l2",
      outline: 0,
      maxH: "96",
      overflowY: "auto",
      boxShadow: "md",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "fastest"
      }
    },
    item: {
      position: "relative",
      userSelect: "none",
      display: "flex",
      alignItems: "center",
      gap: "2",
      cursor: "option",
      justifyContent: "space-between",
      flex: "1",
      textAlign: "start",
      borderRadius: "l1",
      _highlighted: {
        bg: "bg.emphasized/60"
      },
      _disabled: {
        pointerEvents: "none",
        opacity: "0.5"
      },
      _icon: {
        width: "4",
        height: "4"
      }
    },
    control: {
      pos: "relative"
    },
    itemText: {
      flex: "1"
    },
    itemGroup: {
      _first: { mt: "0" }
    },
    itemGroupLabel: {
      py: "1",
      fontWeight: "medium"
    },
    label: {
      fontWeight: "medium",
      userSelect: "none",
      textStyle: "sm",
      _disabled: {
        layerStyle: "disabled"
      }
    },
    valueText: {
      lineClamp: "1",
      maxW: "80%"
    }
  },
  variants: {
    variant: {
      outline: {
        trigger: {
          bg: "transparent",
          borderWidth: "1px",
          borderColor: "border",
          _expanded: {
            borderColor: "border.emphasized"
          }
        }
      },
      subtle: {
        trigger: {
          borderWidth: "1px",
          borderColor: "transparent",
          bg: "bg.muted"
        }
      }
    },
    size: {
      xs: {
        root: {
          "--select-trigger-height": "sizes.8",
          "--select-trigger-padding-x": "spacing.2"
        },
        content: {
          p: "1",
          gap: "1",
          textStyle: "xs"
        },
        trigger: {
          textStyle: "xs",
          gap: "1"
        },
        item: {
          py: "1",
          px: "2"
        },
        itemGroupLabel: {
          py: "1",
          px: "2"
        },
        indicator: {
          _icon: {
            width: "3.5",
            height: "3.5"
          }
        }
      },
      sm: {
        root: {
          "--select-trigger-height": "sizes.9",
          "--select-trigger-padding-x": "spacing.2.5"
        },
        content: {
          p: "1",
          textStyle: "sm"
        },
        trigger: {
          textStyle: "sm",
          gap: "1"
        },
        indicator: {
          _icon: {
            width: "4",
            height: "4"
          }
        },
        item: {
          py: "1",
          px: "1.5"
        },
        itemGroup: {
          mt: "1"
        },
        itemGroupLabel: {
          py: "1",
          px: "1.5"
        }
      },
      md: {
        root: {
          "--select-trigger-height": "sizes.10",
          "--select-trigger-padding-x": "spacing.3"
        },
        content: {
          p: "1",
          textStyle: "sm"
        },
        itemGroup: {
          mt: "1.5"
        },
        item: {
          py: "1.5",
          px: "2"
        },
        itemIndicator: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center"
        },
        itemGroupLabel: {
          py: "1.5",
          px: "2"
        },
        trigger: {
          textStyle: "sm",
          gap: "2"
        },
        indicator: {
          _icon: {
            width: "4",
            height: "4"
          }
        }
      },
      lg: {
        root: {
          "--select-trigger-height": "sizes.12",
          "--select-trigger-padding-x": "spacing.4"
        },
        content: {
          p: "1.5",
          textStyle: "md"
        },
        itemGroup: {
          mt: "2"
        },
        item: {
          py: "2",
          px: "3"
        },
        itemGroupLabel: {
          py: "2",
          px: "3"
        },
        trigger: {
          textStyle: "md",
          py: "3",
          gap: "2"
        },
        indicator: {
          _icon: {
            width: "5",
            height: "5"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/native-select.js
var _a4, _b4;
var nativeSelectSlotRecipe = defineSlotRecipe({
  className: "chakra-native-select",
  slots: nativeSelectAnatomy.keys(),
  base: {
    root: {
      height: "fit-content",
      display: "flex",
      width: "100%",
      position: "relative"
    },
    field: {
      width: "100%",
      minWidth: "0",
      outline: "0",
      appearance: "none",
      borderRadius: "l2",
      "--error-color": "colors.border.error",
      _disabled: {
        layerStyle: "disabled"
      },
      _invalid: {
        focusRingColor: "var(--error-color)",
        borderColor: "var(--error-color)"
      },
      focusVisibleRing: "inside",
      lineHeight: "normal",
      "& > option, & > optgroup": {
        bg: "bg"
      }
    },
    indicator: {
      position: "absolute",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      pointerEvents: "none",
      top: "50%",
      transform: "translateY(-50%)",
      height: "100%",
      color: "fg.muted",
      _disabled: {
        opacity: "0.5"
      },
      _invalid: {
        color: "fg.error"
      },
      _icon: {
        width: "1em",
        height: "1em"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        field: (_a4 = selectSlotRecipe.variants) == null ? void 0 : _a4.variant.outline.trigger
      },
      subtle: {
        field: (_b4 = selectSlotRecipe.variants) == null ? void 0 : _b4.variant.subtle.trigger
      },
      plain: {
        field: {
          bg: "transparent",
          color: "fg",
          focusRingWidth: "2px"
        }
      }
    },
    size: {
      xs: {
        field: {
          textStyle: "xs",
          ps: "2",
          pe: "6",
          height: "6"
        },
        indicator: {
          textStyle: "sm",
          insetEnd: "1.5"
        }
      },
      sm: {
        field: {
          textStyle: "sm",
          ps: "2.5",
          pe: "8",
          height: "8"
        },
        indicator: {
          textStyle: "md",
          insetEnd: "2"
        }
      },
      md: {
        field: {
          textStyle: "sm",
          ps: "3",
          pe: "8",
          height: "10"
        },
        indicator: {
          textStyle: "lg",
          insetEnd: "2"
        }
      },
      lg: {
        field: {
          textStyle: "md",
          ps: "4",
          pe: "8",
          height: "11"
        },
        indicator: {
          textStyle: "xl",
          insetEnd: "3"
        }
      },
      xl: {
        field: {
          textStyle: "md",
          ps: "4.5",
          pe: "10",
          height: "12"
        },
        indicator: {
          textStyle: "xl",
          insetEnd: "3"
        }
      }
    }
  },
  defaultVariants: selectSlotRecipe.defaultVariants
});

// node_modules/@chakra-ui/react/dist/esm/utils/entries.js
function mapEntries2(obj, f) {
  const result = {};
  for (const key in obj) {
    const kv = f(key, obj[key]);
    result[kv[0]] = kv[1];
  }
  return result;
}

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/number-input.js
var triggerStyle = defineStyle({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  flex: "1",
  userSelect: "none",
  cursor: "button",
  lineHeight: "1",
  color: "fg.muted",
  "--stepper-base-radius": "radii.l1",
  "--stepper-radius": "calc(var(--stepper-base-radius) + 1px)",
  _icon: {
    boxSize: "1em"
  },
  _disabled: {
    opacity: "0.5"
  },
  _hover: {
    bg: "bg.muted"
  },
  _active: {
    bg: "bg.emphasized"
  }
});
var numberInputSlotRecipe = defineSlotRecipe({
  className: "chakra-number-input",
  slots: anatomy15.keys(),
  base: {
    root: {
      position: "relative",
      zIndex: "0",
      isolation: "isolate"
    },
    input: {
      ...inputRecipe.base,
      verticalAlign: "top",
      pe: "calc(var(--stepper-width) + 0.5rem)"
    },
    control: {
      display: "flex",
      flexDirection: "column",
      position: "absolute",
      top: "0",
      insetEnd: "0px",
      margin: "1px",
      width: "var(--stepper-width)",
      height: "calc(100% - 2px)",
      zIndex: "1",
      borderStartWidth: "1px",
      divideY: "1px"
    },
    incrementTrigger: {
      ...triggerStyle,
      borderTopEndRadius: "var(--stepper-radius)"
    },
    decrementTrigger: {
      ...triggerStyle,
      borderBottomEndRadius: "var(--stepper-radius)"
    },
    valueText: {
      fontWeight: "medium",
      fontFeatureSettings: "pnum",
      fontVariantNumeric: "proportional-nums"
    }
  },
  variants: {
    size: {
      xs: {
        input: inputRecipe.variants.size.xs,
        control: {
          fontSize: "2xs",
          "--stepper-width": "sizes.4"
        }
      },
      sm: {
        input: inputRecipe.variants.size.sm,
        control: {
          fontSize: "xs",
          "--stepper-width": "sizes.5"
        }
      },
      md: {
        input: inputRecipe.variants.size.md,
        control: {
          fontSize: "sm",
          "--stepper-width": "sizes.6"
        }
      },
      lg: {
        input: inputRecipe.variants.size.lg,
        control: {
          fontSize: "sm",
          "--stepper-width": "sizes.6"
        }
      }
    },
    variant: mapEntries2(inputRecipe.variants.variant, (key, variantStyles) => [
      key,
      { input: variantStyles }
    ])
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/pin-input.js
var { variants: variants2, defaultVariants: defaultVariants2 } = inputRecipe;
var pinInputSlotRecipe = defineSlotRecipe({
  className: "chakra-pin-input",
  slots: anatomy17.keys(),
  base: {
    input: {
      ...inputRecipe.base,
      textAlign: "center",
      width: "var(--input-height)"
    },
    control: {
      display: "inline-flex",
      gap: "2",
      isolation: "isolate"
    }
  },
  variants: {
    size: mapEntries2(variants2.size, (key, value) => [key, { input: value }]),
    variant: mapEntries2(variants2.variant, (key, value) => [
      key,
      { input: value }
    ]),
    attached: {
      true: {
        control: {
          gap: "0",
          spaceX: "-1px"
        },
        input: {
          _notFirst: { borderStartRadius: "0" },
          _notLast: { borderEndRadius: "0" },
          _focusVisible: { zIndex: "1" }
        }
      }
    }
  },
  defaultVariants: defaultVariants2
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/popover.js
var popoverSlotRecipe = defineSlotRecipe({
  className: "chakra-popover",
  slots: popoverAnatomy.keys(),
  base: {
    content: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      textStyle: "sm",
      "--popover-bg": "colors.bg.panel",
      bg: "var(--popover-bg)",
      boxShadow: "lg",
      "--popover-size": "sizes.xs",
      "--popover-mobile-size": "calc(100dvw - 1rem)",
      width: {
        base: "min(var(--popover-mobile-size), var(--popover-size))",
        sm: "var(--popover-size)"
      },
      borderRadius: "l3",
      "--popover-z-index": "zIndex.popover",
      zIndex: "calc(var(--popover-z-index) + var(--layer-index, 0))",
      outline: "0",
      transformOrigin: "var(--transform-origin)",
      maxHeight: "var(--available-height)",
      _open: {
        animationStyle: "scale-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "scale-fade-out",
        animationDuration: "faster"
      }
    },
    header: {
      paddingInline: "var(--popover-padding)",
      paddingTop: "var(--popover-padding)"
    },
    body: {
      padding: "var(--popover-padding)",
      flex: "1"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      paddingInline: "var(--popover-padding)",
      paddingBottom: "var(--popover-padding)"
    },
    arrow: {
      "--arrow-size": "sizes.3",
      "--arrow-background": "var(--popover-bg)"
    },
    arrowTip: {
      borderTopWidth: "1px",
      borderInlineStartWidth: "1px"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          "--popover-padding": "spacing.3"
        }
      },
      sm: {
        content: {
          "--popover-padding": "spacing.4"
        }
      },
      md: {
        content: {
          "--popover-padding": "spacing.5"
        }
      },
      lg: {
        content: {
          "--popover-padding": "spacing.6"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/progress.js
var progressSlotRecipe = defineSlotRecipe({
  slots: anatomy19.keys(),
  className: "chakra-progress",
  base: {
    root: {
      textStyle: "sm",
      position: "relative"
    },
    track: {
      overflow: "hidden",
      position: "relative"
    },
    range: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transitionProperty: "width, height",
      transitionDuration: "slow",
      height: "100%",
      bgColor: "var(--track-color)",
      _indeterminate: {
        "--animate-from-x": "-40%",
        "--animate-to-x": "100%",
        position: "absolute",
        willChange: "left",
        minWidth: "50%",
        animation: "position 1s ease infinite normal none running",
        backgroundImage: `linear-gradient(to right, transparent 0%, var(--track-color) 50%, transparent 100%)`
      }
    },
    label: {
      display: "inline-flex",
      fontWeight: "medium",
      alignItems: "center",
      gap: "1"
    },
    valueText: {
      textStyle: "xs",
      lineHeight: "1",
      fontWeight: "medium"
    }
  },
  variants: {
    variant: {
      outline: {
        track: {
          shadow: "inset",
          bgColor: "bg.muted"
        },
        range: {
          bgColor: "colorPalette.solid"
        }
      },
      subtle: {
        track: {
          bgColor: "colorPalette.muted"
        },
        range: {
          bgColor: "colorPalette.solid/72"
        }
      }
    },
    shape: {
      square: {},
      rounded: {
        track: {
          borderRadius: "l1"
        }
      },
      full: {
        track: {
          borderRadius: "full"
        }
      }
    },
    striped: {
      true: {
        range: {
          backgroundImage: `linear-gradient(45deg, var(--stripe-color) 25%, transparent 25%, transparent 50%, var(--stripe-color) 50%, var(--stripe-color) 75%, transparent 75%, transparent)`,
          backgroundSize: `var(--stripe-size) var(--stripe-size)`,
          "--stripe-size": "1rem",
          "--stripe-color": {
            _light: "rgba(255, 255, 255, 0.3)",
            _dark: "rgba(0, 0, 0, 0.3)"
          }
        }
      }
    },
    animated: {
      true: {
        range: {
          "--animate-from": "var(--stripe-size)",
          animation: "bg-position 1s linear infinite"
        }
      }
    },
    size: {
      xs: {
        track: { h: "1.5" }
      },
      sm: {
        track: { h: "2" }
      },
      md: {
        track: { h: "2.5" }
      },
      lg: {
        track: { h: "3" }
      },
      xl: {
        track: { h: "4" }
      }
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md",
    shape: "rounded"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/progress-circle.js
var progressCircleSlotRecipe = defineSlotRecipe({
  className: "chakra-progress-circle",
  slots: anatomy19.keys(),
  base: {
    root: {
      display: "inline-flex",
      textStyle: "sm",
      position: "relative"
    },
    circle: {
      _indeterminate: {
        animation: "spin 2s linear infinite"
      }
    },
    circleTrack: {
      "--track-color": "colors.colorPalette.muted",
      stroke: "var(--track-color)"
    },
    circleRange: {
      stroke: "colorPalette.solid",
      transitionProperty: "stroke-dasharray",
      transitionDuration: "0.6s",
      _indeterminate: {
        animation: "circular-progress 1.5s linear infinite"
      }
    },
    label: {
      display: "inline-flex"
    },
    valueText: {
      lineHeight: "1",
      fontWeight: "medium",
      letterSpacing: "tight",
      fontVariantNumeric: "tabular-nums"
    }
  },
  variants: {
    size: {
      xs: {
        circle: {
          "--size": "24px",
          "--thickness": "4px"
        },
        valueText: {
          textStyle: "2xs"
        }
      },
      sm: {
        circle: {
          "--size": "32px",
          "--thickness": "5px"
        },
        valueText: {
          textStyle: "2xs"
        }
      },
      md: {
        circle: {
          "--size": "40px",
          "--thickness": "6px"
        },
        valueText: {
          textStyle: "xs"
        }
      },
      lg: {
        circle: {
          "--size": "48px",
          "--thickness": "7px"
        },
        valueText: {
          textStyle: "sm"
        }
      },
      xl: {
        circle: {
          "--size": "64px",
          "--thickness": "8px"
        },
        valueText: {
          textStyle: "sm"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/qr-code.js
var qrCodeSlotRecipe = defineSlotRecipe({
  slots: anatomy20.keys(),
  className: "chakra-qr-code",
  base: {
    root: {
      position: "relative",
      width: "fit-content",
      "--qr-code-overlay-size": "calc(var(--qr-code-size) / 3)"
    },
    frame: {
      width: "var(--qr-code-size)",
      height: "var(--qr-code-size)",
      fill: "currentColor"
    },
    overlay: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: "var(--qr-code-overlay-size)",
      height: "var(--qr-code-overlay-size)",
      padding: "1",
      bg: "bg",
      rounded: "l1"
    }
  },
  variants: {
    size: {
      "2xs": {
        root: { "--qr-code-size": "40px" }
      },
      xs: {
        root: { "--qr-code-size": "64px" }
      },
      sm: {
        root: { "--qr-code-size": "80px" }
      },
      md: {
        root: { "--qr-code-size": "120px" }
      },
      lg: {
        root: { "--qr-code-size": "160px" }
      },
      xl: {
        root: { "--qr-code-size": "200px" }
      },
      "2xl": {
        root: { "--qr-code-size": "240px" }
      },
      full: {
        root: { "--qr-code-size": "100%" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/radio-card.js
var _a5, _b5, _c4, _d4, _e5, _f4, _g4;
var radioCardSlotRecipe = defineSlotRecipe({
  className: "chakra-radio-card",
  slots: radioCardAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5",
      isolation: "isolate"
    },
    item: {
      flex: "1",
      display: "flex",
      flexDirection: "column",
      userSelect: "none",
      position: "relative",
      borderRadius: "l2",
      _focus: {
        bg: "colorPalette.muted/20"
      },
      _disabled: {
        opacity: "0.8",
        borderColor: "border.disabled"
      },
      _checked: {
        zIndex: "1"
      }
    },
    label: {
      display: "inline-flex",
      fontWeight: "medium",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    },
    itemText: {
      fontWeight: "medium",
      flex: "1"
    },
    itemDescription: {
      opacity: "0.64",
      textStyle: "sm"
    },
    itemControl: {
      display: "inline-flex",
      flex: "1",
      pos: "relative",
      rounded: "inherit",
      justifyContent: "var(--radio-card-justify)",
      alignItems: "var(--radio-card-align)",
      _disabled: {
        bg: "bg.muted"
      }
    },
    itemIndicator: radiomarkRecipe.base,
    itemAddon: {
      roundedBottom: "inherit",
      _disabled: {
        color: "fg.muted"
      }
    },
    itemContent: {
      display: "flex",
      flexDirection: "column",
      flex: "1",
      gap: "1",
      justifyContent: "var(--radio-card-justify)",
      alignItems: "var(--radio-card-align)"
    }
  },
  variants: {
    size: {
      sm: {
        item: {
          textStyle: "sm"
        },
        itemControl: {
          padding: "3",
          gap: "1.5"
        },
        itemAddon: {
          px: "3",
          py: "1.5",
          borderTopWidth: "1px"
        },
        itemIndicator: (_a5 = radiomarkRecipe.variants) == null ? void 0 : _a5.size.sm
      },
      md: {
        item: {
          textStyle: "sm"
        },
        itemControl: {
          padding: "4",
          gap: "2.5"
        },
        itemAddon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        itemIndicator: (_b5 = radiomarkRecipe.variants) == null ? void 0 : _b5.size.md
      },
      lg: {
        item: {
          textStyle: "md"
        },
        itemControl: {
          padding: "4",
          gap: "3.5"
        },
        itemAddon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        itemIndicator: (_c4 = radiomarkRecipe.variants) == null ? void 0 : _c4.size.lg
      }
    },
    variant: {
      surface: {
        item: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg",
            borderColor: "colorPalette.muted"
          }
        },
        itemIndicator: (_d4 = radiomarkRecipe.variants) == null ? void 0 : _d4.variant.solid
      },
      subtle: {
        item: {
          bg: "bg.muted"
        },
        itemControl: {
          _checked: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          }
        },
        itemIndicator: (_e5 = radiomarkRecipe.variants) == null ? void 0 : _e5.variant.outline
      },
      outline: {
        item: {
          borderWidth: "1px",
          _checked: {
            boxShadow: "0 0 0 1px var(--shadow-color)",
            boxShadowColor: "colorPalette.solid",
            borderColor: "colorPalette.solid"
          }
        },
        itemIndicator: (_f4 = radiomarkRecipe.variants) == null ? void 0 : _f4.variant.solid
      },
      solid: {
        item: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast",
            borderColor: "colorPalette.solid"
          }
        },
        itemIndicator: (_g4 = radiomarkRecipe.variants) == null ? void 0 : _g4.variant.inverted
      }
    },
    justify: {
      start: {
        item: { "--radio-card-justify": "flex-start" }
      },
      end: {
        item: { "--radio-card-justify": "flex-end" }
      },
      center: {
        item: { "--radio-card-justify": "center" }
      }
    },
    align: {
      start: {
        item: { "--radio-card-align": "flex-start" },
        itemControl: { textAlign: "start" }
      },
      end: {
        item: { "--radio-card-align": "flex-end" },
        itemControl: { textAlign: "end" }
      },
      center: {
        item: { "--radio-card-align": "center" },
        itemControl: { textAlign: "center" }
      }
    },
    orientation: {
      vertical: {
        itemControl: { flexDirection: "column" }
      },
      horizontal: {
        itemControl: { flexDirection: "row" }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    align: "start",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/radio-group.js
var _a6, _b6, _c5, _d5, _e6, _f5, _g5, _h3, _i3, _j3, _k3, _l3, _m3, _n3;
var radioGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-radio-group",
  slots: radioGroupAnatomy.keys(),
  base: {
    item: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative",
      fontWeight: "medium",
      _disabled: {
        cursor: "disabled"
      }
    },
    itemControl: radiomarkRecipe.base,
    label: {
      userSelect: "none",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        itemControl: (_b6 = (_a6 = radiomarkRecipe.variants) == null ? void 0 : _a6.variant) == null ? void 0 : _b6.outline
      },
      subtle: {
        itemControl: (_d5 = (_c5 = radiomarkRecipe.variants) == null ? void 0 : _c5.variant) == null ? void 0 : _d5.subtle
      },
      solid: {
        itemControl: (_f5 = (_e6 = radiomarkRecipe.variants) == null ? void 0 : _e6.variant) == null ? void 0 : _f5.solid
      }
    },
    size: {
      xs: {
        item: { textStyle: "xs", gap: "1.5" },
        itemControl: (_h3 = (_g5 = radiomarkRecipe.variants) == null ? void 0 : _g5.size) == null ? void 0 : _h3.xs
      },
      sm: {
        item: { textStyle: "sm", gap: "2" },
        itemControl: (_j3 = (_i3 = radiomarkRecipe.variants) == null ? void 0 : _i3.size) == null ? void 0 : _j3.sm
      },
      md: {
        item: { textStyle: "sm", gap: "2.5" },
        itemControl: (_l3 = (_k3 = radiomarkRecipe.variants) == null ? void 0 : _k3.size) == null ? void 0 : _l3.md
      },
      lg: {
        item: { textStyle: "md", gap: "3" },
        itemControl: (_n3 = (_m3 = radiomarkRecipe.variants) == null ? void 0 : _m3.size) == null ? void 0 : _n3.lg
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/rating-group.js
var ratingGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-rating-group",
  slots: ratingGroupAnatomy.keys(),
  base: {
    root: {
      display: "inline-flex"
    },
    control: {
      display: "inline-flex",
      alignItems: "center"
    },
    item: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none"
    },
    itemIndicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      width: "1em",
      height: "1em",
      position: "relative",
      _icon: {
        stroke: "currentColor",
        width: "100%",
        height: "100%",
        display: "inline-block",
        flexShrink: 0,
        position: "absolute",
        left: 0,
        top: 0
      },
      "& [data-bg]": {
        color: "bg.emphasized"
      },
      "& [data-fg]": {
        color: "transparent"
      },
      "&[data-highlighted]:not([data-half])": {
        "& [data-fg]": {
          color: "colorPalette.solid"
        }
      },
      "&[data-half]": {
        "& [data-fg]": {
          color: "colorPalette.solid",
          clipPath: "inset(0 50% 0 0)"
        }
      }
    }
  },
  variants: {
    size: {
      xs: {
        item: {
          textStyle: "sm"
        }
      },
      sm: {
        item: {
          textStyle: "md"
        }
      },
      md: {
        item: {
          textStyle: "xl"
        }
      },
      lg: {
        item: {
          textStyle: "2xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/segment-group.js
var segmentGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-segment-group",
  slots: segmentGroupAnatomy.keys(),
  base: {
    root: {
      "--segment-radius": "radii.l2",
      borderRadius: "l2",
      display: "inline-flex",
      boxShadow: "inset",
      minW: "max-content",
      textAlign: "center",
      position: "relative",
      isolation: "isolate",
      bg: "bg.muted"
    },
    item: {
      display: "flex",
      alignItems: "center",
      userSelect: "none",
      fontSize: "sm",
      position: "relative",
      color: "fg",
      borderRadius: "var(--segment-radius)",
      _disabled: {
        opacity: "0.5"
      },
      "&:has(input:focus-visible)": {
        focusRing: "outside"
      },
      _before: {
        content: '""',
        position: "absolute",
        insetInlineStart: 0,
        insetBlock: "1.5",
        bg: "border",
        width: "1px",
        transition: "opacity 0.2s"
      },
      "& + &[data-state=checked], &[data-state=checked] + &, &:first-of-type": {
        _before: {
          opacity: "0"
        }
      },
      "&[data-state=checked][data-ssr]": {
        shadow: "sm",
        bg: "bg",
        borderRadius: "var(--segment-radius)"
      }
    },
    indicator: {
      shadow: "sm",
      pos: "absolute",
      bg: { _light: "bg", _dark: "bg.emphasized" },
      width: "var(--width)",
      height: "var(--height)",
      top: "var(--top)",
      left: "var(--left)",
      zIndex: -1,
      borderRadius: "var(--segment-radius)"
    }
  },
  variants: {
    size: {
      xs: {
        root: {
          height: "6"
        },
        item: {
          textStyle: "xs",
          px: "3",
          gap: "1"
        }
      },
      sm: {
        root: {
          height: "8"
        },
        item: {
          textStyle: "sm",
          px: "4",
          gap: "2"
        }
      },
      md: {
        root: {
          height: "10"
        },
        item: {
          textStyle: "sm",
          px: "4",
          gap: "2"
        }
      },
      lg: {
        root: {
          height: "10"
        },
        item: {
          textStyle: "md",
          px: "5",
          gap: "3"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/slider.js
var sliderSlotRecipe = defineSlotRecipe({
  className: "chakra-slider",
  slots: sliderAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1",
      textStyle: "sm",
      position: "relative",
      isolation: "isolate",
      touchAction: "none"
    },
    label: {
      fontWeight: "medium",
      textStyle: "sm"
    },
    control: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative"
    },
    track: {
      overflow: "hidden",
      borderRadius: "full",
      flex: "1"
    },
    range: {
      width: "inherit",
      height: "inherit",
      _disabled: { bg: "border.emphasized!" }
    },
    markerGroup: {
      position: "absolute!",
      zIndex: "1"
    },
    marker: {
      "--marker-bg": { base: "white", _underValue: "colors.bg" },
      display: "flex",
      alignItems: "center",
      gap: "calc(var(--slider-thumb-size) / 2)",
      color: "fg.muted",
      textStyle: "xs"
    },
    markerIndicator: {
      width: "var(--slider-marker-size)",
      height: "var(--slider-marker-size)",
      borderRadius: "full",
      bg: "var(--marker-bg)"
    },
    thumb: {
      width: "var(--slider-thumb-size)",
      height: "var(--slider-thumb-size)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: 0,
      zIndex: "2",
      borderRadius: "full",
      _focusVisible: {
        ring: "2px",
        ringColor: "colorPalette.focusRing",
        ringOffset: "2px",
        ringOffsetColor: "bg"
      }
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          "--slider-thumb-size": "sizes.4",
          "--slider-track-size": "sizes.1.5",
          "--slider-marker-center": "6px",
          "--slider-marker-size": "sizes.1",
          "--slider-marker-inset": "3px"
        }
      },
      md: {
        root: {
          "--slider-thumb-size": "sizes.5",
          "--slider-track-size": "sizes.2",
          "--slider-marker-center": "8px",
          "--slider-marker-size": "sizes.1",
          "--slider-marker-inset": "4px"
        }
      },
      lg: {
        root: {
          "--slider-thumb-size": "sizes.6",
          "--slider-track-size": "sizes.2.5",
          "--slider-marker-center": "9px",
          "--slider-marker-size": "sizes.1.5",
          "--slider-marker-inset": "5px"
        }
      }
    },
    variant: {
      outline: {
        track: {
          shadow: "inset",
          bg: "bg.emphasized/72"
        },
        range: {
          bg: "colorPalette.solid"
        },
        thumb: {
          borderWidth: "2px",
          borderColor: "colorPalette.solid",
          bg: "bg",
          _disabled: {
            bg: "border.emphasized",
            borderColor: "border.emphasized"
          }
        }
      },
      solid: {
        track: {
          bg: "colorPalette.subtle",
          _disabled: {
            bg: "bg.muted"
          }
        },
        range: {
          bg: "colorPalette.solid"
        },
        thumb: {
          bg: "colorPalette.solid",
          _disabled: {
            bg: "border.emphasized"
          }
        }
      }
    },
    orientation: {
      vertical: {
        root: {
          display: "inline-flex"
        },
        control: {
          flexDirection: "column",
          height: "100%",
          minWidth: "var(--slider-thumb-size)",
          "&[data-has-mark-label], &:has(.chakra-slider__marker-label)": {
            marginEnd: "4"
          }
        },
        track: {
          width: "var(--slider-track-size)"
        },
        thumb: {
          left: "50%",
          translate: "-50% 0"
        },
        markerGroup: {
          insetStart: "var(--slider-marker-center)",
          insetBlock: "var(--slider-marker-inset)"
        },
        marker: {
          flexDirection: "row"
        }
      },
      horizontal: {
        control: {
          flexDirection: "row",
          width: "100%",
          minHeight: "var(--slider-thumb-size)",
          "&[data-has-mark-label], &:has(.chakra-slider__marker-label)": {
            marginBottom: "4"
          }
        },
        track: {
          height: "var(--slider-track-size)"
        },
        thumb: {
          top: "50%",
          translate: "0 -50%"
        },
        markerGroup: {
          top: "var(--slider-marker-center)",
          insetInline: "var(--slider-marker-inset)"
        },
        marker: {
          flexDirection: "column"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/stat.js
var statSlotRecipe = defineSlotRecipe({
  className: "chakra-stat",
  slots: statAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1",
      position: "relative",
      flex: "1"
    },
    label: {
      display: "inline-flex",
      gap: "1.5",
      alignItems: "center",
      color: "fg.muted",
      textStyle: "sm"
    },
    helpText: {
      color: "fg.muted",
      textStyle: "xs"
    },
    valueUnit: {
      color: "fg.muted",
      textStyle: "xs",
      fontWeight: "initial",
      letterSpacing: "initial"
    },
    valueText: {
      verticalAlign: "baseline",
      fontWeight: "semibold",
      letterSpacing: "tight",
      fontFeatureSettings: "pnum",
      fontVariantNumeric: "proportional-nums",
      display: "inline-flex",
      gap: "1"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      marginEnd: 1,
      "& :where(svg)": {
        w: "1em",
        h: "1em"
      },
      "&[data-type=up]": {
        color: "fg.success"
      },
      "&[data-type=down]": {
        color: "fg.error"
      }
    }
  },
  variants: {
    size: {
      sm: {
        valueText: {
          textStyle: "xl"
        }
      },
      md: {
        valueText: {
          textStyle: "2xl"
        }
      },
      lg: {
        valueText: {
          textStyle: "3xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/status.js
var statusSlotRecipe = defineSlotRecipe({
  className: "chakra-status",
  slots: statusAnatomy.keys(),
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      gap: "2"
    },
    indicator: {
      width: "0.64em",
      height: "0.64em",
      flexShrink: 0,
      borderRadius: "full",
      forcedColorAdjust: "none",
      bg: "colorPalette.solid"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/steps.js
var stepsSlotRecipe = defineSlotRecipe({
  className: "chakra-steps",
  slots: stepsAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      width: "full"
    },
    list: {
      display: "flex",
      justifyContent: "space-between",
      "--steps-gutter": "spacing.3",
      "--steps-thickness": "2px"
    },
    title: {
      fontWeight: "medium",
      color: "fg"
    },
    description: {
      color: "fg.muted"
    },
    separator: {
      bg: "border",
      flex: "1"
    },
    indicator: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      flexShrink: "0",
      borderRadius: "full",
      fontWeight: "medium",
      width: "var(--steps-size)",
      height: "var(--steps-size)",
      _icon: {
        flexShrink: "0",
        width: "var(--steps-icon-size)",
        height: "var(--steps-icon-size)"
      }
    },
    item: {
      position: "relative",
      display: "flex",
      flex: "1 0 0",
      "&:last-of-type": {
        flex: "initial",
        "& [data-part=separator]": {
          display: "none"
        }
      }
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      gap: "3",
      textAlign: "start",
      focusVisibleRing: "outside",
      borderRadius: "l2"
    },
    content: {
      focusVisibleRing: "outside"
    }
  },
  variants: {
    orientation: {
      vertical: {
        root: {
          flexDirection: "row",
          height: "100%"
        },
        list: {
          flexDirection: "column",
          alignItems: "flex-start"
        },
        separator: {
          position: "absolute",
          width: "var(--steps-thickness)",
          height: "100%",
          maxHeight: "calc(100% - var(--steps-size) - var(--steps-gutter) * 2)",
          top: "calc(var(--steps-size) + var(--steps-gutter))",
          insetStart: "calc(var(--steps-size) / 2 - 1px)"
        },
        item: {
          alignItems: "flex-start"
        }
      },
      horizontal: {
        root: {
          flexDirection: "column",
          width: "100%"
        },
        list: {
          flexDirection: "row",
          alignItems: "center"
        },
        separator: {
          width: "100%",
          height: "var(--steps-thickness)",
          marginX: "var(--steps-gutter)"
        },
        item: {
          alignItems: "center"
        }
      }
    },
    variant: {
      solid: {
        indicator: {
          _incomplete: {
            borderWidth: "var(--steps-thickness)"
          },
          _current: {
            bg: "colorPalette.muted",
            borderWidth: "var(--steps-thickness)",
            borderColor: "colorPalette.solid",
            color: "colorPalette.fg"
          },
          _complete: {
            bg: "colorPalette.solid",
            borderColor: "colorPalette.solid",
            color: "colorPalette.contrast"
          }
        },
        separator: {
          _complete: {
            bg: "colorPalette.solid"
          }
        }
      },
      subtle: {
        indicator: {
          _incomplete: {
            bg: "bg.muted"
          },
          _current: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          },
          _complete: {
            bg: "colorPalette.emphasized",
            color: "colorPalette.fg"
          }
        },
        separator: {
          _complete: {
            bg: "colorPalette.emphasized"
          }
        }
      }
    },
    size: {
      xs: {
        root: {
          gap: "2.5"
        },
        list: {
          "--steps-size": "sizes.6",
          "--steps-icon-size": "sizes.3.5",
          textStyle: "xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      sm: {
        root: {
          gap: "3"
        },
        list: {
          "--steps-size": "sizes.8",
          "--steps-icon-size": "sizes.4",
          textStyle: "xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      md: {
        root: {
          gap: "4"
        },
        list: {
          "--steps-size": "sizes.10",
          "--steps-icon-size": "sizes.4",
          textStyle: "sm"
        },
        title: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          gap: "6"
        },
        list: {
          "--steps-size": "sizes.11",
          "--steps-icon-size": "sizes.5",
          textStyle: "md"
        },
        title: {
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/switch.js
var switchSlotRecipe = defineSlotRecipe({
  slots: switchAnatomy.keys(),
  className: "chakra-switch",
  base: {
    root: {
      display: "inline-flex",
      gap: "2.5",
      alignItems: "center",
      position: "relative",
      verticalAlign: "middle",
      "--switch-diff": "calc(var(--switch-width) - var(--switch-height))",
      "--switch-x": {
        base: "var(--switch-diff)",
        _rtl: "calc(var(--switch-diff) * -1)"
      }
    },
    label: {
      lineHeight: "1",
      userSelect: "none",
      fontSize: "sm",
      fontWeight: "medium",
      _disabled: {
        opacity: "0.5"
      }
    },
    indicator: {
      position: "absolute",
      height: "var(--switch-height)",
      width: "var(--switch-height)",
      fontSize: "var(--switch-indicator-font-size)",
      fontWeight: "medium",
      flexShrink: 0,
      userSelect: "none",
      display: "grid",
      placeContent: "center",
      transition: "inset-inline-start 0.12s ease",
      insetInlineStart: "calc(var(--switch-x) - 2px)",
      _checked: {
        insetInlineStart: "2px"
      }
    },
    control: {
      display: "inline-flex",
      gap: "0.5rem",
      flexShrink: 0,
      justifyContent: "flex-start",
      cursor: "switch",
      borderRadius: "full",
      position: "relative",
      width: "var(--switch-width)",
      height: "var(--switch-height)",
      transition: "backgrounds",
      _disabled: {
        opacity: "0.5",
        cursor: "not-allowed"
      },
      _invalid: {
        outline: "2px solid",
        outlineColor: "border.error",
        outlineOffset: "2px"
      }
    },
    thumb: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0,
      transitionProperty: "translate",
      transitionDuration: "fast",
      borderRadius: "inherit",
      _checked: {
        translate: "var(--switch-x) 0"
      }
    }
  },
  variants: {
    variant: {
      solid: {
        control: {
          borderRadius: "full",
          bg: "bg.emphasized",
          focusVisibleRing: "outside",
          _checked: {
            bg: "colorPalette.solid"
          }
        },
        thumb: {
          bg: "white",
          width: "var(--switch-height)",
          height: "var(--switch-height)",
          scale: "0.8",
          boxShadow: "sm",
          _checked: {
            bg: "colorPalette.contrast"
          }
        }
      },
      raised: {
        control: {
          borderRadius: "full",
          height: "calc(var(--switch-height) / 2)",
          bg: "bg.muted",
          boxShadow: "inset",
          _checked: {
            bg: "colorPalette.solid/60"
          }
        },
        thumb: {
          width: "var(--switch-height)",
          height: "var(--switch-height)",
          position: "relative",
          top: "calc(var(--switch-height) * -0.25)",
          bg: "white",
          boxShadow: "xs",
          focusVisibleRing: "outside",
          _checked: {
            bg: "colorPalette.solid"
          }
        }
      }
    },
    size: {
      xs: {
        root: {
          "--switch-width": "sizes.6",
          "--switch-height": "sizes.3",
          "--switch-indicator-font-size": "fontSizes.xs"
        }
      },
      sm: {
        root: {
          "--switch-width": "sizes.8",
          "--switch-height": "sizes.4",
          "--switch-indicator-font-size": "fontSizes.xs"
        }
      },
      md: {
        root: {
          "--switch-width": "sizes.10",
          "--switch-height": "sizes.5",
          "--switch-indicator-font-size": "fontSizes.sm"
        }
      },
      lg: {
        root: {
          "--switch-width": "sizes.12",
          "--switch-height": "sizes.6",
          "--switch-indicator-font-size": "fontSizes.md"
        }
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/table.js
var tableSlotRecipe = defineSlotRecipe({
  className: "chakra-table",
  slots: tableAnatomy.keys(),
  base: {
    root: {
      fontVariantNumeric: "lining-nums tabular-nums",
      borderCollapse: "collapse",
      width: "full",
      textAlign: "start",
      verticalAlign: "top"
    },
    row: {
      _selected: {
        bg: "colorPalette.subtle"
      }
    },
    cell: {
      textAlign: "start",
      alignItems: "center"
    },
    columnHeader: {
      fontWeight: "medium",
      textAlign: "start",
      color: "fg"
    },
    caption: {
      fontWeight: "medium",
      textStyle: "xs"
    },
    footer: {
      fontWeight: "medium"
    }
  },
  variants: {
    interactive: {
      true: {
        body: {
          "& tr": {
            _hover: {
              bg: "colorPalette.subtle"
            }
          }
        }
      }
    },
    stickyHeader: {
      true: {
        header: {
          "& :where(tr)": {
            top: "var(--table-sticky-offset, 0)",
            position: "sticky",
            zIndex: 1
          }
        }
      }
    },
    striped: {
      true: {
        row: {
          "&:nth-of-type(odd) td": {
            bg: "bg.muted"
          }
        }
      }
    },
    showColumnBorder: {
      true: {
        columnHeader: {
          "&:not(:last-of-type)": {
            borderInlineEndWidth: "1px"
          }
        },
        cell: {
          "&:not(:last-of-type)": {
            borderInlineEndWidth: "1px"
          }
        }
      }
    },
    variant: {
      line: {
        columnHeader: {
          borderBottomWidth: "1px"
        },
        cell: {
          borderBottomWidth: "1px"
        },
        row: {
          bg: "bg"
        }
      },
      outline: {
        root: {
          boxShadow: "0 0 0 1px {colors.border}",
          overflow: "hidden"
        },
        columnHeader: {
          borderBottomWidth: "1px"
        },
        header: {
          bg: "bg.muted"
        },
        row: {
          "&:not(:last-of-type)": {
            borderBottomWidth: "1px"
          }
        },
        footer: {
          borderTopWidth: "1px"
        }
      }
    },
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        columnHeader: {
          px: "2",
          py: "2"
        },
        cell: {
          px: "2",
          py: "2"
        }
      },
      md: {
        root: {
          textStyle: "sm"
        },
        columnHeader: {
          px: "3",
          py: "3"
        },
        cell: {
          px: "3",
          py: "3"
        }
      },
      lg: {
        root: {
          textStyle: "md"
        },
        columnHeader: {
          px: "4",
          py: "3"
        },
        cell: {
          px: "4",
          py: "3"
        }
      }
    }
  },
  defaultVariants: {
    variant: "line",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/tabs.js
var tabsSlotRecipe = defineSlotRecipe({
  slots: tabsAnatomy.keys(),
  className: "chakra-tabs",
  base: {
    root: {
      "--tabs-trigger-radius": "radii.l2",
      position: "relative",
      _horizontal: {
        display: "block"
      },
      _vertical: {
        display: "flex"
      }
    },
    list: {
      display: "inline-flex",
      position: "relative",
      isolation: "isolate",
      "--tabs-indicator-shadow": "shadows.xs",
      "--tabs-indicator-bg": "colors.bg",
      minH: "var(--tabs-height)",
      _horizontal: {
        flexDirection: "row"
      },
      _vertical: {
        flexDirection: "column"
      }
    },
    trigger: {
      outline: "0",
      minW: "var(--tabs-height)",
      height: "var(--tabs-height)",
      display: "flex",
      alignItems: "center",
      fontWeight: "medium",
      position: "relative",
      cursor: "button",
      gap: "2",
      _focusVisible: {
        zIndex: 1,
        outline: "2px solid",
        outlineColor: "colorPalette.focusRing"
      },
      _disabled: {
        cursor: "not-allowed",
        opacity: 0.5
      }
    },
    content: {
      focusVisibleRing: "inside",
      _horizontal: {
        width: "100%",
        pt: "var(--tabs-content-padding)"
      },
      _vertical: {
        height: "100%",
        ps: "var(--tabs-content-padding)"
      }
    },
    indicator: {
      width: "var(--width)",
      height: "var(--height)",
      borderRadius: "var(--tabs-indicator-radius)",
      bg: "var(--tabs-indicator-bg)",
      shadow: "var(--tabs-indicator-shadow)",
      zIndex: -1
    }
  },
  variants: {
    fitted: {
      true: {
        list: {
          display: "flex"
        },
        trigger: {
          flex: 1,
          textAlign: "center",
          justifyContent: "center"
        }
      }
    },
    justify: {
      start: {
        list: {
          justifyContent: "flex-start"
        }
      },
      center: {
        list: {
          justifyContent: "center"
        }
      },
      end: {
        list: {
          justifyContent: "flex-end"
        }
      }
    },
    size: {
      sm: {
        root: {
          "--tabs-height": "sizes.9",
          "--tabs-content-padding": "spacing.3"
        },
        trigger: {
          py: "1",
          px: "3",
          textStyle: "sm"
        }
      },
      md: {
        root: {
          "--tabs-height": "sizes.10",
          "--tabs-content-padding": "spacing.4"
        },
        trigger: {
          py: "2",
          px: "4",
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          "--tabs-height": "sizes.11",
          "--tabs-content-padding": "spacing.4.5"
        },
        trigger: {
          py: "2",
          px: "4.5",
          textStyle: "md"
        }
      }
    },
    variant: {
      line: {
        list: {
          display: "flex",
          borderColor: "border",
          _horizontal: {
            borderBottomWidth: "1px"
          },
          _vertical: {
            borderEndWidth: "1px"
          }
        },
        trigger: {
          color: "fg.muted",
          _disabled: {
            _active: { bg: "initial" }
          },
          _selected: {
            color: "fg",
            _horizontal: {
              layerStyle: "indicator.bottom",
              "--indicator-offset-y": "-1px",
              "--indicator-color": "colors.colorPalette.solid"
            },
            _vertical: {
              layerStyle: "indicator.end",
              "--indicator-offset-x": "-1px"
            }
          }
        }
      },
      subtle: {
        trigger: {
          borderRadius: "var(--tabs-trigger-radius)",
          color: "fg.muted",
          _selected: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg"
          }
        }
      },
      enclosed: {
        list: {
          bg: "bg.muted",
          padding: "1",
          borderRadius: "l3",
          minH: "calc(var(--tabs-height) - 4px)"
        },
        trigger: {
          justifyContent: "center",
          color: "fg.muted",
          borderRadius: "var(--tabs-trigger-radius)",
          _selected: {
            bg: "bg",
            color: "colorPalette.fg",
            shadow: "xs"
          }
        }
      },
      outline: {
        list: {
          "--line-thickness": "1px",
          "--line-offset": "calc(var(--line-thickness) * -1)",
          borderColor: "border",
          display: "flex",
          _horizontal: {
            _before: {
              content: '""',
              position: "absolute",
              bottom: "0px",
              width: "100%",
              borderBottomWidth: "var(--line-thickness)",
              borderBottomColor: "border"
            }
          },
          _vertical: {
            _before: {
              content: '""',
              position: "absolute",
              insetInline: "var(--line-offset)",
              height: "calc(100% - calc(var(--line-thickness) * 2))",
              borderEndWidth: "var(--line-thickness)",
              borderEndColor: "border"
            }
          }
        },
        trigger: {
          color: "fg.muted",
          borderWidth: "1px",
          borderColor: "transparent",
          _selected: {
            bg: "currentBg",
            color: "colorPalette.fg"
          },
          _horizontal: {
            borderTopRadius: "var(--tabs-trigger-radius)",
            marginBottom: "var(--line-offset)",
            marginEnd: { _notLast: "var(--line-offset)" },
            _selected: {
              borderColor: "border",
              borderBottomColor: "transparent"
            }
          },
          _vertical: {
            borderStartRadius: "var(--tabs-trigger-radius)",
            marginEnd: "var(--line-offset)",
            marginBottom: { _notLast: "var(--line-offset)" },
            _selected: {
              borderColor: "border",
              borderEndColor: "transparent"
            }
          }
        }
      },
      plain: {
        trigger: {
          color: "fg.muted",
          _selected: {
            color: "colorPalette.fg"
          },
          borderRadius: "var(--tabs-trigger-radius)",
          "&[data-selected][data-ssr]": {
            bg: "var(--tabs-indicator-bg)",
            shadow: "var(--tabs-indicator-shadow)",
            borderRadius: "var(--tabs-indicator-radius)"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "line"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/tag.js
var _a7;
var badgeVariant = (_a7 = badgeRecipe.variants) == null ? void 0 : _a7.variant;
var tagSlotRecipe = defineSlotRecipe({
  slots: tagAnatomy.keys(),
  className: "chakra-tag",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      verticalAlign: "top",
      maxWidth: "100%",
      userSelect: "none",
      borderRadius: "l2",
      focusVisibleRing: "outside"
    },
    label: {
      lineClamp: "1"
    },
    closeTrigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: "0",
      borderRadius: "l1",
      color: "currentColor",
      focusVisibleRing: "inside",
      focusRingWidth: "2px"
    },
    startElement: {
      flexShrink: 0,
      boxSize: "var(--tag-element-size)",
      ms: "var(--tag-element-offset)",
      "&:has([data-scope=avatar])": {
        boxSize: "var(--tag-avatar-size)",
        ms: "calc(var(--tag-element-offset) * 1.5)"
      },
      _icon: { boxSize: "100%" }
    },
    endElement: {
      flexShrink: 0,
      boxSize: "var(--tag-element-size)",
      me: "var(--tag-element-offset)",
      _icon: { boxSize: "100%" },
      "&:has(button)": {
        ms: "calc(var(--tag-element-offset) * -1)"
      }
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          px: "1.5",
          minH: "4.5",
          gap: "1",
          "--tag-avatar-size": "spacing.3",
          "--tag-element-size": "spacing.3",
          "--tag-element-offset": "-2px"
        },
        label: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          px: "1.5",
          minH: "5",
          gap: "1",
          "--tag-avatar-size": "spacing.3.5",
          "--tag-element-size": "spacing.3.5",
          "--tag-element-offset": "-2px"
        },
        label: {
          textStyle: "xs"
        }
      },
      lg: {
        root: {
          px: "2",
          minH: "6",
          gap: "1.5",
          "--tag-avatar-size": "spacing.4.5",
          "--tag-element-size": "spacing.4",
          "--tag-element-offset": "-3px"
        },
        label: {
          textStyle: "sm"
        }
      },
      xl: {
        root: {
          px: "2.5",
          minH: "8",
          gap: "1.5",
          "--tag-avatar-size": "spacing.6",
          "--tag-element-size": "spacing.4.5",
          "--tag-element-offset": "-4px"
        },
        label: {
          textStyle: "sm"
        }
      }
    },
    variant: {
      subtle: {
        root: badgeVariant == null ? void 0 : badgeVariant.subtle
      },
      solid: {
        root: badgeVariant == null ? void 0 : badgeVariant.solid
      },
      outline: {
        root: badgeVariant == null ? void 0 : badgeVariant.outline
      },
      surface: {
        root: badgeVariant == null ? void 0 : badgeVariant.surface
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "surface"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/timeline.js
var timelineSlotRecipe = defineSlotRecipe({
  slots: timelineAnatomy.keys(),
  className: "chakra-timeline",
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      width: "full",
      "--timeline-thickness": "1px",
      "--timeline-gutter": "4px"
    },
    item: {
      display: "flex",
      position: "relative",
      alignItems: "flex-start",
      flexShrink: 0,
      gap: "4",
      _last: {
        "& :where(.chakra-timeline__separator)": { display: "none" }
      }
    },
    separator: {
      position: "absolute",
      borderStartWidth: "var(--timeline-thickness)",
      ms: "calc(-1 * var(--timeline-thickness) / 2)",
      insetInlineStart: "calc(var(--timeline-indicator-size) / 2)",
      insetBlock: "0",
      borderColor: "border"
    },
    indicator: {
      outline: "2px solid {colors.bg}",
      position: "relative",
      flexShrink: "0",
      boxSize: "var(--timeline-indicator-size)",
      fontSize: "var(--timeline-font-size)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      borderRadius: "full",
      fontWeight: "medium"
    },
    connector: {
      alignSelf: "stretch",
      position: "relative"
    },
    content: {
      pb: "6",
      display: "flex",
      flexDirection: "column",
      width: "full",
      gap: "2"
    },
    title: {
      display: "flex",
      fontWeight: "medium",
      flexWrap: "wrap",
      gap: "1.5",
      alignItems: "center",
      mt: "var(--timeline-margin)"
    },
    description: {
      color: "fg.muted",
      textStyle: "xs"
    }
  },
  variants: {
    variant: {
      subtle: {
        indicator: {
          bg: "colorPalette.muted"
        }
      },
      solid: {
        indicator: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        }
      },
      outline: {
        indicator: {
          bg: "currentBg",
          borderWidth: "1px",
          borderColor: "colorPalette.muted"
        }
      },
      plain: {}
    },
    size: {
      sm: {
        root: {
          "--timeline-indicator-size": "sizes.4",
          "--timeline-font-size": "fontSizes.2xs"
        },
        title: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          "--timeline-indicator-size": "sizes.5",
          "--timeline-font-size": "fontSizes.xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          "--timeline-indicator-size": "sizes.6",
          "--timeline-font-size": "fontSizes.xs"
        },
        title: {
          mt: "0.5",
          textStyle: "sm"
        }
      },
      xl: {
        root: {
          "--timeline-indicator-size": "sizes.8",
          "--timeline-font-size": "fontSizes.sm"
        },
        title: {
          mt: "1.5",
          textStyle: "sm"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/toast.js
var toastSlotRecipe = defineSlotRecipe({
  slots: toastAnatomy.keys(),
  className: "chakra-toast",
  base: {
    root: {
      width: "full",
      display: "flex",
      alignItems: "flex-start",
      position: "relative",
      gap: "3",
      py: "4",
      ps: "4",
      pe: "6",
      borderRadius: "l2",
      translate: "var(--x) var(--y)",
      scale: "var(--scale)",
      zIndex: "var(--z-index)",
      height: "var(--height)",
      opacity: "var(--opacity)",
      willChange: "translate, opacity, scale",
      transition: "translate 400ms, scale 400ms, opacity 400ms, height 400ms, box-shadow 200ms",
      transitionTimingFunction: "cubic-bezier(0.21, 1.02, 0.73, 1)",
      _closed: {
        transition: "translate 400ms, scale 400ms, opacity 200ms",
        transitionTimingFunction: "cubic-bezier(0.06, 0.71, 0.55, 1)"
      },
      bg: "bg.panel",
      color: "fg",
      boxShadow: "xl",
      "--toast-trigger-bg": "colors.bg.muted",
      "&[data-type=warning]": {
        bg: "orange.solid",
        color: "orange.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      },
      "&[data-type=success]": {
        bg: "green.solid",
        color: "green.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      },
      "&[data-type=error]": {
        bg: "red.solid",
        color: "red.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      }
    },
    title: {
      fontWeight: "medium",
      textStyle: "sm",
      marginEnd: "2"
    },
    description: {
      display: "inline",
      textStyle: "sm",
      opacity: "0.8"
    },
    indicator: {
      flexShrink: "0",
      boxSize: "5"
    },
    actionTrigger: {
      textStyle: "sm",
      fontWeight: "medium",
      height: "8",
      px: "3",
      borderRadius: "l2",
      alignSelf: "center",
      borderWidth: "1px",
      borderColor: "var(--toast-border-color, inherit)",
      transition: "background 200ms",
      _hover: {
        bg: "var(--toast-trigger-bg)"
      }
    },
    closeTrigger: {
      position: "absolute",
      top: "1",
      insetEnd: "1",
      padding: "1",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      color: "{currentColor/60}",
      borderRadius: "l2",
      textStyle: "md",
      transition: "background 200ms",
      _icon: {
        boxSize: "1em"
      }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/tooltip.js
var tooltipSlotRecipe = defineSlotRecipe({
  slots: anatomy35.keys(),
  className: "chakra-tooltip",
  base: {
    content: {
      "--tooltip-bg": "colors.bg.inverted",
      bg: "var(--tooltip-bg)",
      color: "fg.inverted",
      px: "2.5",
      py: "1",
      borderRadius: "l2",
      fontWeight: "medium",
      textStyle: "xs",
      boxShadow: "md",
      maxW: "xs",
      zIndex: "tooltip",
      transformOrigin: "var(--transform-origin)",
      _open: {
        animationStyle: "scale-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "scale-fade-out",
        animationDuration: "fast"
      }
    },
    arrow: {
      "--arrow-size": "sizes.2",
      "--arrow-background": "var(--tooltip-bg)"
    },
    arrowTip: {
      borderTopWidth: "1px",
      borderInlineStartWidth: "1px",
      borderColor: "var(--tooltip-bg)"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/slot-recipes.js
var slotRecipes = {
  accordion: accordionSlotRecipe,
  actionBar: actionBarSlotRecipe,
  alert: alertSlotRecipe,
  avatar: avatarSlotRecipe,
  blockquote: blockquoteSlotRecipe,
  breadcrumb: breadcrumbSlotRecipe,
  card: cardSlotRecipe,
  checkbox: checkboxSlotRecipe,
  checkboxCard: checkboxCardSlotRecipe,
  collapsible: collapsibleSlotRecipe,
  dataList: dataListSlotRecipe,
  dialog: dialogSlotRecipe,
  drawer: drawerSlotRecipe,
  editable: editableSlotRecipe,
  emptyState: emptyStateSlotRecipe,
  field: fieldSlotRecipe,
  fieldset: fieldsetSlotRecipe,
  fileUpload: fileUploadSlotRecipe,
  hoverCard: hoverCardSlotRecipe,
  list: listSlotRecipe,
  menu: menuSlotRecipe,
  nativeSelect: nativeSelectSlotRecipe,
  numberInput: numberInputSlotRecipe,
  pinInput: pinInputSlotRecipe,
  popover: popoverSlotRecipe,
  progress: progressSlotRecipe,
  progressCircle: progressCircleSlotRecipe,
  radioCard: radioCardSlotRecipe,
  radioGroup: radioGroupSlotRecipe,
  ratingGroup: ratingGroupSlotRecipe,
  segmentGroup: segmentGroupSlotRecipe,
  select: selectSlotRecipe,
  slider: sliderSlotRecipe,
  stat: statSlotRecipe,
  steps: stepsSlotRecipe,
  switch: switchSlotRecipe,
  table: tableSlotRecipe,
  tabs: tabsSlotRecipe,
  tag: tagSlotRecipe,
  toast: toastSlotRecipe,
  tooltip: tooltipSlotRecipe,
  status: statusSlotRecipe,
  timeline: timelineSlotRecipe,
  colorPicker: colorPickerSlotRecipe,
  qrCode: qrCodeSlotRecipe
};

// node_modules/@chakra-ui/react/dist/esm/theme/text-styles.js
var textStyles = defineTextStyles({
  "2xs": { value: { fontSize: "2xs", lineHeight: "0.75rem" } },
  xs: { value: { fontSize: "xs", lineHeight: "1rem" } },
  sm: { value: { fontSize: "sm", lineHeight: "1.25rem" } },
  md: { value: { fontSize: "md", lineHeight: "1.5rem" } },
  lg: { value: { fontSize: "lg", lineHeight: "1.75rem" } },
  xl: { value: { fontSize: "xl", lineHeight: "1.875rem" } },
  "2xl": { value: { fontSize: "2xl", lineHeight: "2rem" } },
  "3xl": { value: { fontSize: "3xl", lineHeight: "2.375rem" } },
  "4xl": {
    value: {
      fontSize: "4xl",
      lineHeight: "2.75rem",
      letterSpacing: "-0.025em"
    }
  },
  "5xl": {
    value: {
      fontSize: "5xl",
      lineHeight: "3.75rem",
      letterSpacing: "-0.025em"
    }
  },
  "6xl": {
    value: { fontSize: "6xl", lineHeight: "4.5rem", letterSpacing: "-0.025em" }
  },
  "7xl": {
    value: {
      fontSize: "7xl",
      lineHeight: "5.75rem",
      letterSpacing: "-0.025em"
    }
  },
  none: {
    value: {}
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/animations.js
var animations = defineTokens.animations({
  spin: { value: "spin 1s linear infinite" },
  ping: { value: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite" },
  pulse: { value: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite" },
  bounce: { value: "bounce 1s infinite" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/aspect-ratios.js
var aspectRatios = defineTokens.aspectRatios({
  square: { value: "1 / 1" },
  landscape: { value: "4 / 3" },
  portrait: { value: "3 / 4" },
  wide: { value: "16 / 9" },
  ultrawide: { value: "18 / 5" },
  golden: { value: "1.618 / 1" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/blurs.js
var blurs = defineTokens.blurs({
  none: { value: " " },
  sm: { value: "4px" },
  md: { value: "8px" },
  lg: { value: "12px" },
  xl: { value: "16px" },
  "2xl": { value: "24px" },
  "3xl": { value: "40px" },
  "4xl": { value: "64px" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/borders.js
var borders = defineTokens.borders({
  xs: { value: "0.5px solid" },
  sm: { value: "1px solid" },
  md: { value: "2px solid" },
  lg: { value: "4px solid" },
  xl: { value: "8px solid" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/colors.js
var colors = defineTokens.colors({
  transparent: { value: "transparent" },
  current: { value: "currentColor" },
  black: { value: "#09090B" },
  white: { value: "#FFFFFF" },
  whiteAlpha: {
    50: { value: "rgba(255, 255, 255, 0.04)" },
    100: { value: "rgba(255, 255, 255, 0.06)" },
    200: { value: "rgba(255, 255, 255, 0.08)" },
    300: { value: "rgba(255, 255, 255, 0.16)" },
    400: { value: "rgba(255, 255, 255, 0.24)" },
    500: { value: "rgba(255, 255, 255, 0.36)" },
    600: { value: "rgba(255, 255, 255, 0.48)" },
    700: { value: "rgba(255, 255, 255, 0.64)" },
    800: { value: "rgba(255, 255, 255, 0.80)" },
    900: { value: "rgba(255, 255, 255, 0.92)" },
    950: { value: "rgba(255, 255, 255, 0.95)" }
  },
  blackAlpha: {
    50: { value: "rgba(0, 0, 0, 0.04)" },
    100: { value: "rgba(0, 0, 0, 0.06)" },
    200: { value: "rgba(0, 0, 0, 0.08)" },
    300: { value: "rgba(0, 0, 0, 0.16)" },
    400: { value: "rgba(0, 0, 0, 0.24)" },
    500: { value: "rgba(0, 0, 0, 0.36)" },
    600: { value: "rgba(0, 0, 0, 0.48)" },
    700: { value: "rgba(0, 0, 0, 0.64)" },
    800: { value: "rgba(0, 0, 0, 0.80)" },
    900: { value: "rgba(0, 0, 0, 0.92)" },
    950: { value: "rgba(0, 0, 0, 0.95)" }
  },
  gray: {
    50: { value: "#fafafa" },
    100: { value: "#f4f4f5" },
    200: { value: "#e4e4e7" },
    300: { value: "#d4d4d8" },
    400: { value: "#a1a1aa" },
    500: { value: "#71717a" },
    600: { value: "#52525b" },
    700: { value: "#3f3f46" },
    800: { value: "#27272a" },
    900: { value: "#18181b" },
    950: { value: "#111111" }
  },
  red: {
    50: { value: "#fef2f2" },
    100: { value: "#fee2e2" },
    200: { value: "#fecaca" },
    300: { value: "#fca5a5" },
    400: { value: "#f87171" },
    500: { value: "#ef4444" },
    600: { value: "#dc2626" },
    700: { value: "#991919" },
    800: { value: "#511111" },
    900: { value: "#300c0c" },
    950: { value: "#1f0808" }
  },
  orange: {
    50: { value: "#fff7ed" },
    100: { value: "#ffedd5" },
    200: { value: "#fed7aa" },
    300: { value: "#fdba74" },
    400: { value: "#fb923c" },
    500: { value: "#f97316" },
    600: { value: "#ea580c" },
    700: { value: "#92310a" },
    800: { value: "#6c2710" },
    900: { value: "#3b1106" },
    950: { value: "#220a04" }
  },
  yellow: {
    50: { value: "#fefce8" },
    100: { value: "#fef9c3" },
    200: { value: "#fef08a" },
    300: { value: "#fde047" },
    400: { value: "#facc15" },
    500: { value: "#eab308" },
    600: { value: "#ca8a04" },
    700: { value: "#845209" },
    800: { value: "#713f12" },
    900: { value: "#422006" },
    950: { value: "#281304" }
  },
  green: {
    50: { value: "#f0fdf4" },
    100: { value: "#dcfce7" },
    200: { value: "#bbf7d0" },
    300: { value: "#86efac" },
    400: { value: "#4ade80" },
    500: { value: "#22c55e" },
    600: { value: "#16a34a" },
    700: { value: "#116932" },
    800: { value: "#124a28" },
    900: { value: "#042713" },
    950: { value: "#03190c" }
  },
  teal: {
    50: { value: "#f0fdfa" },
    100: { value: "#ccfbf1" },
    200: { value: "#99f6e4" },
    300: { value: "#5eead4" },
    400: { value: "#2dd4bf" },
    500: { value: "#14b8a6" },
    600: { value: "#0d9488" },
    700: { value: "#0c5d56" },
    800: { value: "#114240" },
    900: { value: "#032726" },
    950: { value: "#021716" }
  },
  blue: {
    50: { value: "#eff6ff" },
    100: { value: "#dbeafe" },
    200: { value: "#bfdbfe" },
    300: { value: "#a3cfff" },
    400: { value: "#60a5fa" },
    500: { value: "#3b82f6" },
    600: { value: "#2563eb" },
    700: { value: "#173da6" },
    800: { value: "#1a3478" },
    900: { value: "#14204a" },
    950: { value: "#0c142e" }
  },
  cyan: {
    50: { value: "#ecfeff" },
    100: { value: "#cffafe" },
    200: { value: "#a5f3fc" },
    300: { value: "#67e8f9" },
    400: { value: "#22d3ee" },
    500: { value: "#06b6d4" },
    600: { value: "#0891b2" },
    700: { value: "#0c5c72" },
    800: { value: "#134152" },
    900: { value: "#072a38" },
    950: { value: "#051b24" }
  },
  purple: {
    50: { value: "#faf5ff" },
    100: { value: "#f3e8ff" },
    200: { value: "#e9d5ff" },
    300: { value: "#d8b4fe" },
    400: { value: "#c084fc" },
    500: { value: "#a855f7" },
    600: { value: "#9333ea" },
    700: { value: "#641ba3" },
    800: { value: "#4a1772" },
    900: { value: "#2f0553" },
    950: { value: "#1a032e" }
  },
  pink: {
    50: { value: "#fdf2f8" },
    100: { value: "#fce7f3" },
    200: { value: "#fbcfe8" },
    300: { value: "#f9a8d4" },
    400: { value: "#f472b6" },
    500: { value: "#ec4899" },
    600: { value: "#db2777" },
    700: { value: "#a41752" },
    800: { value: "#6d0e34" },
    900: { value: "#45061f" },
    950: { value: "#2c0514" }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/cursor.js
var cursor2 = defineTokens.cursor({
  button: { value: "pointer" },
  checkbox: { value: "default" },
  disabled: { value: "not-allowed" },
  menuitem: { value: "default" },
  option: { value: "default" },
  radio: { value: "default" },
  slider: { value: "default" },
  switch: { value: "pointer" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/durations.js
var durations = defineTokens.durations({
  fastest: { value: "50ms" },
  faster: { value: "100ms" },
  fast: { value: "150ms" },
  moderate: { value: "200ms" },
  slow: { value: "300ms" },
  slower: { value: "400ms" },
  slowest: { value: "500ms" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/easings.js
var easings = defineTokens.easings({
  "ease-in": { value: "cubic-bezier(0.42, 0, 1, 1)" },
  "ease-out": { value: "cubic-bezier(0, 0, 0.58, 1)" },
  "ease-in-out": { value: "cubic-bezier(0.42, 0, 0.58, 1)" },
  "ease-in-smooth": { value: "cubic-bezier(0.32, 0.72, 0, 1)" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/font-sizes.js
var fontSizes = defineTokens.fontSizes({
  "2xs": { value: "0.625rem" },
  xs: { value: "0.75rem" },
  sm: { value: "0.875rem" },
  md: { value: "1rem" },
  lg: { value: "1.125rem" },
  xl: { value: "1.25rem" },
  "2xl": { value: "1.5rem" },
  "3xl": { value: "1.875rem" },
  "4xl": { value: "2.25rem" },
  "5xl": { value: "3rem" },
  "6xl": { value: "3.75rem" },
  "7xl": { value: "4.5rem" },
  "8xl": { value: "6rem" },
  "9xl": { value: "8rem" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/font-weights.js
var fontWeights = defineTokens.fontWeights({
  thin: { value: "100" },
  extralight: { value: "200" },
  light: { value: "300" },
  normal: { value: "400" },
  medium: { value: "500" },
  semibold: { value: "600" },
  bold: { value: "700" },
  extrabold: { value: "800" },
  black: { value: "900" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/fonts.js
var fallback3 = `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
var fonts = defineTokens.fonts({
  heading: {
    value: `Inter, ${fallback3}`
  },
  body: {
    value: `Inter, ${fallback3}`
  },
  mono: {
    value: `SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace`
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/keyframes.js
var keyframes = defineKeyframes({
  spin: {
    "0%": { transform: "rotate(0deg)" },
    "100%": { transform: "rotate(360deg)" }
  },
  pulse: {
    "50%": { opacity: "0.5" }
  },
  ping: {
    "75%, 100%": {
      transform: "scale(2)",
      opacity: "0"
    }
  },
  bounce: {
    "0%, 100%": {
      transform: "translateY(-25%)",
      animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
    },
    "50%": {
      transform: "none",
      animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
    }
  },
  "bg-position": {
    from: { backgroundPosition: "var(--animate-from, 1rem) 0" },
    to: { backgroundPosition: "var(--animate-to, 0) 0" }
  },
  position: {
    from: {
      insetInlineStart: "var(--animate-from-x)",
      insetBlockStart: "var(--animate-from-y)"
    },
    to: {
      insetInlineStart: "var(--animate-to-x)",
      insetBlockStart: "var(--animate-to-y)"
    }
  },
  "circular-progress": {
    "0%": {
      strokeDasharray: "1, 400",
      strokeDashoffset: "0"
    },
    "50%": {
      strokeDasharray: "400, 400",
      strokeDashoffset: "-100%"
    },
    "100%": {
      strokeDasharray: "400, 400",
      strokeDashoffset: "-260%"
    }
  },
  // collapse
  "expand-height": {
    from: { height: "0" },
    to: { height: "var(--height)" }
  },
  "collapse-height": {
    from: { height: "var(--height)" },
    to: { height: "0" }
  },
  "expand-width": {
    from: { width: "0" },
    to: { width: "var(--width)" }
  },
  "collapse-width": {
    from: { height: "var(--width)" },
    to: { height: "0" }
  },
  // fade
  "fade-in": {
    from: { opacity: 0 },
    to: { opacity: 1 }
  },
  "fade-out": {
    from: { opacity: 1 },
    to: { opacity: 0 }
  },
  // slide from (full)
  "slide-from-left-full": {
    from: { translate: "-100% 0" },
    to: { translate: "0 0" }
  },
  "slide-from-right-full": {
    from: { translate: "100% 0" },
    to: { translate: "0 0" }
  },
  "slide-from-top-full": {
    from: { translate: "0 -100%" },
    to: { translate: "0 0" }
  },
  "slide-from-bottom-full": {
    from: { translate: "0 100%" },
    to: { translate: "0 0" }
  },
  // slide to (full)
  "slide-to-left-full": {
    from: { translate: "0 0" },
    to: { translate: "-100% 0" }
  },
  "slide-to-right-full": {
    from: { translate: "0 0" },
    to: { translate: "100% 0" }
  },
  "slide-to-top-full": {
    from: { translate: "0 0" },
    to: { translate: "0 -100%" }
  },
  "slide-to-bottom-full": {
    from: { translate: "0 0" },
    to: { translate: "0 100%" }
  },
  // slide from
  "slide-from-top": {
    "0%": { translate: "0 -0.5rem" },
    to: { translate: "0" }
  },
  "slide-from-bottom": {
    "0%": { translate: "0 0.5rem" },
    to: { translate: "0" }
  },
  "slide-from-left": {
    "0%": { translate: "-0.5rem 0" },
    to: { translate: "0" }
  },
  "slide-from-right": {
    "0%": { translate: "0.5rem 0" },
    to: { translate: "0" }
  },
  // slide to
  "slide-to-top": {
    "0%": { translate: "0" },
    to: { translate: "0 -0.5rem" }
  },
  "slide-to-bottom": {
    "0%": { translate: "0" },
    to: { translate: "0 0.5rem" }
  },
  "slide-to-left": {
    "0%": { translate: "0" },
    to: { translate: "-0.5rem 0" }
  },
  "slide-to-right": {
    "0%": { translate: "0" },
    to: { translate: "0.5rem 0" }
  },
  // scale
  "scale-in": {
    from: { scale: "0.95" },
    to: { scale: "1" }
  },
  "scale-out": {
    from: { scale: "1" },
    to: { scale: "0.95" }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/letter-spacing.js
var letterSpacings = defineTokens.letterSpacings({
  tighter: { value: "-0.05em" },
  tight: { value: "-0.025em" },
  wide: { value: "0.025em" },
  wider: { value: "0.05em" },
  widest: { value: "0.1em" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/line-heights.js
var lineHeights = defineTokens.lineHeights({
  shorter: { value: 1.25 },
  short: { value: 1.375 },
  moderate: { value: 1.5 },
  tall: { value: 1.625 },
  taller: { value: 2 }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/radius.js
var radii = defineTokens.radii({
  none: { value: "0" },
  "2xs": { value: "0.0625rem" },
  xs: { value: "0.125rem" },
  sm: { value: "0.25rem" },
  md: { value: "0.375rem" },
  lg: { value: "0.5rem" },
  xl: { value: "0.75rem" },
  "2xl": { value: "1rem" },
  "3xl": { value: "1.5rem" },
  "4xl": { value: "2rem" },
  full: { value: "9999px" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/spacing.js
var spacing = defineTokens.spacing({
  0.5: { value: "0.125rem" },
  1: { value: "0.25rem" },
  1.5: { value: "0.375rem" },
  2: { value: "0.5rem" },
  2.5: { value: "0.625rem" },
  3: { value: "0.75rem" },
  3.5: { value: "0.875rem" },
  4: { value: "1rem" },
  4.5: { value: "1.125rem" },
  5: { value: "1.25rem" },
  6: { value: "1.5rem" },
  7: { value: "1.75rem" },
  8: { value: "2rem" },
  9: { value: "2.25rem" },
  10: { value: "2.5rem" },
  11: { value: "2.75rem" },
  12: { value: "3rem" },
  14: { value: "3.5rem" },
  16: { value: "4rem" },
  20: { value: "5rem" },
  24: { value: "6rem" },
  28: { value: "7rem" },
  32: { value: "8rem" },
  36: { value: "9rem" },
  40: { value: "10rem" },
  44: { value: "11rem" },
  48: { value: "12rem" },
  52: { value: "13rem" },
  56: { value: "14rem" },
  60: { value: "15rem" },
  64: { value: "16rem" },
  72: { value: "18rem" },
  80: { value: "20rem" },
  96: { value: "24rem" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/sizes.js
var largeSizes = defineTokens.sizes({
  "3xs": { value: "14rem" },
  "2xs": { value: "16rem" },
  xs: { value: "20rem" },
  sm: { value: "24rem" },
  md: { value: "28rem" },
  lg: { value: "32rem" },
  xl: { value: "36rem" },
  "2xl": { value: "42rem" },
  "3xl": { value: "48rem" },
  "4xl": { value: "56rem" },
  "5xl": { value: "64rem" },
  "6xl": { value: "72rem" },
  "7xl": { value: "80rem" },
  "8xl": { value: "90rem" }
});
var namedSizes = defineTokens.sizes({
  max: { value: "max-content" },
  min: { value: "min-content" },
  fit: { value: "fit-content" },
  prose: { value: "60ch" },
  full: { value: "100%" },
  dvh: { value: "100dvh" },
  svh: { value: "100svh" },
  lvh: { value: "100lvh" },
  dvw: { value: "100dvw" },
  svw: { value: "100svw" },
  lvw: { value: "100lvw" },
  vw: { value: "100vw" },
  vh: { value: "100vh" }
});
var fractionalSizes = defineTokens.sizes({
  "1/2": { value: "50%" },
  "1/3": { value: "33.333333%" },
  "2/3": { value: "66.666667%" },
  "1/4": { value: "25%" },
  "3/4": { value: "75%" },
  "1/5": { value: "20%" },
  "2/5": { value: "40%" },
  "3/5": { value: "60%" },
  "4/5": { value: "80%" },
  "1/6": { value: "16.666667%" },
  "2/6": { value: "33.333333%" },
  "3/6": { value: "50%" },
  "4/6": { value: "66.666667%" },
  "5/6": { value: "83.333333%" },
  "1/12": { value: "8.333333%" },
  "2/12": { value: "16.666667%" },
  "3/12": { value: "25%" },
  "4/12": { value: "33.333333%" },
  "5/12": { value: "41.666667%" },
  "6/12": { value: "50%" },
  "7/12": { value: "58.333333%" },
  "8/12": { value: "66.666667%" },
  "9/12": { value: "75%" },
  "10/12": { value: "83.333333%" },
  "11/12": { value: "91.666667%" }
});
var sizes = defineTokens.sizes({
  ...largeSizes,
  ...spacing,
  ...fractionalSizes,
  ...namedSizes
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/z-indices.js
var zIndices = defineTokens.zIndex({
  hide: { value: -1 },
  base: { value: 0 },
  docked: { value: 10 },
  dropdown: { value: 1e3 },
  sticky: { value: 1100 },
  banner: { value: 1200 },
  overlay: { value: 1300 },
  modal: { value: 1400 },
  popover: { value: 1500 },
  skipNav: { value: 1600 },
  toast: { value: 1700 },
  tooltip: { value: 1800 },
  max: { value: 2147483647 }
});

// node_modules/@chakra-ui/react/dist/esm/theme/index.js
var defaultThemeConfig = defineConfig({
  preflight: true,
  cssVarsPrefix: "chakra",
  cssVarsRoot: ":where(html, .chakra-theme)",
  globalCss,
  theme: {
    breakpoints,
    keyframes,
    tokens: {
      aspectRatios,
      animations,
      blurs,
      borders,
      colors,
      durations,
      easings,
      fonts,
      fontSizes,
      fontWeights,
      letterSpacings,
      lineHeights,
      radii,
      spacing,
      sizes,
      zIndex: zIndices,
      cursor: cursor2
    },
    semanticTokens: {
      colors: semanticColors,
      shadows: semanticShadows,
      radii: semanticRadii
    },
    recipes,
    slotRecipes,
    textStyles,
    layerStyles,
    animationStyles
  }
});

// node_modules/@chakra-ui/react/dist/esm/preset.js
var defaultConfig = mergeConfigs(defaultBaseConfig, defaultThemeConfig);
var defaultSystem = createSystem(defaultConfig);

// node_modules/@chakra-ui/react/dist/esm/styled-system/create-slot-recipe-context.js
var import_jsx_runtime411 = __toESM(require_jsx_runtime(), 1);
var import_react891 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/styled-system/use-slot-recipe.js
var import_react890 = __toESM(require_react(), 1);
function useSlotRecipe(options) {
  const { key, recipe: recipeProp } = options;
  const sys = useChakraContext();
  return (0, import_react890.useMemo)(() => {
    const recipe = recipeProp || (key != null ? sys.getSlotRecipe(key) : {});
    return sys.sva(structuredClone(recipe));
  }, [key, recipeProp, sys]);
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/create-slot-recipe-context.js
var upperFirst2 = (str) => str.charAt(0).toUpperCase() + str.slice(1);
var createSlotRecipeContext = (options) => {
  const { key: recipeKey, recipe: recipeConfig } = options;
  const contextName = upperFirst2(
    recipeKey || recipeConfig.className || "Component"
  );
  const [StylesProvider2, useStyles] = createContext({
    name: `${contextName}StylesContext`,
    errorMessage: `use${contextName}Styles returned is 'undefined'. Seems you forgot to wrap the components in "<${contextName}.Root />" `
  });
  const [ClassNamesProvider2, useClassNames4] = createContext({
    name: `${contextName}ClassNameContext`,
    errorMessage: `use${contextName}ClassNames returned is 'undefined'. Seems you forgot to wrap the components in "<${contextName}.Root />" `,
    strict: false
  });
  const [PropsProvider62, usePropsContext2] = createContext({
    strict: false,
    name: `${contextName}PropsContext`,
    providerName: `${contextName}PropsContext`,
    defaultValue: {}
  });
  function useRecipeResult6(props34) {
    const { unstyled, ...restProps } = props34;
    const slotRecipe = useSlotRecipe({
      key: recipeKey,
      recipe: restProps.recipe || recipeConfig
    });
    const [variantProps, otherProps] = (0, import_react891.useMemo)(
      () => slotRecipe.splitVariantProps(restProps),
      [restProps, slotRecipe]
    );
    const styles = (0, import_react891.useMemo)(
      () => unstyled ? EMPTY_SLOT_STYLES : slotRecipe(variantProps),
      [unstyled, variantProps, slotRecipe]
    );
    return {
      styles,
      classNames: slotRecipe.classNameMap,
      props: otherProps
    };
  }
  function withRootProvider8(Component, options2 = {}) {
    const { defaultProps } = options2;
    const StyledComponent = (inProps) => {
      const propsContext = usePropsContext2();
      const props34 = (0, import_react891.useMemo)(
        () => mergeProps(defaultProps, propsContext, inProps),
        [propsContext, inProps]
      );
      const { styles, classNames, props: rootProps } = useRecipeResult6(props34);
      return (0, import_jsx_runtime411.jsx)(StylesProvider2, { value: styles, children: (0, import_jsx_runtime411.jsx)(ClassNamesProvider2, { value: classNames, children: (0, import_jsx_runtime411.jsx)(Component, { ...rootProps }) }) });
    };
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  }
  const withProvider41 = (Component, slot, options2) => {
    const { defaultProps, ...restOptions } = options2 ?? {};
    const SuperComponent = chakra(Component, {}, restOptions);
    const StyledComponent = (0, import_react891.forwardRef)((inProps, ref2) => {
      var _a8;
      const propsContext = usePropsContext2();
      const props34 = (0, import_react891.useMemo)(
        () => mergeProps(defaultProps ?? {}, propsContext, inProps),
        [propsContext, inProps]
      );
      const { styles, props: rootProps, classNames } = useRecipeResult6(props34);
      const className = classNames[slot];
      const element = (0, import_jsx_runtime411.jsx)(StylesProvider2, { value: styles, children: (0, import_jsx_runtime411.jsx)(ClassNamesProvider2, { value: classNames, children: (0, import_jsx_runtime411.jsx)(
        SuperComponent,
        {
          ref: ref2,
          ...rootProps,
          css: [styles[slot], props34.css],
          className: cx(props34.className, className)
        }
      ) }) });
      return ((_a8 = options2 == null ? void 0 : options2.wrapElement) == null ? void 0 : _a8.call(options2, element, props34)) ?? element;
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  const withContext60 = (Component, slot, options2) => {
    const SuperComponent = chakra(Component, {}, options2);
    const StyledComponent = (0, import_react891.forwardRef)((props34, ref2) => {
      const styles = useStyles();
      const classNames = useClassNames4();
      const className = classNames == null ? void 0 : classNames[slot];
      return (0, import_jsx_runtime411.jsx)(
        SuperComponent,
        {
          ...props34,
          css: [slot ? styles[slot] : void 0, props34.css],
          ref: ref2,
          className: cx(props34.className, className)
        }
      );
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  return {
    StylesProvider: StylesProvider2,
    ClassNamesProvider: ClassNamesProvider2,
    PropsProvider: PropsProvider62,
    usePropsContext: usePropsContext2,
    useRecipeResult: useRecipeResult6,
    withProvider: withProvider41,
    withContext: withContext60,
    withRootProvider: withRootProvider8,
    useStyles,
    useClassNames: useClassNames4
  };
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/recipe-props.js
var import_jsx_runtime412 = __toESM(require_jsx_runtime(), 1);
var [RecipePropsContextProvider, useParentRecipeProps] = createContext({
  name: "RecipePropsContext",
  strict: false
});
function RecipePropsProvider(props34) {
  return (0, import_jsx_runtime412.jsx)(RecipePropsContextProvider, { value: props34.value, children: props34.children });
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/use-token.js
var import_react892 = __toESM(require_react(), 1);
function useToken(category, token2) {
  const sys = useChakraContext();
  return (0, import_react892.useMemo)(() => {
    const arr = Array.isArray(token2) ? token2 : [token2];
    return arr.map((t) => sys.token(`${category}.${t}`, t));
  }, [sys, category, token2]);
}

// node_modules/@chakra-ui/react/dist/esm/components/accordion/accordion.js
var import_jsx_runtime414 = __toESM(require_jsx_runtime(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/icons.js
var import_jsx_runtime413 = __toESM(require_jsx_runtime(), 1);
var CheckIcon = (props34) => {
  return (0, import_jsx_runtime413.jsx)(
    chakra.svg,
    {
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...props34,
      children: (0, import_jsx_runtime413.jsx)("path", { d: "M20 6 9 17l-5-5" })
    }
  );
};
var ChevronUpIcon = (props34) => (0, import_jsx_runtime413.jsx)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props34,
    children: (0, import_jsx_runtime413.jsx)("path", { d: "m18 15-6-6-6 6" })
  }
);
var ChevronDownIcon = (props34) => {
  return (0, import_jsx_runtime413.jsx)(
    chakra.svg,
    {
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...props34,
      children: (0, import_jsx_runtime413.jsx)("path", { d: "m6 9 6 6 6-6" })
    }
  );
};
var ChevronRightIcon = (props34) => (0, import_jsx_runtime413.jsx)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props34,
    children: (0, import_jsx_runtime413.jsx)("path", { d: "m9 18 6-6-6-6" })
  }
);
var EllpsisIcon = (props34) => (0, import_jsx_runtime413.jsxs)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props34,
    children: [
      (0, import_jsx_runtime413.jsx)("circle", { cx: "12", cy: "12", r: "1" }),
      (0, import_jsx_runtime413.jsx)("circle", { cx: "19", cy: "12", r: "1" }),
      (0, import_jsx_runtime413.jsx)("circle", { cx: "5", cy: "12", r: "1" })
    ]
  }
);
var ArrowUpIcon = (props34) => (0, import_jsx_runtime413.jsxs)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "3",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props34,
    children: [
      (0, import_jsx_runtime413.jsx)("path", { d: "m5 12 7-7 7 7" }),
      (0, import_jsx_runtime413.jsx)("path", { d: "M12 19V5" })
    ]
  }
);
var ArrowDownIcon = (props34) => (0, import_jsx_runtime413.jsxs)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "3",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props34,
    children: [
      (0, import_jsx_runtime413.jsx)("path", { d: "M12 5v14" }),
      (0, import_jsx_runtime413.jsx)("path", { d: "m19 12-7 7-7-7" })
    ]
  }
);
var CheckCircleIcon = (props34) => (0, import_jsx_runtime413.jsx)(
  chakra.svg,
  {
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 24 24",
    ...props34,
    children: (0, import_jsx_runtime413.jsx)("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11.0026 16L6.75999 11.7574L8.17421 10.3431L11.0026 13.1716L16.6595 7.51472L18.0737 8.92893L11.0026 16Z" })
  }
);
var WarningIcon = (props34) => (0, import_jsx_runtime413.jsx)(
  chakra.svg,
  {
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 24 24",
    ...props34,
    children: (0, import_jsx_runtime413.jsx)("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11 15H13V17H11V15ZM11 7H13V13H11V7Z" })
  }
);
var InfoIcon = (props34) => (0, import_jsx_runtime413.jsx)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "currentColor",
    stroke: "currentColor",
    strokeWidth: "0",
    ...props34,
    children: (0, import_jsx_runtime413.jsx)("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11 7H13V9H11V7ZM11 11H13V17H11V11Z" })
  }
);
var QuoteIcon = (props34) => (0, import_jsx_runtime413.jsx)(chakra.svg, { viewBox: "0 0 24 24", fill: "currentColor", ...props34, children: (0, import_jsx_runtime413.jsx)("path", { d: "M6.5 10c-.223 0-.437.034-.65.065.069-.232.14-.468.254-.68.114-.308.292-.575.469-.844.148-.291.409-.488.601-.737.201-.242.475-.403.692-.604.213-.21.492-.315.714-.463.232-.133.434-.28.65-.35l.539-.222.474-.197-.485-1.938-.597.144c-.191.048-.424.104-.689.171-.271.05-.56.187-.882.312-.318.142-.686.238-1.028.466-.344.218-.741.4-1.091.692-.339.301-.748.562-1.05.945-.33.358-.656.734-.909 1.162-.293.408-.492.856-.702 1.299-.19.443-.343.896-.468 1.336-.237.882-.343 1.72-.384 2.437-.034.718-.014 1.315.028 1.747.015.204.043.402.063.539l.025.168.026-.006A4.5 4.5 0 1 0 6.5 10zm11 0c-.223 0-.437.034-.65.065.069-.232.14-.468.254-.68.114-.308.292-.575.469-.844.148-.291.409-.488.601-.737.201-.242.475-.403.692-.604.213-.21.492-.315.714-.463.232-.133.434-.28.65-.35l.539-.222.474-.197-.485-1.938-.597.144c-.191.048-.424.104-.689.171-.271.05-.56.187-.882.312-.317.143-.686.238-1.028.467-.344.218-.741.4-1.091.692-.339.301-.748.562-1.05.944-.33.358-.656.734-.909 1.162-.293.408-.492.856-.702 1.299-.19.443-.343.896-.468 1.336-.237.882-.343 1.72-.384 2.437-.034.718-.014 1.315.028 1.747.015.204.043.402.063.539l.025.168.026-.006A4.5 4.5 0 1 0 17.5 10z" }) });
var StarIcon = (props34) => (0, import_jsx_runtime413.jsx)(chakra.svg, { viewBox: "0 0 24 24", fill: "currentColor", ...props34, children: (0, import_jsx_runtime413.jsx)("path", { d: "M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z" }) });
var CloseIcon = (props34) => (0, import_jsx_runtime413.jsx)(chakra.svg, { viewBox: "0 0 24 24", fill: "currentColor", ...props34, children: (0, import_jsx_runtime413.jsx)(
  "path",
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M18.7071 6.70711C19.0976 6.31658 19.0976 5.68342 18.7071 5.29289C18.3166 4.90237 17.6834 4.90237 17.2929 5.29289L12 10.5858L6.70711 5.29289C6.31658 4.90237 5.68342 4.90237 5.29289 5.29289C4.90237 5.68342 4.90237 6.31658 5.29289 6.70711L10.5858 12L5.29289 17.2929C4.90237 17.6834 4.90237 18.3166 5.29289 18.7071C5.68342 19.0976 6.31658 19.0976 6.70711 18.7071L12 13.4142L17.2929 18.7071C17.6834 19.0976 18.3166 19.0976 18.7071 18.7071C19.0976 18.3166 19.0976 17.6834 18.7071 17.2929L13.4142 12L18.7071 6.70711Z"
  }
) });

// node_modules/@chakra-ui/react/dist/esm/components/accordion/accordion.js
var {
  withProvider,
  withContext,
  useStyles: useAccordionStyles,
  PropsProvider
} = createSlotRecipeContext({ key: "accordion" });
var AccordionRootProvider2 = withProvider(accordion_exports.RootProvider, "root", { forwardAsChild: true });
var AccordionRoot2 = withProvider(
  accordion_exports.Root,
  "root",
  { forwardAsChild: true }
);
var AccordionPropsProvider = PropsProvider;
var AccordionItem2 = withContext(
  accordion_exports.Item,
  "item",
  { forwardAsChild: true }
);
var AccordionItemContent2 = withContext(accordion_exports.ItemContent, "itemContent", { forwardAsChild: true });
var AccordionItemBody = withContext("div", "itemBody");
var AccordionItemTrigger2 = withContext(accordion_exports.ItemTrigger, "itemTrigger", { forwardAsChild: true });
var AccordionItemIndicator2 = withContext(accordion_exports.ItemIndicator, "itemIndicator", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime414.jsx)(ChevronDownIcon, {})
  }
});
var AccordionContext2 = accordion_exports.Context;
var AccordionItemContext2 = accordion_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/accordion/namespace.js
var namespace_exports = {};
__export(namespace_exports, {
  Context: () => AccordionContext2,
  Item: () => AccordionItem2,
  ItemBody: () => AccordionItemBody,
  ItemContent: () => AccordionItemContent2,
  ItemContext: () => AccordionItemContext2,
  ItemIndicator: () => AccordionItemIndicator2,
  ItemTrigger: () => AccordionItemTrigger2,
  PropsProvider: () => AccordionPropsProvider,
  Root: () => AccordionRoot2,
  RootProvider: () => AccordionRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/action-bar/action-bar.js
var {
  withRootProvider,
  withContext: withContext2,
  useStyles: useActionBarStyles,
  PropsProvider: PropsProvider2
} = createSlotRecipeContext({ key: "actionBar" });
var ActionBarRootProvider = withRootProvider(popover_exports.RootProvider, {
  defaultProps: {
    lazyMount: true,
    unmountOnExit: true
  }
});
var ActionBarRoot = withRootProvider(
  popover_exports.Root,
  {
    defaultProps: {
      autoFocus: false,
      lazyMount: true,
      unmountOnExit: true
    }
  }
);
var ActionBarPropsProvider = PropsProvider2;
var ActionBarPositioner = withContext2("div", "positioner", { forwardAsChild: true });
var ActionBarContent = withContext2(popover_exports.Content, "content", { forwardAsChild: true });
var ActionBarSeparator = withContext2("div", "separator");
var ActionBarSelectionTrigger = withContext2("button", "selectionTrigger");
var ActionBarCloseTrigger = withContext2(popover_exports.CloseTrigger, "closeTrigger", { forwardAsChild: true });
var ActionBarContext = popover_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/action-bar/namespace.js
var namespace_exports2 = {};
__export(namespace_exports2, {
  CloseTrigger: () => ActionBarCloseTrigger,
  Content: () => ActionBarContent,
  Context: () => ActionBarContext,
  Positioner: () => ActionBarPositioner,
  PropsProvider: () => ActionBarPropsProvider,
  Root: () => ActionBarRoot,
  RootProvider: () => ActionBarRootProvider,
  SelectionTrigger: () => ActionBarSelectionTrigger,
  Separator: () => ActionBarSeparator
});

// node_modules/@chakra-ui/react/dist/esm/components/alert/alert.js
var import_jsx_runtime415 = __toESM(require_jsx_runtime(), 1);
var import_react893 = __toESM(require_react(), 1);
var [AlertStatusProvider, useAlertStatusContext] = createContext({
  name: "AlertStatusContext",
  hookName: "useAlertStatusContext",
  providerName: "<Alert />"
});
var {
  withProvider: withProvider2,
  withContext: withContext3,
  useStyles: useAlertStyles,
  PropsProvider: PropsProvider3
} = createSlotRecipeContext({ key: "alert" });
var AlertRoot = withProvider2(
  "div",
  "root",
  {
    forwardAsChild: true,
    wrapElement(element, props34) {
      return (
        // @ts-ignore fix later
        (0, import_jsx_runtime415.jsx)(AlertStatusProvider, { value: { status: props34.status || "info" }, children: element })
      );
    }
  }
);
var AlertPropsProvider = PropsProvider3;
var AlertTitle = withContext3(
  "div",
  "title"
);
var AlertDescription = withContext3("div", "description");
var AlertContent = withContext3(
  "div",
  "content"
);
var iconMap = {
  info: InfoIcon,
  warning: WarningIcon,
  success: CheckCircleIcon,
  error: WarningIcon,
  neutral: InfoIcon
};
var AlertIndicator = (0, import_react893.forwardRef)(
  function AlertIndicator2(props34, ref2) {
    const api = useAlertStatusContext();
    const styles = useAlertStyles();
    const Icon3 = typeof api.status === "string" ? iconMap[api.status] : import_react893.Fragment;
    const { children = (0, import_jsx_runtime415.jsx)(Icon3, {}), ...rest } = props34;
    return (0, import_jsx_runtime415.jsx)(chakra.span, { ref: ref2, ...rest, css: [styles.indicator, props34.css], children });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/alert/namespace.js
var namespace_exports3 = {};
__export(namespace_exports3, {
  Content: () => AlertContent,
  Description: () => AlertDescription,
  Indicator: () => AlertIndicator,
  Root: () => AlertRoot,
  RootPropsProvider: () => AlertPropsProvider,
  Title: () => AlertTitle
});

// node_modules/@chakra-ui/react/dist/esm/components/aspect-ratio/aspect-ratio.js
var import_jsx_runtime416 = __toESM(require_jsx_runtime(), 1);
var import_react894 = __toESM(require_react(), 1);
var baseStyle = defineStyle({
  "& > *:not(style)": {
    overflow: "hidden",
    position: "absolute",
    top: "0",
    right: "0",
    bottom: "0",
    left: "0",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    width: "100%",
    height: "100%"
  },
  "& > img, & > video": {
    objectFit: "cover"
  }
});
var AspectRatio = (0, import_react894.forwardRef)(
  function AspectRatio2(props34, ref2) {
    const { ratio = 4 / 3, children, className, ...rest } = props34;
    const child = import_react894.Children.only(children);
    return (0, import_jsx_runtime416.jsx)(
      chakra.div,
      {
        ref: ref2,
        position: "relative",
        className: cx("chakra-aspect-ratio", className),
        _before: {
          height: 0,
          content: `""`,
          display: "block",
          paddingBottom: mapObject(ratio, (r) => `${1 / r * 100}%`)
        },
        ...rest,
        css: [baseStyle, props34.css],
        children: child
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/avatar/avatar.js
var import_jsx_runtime418 = __toESM(require_jsx_runtime(), 1);
var import_react896 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/group/group.js
var import_jsx_runtime417 = __toESM(require_jsx_runtime(), 1);
var import_react895 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/attr.js
var dataAttr2 = (condition) => condition ? "" : void 0;

// node_modules/@chakra-ui/react/dist/esm/components/group/group.js
var StyledGroup = chakra("div", {
  base: {
    display: "inline-flex",
    gap: "0.5rem",
    isolation: "isolate",
    position: "relative",
    "& [data-group-item]": {
      _focusVisible: {
        zIndex: 1
      }
    }
  },
  variants: {
    orientation: {
      horizontal: {
        flexDirection: "row"
      },
      vertical: {
        flexDirection: "column"
      }
    },
    attached: {
      true: {
        gap: "0!"
      }
    },
    grow: {
      true: {
        display: "flex",
        "& > *": {
          flex: 1
        }
      }
    },
    stacking: {
      "first-on-top": {
        "& > [data-group-item]": {
          zIndex: "calc(var(--group-count) - var(--group-index))"
        }
      },
      "last-on-top": {
        "& > [data-group-item]": {
          zIndex: "var(--group-index)"
        }
      }
    }
  },
  compoundVariants: [
    {
      orientation: "horizontal",
      attached: true,
      css: {
        "& > *[data-first]": {
          borderEndRadius: "0!",
          marginEnd: "-1px"
        },
        "& > *[data-between]": {
          borderRadius: "0!",
          marginEnd: "-1px"
        },
        "& > *[data-last]": {
          borderStartRadius: "0!"
        }
      }
    },
    {
      orientation: "vertical",
      attached: true,
      css: {
        "& > *[data-first]": {
          borderBottomRadius: "0!",
          marginBottom: "-1px"
        },
        "& > *[data-between]": {
          borderRadius: "0!",
          marginBottom: "-1px"
        },
        "& > *[data-last]": {
          borderTopRadius: "0!"
        }
      }
    }
  ],
  defaultVariants: {
    orientation: "horizontal"
  }
});
var Group = (0, import_react895.memo)(
  (0, import_react895.forwardRef)(function Group2(props34, ref2) {
    const {
      align = "center",
      justify = "flex-start",
      children,
      wrap: wrap5,
      ...rest
    } = props34;
    const _children = (0, import_react895.useMemo)(() => {
      const childArray = import_react895.Children.toArray(children).filter(import_react895.isValidElement);
      const count = childArray.length;
      return childArray.map((child, index) => {
        const childProps = child.props;
        return (0, import_react895.cloneElement)(child, {
          ...childProps,
          "data-group-item": "",
          "data-first": dataAttr2(index === 0),
          "data-last": dataAttr2(index === count - 1),
          "data-between": dataAttr2(index > 0 && index < count - 1),
          style: {
            "--group-count": count,
            "--group-index": index,
            ...(childProps == null ? void 0 : childProps.style) ?? {}
          }
        });
      });
    }, [children]);
    return (0, import_jsx_runtime417.jsx)(
      StyledGroup,
      {
        ref: ref2,
        alignItems: align,
        justifyContent: justify,
        flexWrap: wrap5,
        ...rest,
        className: cx("chakra-group", props34.className),
        children: _children
      }
    );
  })
);

// node_modules/@chakra-ui/react/dist/esm/components/avatar/avatar.js
var {
  withProvider: withProvider3,
  withContext: withContext4,
  useStyles: useAvatarStyles,
  useClassNames,
  PropsProvider: PropsProvider4
} = createSlotRecipeContext({ key: "avatar" });
var AvatarRootProvider2 = withProvider3(avatar_exports.RootProvider, "root", { forwardAsChild: true });
var AvatarRoot2 = withProvider3(
  avatar_exports.Root,
  "root",
  { forwardAsChild: true }
);
var AvatarPropsProvider = PropsProvider4;
var StyledFallback = chakra(avatar_exports.Fallback, {}, { forwardAsChild: true });
function getFallbackChildren(props34) {
  if (props34.children || props34.asChild) return props34.children;
  if (props34.name) return getInitials(props34.name);
  return (0, import_jsx_runtime418.jsx)(AvatarIcon, {});
}
function getInitials(name) {
  const names = name.trim().split(" ");
  const firstName = names[0] != null ? names[0] : "";
  const lastName = names.length > 1 ? names[names.length - 1] : "";
  return firstName && lastName ? `${firstName.charAt(0)}${lastName.charAt(0)}` : firstName.charAt(0);
}
var AvatarFallback2 = (0, import_react896.forwardRef)(
  function AvatarFallback22(props34, ref2) {
    const styles = useAvatarStyles();
    const classNames = useClassNames();
    const { name: _, ...rest } = props34;
    return (0, import_jsx_runtime418.jsx)(
      StyledFallback,
      {
        ref: ref2,
        ...rest,
        className: cx(props34.className, classNames.fallback),
        css: [styles.fallback, props34.css],
        children: getFallbackChildren(props34)
      }
    );
  }
);
var AvatarImage2 = withContext4(
  avatar_exports.Image,
  "image",
  {
    forwardAsChild: true,
    defaultProps: {
      draggable: "false",
      referrerPolicy: "no-referrer"
    }
  }
);
var AvatarIcon = (0, import_react896.forwardRef)(
  function AvatarIcon2(props34, ref2) {
    return (0, import_jsx_runtime418.jsx)(
      chakra.svg,
      {
        stroke: "currentColor",
        fill: "currentColor",
        strokeWidth: "0",
        viewBox: "0 0 24 24",
        height: "1.2em",
        width: "1.2em",
        ref: ref2,
        ...props34,
        children: (0, import_jsx_runtime418.jsx)("path", { d: "M20 22H18V20C18 18.3431 16.6569 17 15 17H9C7.34315 17 6 18.3431 6 20V22H4V20C4 17.2386 6.23858 15 9 15H15C17.7614 15 20 17.2386 20 20V22ZM12 13C8.68629 13 6 10.3137 6 7C6 3.68629 8.68629 1 12 1C15.3137 1 18 3.68629 18 7C18 10.3137 15.3137 13 12 13ZM12 11C14.2091 11 16 9.20914 16 7C16 4.79086 14.2091 3 12 3C9.79086 3 8 4.79086 8 7C8 9.20914 9.79086 11 12 11Z" })
      }
    );
  }
);
var AvatarContext2 = avatar_exports.Context;
var AvatarGroup = (0, import_react896.forwardRef)(
  function AvatarGroup2(props34, ref2) {
    const recipe = useSlotRecipe({ key: "avatar" });
    const [variantProps, localProps] = (0, import_react896.useMemo)(
      () => recipe.splitVariantProps(props34),
      [props34, recipe]
    );
    return (0, import_jsx_runtime418.jsx)(PropsProvider4, { value: variantProps, children: (0, import_jsx_runtime418.jsx)(Group, { gap: "0", spaceX: "-3", ref: ref2, ...localProps }) });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/avatar/namespace.js
var namespace_exports4 = {};
__export(namespace_exports4, {
  Context: () => AvatarContext2,
  Fallback: () => AvatarFallback2,
  Icon: () => AvatarIcon,
  Image: () => AvatarImage2,
  PropsProvider: () => AvatarPropsProvider,
  Root: () => AvatarRoot2,
  RootProvider: () => AvatarRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/badge/badge.js
var { PropsProvider: PropsProvider5, withContext: withContext5 } = createRecipeContext({
  key: "badge"
});
var Badge = withContext5("span");
var BadgePropsProvider = PropsProvider5;

// node_modules/@chakra-ui/react/dist/esm/components/bleed/bleed.js
var import_jsx_runtime419 = __toESM(require_jsx_runtime(), 1);
var import_react897 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/unit.js
var lengthUnits = "cm,mm,Q,in,pc,pt,px,em,ex,ch,rem,lh,rlh,vw,vh,vmin,vmax,vb,vi,svw,svh,lvw,lvh,dvw,dvh,cqw,cqh,cqi,cqb,cqmin,cqmax,%";
var lengthUnitsPattern = `(?:${lengthUnits.split(",").join("|")})`;
var lengthRegExp = new RegExp(
  `^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${lengthUnitsPattern}$`
);
var isCssUnit = (v) => typeof v === "string" && lengthRegExp.test(v);

// node_modules/@chakra-ui/react/dist/esm/components/bleed/bleed.js
var valueFn = (v) => isCssUnit(v) || isCssVar(v) ? v : `token(spacing.${v}, ${v})`;
var Bleed = (0, import_react897.forwardRef)(
  function Bleed2(props34, ref2) {
    const {
      inline: inline2,
      inlineStart,
      inlineEnd,
      block,
      blockStart,
      blockEnd,
      ...rest
    } = props34;
    return (0, import_jsx_runtime419.jsx)(
      chakra.div,
      {
        ref: ref2,
        ...rest,
        css: {
          "--bleed-inline-start": mapObject(inline2 ?? inlineStart, valueFn),
          "--bleed-inline-end": mapObject(inline2 ?? inlineEnd, valueFn),
          "--bleed-block-start": mapObject(block ?? blockStart, valueFn),
          "--bleed-block-end": mapObject(block ?? blockEnd, valueFn),
          marginInlineStart: "calc(var(--bleed-inline-start, 0) * -1)",
          marginInlineEnd: "calc(var(--bleed-inline-end, 0) * -1)",
          marginBlockStart: "calc(var(--bleed-block-start, 0) * -1)",
          marginBlockEnd: "calc(var(--bleed-block-end, 0) * -1)"
        }
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/blockquote/blockquote.js
var {
  withProvider: withProvider4,
  withContext: withContext6,
  useStyles: useBlockquoteStyles,
  PropsProvider: PropsProvider6
} = createSlotRecipeContext({ key: "blockquote" });
var BlockquoteRoot = withProvider4(
  "figure",
  "root"
);
var BlockquotePropsProvider = PropsProvider6;
var BlockquoteContent = withContext6("blockquote", "content");
var BlockquoteCaption = withContext6("figcaption", "caption");
var BlockquoteIcon = withContext6(
  QuoteIcon,
  "icon"
);

// node_modules/@chakra-ui/react/dist/esm/components/blockquote/namespace.js
var namespace_exports5 = {};
__export(namespace_exports5, {
  Caption: () => BlockquoteCaption,
  Content: () => BlockquoteContent,
  Icon: () => BlockquoteIcon,
  PropsProvider: () => BlockquotePropsProvider,
  Root: () => BlockquoteRoot
});

// node_modules/@chakra-ui/react/dist/esm/components/box/box.js
var Box = chakra("div");
Box.displayName = "Box";

// node_modules/@chakra-ui/react/dist/esm/components/box/square.js
var import_jsx_runtime420 = __toESM(require_jsx_runtime(), 1);
var import_react898 = __toESM(require_react(), 1);
var Square = (0, import_react898.forwardRef)(
  function Square2(props34, ref2) {
    const { size: size3, ...rest } = props34;
    return (0, import_jsx_runtime420.jsx)(
      Box,
      {
        ...rest,
        ref: ref2,
        boxSize: size3,
        css: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          flexShrink: 0,
          flexGrow: 0,
          ...props34.css
        }
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/box/circle.js
var import_jsx_runtime421 = __toESM(require_jsx_runtime(), 1);
var import_react899 = __toESM(require_react(), 1);
var Circle = (0, import_react899.forwardRef)(
  function Circle2(props34, ref2) {
    const { size: size3, ...rest } = props34;
    return (0, import_jsx_runtime421.jsx)(Square, { size: size3, ref: ref2, borderRadius: "9999px", ...rest });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/box/span.js
var Span = chakra("span");

// node_modules/@chakra-ui/react/dist/esm/components/box/sticky.js
var Sticky = chakra("div", {
  base: {
    position: "sticky",
    top: 0
  }
});
Sticky.displayName = "Sticky";

// node_modules/@chakra-ui/react/dist/esm/components/breadcrumb/breadcrumb.js
var import_jsx_runtime422 = __toESM(require_jsx_runtime(), 1);
var {
  withProvider: withProvider5,
  withContext: withContext7,
  useStyles: useBreadcrumbStyles,
  PropsProvider: PropsProvider7
} = createSlotRecipeContext({ key: "breadcrumb" });
var BreadcrumbRoot = withProvider5(
  "nav",
  "root",
  {
    defaultProps: { "aria-label": "breadcrumb" }
  }
);
var BreadcrumbPropsProvider = PropsProvider7;
var BreadcrumbList = withContext7(
  "ol",
  "list"
);
var BreadcrumbItem = withContext7(
  "li",
  "item"
);
var BreadcrumbLink = withContext7("a", "link");
var BreadcrumbCurrentLink = withContext7("span", "currentLink", {
  defaultProps: {
    role: "link",
    "aria-current": "page"
  }
});
var BreadcrumbSeparator = withContext7("li", "separator", {
  defaultProps: {
    children: (0, import_jsx_runtime422.jsx)(ChevronRightIcon, {})
  }
});
var BreadcrumbEllipsis = withContext7("span", "ellipsis", {
  defaultProps: {
    role: "presentation",
    "aria-hidden": true,
    children: (0, import_jsx_runtime422.jsx)(EllpsisIcon, {})
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/breadcrumb/namespace.js
var namespace_exports6 = {};
__export(namespace_exports6, {
  CurrentLink: () => BreadcrumbCurrentLink,
  Ellipsis: () => BreadcrumbEllipsis,
  Item: () => BreadcrumbItem,
  Link: () => BreadcrumbLink,
  List: () => BreadcrumbList,
  PropsProvider: () => BreadcrumbPropsProvider,
  Root: () => BreadcrumbRoot,
  Separator: () => BreadcrumbSeparator
});

// node_modules/@chakra-ui/react/dist/esm/components/button/button.js
var import_jsx_runtime424 = __toESM(require_jsx_runtime(), 1);
var import_react900 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/loader/loader.js
var import_jsx_runtime423 = __toESM(require_jsx_runtime(), 1);
var React6 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/center/absolute-center.js
var AbsoluteCenter = chakra("div", {
  base: {
    position: "absolute",
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  variants: {
    axis: {
      horizontal: {
        insetStart: "50%",
        translate: "-50%",
        _rtl: {
          translate: "50%"
        }
      },
      vertical: {
        top: "50%",
        translate: "0 -50%"
      },
      both: {
        insetStart: "50%",
        top: "50%",
        translate: "-50% -50%",
        _rtl: {
          translate: "50% -50%"
        }
      }
    }
  },
  defaultVariants: {
    axis: "both"
  }
});
AbsoluteCenter.displayName = "AbsoluteCenter";

// node_modules/@chakra-ui/react/dist/esm/components/spinner/spinner.js
var { withContext: withContext8, PropsProvider: PropsProvider8 } = createRecipeContext({
  key: "spinner"
});
var Spinner = withContext8("span");
var SpinnerPropsProvider = PropsProvider8;

// node_modules/@chakra-ui/react/dist/esm/components/loader/loader.js
var Loader = React6.forwardRef(
  function Loader2(props34, ref2) {
    const {
      spinner = (0, import_jsx_runtime423.jsx)(Spinner, { size: "inherit", borderWidth: "0.125em", color: "inherit" }),
      spinnerPlacement = "start",
      children,
      text,
      visible = true,
      ...rest
    } = props34;
    if (!visible) return children;
    if (text) {
      return (0, import_jsx_runtime423.jsxs)(Span, { ref: ref2, display: "contents", ...rest, children: [
        spinnerPlacement === "start" && spinner,
        text,
        spinnerPlacement === "end" && spinner
      ] });
    }
    if (spinner) {
      return (0, import_jsx_runtime423.jsxs)(Span, { ref: ref2, display: "contents", ...rest, children: [
        (0, import_jsx_runtime423.jsx)(AbsoluteCenter, { display: "inline-flex", children: spinner }),
        (0, import_jsx_runtime423.jsx)(Span, { opacity: 0, children })
      ] });
    }
    return (0, import_jsx_runtime423.jsx)(Span, { ref: ref2, display: "contents", ...rest, children });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/button/button.js
var { useRecipeResult: useRecipeResult2, PropsProvider: PropsProvider9, usePropsContext } = createRecipeContext(
  { key: "button" }
);
var Button = (0, import_react900.forwardRef)(
  function Button2(inProps, ref2) {
    const propsContext = usePropsContext();
    const props34 = (0, import_react900.useMemo)(
      () => mergeProps(propsContext, inProps),
      [propsContext, inProps]
    );
    const result = useRecipeResult2(props34);
    const {
      loading,
      loadingText,
      children,
      spinner,
      spinnerPlacement,
      ...rest
    } = result.props;
    return (0, import_jsx_runtime424.jsx)(
      chakra.button,
      {
        type: "button",
        ref: ref2,
        ...rest,
        disabled: loading || rest.disabled,
        className: cx(result.className, props34.className),
        css: [result.styles, props34.css],
        children: !props34.asChild && loading ? (0, import_jsx_runtime424.jsx)(
          Loader,
          {
            spinner,
            text: loadingText,
            spinnerPlacement,
            children
          }
        ) : children
      }
    );
  }
);
var ButtonPropsProvider = PropsProvider9;

// node_modules/@chakra-ui/react/dist/esm/components/button/icon-button.js
var import_jsx_runtime425 = __toESM(require_jsx_runtime(), 1);
var import_react901 = __toESM(require_react(), 1);
var IconButton = (0, import_react901.forwardRef)(
  function IconButton2(props34, ref2) {
    return (0, import_jsx_runtime425.jsx)(
      Button,
      {
        px: "0",
        py: "0",
        _icon: { fontSize: "1.2em" },
        ref: ref2,
        ...props34
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/button/button-group.js
var import_jsx_runtime426 = __toESM(require_jsx_runtime(), 1);
var import_react902 = __toESM(require_react(), 1);
var ButtonGroup = (0, import_react902.forwardRef)(
  function ButtonGroup2(props34, ref2) {
    const recipe = useRecipe({ key: "button" });
    const [variantProps, otherProps] = (0, import_react902.useMemo)(
      () => recipe.splitVariantProps(props34),
      [props34, recipe]
    );
    return (0, import_jsx_runtime426.jsx)(ButtonPropsProvider, { value: variantProps, children: (0, import_jsx_runtime426.jsx)(Group, { ref: ref2, ...otherProps }) });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/button/close-button.js
var import_jsx_runtime427 = __toESM(require_jsx_runtime(), 1);
var React7 = __toESM(require_react(), 1);
var CloseButton = React7.forwardRef(function CloseButton2(props34, ref2) {
  return (0, import_jsx_runtime427.jsx)(IconButton, { variant: "ghost", "aria-label": "Close", ref: ref2, ...props34, children: props34.children ?? (0, import_jsx_runtime427.jsx)(CloseIcon, {}) });
});

// node_modules/@chakra-ui/react/dist/esm/components/card/card.js
var {
  withProvider: withProvider6,
  withContext: withContext9,
  useStyles: useCardStyles,
  PropsProvider: PropsProvider10
} = createSlotRecipeContext({ key: "card" });
var CardRoot = withProvider6(
  "div",
  "root"
);
var CardPropsProvider = PropsProvider10;
var CardBody = withContext9(
  "div",
  "body"
);
var CardHeader = withContext9(
  "div",
  "header"
);
var CardFooter = withContext9(
  "div",
  "footer"
);
var CardTitle = withContext9(
  "h3",
  "title"
);
var CardDescription = withContext9("p", "description");

// node_modules/@chakra-ui/react/dist/esm/components/card/namespace.js
var namespace_exports7 = {};
__export(namespace_exports7, {
  Body: () => CardBody,
  Description: () => CardDescription,
  Footer: () => CardFooter,
  Header: () => CardHeader,
  PropsProvider: () => CardPropsProvider,
  Root: () => CardRoot,
  Title: () => CardTitle
});

// node_modules/@chakra-ui/react/dist/esm/components/center/center.js
var Center = chakra("div", {
  base: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  variants: {
    inline: {
      true: {
        display: "inline-flex"
      }
    }
  }
});
Center.displayName = "Center";

// node_modules/@chakra-ui/react/dist/esm/components/checkbox/checkbox.js
var import_jsx_runtime429 = __toESM(require_jsx_runtime(), 1);
var import_react904 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/checkmark/checkmark.js
var import_jsx_runtime428 = __toESM(require_jsx_runtime(), 1);
var import_react903 = __toESM(require_react(), 1);
var Checkmark = (0, import_react903.forwardRef)(
  function Checkmark2(props34, ref2) {
    const recipe = useRecipe({ key: "checkmark", recipe: props34.recipe });
    const [variantProps, restProps] = recipe.splitVariantProps(props34);
    const { checked, indeterminate, disabled, unstyled, children, ...rest } = restProps;
    const styles = unstyled ? EMPTY_STYLES : recipe(variantProps);
    return (0, import_jsx_runtime428.jsx)(
      chakra.svg,
      {
        ref: ref2,
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "3px",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        "data-state": indeterminate ? "indeterminate" : checked ? "checked" : "unchecked",
        "data-disabled": dataAttr2(disabled),
        css: [styles, props34.css],
        ...rest,
        children: indeterminate ? (0, import_jsx_runtime428.jsx)("path", { d: "M5 12h14" }) : checked ? (0, import_jsx_runtime428.jsx)("polyline", { points: "20 6 9 17 4 12" }) : null
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/checkbox/checkbox.js
var {
  withProvider: withProvider7,
  withContext: withContext10,
  useStyles: useCheckboxStyles,
  PropsProvider: PropsProvider11
} = createSlotRecipeContext({ key: "checkbox" });
var CheckboxRootProvider2 = withProvider7(checkbox_exports.RootProvider, "root", { forwardAsChild: true });
var CheckboxRoot2 = withProvider7(
  checkbox_exports.Root,
  "root",
  { forwardAsChild: true }
);
var CheckboxPropsProvider = PropsProvider11;
var CheckboxLabel2 = withContext10(
  checkbox_exports.Label,
  "label",
  { forwardAsChild: true }
);
var CheckboxIndicator2 = (0, import_react904.forwardRef)(function CheckboxIndicator22(props34, ref2) {
  const { checked, indeterminate, ...rest } = props34;
  const api = useCheckboxContext();
  const styles = useCheckboxStyles();
  if (checked && api.checked) {
    return (0, import_jsx_runtime429.jsx)(
      chakra.svg,
      {
        ref: ref2,
        asChild: true,
        ...rest,
        css: [styles.indicator, props34.css],
        children: checked
      }
    );
  }
  if (indeterminate && api.indeterminate) {
    return (0, import_jsx_runtime429.jsx)(
      chakra.svg,
      {
        ref: ref2,
        asChild: true,
        ...rest,
        css: [styles.indicator, props34.css],
        children: indeterminate
      }
    );
  }
  return (0, import_jsx_runtime429.jsx)(
    Checkmark,
    {
      ref: ref2,
      checked: api.checked,
      indeterminate: api.indeterminate,
      disabled: api.disabled,
      unstyled: true,
      ...rest,
      css: [styles.indicator, props34.css]
    }
  );
});
var CheckboxControl2 = withContext10(
  checkbox_exports.Control,
  "control",
  {
    forwardAsChild: true,
    defaultProps: { children: (0, import_jsx_runtime429.jsx)(CheckboxIndicator2, {}) }
  }
);
var CheckboxGroup2 = chakra(
  checkbox_exports.Group,
  {
    base: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    }
  },
  { forwardAsChild: true }
);
var CheckboxContext2 = checkbox_exports.Context;
var CheckboxHiddenInput2 = checkbox_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/checkbox/namespace.js
var namespace_exports8 = {};
__export(namespace_exports8, {
  Context: () => CheckboxContext2,
  Control: () => CheckboxControl2,
  Group: () => CheckboxGroup2,
  HiddenInput: () => CheckboxHiddenInput2,
  Indicator: () => CheckboxIndicator2,
  Label: () => CheckboxLabel2,
  PropsProvider: () => CheckboxPropsProvider,
  Root: () => CheckboxRoot2,
  RootProvider: () => CheckboxRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/checkbox-card/checkbox-card.js
var import_jsx_runtime430 = __toESM(require_jsx_runtime(), 1);
var import_react905 = __toESM(require_react(), 1);
var {
  withProvider: withProvider8,
  withContext: withContext11,
  useStyles: useCheckboxCardStyles,
  PropsProvider: PropsProvider12
} = createSlotRecipeContext({ key: "checkboxCard" });
var CheckboxCardRootProvider = withProvider8(checkbox_exports.RootProvider, "root", { forwardAsChild: true });
var CheckboxCardRoot = withProvider8(checkbox_exports.Root, "root", { forwardAsChild: true });
var CheckboxCardRootPropsProvider = PropsProvider12;
var CheckboxCardLabel = withContext11(checkbox_exports.Label, "label", { forwardAsChild: true });
var CheckboxCardDescription = (0, import_react905.forwardRef)(function CheckboxCardDescription2(props34, ref2) {
  const styles = useCheckboxCardStyles();
  const api = useCheckboxContext();
  return (0, import_jsx_runtime430.jsx)(
    chakra.div,
    {
      ref: ref2,
      ...props34,
      css: [styles.description, props34.css],
      "data-disabled": api.disabled ? "" : void 0,
      "data-state": api.checked ? "checked" : "unchecked"
    }
  );
});
var CheckboxCardControl = withContext11(checkbox_exports.Control, "control", { forwardAsChild: true });
var CheckboxCardContent = withContext11("div", "content");
var CheckboxCardIndicator = (0, import_react905.forwardRef)(function CheckboxCardIndicator2(props34, ref2) {
  const api = useCheckboxContext();
  const styles = useCheckboxCardStyles();
  return (0, import_jsx_runtime430.jsx)(
    Checkmark,
    {
      ref: ref2,
      checked: api.checked,
      indeterminate: api.indeterminate,
      disabled: api.disabled,
      unstyled: true,
      ...props34,
      css: [styles.indicator, props34.css]
    }
  );
});
var CheckboxCardAddon = withContext11("div", "addon");
var CheckboxCardContext = checkbox_exports.Context;
var CheckboxCardHiddenInput = checkbox_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/checkbox-card/namespace.js
var namespace_exports9 = {};
__export(namespace_exports9, {
  Addon: () => CheckboxCardAddon,
  Content: () => CheckboxCardContent,
  Context: () => CheckboxCardContext,
  Control: () => CheckboxCardControl,
  Description: () => CheckboxCardDescription,
  HiddenInput: () => CheckboxCardHiddenInput,
  Indicator: () => CheckboxCardIndicator,
  Label: () => CheckboxCardLabel,
  Root: () => CheckboxCardRoot,
  RootPropsProvider: () => CheckboxCardRootPropsProvider,
  RootProvider: () => CheckboxCardRootProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/client-only/client-only.js
var import_jsx_runtime432 = __toESM(require_jsx_runtime(), 1);
var import_react907 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/show/show.js
var import_jsx_runtime431 = __toESM(require_jsx_runtime(), 1);
var import_react906 = __toESM(require_react(), 1);
function Show(props34) {
  const { when, fallback: fallback4, children } = props34;
  let result;
  if (!when) {
    result = fallback4;
  } else {
    result = typeof children === "function" ? children(when) : children;
  }
  return (0, import_react906.isValidElement)(result) ? result : (0, import_jsx_runtime431.jsx)(import_jsx_runtime431.Fragment, { children: result });
}

// node_modules/@chakra-ui/react/dist/esm/components/client-only/client-only.js
var ClientOnly2 = (props34) => {
  const { children, fallback: fallback4 } = props34;
  const [hasMounted, setHasMounted] = (0, import_react907.useState)(false);
  (0, import_react907.useEffect)(() => {
    setHasMounted(true);
  }, []);
  return (0, import_jsx_runtime432.jsx)(Show, { when: hasMounted, fallback: fallback4, children });
};

// node_modules/@chakra-ui/react/dist/esm/components/clipboard/clipboard.js
var {
  withProvider: withProvider9,
  withContext: withContext12,
  useStyles: useClipboardStyles,
  PropsProvider: PropsProvider13
} = createSlotRecipeContext({ key: "clipboard" });
var ClipboardRootProvider2 = withProvider9(clipboard_exports.RootProvider, "root", { forwardAsChild: true });
var ClipboardRoot2 = withProvider9(
  clipboard_exports.Root,
  "root",
  { forwardAsChild: true }
);
var ClipboardPropsProvider = PropsProvider13;
var ClipboardTrigger2 = withContext12(clipboard_exports.Trigger, "trigger", { forwardAsChild: true });
var ClipboardControl2 = withContext12(clipboard_exports.Control, "control", { forwardAsChild: true });
var ClipboardIndicator2 = withContext12(clipboard_exports.Indicator, "indicator", { forwardAsChild: true });
var ClipboardInput2 = withContext12(clipboard_exports.Input, "input", { forwardAsChild: true });
var ClipboardLabel2 = withContext12(clipboard_exports.Label, "label", { forwardAsChild: true });
var ClipboardContext2 = clipboard_exports.Context;
var ClipboardValueText2 = withContext12(clipboard_exports.ValueText, "valueText", { forwardAsChild: true });

// node_modules/@chakra-ui/react/dist/esm/components/clipboard/namespace.js
var namespace_exports10 = {};
__export(namespace_exports10, {
  Context: () => ClipboardContext2,
  Control: () => ClipboardControl2,
  Indicator: () => ClipboardIndicator2,
  Input: () => ClipboardInput2,
  Label: () => ClipboardLabel2,
  PropsProvider: () => ClipboardPropsProvider,
  Root: () => ClipboardRoot2,
  RootProvider: () => ClipboardRootProvider2,
  Trigger: () => ClipboardTrigger2,
  ValueText: () => ClipboardValueText2
});

// node_modules/@chakra-ui/react/dist/esm/components/code/code.js
var { withContext: withContext13, PropsProvider: PropsProvider14 } = createRecipeContext({
  key: "code"
});
var Code = withContext13("code");
var CodePropsProvider = PropsProvider14;

// node_modules/@chakra-ui/react/dist/esm/components/collapsible/collapsible.js
var {
  withProvider: withProvider10,
  withContext: withContext14,
  useStyles: useCollapsibleStyles,
  PropsProvider: PropsProvider15
} = createSlotRecipeContext({ key: "collapsible" });
var CollapsibleRootProvider2 = withProvider10(collapsible_exports.RootProvider, "root", { forwardAsChild: true });
var CollapsibleRoot2 = withProvider10(collapsible_exports.Root, "root", { forwardAsChild: true });
var CollapsiblePropsProvider = PropsProvider15;
var CollapsibleTrigger2 = withContext14(collapsible_exports.Trigger, "trigger", { forwardAsChild: true });
var CollapsibleContent2 = withContext14(collapsible_exports.Content, "content", { forwardAsChild: true });
var CollapsibleContext2 = collapsible_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/collapsible/namespace.js
var namespace_exports11 = {};
__export(namespace_exports11, {
  Content: () => CollapsibleContent2,
  Context: () => CollapsibleContext2,
  PropsProvider: () => CollapsiblePropsProvider,
  Root: () => CollapsibleRoot2,
  RootProvider: () => CollapsibleRootProvider2,
  Trigger: () => CollapsibleTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/color-picker/color-picker.js
var {
  withProvider: withProvider11,
  withContext: withContext15,
  useStyles: useColorPickerStyles,
  PropsProvider: PropsProvider16
} = createSlotRecipeContext({ key: "colorPicker" });
var ColorPickerRootProvider2 = withProvider11(color_picker_exports.RootProvider, "root", { forwardAsChild: true });
var ColorPickerRoot2 = withProvider11(color_picker_exports.Root, "root", { forwardAsChild: true });
var ColorPickerPropsProvider = PropsProvider16;
var ColorPickerLabel2 = withContext15(color_picker_exports.Label, "label", { forwardAsChild: true });
var ColorPickerControl2 = withContext15(color_picker_exports.Control, "control", { forwardAsChild: true });
var ColorPickerTrigger2 = withContext15(color_picker_exports.Trigger, "trigger", { forwardAsChild: true });
var ColorPickerPositioner2 = withContext15(color_picker_exports.Positioner, "positioner", { forwardAsChild: true });
var ColorPickerContent2 = withContext15(color_picker_exports.Content, "content", { forwardAsChild: true });
var ColorPickerArea2 = withContext15(color_picker_exports.Area, "area", { forwardAsChild: true });
var ColorPickerAreaBackground2 = withContext15(color_picker_exports.AreaBackground, "areaBackground", { forwardAsChild: true });
var ColorPickerAreaThumb2 = withContext15(color_picker_exports.AreaThumb, "areaThumb", { forwardAsChild: true });
var ColorPickerChannelSlider2 = withContext15(color_picker_exports.ChannelSlider, "channelSlider", { forwardAsChild: true });
var ColorPickerChannelSliderTrack2 = withContext15(color_picker_exports.ChannelSliderTrack, "channelSliderTrack", {
  forwardAsChild: true
});
var ColorPickerChannelSliderThumb2 = withContext15(color_picker_exports.ChannelSliderThumb, "channelSliderThumb", {
  forwardAsChild: true
});
var ColorPickerChannelInput2 = withContext15(color_picker_exports.ChannelInput, "channelInput", { forwardAsChild: true });
var ColorPickerTransparencyGrid2 = withContext15(color_picker_exports.TransparencyGrid, "transparencyGrid", { forwardAsChild: true });
var ColorPickerSwatchGroup2 = withContext15(color_picker_exports.SwatchGroup, "swatchGroup", { forwardAsChild: true });
var ColorPickerSwatchTrigger2 = withContext15(color_picker_exports.SwatchTrigger, "swatchTrigger", { forwardAsChild: true });
var ColorPickerSwatch2 = withContext15(color_picker_exports.Swatch, "swatch", { forwardAsChild: true });
var ColorPickerSwatchIndicator2 = withContext15(color_picker_exports.SwatchIndicator, "swatchIndicator", { forwardAsChild: true });
var ColorPickerValueText2 = withContext15(color_picker_exports.ValueText, "valueText", { forwardAsChild: true });
var ColorPickerValueSwatch2 = withContext15(color_picker_exports.ValueSwatch, "swatch", { forwardAsChild: true });
var ColorPickerView2 = withContext15(color_picker_exports.View, "view", { forwardAsChild: true });
var ColorPickerFormatTrigger2 = withContext15(color_picker_exports.FormatTrigger, "formatTrigger", { forwardAsChild: true });
var ColorPickerFormatSelect2 = withContext15(color_picker_exports.FormatSelect, "formatSelect", { forwardAsChild: true });
var ColorPickerEyeDropperTrigger2 = withContext15(color_picker_exports.EyeDropperTrigger, "eyeDropperTrigger", {
  forwardAsChild: true
});
var ColorPickerChannelSliderValueText2 = withContext15(color_picker_exports.ChannelSliderValueText, "channelSliderValueText", {
  forwardAsChild: true
});
var ColorPickerChannelSliderLabel2 = withContext15(color_picker_exports.ChannelSliderLabel, "channelSliderLabel", {
  forwardAsChild: true
});
var ColorPickerHiddenInput2 = color_picker_exports.HiddenInput;
var ColorPickerContext2 = color_picker_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/color-picker/namespace.js
var namespace_exports12 = {};
__export(namespace_exports12, {
  Area: () => ColorPickerArea2,
  AreaBackground: () => ColorPickerAreaBackground2,
  AreaThumb: () => ColorPickerAreaThumb2,
  ChannelInput: () => ColorPickerChannelInput2,
  ChannelSlider: () => ColorPickerChannelSlider2,
  ChannelSliderLabel: () => ColorPickerChannelSliderLabel2,
  ChannelSliderThumb: () => ColorPickerChannelSliderThumb2,
  ChannelSliderTrack: () => ColorPickerChannelSliderTrack2,
  ChannelSliderValueText: () => ColorPickerChannelSliderValueText2,
  Content: () => ColorPickerContent2,
  Context: () => ColorPickerContext2,
  Control: () => ColorPickerControl2,
  EyeDropperTrigger: () => ColorPickerEyeDropperTrigger2,
  FormatSelect: () => ColorPickerFormatSelect2,
  FormatTrigger: () => ColorPickerFormatTrigger2,
  HiddenInput: () => ColorPickerHiddenInput2,
  Label: () => ColorPickerLabel2,
  Positioner: () => ColorPickerPositioner2,
  PropsProvider: () => ColorPickerPropsProvider,
  Root: () => ColorPickerRoot2,
  RootProvider: () => ColorPickerRootProvider2,
  Swatch: () => ColorPickerSwatch2,
  SwatchGroup: () => ColorPickerSwatchGroup2,
  SwatchIndicator: () => ColorPickerSwatchIndicator2,
  SwatchTrigger: () => ColorPickerSwatchTrigger2,
  TransparencyGrid: () => ColorPickerTransparencyGrid2,
  Trigger: () => ColorPickerTrigger2,
  ValueSwatch: () => ColorPickerValueSwatch2,
  ValueText: () => ColorPickerValueText2,
  View: () => ColorPickerView2
});

// node_modules/@chakra-ui/react/dist/esm/components/container/container.js
var { withContext: withContext16, PropsProvider: PropsProvider17 } = createRecipeContext({
  key: "container"
});
var Container = withContext16("div");
var ContainerPropsProvider = PropsProvider17;

// node_modules/@chakra-ui/react/dist/esm/components/data-list/data-list.js
var {
  withProvider: withProvider12,
  withContext: withContext17,
  useStyles: useDataListStyles,
  PropsProvider: PropsProvider18
} = createSlotRecipeContext({ key: "dataList" });
var DataListRoot = withProvider12(
  "dl",
  "root"
);
var DataListPropsProvider = PropsProvider18;
var DataListItem = withContext17(
  "div",
  "item"
);
var DataListItemLabel = withContext17("dt", "itemLabel");
var DataListItemValue = withContext17("dd", "itemValue");

// node_modules/@chakra-ui/react/dist/esm/components/data-list/namespace.js
var namespace_exports13 = {};
__export(namespace_exports13, {
  Item: () => DataListItem,
  ItemLabel: () => DataListItemLabel,
  ItemValue: () => DataListItemValue,
  PropsProvider: () => DataListPropsProvider,
  Root: () => DataListRoot
});

// node_modules/@chakra-ui/react/dist/esm/components/dialog/dialog.js
var import_jsx_runtime433 = __toESM(require_jsx_runtime(), 1);
var import_react908 = __toESM(require_react(), 1);
var {
  withRootProvider: withRootProvider2,
  withContext: withContext18,
  useStyles: useDialogStyles,
  PropsProvider: PropsProvider19
} = createSlotRecipeContext({ key: "dialog" });
var DialogRootProvider2 = withRootProvider2(
  dialog_exports.RootProvider,
  {
    defaultProps: { unmountOnExit: true, lazyMount: true }
  }
);
var DialogRoot2 = withRootProvider2(dialog_exports.Root, {
  defaultProps: { unmountOnExit: true, lazyMount: true }
});
var DialogPropsProvider = PropsProvider19;
var DialogTrigger2 = withContext18(
  dialog_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var DialogPositioner2 = withContext18(dialog_exports.Positioner, "positioner", { forwardAsChild: true });
var DialogContent2 = withContext18(
  dialog_exports.Content,
  "content",
  { forwardAsChild: true }
);
var DialogDescription2 = withContext18(dialog_exports.Description, "description", { forwardAsChild: true });
var DialogTitle2 = withContext18(
  dialog_exports.Title,
  "title",
  { forwardAsChild: true }
);
var DialogCloseTrigger2 = withContext18(dialog_exports.CloseTrigger, "closeTrigger", { forwardAsChild: true });
var DialogActionTrigger = (0, import_react908.forwardRef)(function DialogActionTrigger2(props34, ref2) {
  const dialog = useDialogContext();
  return (0, import_jsx_runtime433.jsx)(chakra.button, { ...props34, ref: ref2, onClick: () => dialog.setOpen(false) });
});
var DialogBackdrop2 = withContext18(
  dialog_exports.Backdrop,
  "backdrop",
  { forwardAsChild: true }
);
var DialogBody = withContext18(
  "div",
  "body"
);
var DialogFooter = withContext18(
  "div",
  "footer"
);
var DialogHeader = withContext18(
  "div",
  "header"
);
var DialogContext2 = dialog_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/dialog/namespace.js
var namespace_exports14 = {};
__export(namespace_exports14, {
  ActionTrigger: () => DialogActionTrigger,
  Backdrop: () => DialogBackdrop2,
  Body: () => DialogBody,
  CloseTrigger: () => DialogCloseTrigger2,
  Content: () => DialogContent2,
  Context: () => DialogContext2,
  Description: () => DialogDescription2,
  Footer: () => DialogFooter,
  Header: () => DialogHeader,
  Positioner: () => DialogPositioner2,
  PropsProvider: () => DialogPropsProvider,
  Root: () => DialogRoot2,
  RootProvider: () => DialogRootProvider2,
  Title: () => DialogTitle2,
  Trigger: () => DialogTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/drawer/drawer.js
var import_jsx_runtime434 = __toESM(require_jsx_runtime(), 1);
var import_react909 = __toESM(require_react(), 1);
var {
  withRootProvider: withRootProvider3,
  withContext: withContext19,
  useStyles: useDrawerStyles,
  PropsProvider: PropsProvider20
} = createSlotRecipeContext({ key: "drawer" });
var DrawerRootProvider = withRootProvider3(
  dialog_exports.RootProvider,
  {
    defaultProps: { unmountOnExit: true, lazyMount: true }
  }
);
var DrawerRoot = withRootProvider3(dialog_exports.Root, {
  defaultProps: { unmountOnExit: true, lazyMount: true }
});
var DrawerRootPropsProvider = PropsProvider20;
var DrawerTrigger = withContext19(
  dialog_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var DrawerPositioner = withContext19(dialog_exports.Positioner, "positioner", { forwardAsChild: true });
var DrawerContent = withContext19(
  dialog_exports.Content,
  "content",
  { forwardAsChild: true }
);
var DrawerDescription = withContext19(dialog_exports.Description, "description", { forwardAsChild: true });
var DrawerTitle = withContext19(
  dialog_exports.Title,
  "title",
  { forwardAsChild: true }
);
var DrawerCloseTrigger = withContext19(dialog_exports.CloseTrigger, "closeTrigger", { forwardAsChild: true });
var DrawerActionTrigger = (0, import_react909.forwardRef)(function DrawerActionTrigger2(props34, ref2) {
  const drawer = useDialogContext();
  return (0, import_jsx_runtime434.jsx)(chakra.button, { ...props34, ref: ref2, onClick: () => drawer.setOpen(false) });
});
var DrawerBackdrop = withContext19(
  dialog_exports.Backdrop,
  "backdrop",
  { forwardAsChild: true }
);
var DrawerBody = withContext19(
  "div",
  "body"
);
var DrawerFooter = withContext19(
  "div",
  "footer"
);
var DrawerHeader = withContext19(
  "div",
  "header"
);
var DrawerContext = dialog_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/drawer/namespace.js
var namespace_exports15 = {};
__export(namespace_exports15, {
  ActionTrigger: () => DrawerActionTrigger,
  Backdrop: () => DrawerBackdrop,
  Body: () => DrawerBody,
  CloseTrigger: () => DrawerCloseTrigger,
  Content: () => DrawerContent,
  Context: () => DrawerContext,
  Description: () => DrawerDescription,
  Footer: () => DrawerFooter,
  Header: () => DrawerHeader,
  Positioner: () => DrawerPositioner,
  Root: () => DrawerRoot,
  RootPropsProvider: () => DrawerRootPropsProvider,
  RootProvider: () => DrawerRootProvider,
  Title: () => DrawerTitle,
  Trigger: () => DrawerTrigger
});

// node_modules/@chakra-ui/react/dist/esm/components/editable/editable.js
var import_jsx_runtime435 = __toESM(require_jsx_runtime(), 1);
var import_react910 = __toESM(require_react(), 1);
var {
  withProvider: withProvider13,
  withContext: withContext20,
  useStyles: useEditableStyles,
  PropsProvider: PropsProvider21
} = createSlotRecipeContext({ key: "editable" });
var EditableRootProvider2 = withProvider13(editable_exports.RootProvider, "root", { forwardAsChild: true });
var EditableRoot2 = withProvider13(
  editable_exports.Root,
  "root",
  { forwardAsChild: true }
);
var EditablePropsProvider = PropsProvider21;
var EditablePreview2 = withContext20(editable_exports.Preview, "preview", { forwardAsChild: true });
var EditableInput2 = withContext20(
  editable_exports.Input,
  "input",
  { forwardAsChild: true }
);
var ArkEditableTextarea = (0, import_react910.forwardRef)(function EditableTextarea2(props34, ref2) {
  const editable = useEditableContext();
  const mergedProps = mergeProps(editable.getInputProps(), props34);
  return (0, import_jsx_runtime435.jsx)(ark.textarea, { ref: ref2, ...mergedProps });
});
var EditableTextarea = withContext20(ArkEditableTextarea, "input", { forwardAsChild: true });
var EditableControl2 = withContext20(editable_exports.Control, "control", { forwardAsChild: true });
var EditableArea2 = withContext20(
  editable_exports.Area,
  "area",
  { forwardAsChild: true }
);
var EditableEditTrigger2 = withContext20(editable_exports.EditTrigger, "editTrigger", { forwardAsChild: true });
var EditableSubmitTrigger2 = withContext20(editable_exports.SubmitTrigger, "submitTrigger", { forwardAsChild: true });
var EditableCancelTrigger2 = withContext20(editable_exports.CancelTrigger, "cancelTrigger", { forwardAsChild: true });
var EditableContext2 = editable_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/editable/namespace.js
var namespace_exports16 = {};
__export(namespace_exports16, {
  Area: () => EditableArea2,
  CancelTrigger: () => EditableCancelTrigger2,
  Context: () => EditableContext2,
  Control: () => EditableControl2,
  EditTrigger: () => EditableEditTrigger2,
  Input: () => EditableInput2,
  Preview: () => EditablePreview2,
  PropsProvider: () => EditablePropsProvider,
  Root: () => EditableRoot2,
  RootProvider: () => EditableRootProvider2,
  SubmitTrigger: () => EditableSubmitTrigger2,
  Textarea: () => EditableTextarea
});

// node_modules/@chakra-ui/react/dist/esm/components/empty-state/empty-state.js
var {
  withProvider: withProvider14,
  withContext: withContext21,
  useStyles: useEmptyStateStyles,
  PropsProvider: PropsProvider22
} = createSlotRecipeContext({ key: "emptyState" });
var EmptyStateRoot = withProvider14(
  "div",
  "root"
);
var EmptyStatePropsProvider = PropsProvider22;
var EmptyStateContent = withContext21("div", "content");
var EmptyStateIndicator = withContext21("div", "indicator");
var EmptyStateTitle = withContext21("h3", "title");
var EmptyStateDescription = withContext21("p", "description");

// node_modules/@chakra-ui/react/dist/esm/components/empty-state/namespace.js
var namespace_exports17 = {};
__export(namespace_exports17, {
  Content: () => EmptyStateContent,
  Description: () => EmptyStateDescription,
  Indicator: () => EmptyStateIndicator,
  PropsProvider: () => EmptyStatePropsProvider,
  Root: () => EmptyStateRoot,
  Title: () => EmptyStateTitle
});

// node_modules/@chakra-ui/react/dist/esm/components/field/field.js
var import_jsx_runtime438 = __toESM(require_jsx_runtime(), 1);
var import_react912 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/icon/create-icon.js
var import_jsx_runtime437 = __toESM(require_jsx_runtime(), 1);
var import_react911 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/icon/icon.js
var import_jsx_runtime436 = __toESM(require_jsx_runtime(), 1);
var React8 = __toESM(require_react(), 1);
var { useRecipeResult: useRecipeResult3, PropsProvider: PropsProvider23 } = createRecipeContext({ key: "icon" });
var Icon = React8.forwardRef(
  function Icon2(props34, ref2) {
    const {
      styles,
      className,
      props: otherProps
    } = useRecipeResult3({ asChild: !props34.as, ...props34 });
    return (0, import_jsx_runtime436.jsx)(
      chakra.svg,
      {
        ref: ref2,
        focusable: false,
        "aria-hidden": "true",
        ...otherProps,
        css: [styles, props34.css],
        className: cx(className, props34.className)
      }
    );
  }
);
var IconPropsProvider = PropsProvider23;

// node_modules/@chakra-ui/react/dist/esm/components/icon/create-icon.js
function createIcon(options) {
  const {
    viewBox = "0 0 24 24",
    d: pathDefinition,
    displayName,
    defaultProps = {}
  } = options;
  const path = import_react911.Children.toArray(options.path);
  const Comp = (0, import_react911.forwardRef)((props34, ref2) => (0, import_jsx_runtime437.jsx)(
    Icon,
    {
      ref: ref2,
      asChild: false,
      viewBox,
      ...defaultProps,
      ...props34,
      children: path.length ? path : (0, import_jsx_runtime437.jsx)("path", { fill: "currentColor", d: pathDefinition })
    }
  ));
  Comp.displayName = displayName;
  return Comp;
}

// node_modules/@chakra-ui/react/dist/esm/components/field/field.js
var {
  withProvider: withProvider15,
  withContext: withContext22,
  useStyles: useFieldStyles,
  useClassNames: useClassNames2,
  PropsProvider: PropsProvider24
} = createSlotRecipeContext({ key: "field" });
var FieldRoot2 = withProvider15(
  field_exports.Root,
  "root",
  { forwardAsChild: true }
);
var FieldPropsProvider = PropsProvider24;
var FieldLabel2 = withContext22(
  field_exports.Label,
  "label",
  { forwardAsChild: true }
);
var FieldHelperText2 = withContext22(field_exports.HelperText, "helperText", { forwardAsChild: true });
var FieldErrorText2 = withContext22(
  field_exports.ErrorText,
  "errorText",
  { forwardAsChild: true }
);
var FieldErrorIcon = createIcon({
  d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
});
var FieldRequiredIndicator2 = (0, import_react912.forwardRef)(function RequiredIndicator(props34, ref2) {
  const { fallback: fallback4, children = "*", ...restProps } = props34;
  const field = useFieldContext();
  const classNames = useClassNames2();
  const styles = useFieldStyles();
  if (!(field == null ? void 0 : field.required)) {
    return fallback4;
  }
  return (0, import_jsx_runtime438.jsx)(
    chakra.span,
    {
      ref: ref2,
      "aria-hidden": "true",
      ...restProps,
      className: cx(classNames.requiredIndicator, props34.className),
      css: [styles.requiredIndicator, props34.css],
      children
    }
  );
});

// node_modules/@chakra-ui/react/dist/esm/components/field/namespace.js
var namespace_exports18 = {};
__export(namespace_exports18, {
  ErrorIcon: () => FieldErrorIcon,
  ErrorText: () => FieldErrorText2,
  HelperText: () => FieldHelperText2,
  Label: () => FieldLabel2,
  PropsProvider: () => FieldPropsProvider,
  RequiredIndicator: () => FieldRequiredIndicator2,
  Root: () => FieldRoot2
});

// node_modules/@chakra-ui/react/dist/esm/components/fieldset/fieldset.js
var { withProvider: withProvider16, withContext: withContext23 } = createSlotRecipeContext({
  key: "fieldset"
});
var FieldsetRoot2 = withProvider16(fieldset_exports.Root, "root");
var FieldsetErrorText2 = withContext23(fieldset_exports.ErrorText, "errorText");
var FieldsetHelperText2 = withContext23(fieldset_exports.HelperText, "helperText");
var FieldsetLegend2 = withContext23(fieldset_exports.Legend, "legend");
var FieldsetContent = withContext23(ark.div, "content");
var FieldsetContext2 = fieldset_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/fieldset/namespace.js
var namespace_exports19 = {};
__export(namespace_exports19, {
  Content: () => FieldsetContent,
  Context: () => FieldsetContext2,
  ErrorText: () => FieldsetErrorText2,
  HelperText: () => FieldsetHelperText2,
  Legend: () => FieldsetLegend2,
  Root: () => FieldsetRoot2
});

// node_modules/@chakra-ui/react/dist/esm/components/file-upload/file-upload.js
var import_jsx_runtime439 = __toESM(require_jsx_runtime(), 1);
var import_react913 = __toESM(require_react(), 1);
var {
  withProvider: withProvider17,
  withContext: withContext24,
  useStyles: useFileUploadStyles,
  PropsProvider: PropsProvider25
} = createSlotRecipeContext({ key: "fileUpload" });
var FileUploadRootProvider2 = withProvider17(file_upload_exports.RootProvider, "root", { forwardAsChild: true });
var FileUploadRoot2 = withProvider17(
  file_upload_exports.Root,
  "root",
  { forwardAsChild: true }
);
var FileUploadPropsProvider = PropsProvider25;
var FileUploadClearTrigger2 = (0, import_react913.forwardRef)(function FileUploadClearTrigger22(props34, ref2) {
  const fileUpload = useFileUploadContext();
  return (0, import_jsx_runtime439.jsx)(
    chakra.button,
    {
      ref: ref2,
      type: "button",
      "data-scope": "file-upload",
      "data-part": "clear-trigger",
      "aria-label": "Clear selected files",
      hidden: fileUpload.acceptedFiles.length === 0,
      ...props34,
      onClick: (event) => {
        var _a8;
        (_a8 = props34.onClick) == null ? void 0 : _a8.call(props34, event);
        if (event.defaultPrevented) return;
        fileUpload.clearFiles();
      }
    }
  );
});
var FileUploadDropzone2 = withContext24(file_upload_exports.Dropzone, "dropzone", { forwardAsChild: true });
var FileUploadDropzoneContent = withContext24("div", "dropzoneContent");
var FileUploadItem2 = withContext24(
  file_upload_exports.Item,
  "item",
  { forwardAsChild: true }
);
var FileUploadItemContent = withContext24("div", "itemContent");
var FileUploadItemDeleteTrigger2 = withContext24(file_upload_exports.ItemDeleteTrigger, "itemDeleteTrigger", {
  forwardAsChild: true
});
var FileUploadItemGroup2 = withContext24(file_upload_exports.ItemGroup, "itemGroup", { forwardAsChild: true });
var FileUploadItemName2 = withContext24(file_upload_exports.ItemName, "itemName", { forwardAsChild: true });
var FileUploadItemPreview2 = withContext24(file_upload_exports.ItemPreview, "itemPreview", { forwardAsChild: true });
var FileUploadItemPreviewImage2 = withContext24(file_upload_exports.ItemPreviewImage, "itemPreviewImage", { forwardAsChild: true });
var FileUploadItemSizeText2 = withContext24(file_upload_exports.ItemSizeText, "itemSizeText", { forwardAsChild: true });
var FileUploadLabel2 = withContext24(file_upload_exports.Label, "label", { forwardAsChild: true });
var FileUploadTrigger2 = withContext24(file_upload_exports.Trigger, "trigger", { forwardAsChild: true });
var FileUploadContext2 = file_upload_exports.Context;
var FileUploadHiddenInput2 = file_upload_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/file-upload/namespace.js
var namespace_exports20 = {};
__export(namespace_exports20, {
  ClearTrigger: () => FileUploadClearTrigger2,
  Context: () => FileUploadContext2,
  Dropzone: () => FileUploadDropzone2,
  DropzoneContent: () => FileUploadDropzoneContent,
  HiddenInput: () => FileUploadHiddenInput2,
  Item: () => FileUploadItem2,
  ItemContent: () => FileUploadItemContent,
  ItemDeleteTrigger: () => FileUploadItemDeleteTrigger2,
  ItemGroup: () => FileUploadItemGroup2,
  ItemName: () => FileUploadItemName2,
  ItemPreview: () => FileUploadItemPreview2,
  ItemPreviewImage: () => FileUploadItemPreviewImage2,
  ItemSizeText: () => FileUploadItemSizeText2,
  Label: () => FileUploadLabel2,
  PropsProvider: () => FileUploadPropsProvider,
  Root: () => FileUploadRoot2,
  RootProvider: () => FileUploadRootProvider2,
  Trigger: () => FileUploadTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/flex/flex.js
var import_jsx_runtime440 = __toESM(require_jsx_runtime(), 1);
var import_react914 = __toESM(require_react(), 1);
var Flex = (0, import_react914.forwardRef)(
  function Flex2(props34, ref2) {
    const {
      direction,
      align,
      justify,
      wrap: wrap5,
      basis,
      grow,
      shrink,
      inline: inline2,
      ...rest
    } = props34;
    return (0, import_jsx_runtime440.jsx)(
      chakra.div,
      {
        ref: ref2,
        ...rest,
        css: {
          display: inline2 ? "inline-flex" : "flex",
          flexDirection: direction,
          alignItems: align,
          justifyContent: justify,
          flexWrap: wrap5,
          flexBasis: basis,
          flexGrow: grow,
          flexShrink: shrink,
          ...props34.css
        }
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/float/float.js
var import_jsx_runtime441 = __toESM(require_jsx_runtime(), 1);
var import_react915 = __toESM(require_react(), 1);
var Float = (0, import_react915.forwardRef)(
  function Float2(props34, ref2) {
    const {
      offsetX,
      offsetY,
      offset: offset3 = "0",
      placement = "top-end",
      ...rest
    } = props34;
    const styles = (0, import_react915.useMemo)(
      () => ({
        display: "inline-flex",
        justifyContent: "center",
        alignItems: "center",
        position: "absolute",
        insetBlockStart: mapObject(placement, (v) => {
          const [side] = v.split("-");
          const map2 = {
            top: offsetY ?? offset3,
            middle: "50%",
            bottom: "auto"
          };
          return map2[side];
        }),
        insetBlockEnd: mapObject(placement, (v) => {
          const [side] = v.split("-");
          const map2 = {
            top: "auto",
            middle: "50%",
            bottom: offsetY ?? offset3
          };
          return map2[side];
        }),
        insetStart: mapObject(placement, (v) => {
          const [, align] = v.split("-");
          const map2 = {
            start: offsetX ?? offset3,
            center: "50%",
            end: "auto"
          };
          return map2[align];
        }),
        insetEnd: mapObject(placement, (v) => {
          const [, align] = v.split("-");
          const map2 = {
            start: "auto",
            center: "50%",
            end: offsetX ?? offset3
          };
          return map2[align];
        }),
        translate: mapObject(placement, (v) => {
          const [side, align] = v.split("-");
          const mapX = { start: "-50%", center: "-50%", end: "50%" };
          const mapY = { top: "-50%", middle: "-50%", bottom: "50%" };
          return `${mapX[align]} ${mapY[side]}`;
        })
      }),
      [offset3, offsetX, offsetY, placement]
    );
    return (0, import_jsx_runtime441.jsx)(chakra.div, { ref: ref2, css: styles, ...rest });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/focus-trap/focus-trap.js
var FocusTrap3 = chakra(FocusTrap2);

// node_modules/@chakra-ui/react/dist/esm/components/for/for.js
function For(props34) {
  const { each: each2, fallback: fallback4, children } = props34;
  if ((each2 == null ? void 0 : each2.length) === 0) {
    return fallback4 || null;
  }
  return each2 == null ? void 0 : each2.map(children);
}

// node_modules/@chakra-ui/react/dist/esm/components/grid/grid-item.js
var import_jsx_runtime442 = __toESM(require_jsx_runtime(), 1);
var import_react916 = __toESM(require_react(), 1);
function spanFn(span) {
  return mapObject(
    span,
    (value) => value === "auto" ? "auto" : `span ${value}/span ${value}`
  );
}
var GridItem = (0, import_react916.forwardRef)(
  function GridItem2(props34, ref2) {
    const {
      area,
      colSpan,
      colStart,
      colEnd,
      rowEnd,
      rowSpan,
      rowStart,
      ...rest
    } = props34;
    const styles = compact({
      gridArea: area,
      gridColumn: spanFn(colSpan),
      gridRow: spanFn(rowSpan),
      gridColumnStart: colStart,
      gridColumnEnd: colEnd,
      gridRowStart: rowStart,
      gridRowEnd: rowEnd
    });
    return (0, import_jsx_runtime442.jsx)(chakra.div, { ref: ref2, css: styles, ...rest });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/grid/simple-grid.js
var import_jsx_runtime443 = __toESM(require_jsx_runtime(), 1);
var import_react917 = __toESM(require_react(), 1);
var SimpleGrid = (0, import_react917.forwardRef)(
  function SimpleGrid2(props34, ref2) {
    const { columns, minChildWidth, ...rest } = props34;
    const sys = useChakraContext();
    const templateColumns = minChildWidth ? widthToColumns(minChildWidth, sys) : countToColumns(columns);
    return (0, import_jsx_runtime443.jsx)(Grid, { ref: ref2, templateColumns, ...rest });
  }
);
function toPx2(n) {
  return typeof n === "number" ? `${n}px` : n;
}
function widthToColumns(width, sys) {
  return mapObject(width, (value) => {
    const _value = sys.tokens.getVar(`sizes.${value}`, toPx2(value));
    return value === null ? null : `repeat(auto-fit, minmax(${_value}, 1fr))`;
  });
}
function countToColumns(count) {
  return mapObject(
    count,
    (value) => value === null ? null : `repeat(${value}, minmax(0, 1fr))`
  );
}

// node_modules/@chakra-ui/react/dist/esm/components/highlight/highlight.js
var import_jsx_runtime444 = __toESM(require_jsx_runtime(), 1);
var import_react918 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/typography/mark.js
var { withContext: withContext25, PropsProvider: PropsProvider26 } = createRecipeContext({
  key: "mark"
});
var Mark = withContext25("mark");
var MarkPropsProvider = PropsProvider26;

// node_modules/@chakra-ui/react/dist/esm/components/highlight/highlight.js
function Highlight2(props34) {
  const { children, query: query2, ignoreCase, matchAll, styles } = props34;
  if (typeof children !== "string") {
    throw new Error("The children prop of Highlight must be a string");
  }
  const chunks = useHighlight({
    query: query2,
    text: children,
    matchAll,
    ignoreCase
  });
  return (0, import_jsx_runtime444.jsx)(For, { each: chunks, children: (chunk2, index) => {
    return chunk2.match ? (0, import_jsx_runtime444.jsx)(Mark, { css: styles, children: chunk2.text }, index) : (0, import_jsx_runtime444.jsx)(import_react918.Fragment, { children: chunk2.text }, index);
  } });
}

// node_modules/@chakra-ui/react/dist/esm/components/hover-card/hover-card.js
var import_jsx_runtime445 = __toESM(require_jsx_runtime(), 1);
var {
  withRootProvider: withRootProvider4,
  withContext: withContext26,
  useStyles: useHoverCardStyles,
  PropsProvider: PropsProvider27
} = createSlotRecipeContext({ key: "hoverCard" });
var HoverCardRootProvider2 = withRootProvider4(hover_card_exports.RootProvider);
var HoverCardRoot2 = withRootProvider4(
  hover_card_exports.Root
);
var HoverCardPropsProvider = PropsProvider27;
var HoverCardTrigger2 = withContext26(hover_card_exports.Trigger, "trigger", { forwardAsChild: true });
var HoverCardPositioner2 = withContext26(hover_card_exports.Positioner, "positioner", { forwardAsChild: true });
var HoverCardContent2 = withContext26(hover_card_exports.Content, "content", { forwardAsChild: true });
var HoverCardArrowTip2 = withContext26(hover_card_exports.ArrowTip, "arrowTip", { forwardAsChild: true });
var HoverCardArrow2 = withContext26(
  hover_card_exports.Arrow,
  "arrow",
  {
    forwardAsChild: true,
    defaultProps: { children: (0, import_jsx_runtime445.jsx)(HoverCardArrowTip2, {}) }
  }
);
var HoverCardContext2 = hover_card_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/hover-card/namespace.js
var namespace_exports21 = {};
__export(namespace_exports21, {
  Arrow: () => HoverCardArrow2,
  ArrowTip: () => HoverCardArrowTip2,
  Content: () => HoverCardContent2,
  Context: () => HoverCardContext2,
  Positioner: () => HoverCardPositioner2,
  PropsProvider: () => HoverCardPropsProvider,
  Root: () => HoverCardRoot2,
  RootProvider: () => HoverCardRootProvider2,
  Trigger: () => HoverCardTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/image/image.js
var import_jsx_runtime446 = __toESM(require_jsx_runtime(), 1);
var import_react919 = __toESM(require_react(), 1);
var Image = (0, import_react919.forwardRef)(
  function Image2(props34, ref2) {
    const { align, fit = "cover", ...rest } = props34;
    return (0, import_jsx_runtime446.jsx)(
      chakra.img,
      {
        ref: ref2,
        objectFit: fit,
        objectPosition: align,
        className: cx("chakra-image", props34.className),
        ...rest
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/input/input.js
var { withContext: withContext27, PropsProvider: PropsProvider28 } = createRecipeContext({
  key: "input"
});
var Input = withContext27(field_exports.Input);
var InputPropsProvider = PropsProvider28;

// node_modules/@chakra-ui/react/dist/esm/components/input/input-addon.js
var import_jsx_runtime447 = __toESM(require_jsx_runtime(), 1);
var import_react920 = __toESM(require_react(), 1);
var InputAddon = (0, import_react920.forwardRef)(
  function InputAddon2({ unstyled, ...props34 }, ref2) {
    const recipe = useRecipe({ key: "inputAddon", recipe: props34.recipe });
    const [variantProps, localProps] = recipe.splitVariantProps(props34);
    const styles = unstyled ? EMPTY_SLOT_STYLES : recipe(variantProps);
    return (0, import_jsx_runtime447.jsx)(chakra.div, { ref: ref2, ...localProps, css: [styles, props34.css] });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/input/input-element.js
var InputElement = chakra("div", {
  base: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "absolute",
    zIndex: 2,
    color: "fg.subtle",
    height: "full",
    fontSize: "sm",
    px: "3"
  },
  variants: {
    placement: {
      start: {
        insetInlineStart: "0"
      },
      end: {
        insetInlineEnd: "0"
      }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/kbd/kbd.js
var { withContext: withContext28, PropsProvider: PropsProvider29 } = createRecipeContext({
  key: "kbd"
});
var Kbd = withContext28("kbd");

// node_modules/@chakra-ui/react/dist/esm/components/link/link.js
var { withContext: withContext29, PropsProvider: PropsProvider30 } = createRecipeContext({
  key: "link"
});
var Link = withContext29("a");
var LinkPropsProvider = PropsProvider30;

// node_modules/@chakra-ui/react/dist/esm/components/link/link-box.js
var import_jsx_runtime448 = __toESM(require_jsx_runtime(), 1);
var import_react921 = __toESM(require_react(), 1);
var LinkOverlay = (0, import_react921.forwardRef)(
  function LinkOverlay2(props34, ref2) {
    const { rel, className, ...rest } = props34;
    return (0, import_jsx_runtime448.jsx)(
      chakra.a,
      {
        ...rest,
        ref: ref2,
        className: cx("chakra-linkbox__overlay", className),
        css: [
          {
            position: "static",
            "&::before": {
              content: "''",
              cursor: "inherit",
              display: "block",
              position: "absolute",
              top: 0,
              left: 0,
              zIndex: 0,
              width: "100%",
              height: "100%"
            }
          },
          props34.css
        ]
      }
    );
  }
);
var LinkBox = (0, import_react921.forwardRef)(
  function LinkBox2(props34, ref2) {
    const { className, ...rest } = props34;
    return (0, import_jsx_runtime448.jsx)(
      chakra.div,
      {
        ref: ref2,
        position: "relative",
        ...rest,
        className: cx("chakra-linkbox", className),
        css: [
          {
            /* Elevate the links and abbreviations up */
            "& a[href]:not(.chakra-linkbox__overlay), abbr[title]": {
              position: "relative",
              zIndex: 1
            }
          },
          props34.css
        ]
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/list/list.js
var {
  withProvider: withProvider18,
  withContext: withContext30,
  useStyles: useListStyles,
  PropsProvider: PropsProvider31
} = createSlotRecipeContext({ key: "list" });
var ListRoot = withProvider18(
  "ul",
  "root",
  { defaultProps: { role: "list" } }
);
var ListRootPropsProvider = PropsProvider31;
var ListItem = withContext30("li", "item");
var ListIndicator = withContext30(
  "span",
  "indicator"
);

// node_modules/@chakra-ui/react/dist/esm/components/list/namespace.js
var namespace_exports22 = {};
__export(namespace_exports22, {
  Indicator: () => ListIndicator,
  Item: () => ListItem,
  Root: () => ListRoot,
  RootPropsProvider: () => ListRootPropsProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/loader/loader-overlay.js
var LoaderOverlay = chakra("div", {
  base: {
    pos: "absolute",
    inset: "0",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    boxSize: "full",
    gap: "2"
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/menu/menu.js
var import_jsx_runtime449 = __toESM(require_jsx_runtime(), 1);
var {
  withRootProvider: withRootProvider5,
  withContext: withContext31,
  useStyles: useMenuStyles,
  PropsProvider: PropsProvider32
} = createSlotRecipeContext({ key: "menu" });
var MenuRootProvider2 = withRootProvider5(
  menu_exports.RootProvider
);
var MenuRoot2 = withRootProvider5(menu_exports.Root, {
  defaultProps: { lazyMount: true, unmountOnExit: true }
});
var MenuPropsProvider = PropsProvider32;
var MenuTrigger2 = withContext31(
  menu_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var MenuContextTrigger2 = withContext31(menu_exports.ContextTrigger, "contextTrigger", { forwardAsChild: true });
var MenuPositioner2 = withContext31(
  menu_exports.Positioner,
  "positioner",
  { forwardAsChild: true }
);
var MenuSeparator2 = withContext31(
  menu_exports.Separator,
  "separator",
  { forwardAsChild: true }
);
var MenuContent2 = withContext31(
  menu_exports.Content,
  "content",
  { forwardAsChild: true }
);
var MenuArrowTip2 = withContext31(
  menu_exports.ArrowTip,
  "arrowTip",
  { forwardAsChild: true }
);
var MenuArrow2 = withContext31(
  menu_exports.Arrow,
  "arrow",
  { forwardAsChild: true, defaultProps: { children: (0, import_jsx_runtime449.jsx)(MenuArrowTip2, {}) } }
);
var MenuIndicator2 = withContext31(
  menu_exports.Indicator,
  "indicator",
  { forwardAsChild: true }
);
var MenuItemGroup2 = withContext31(
  menu_exports.ItemGroup,
  "itemGroup",
  { forwardAsChild: true }
);
var MenuItemGroupLabel2 = withContext31(menu_exports.ItemGroupLabel, "itemGroupLabel", { forwardAsChild: true });
var MenuItem2 = withContext31(
  menu_exports.Item,
  "item",
  { forwardAsChild: true }
);
var MenuTriggerItem2 = withContext31(menu_exports.TriggerItem, "item", { forwardAsChild: true });
var MenuItemText2 = withContext31(
  menu_exports.ItemText,
  "itemText",
  { forwardAsChild: true }
);
var MenuItemCommand = withContext31(
  "kbd",
  "itemCommand"
);
var MenuItemIndicator2 = withContext31(menu_exports.ItemIndicator, "itemIndicator", { forwardAsChild: true });
var MenuCheckboxItem2 = withContext31(menu_exports.CheckboxItem, "item", { forwardAsChild: true });
var MenuRadioItemGroup2 = withContext31(menu_exports.RadioItemGroup, "itemGroup", { forwardAsChild: true });
var MenuRadioItem2 = withContext31(
  menu_exports.RadioItem,
  "item",
  { forwardAsChild: true }
);
var MenuContext2 = menu_exports.Context;
var MenuItemContext2 = menu_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/menu/namespace.js
var namespace_exports23 = {};
__export(namespace_exports23, {
  Arrow: () => MenuArrow2,
  ArrowTip: () => MenuArrowTip2,
  CheckboxItem: () => MenuCheckboxItem2,
  Content: () => MenuContent2,
  Context: () => MenuContext2,
  ContextTrigger: () => MenuContextTrigger2,
  Indicator: () => MenuIndicator2,
  Item: () => MenuItem2,
  ItemCommand: () => MenuItemCommand,
  ItemContext: () => MenuItemContext2,
  ItemGroup: () => MenuItemGroup2,
  ItemGroupLabel: () => MenuItemGroupLabel2,
  ItemIndicator: () => MenuItemIndicator2,
  ItemText: () => MenuItemText2,
  Positioner: () => MenuPositioner2,
  RadioItem: () => MenuRadioItem2,
  RadioItemGroup: () => MenuRadioItemGroup2,
  Root: () => MenuRoot2,
  RootPropsProvider: () => MenuPropsProvider,
  RootProvider: () => MenuRootProvider2,
  Separator: () => MenuSeparator2,
  Trigger: () => MenuTrigger2,
  TriggerItem: () => MenuTriggerItem2
});

// node_modules/@chakra-ui/react/dist/esm/components/native-select/native-select.js
var import_jsx_runtime450 = __toESM(require_jsx_runtime(), 1);
var import_react922 = __toESM(require_react(), 1);
var [NativeSelectBasePropsProvider, useNativeSelectBaseProps] = createContext({
  name: "NativeSelectBasePropsContext",
  hookName: "useNativeSelectBaseProps",
  providerName: "<NativeSelectRoot />",
  strict: false
});
var {
  withProvider: withProvider19,
  useClassNames: useClassNames3,
  useStyles: useNativeSelectStyles,
  PropsProvider: PropsProvider33
} = createSlotRecipeContext({ key: "nativeSelect" });
var NativeSelectRoot = withProvider19("div", "root", {
  wrapElement(element, props34) {
    const field = useFieldContext();
    const disabled = Boolean((field == null ? void 0 : field.disabled) ?? props34.disabled);
    const invalid = Boolean((field == null ? void 0 : field.invalid) ?? props34.invalid);
    return (0, import_jsx_runtime450.jsx)(NativeSelectBasePropsProvider, { value: { disabled, invalid }, children: element });
  }
});
var NativeSelectPropsProvider = PropsProvider33;
var StyledSelect = chakra(field_exports.Select, {}, { forwardAsChild: true });
var NativeSelectField = (0, import_react922.forwardRef)(function NativeSelectField2(props34, ref2) {
  const { children, placeholder, ...restProps } = props34;
  const { disabled, invalid } = useNativeSelectBaseProps();
  const styles = useNativeSelectStyles();
  const classNames = useClassNames3();
  return (0, import_jsx_runtime450.jsxs)(
    StyledSelect,
    {
      disabled,
      "data-invalid": dataAttr2(invalid),
      ...restProps,
      ref: ref2,
      className: cx(classNames.field, props34.className),
      css: [styles.field, props34.css],
      children: [
        placeholder && (0, import_jsx_runtime450.jsx)("option", { value: "", children: placeholder }),
        children
      ]
    }
  );
});
function NativeSelectIndicator(props34) {
  const styles = useNativeSelectStyles();
  const { disabled, invalid } = useNativeSelectBaseProps();
  const classNames = useClassNames3();
  return (0, import_jsx_runtime450.jsx)(
    chakra.div,
    {
      ...props34,
      "data-disabled": dataAttr2(disabled),
      "data-invalid": dataAttr2(invalid),
      className: cx(classNames.indicator, props34.className),
      css: [styles.indicator, props34.css],
      children: props34.children ?? (0, import_jsx_runtime450.jsx)(ChevronDownIcon, {})
    }
  );
}

// node_modules/@chakra-ui/react/dist/esm/components/native-select/namespace.js
var namespace_exports24 = {};
__export(namespace_exports24, {
  Field: () => NativeSelectField,
  Indicator: () => NativeSelectIndicator,
  PropsProvider: () => NativeSelectPropsProvider,
  Root: () => NativeSelectRoot
});

// node_modules/@chakra-ui/react/dist/esm/components/number-input/number-input.js
var import_jsx_runtime451 = __toESM(require_jsx_runtime(), 1);
var {
  withProvider: withProvider20,
  withContext: withContext32,
  useStyles: useNumberInputStyles,
  PropsProvider: PropsProvider34
} = createSlotRecipeContext({ key: "numberInput" });
var NumberInputRootProvider2 = withProvider20(number_input_exports.RootProvider, "root", { forwardAsChild: true });
var NumberInputRoot2 = withProvider20(number_input_exports.Root, "root", { forwardAsChild: true });
var NumberInputPropsProvider = PropsProvider34;
var NumberInputLabel2 = withContext32(number_input_exports.Label, "label", { forwardAsChild: true });
var NumberInputInput2 = withContext32(number_input_exports.Input, "input", { forwardAsChild: true });
var NumberInputIncrementTrigger2 = withContext32(number_input_exports.IncrementTrigger, "incrementTrigger", {
  forwardAsChild: true,
  defaultProps: { children: (0, import_jsx_runtime451.jsx)(ChevronUpIcon, {}) }
});
var NumberInputDecrementTrigger2 = withContext32(number_input_exports.DecrementTrigger, "decrementTrigger", {
  forwardAsChild: true,
  defaultProps: { children: (0, import_jsx_runtime451.jsx)(ChevronDownIcon, {}) }
});
var NumberInputControl2 = withContext32(number_input_exports.Control, "control", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime451.jsxs)(import_jsx_runtime451.Fragment, { children: [
      (0, import_jsx_runtime451.jsx)(NumberInputIncrementTrigger2, {}),
      (0, import_jsx_runtime451.jsx)(NumberInputDecrementTrigger2, {})
    ] })
  }
});
var NumberInputScrubber2 = withContext32(number_input_exports.Scrubber, "scrubber", { forwardAsChild: true });
var NumberInputValueText2 = withContext32(number_input_exports.ValueText, "valueText", { forwardAsChild: true });
var NumberInputContext2 = number_input_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/number-input/namespace.js
var namespace_exports25 = {};
__export(namespace_exports25, {
  Context: () => NumberInputContext2,
  Control: () => NumberInputControl2,
  DecrementTrigger: () => NumberInputDecrementTrigger2,
  IncrementTrigger: () => NumberInputIncrementTrigger2,
  Input: () => NumberInputInput2,
  Label: () => NumberInputLabel2,
  PropsProvider: () => NumberInputPropsProvider,
  Root: () => NumberInputRoot2,
  RootProvider: () => NumberInputRootProvider2,
  Scrubber: () => NumberInputScrubber2,
  ValueText: () => NumberInputValueText2
});

// node_modules/@chakra-ui/react/dist/esm/components/pagination/pagination.js
var {
  withProvider: withProvider21,
  withContext: withContext33,
  useStyles: usePaginationStyles,
  PropsProvider: PropsProvider35
} = createSlotRecipeContext({ key: "pagination" });
var PaginationRootProvider2 = withProvider21(pagination_exports.RootProvider, "root", {
  forwardAsChild: true,
  forwardProps: ["page"]
});
var PaginationRoot2 = withProvider21(
  pagination_exports.Root,
  "root",
  { forwardAsChild: true, forwardProps: ["page"] }
);
var PaginationPropsProvider = PropsProvider35;
var PaginationEllipsis2 = withContext33(pagination_exports.Ellipsis, "ellipsis", { forwardAsChild: true });
var PaginationItem2 = withContext33(pagination_exports.Item, "item", { forwardAsChild: true });
var PaginationNextTrigger2 = withContext33(pagination_exports.NextTrigger, "nextTrigger", { forwardAsChild: true });
var PaginationPrevTrigger2 = withContext33(pagination_exports.PrevTrigger, "prevTrigger", { forwardAsChild: true });
var PaginationContext2 = pagination_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/pagination/namespace.js
var namespace_exports26 = {};
__export(namespace_exports26, {
  Context: () => PaginationContext2,
  Ellipsis: () => PaginationEllipsis2,
  Item: () => PaginationItem2,
  NextTrigger: () => PaginationNextTrigger2,
  PrevTrigger: () => PaginationPrevTrigger2,
  PropsProvider: () => PaginationPropsProvider,
  Root: () => PaginationRoot2,
  RootProvider: () => PaginationRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/pin-input/pin-input.js
var {
  withProvider: withProvider22,
  withContext: withContext34,
  useStyles: usePinInputStyles,
  PropsProvider: PropsProvider36
} = createSlotRecipeContext({ key: "pinInput" });
var PinInputRootProvider2 = withProvider22(pin_input_exports.RootProvider, "root", { forwardAsChild: true });
var PinInputRoot2 = withProvider22(
  pin_input_exports.Root,
  "root",
  { forwardProps: ["mask"], forwardAsChild: true }
);
var PinInputPropsProvider = PropsProvider36;
var PinInputControl2 = withContext34(pin_input_exports.Control, "control", { forwardAsChild: true });
var PinInputInput2 = withContext34(
  pin_input_exports.Input,
  "input",
  { forwardAsChild: true }
);
var PinInputLabel2 = withContext34(
  pin_input_exports.Label,
  "label",
  { forwardAsChild: true }
);
var PinInputContext2 = pin_input_exports.Context;
var PinInputHiddenInput2 = pin_input_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/pin-input/namespace.js
var namespace_exports27 = {};
__export(namespace_exports27, {
  Context: () => PinInputContext2,
  Control: () => PinInputControl2,
  HiddenInput: () => PinInputHiddenInput2,
  Input: () => PinInputInput2,
  Label: () => PinInputLabel2,
  PropsProvider: () => PinInputPropsProvider,
  Root: () => PinInputRoot2,
  RootProvider: () => PinInputRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/popover/popover.js
var import_jsx_runtime452 = __toESM(require_jsx_runtime(), 1);
var {
  withRootProvider: withRootProvider6,
  withContext: withContext35,
  useStyles: usePopoverStyles,
  PropsProvider: PropsProvider37
} = createSlotRecipeContext({ key: "popover" });
var PopoverRootProvider2 = withRootProvider6(
  popover_exports.RootProvider
);
var PopoverRoot2 = withRootProvider6(popover_exports.Root);
var PopoverPropsProvider = PropsProvider37;
var PopoverTrigger2 = withContext35(popover_exports.Trigger, "trigger", { forwardAsChild: true });
var PopoverPositioner2 = withContext35(popover_exports.Positioner, "positioner", { forwardAsChild: true });
var PopoverContent2 = withContext35(
  popover_exports.Content,
  "content",
  { forwardAsChild: true }
);
var PopoverArrowTip2 = withContext35(popover_exports.ArrowTip, "arrowTip", { forwardAsChild: true });
var PopoverArrow2 = withContext35(
  popover_exports.Arrow,
  "arrow",
  {
    forwardAsChild: true,
    defaultProps: { children: (0, import_jsx_runtime452.jsx)(PopoverArrowTip2, {}) }
  }
);
var PopoverCloseTrigger2 = withContext35(popover_exports.CloseTrigger, "closeTrigger", { forwardAsChild: true });
var PopoverIndicator2 = withContext35(popover_exports.Indicator, "indicator", { forwardAsChild: true });
var PopoverTitle2 = withContext35(
  popover_exports.Title,
  "title",
  { forwardAsChild: true }
);
var PopoverDescription2 = withContext35(popover_exports.Description, "description", { forwardAsChild: true });
var PopoverFooter = withContext35(
  "footer",
  "footer"
);
var PopoverHeader = withContext35(
  "header",
  "header"
);
var PopoverBody = withContext35(
  "div",
  "body"
);
var PopoverAnchor2 = withContext35(
  popover_exports.Anchor,
  void 0,
  { forwardAsChild: true }
);
var PopoverContext2 = popover_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/popover/namespace.js
var namespace_exports28 = {};
__export(namespace_exports28, {
  Anchor: () => PopoverAnchor2,
  Arrow: () => PopoverArrow2,
  ArrowTip: () => PopoverArrowTip2,
  Body: () => PopoverBody,
  CloseTrigger: () => PopoverCloseTrigger2,
  Content: () => PopoverContent2,
  Context: () => PopoverContext2,
  Description: () => PopoverDescription2,
  Footer: () => PopoverFooter,
  Header: () => PopoverHeader,
  Positioner: () => PopoverPositioner2,
  PropsProvider: () => PopoverPropsProvider,
  Root: () => PopoverRoot2,
  RootProvider: () => PopoverRootProvider2,
  Title: () => PopoverTitle2,
  Trigger: () => PopoverTrigger2,
  usePopoverStyles: () => usePopoverStyles
});

// node_modules/@chakra-ui/react/dist/esm/components/progress/progress.js
var {
  withProvider: withProvider23,
  withContext: withContext36,
  useStyles: useProgressStyles,
  PropsProvider: PropsProvider38
} = createSlotRecipeContext({ key: "progress" });
var ProgressRootProvider2 = withProvider23(progress_exports.RootProvider, "root", { forwardAsChild: true });
var ProgressRoot2 = withProvider23(
  progress_exports.Root,
  "root"
);
var ProgressPropsProvider = PropsProvider38;
var ProgressLabel2 = withContext36(
  progress_exports.Label,
  "label",
  { forwardAsChild: true }
);
var ProgressTrack2 = withContext36(
  progress_exports.Track,
  "track",
  { forwardAsChild: true }
);
var ProgressRange2 = withContext36(
  progress_exports.Range,
  "range",
  { forwardAsChild: true }
);
var ProgressValueText2 = withContext36(progress_exports.ValueText, "valueText", { forwardAsChild: true });
var ProgressContext2 = progress_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/progress/namespace.js
var namespace_exports29 = {};
__export(namespace_exports29, {
  Context: () => ProgressContext2,
  Label: () => ProgressLabel2,
  PropsProvider: () => ProgressPropsProvider,
  Range: () => ProgressRange2,
  Root: () => ProgressRoot2,
  RootProvider: () => ProgressRootProvider2,
  Track: () => ProgressTrack2,
  ValueText: () => ProgressValueText2
});

// node_modules/@chakra-ui/react/dist/esm/components/progress-circle/progress-circle.js
var {
  withProvider: withProvider24,
  withContext: withContext37,
  useStyles: useProgressCircleStyles,
  PropsProvider: PropsProvider39
} = createSlotRecipeContext({ key: "progressCircle" });
var ProgressCircleRootProvider = withProvider24(progress_exports.RootProvider, "root", { forwardAsChild: true });
var ProgressCircleRoot = withProvider24(progress_exports.Root, "root", { forwardAsChild: true });
var ProgressCirclePropsProvider = PropsProvider39;
var ProgressCircleLabel = withContext37(progress_exports.Label, "label", { forwardAsChild: true });
var ProgressCircleCircle = withContext37(progress_exports.Circle, "circle", { forwardAsChild: true });
var ProgressCircleTrack2 = withContext37(progress_exports.CircleTrack, "circleTrack", { forwardAsChild: true });
var ProgressCircleRange2 = withContext37(progress_exports.CircleRange, "circleRange", { forwardAsChild: true });
var ProgressCircleValueText = withContext37(progress_exports.ValueText, "valueText", { forwardAsChild: true });
var ProgressCircleContext = progress_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/progress-circle/namespace.js
var namespace_exports30 = {};
__export(namespace_exports30, {
  Circle: () => ProgressCircleCircle,
  Label: () => ProgressCircleLabel,
  PropsProvider: () => ProgressCirclePropsProvider,
  Range: () => ProgressCircleRange2,
  Root: () => ProgressCircleRoot,
  RootProvider: () => ProgressCircleRootProvider,
  Track: () => ProgressCircleTrack2,
  ValueText: () => ProgressCircleValueText
});

// node_modules/@chakra-ui/react/dist/esm/components/qr-code/qr-code.js
var import_jsx_runtime453 = __toESM(require_jsx_runtime(), 1);
var {
  withProvider: withProvider25,
  withContext: withContext38,
  useStyles: useQrCodeStyles,
  PropsProvider: PropsProvider40
} = createSlotRecipeContext({ key: "qrCode" });
var QrCodeRoot2 = withProvider25(
  qr_code_exports.Root,
  "root",
  { forwardAsChild: true }
);
var QrCodeRootProvider2 = withProvider25(qr_code_exports.RootProvider, "root", { forwardAsChild: true });
var QrCodePropsProvider = PropsProvider40;
var QrCodePattern2 = withContext38(
  qr_code_exports.Pattern,
  "pattern",
  { forwardAsChild: true }
);
var QrCodeFrame2 = withContext38(
  qr_code_exports.Frame,
  "frame",
  {
    forwardAsChild: true,
    defaultProps: { children: (0, import_jsx_runtime453.jsx)(QrCodePattern2, {}) }
  }
);
var QrCodeOverlay2 = withContext38(
  qr_code_exports.Overlay,
  "overlay",
  { forwardAsChild: true }
);
var QrCodeDownloadTrigger2 = withContext38(qr_code_exports.DownloadTrigger, "downloadTrigger", { forwardAsChild: true });

// node_modules/@chakra-ui/react/dist/esm/components/qr-code/namespace.js
var namespace_exports31 = {};
__export(namespace_exports31, {
  Context: () => QrCodeContext,
  DownloadTrigger: () => QrCodeDownloadTrigger2,
  Frame: () => QrCodeFrame2,
  Overlay: () => QrCodeOverlay2,
  Pattern: () => QrCodePattern2,
  PropsProvider: () => QrCodePropsProvider,
  Root: () => QrCodeRoot2,
  RootProvider: () => QrCodeRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/radio-card/radio-card.js
var import_jsx_runtime455 = __toESM(require_jsx_runtime(), 1);
var import_react924 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/radiomark/radiomark.js
var import_jsx_runtime454 = __toESM(require_jsx_runtime(), 1);
var import_react923 = __toESM(require_react(), 1);
var Radiomark = (0, import_react923.forwardRef)(
  function Radiomark2(props34, ref2) {
    const recipe = useRecipe({ key: "radiomark", recipe: props34.recipe });
    const [variantProps, restProps] = recipe.splitVariantProps(props34);
    const { checked, disabled, unstyled, children, ...rest } = restProps;
    const styles = unstyled ? EMPTY_STYLES : recipe(variantProps);
    const sharedProps = {
      ref: ref2,
      "data-checked": dataAttr2(checked),
      "data-disabled": dataAttr2(disabled),
      ...rest,
      css: [styles, props34.css]
    };
    return (0, import_jsx_runtime454.jsx)(chakra.span, { ...sharedProps, children: checked && (0, import_jsx_runtime454.jsx)("span", { className: "dot" }) });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/radio-card/radio-card.js
var {
  withProvider: withProvider26,
  withContext: withContext39,
  useStyles: useRadioCardStyles,
  PropsProvider: PropsProvider41
} = createSlotRecipeContext({ key: "radioCard" });
var RadioCardRootProvider = withProvider26(radio_group_exports.RootProvider, "root", { forwardAsChild: true });
var RadioCardRoot = withProvider26(
  radio_group_exports.Root,
  "root",
  { forwardAsChild: true }
);
var RadioCardPropsProvider = PropsProvider41;
var RadioCardLabel = withContext39(
  radio_group_exports.Label,
  "label",
  { forwardAsChild: true }
);
var RadioCardItem = withContext39(
  radio_group_exports.Item,
  "item",
  { forwardAsChild: true }
);
var RadioCardItemText = withContext39(radio_group_exports.ItemText, "itemText", { forwardAsChild: true });
var RadioCardItemDescription = withContext39("div", "itemDescription", { forwardAsChild: true });
var RadioCardItemControl = withContext39(radio_group_exports.ItemControl, "itemControl", { forwardAsChild: true });
var RadioCardItemContent = withContext39("div", "itemContent");
var RadioCardItemAddon = withContext39("div", "itemAddon");
var RadioCardItemIndicator = (0, import_react924.forwardRef)(function RadioGroupItemIndicator(props34, ref2) {
  const { checked, ...rest } = props34;
  const styles = useRadioCardStyles();
  const itemContext = useRadioGroupItemContext();
  if (checked && itemContext.checked) {
    return (0, import_jsx_runtime455.jsx)(
      chakra.span,
      {
        ref: ref2,
        asChild: true,
        ...rest,
        css: [styles["itemIndicator"], props34.css],
        children: checked
      }
    );
  }
  return (0, import_jsx_runtime455.jsx)(
    Radiomark,
    {
      ref: ref2,
      unstyled: true,
      ...props34,
      checked: itemContext.checked,
      disabled: itemContext.disabled,
      css: [styles["itemIndicator"], props34.css]
    }
  );
});
var RadioCardContext = radio_group_exports.Context;
var RadioCardItemContext = radio_group_exports.ItemContext;
var RadioCardItemHiddenInput = radio_group_exports.ItemHiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/radio-card/namespace.js
var namespace_exports32 = {};
__export(namespace_exports32, {
  Context: () => RadioCardContext,
  Item: () => RadioCardItem,
  ItemAddon: () => RadioCardItemAddon,
  ItemContent: () => RadioCardItemContent,
  ItemContext: () => RadioCardItemContext,
  ItemControl: () => RadioCardItemControl,
  ItemDescription: () => RadioCardItemDescription,
  ItemHiddenInput: () => RadioCardItemHiddenInput,
  ItemIndicator: () => RadioCardItemIndicator,
  ItemText: () => RadioCardItemText,
  Label: () => RadioCardLabel,
  PropsProvider: () => RadioCardPropsProvider,
  Root: () => RadioCardRoot,
  RootProvider: () => RadioCardRootProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/radio-group/radio-group.js
var import_jsx_runtime456 = __toESM(require_jsx_runtime(), 1);
var import_react925 = __toESM(require_react(), 1);
var {
  withProvider: withProvider27,
  withContext: withContext40,
  useStyles: useRadioGroupStyles,
  PropsProvider: PropsProvider42
} = createSlotRecipeContext({ key: "radioGroup" });
var RadioGroupRootProvider2 = withProvider27(radio_group_exports.RootProvider, "root", { forwardAsChild: true });
var RadioGroupRoot2 = withProvider27(
  radio_group_exports.Root,
  "root",
  { forwardAsChild: true }
);
var RadioGroupPropsProvider = PropsProvider42;
var RadioGroupLabel2 = withContext40(radio_group_exports.Label, "label", { forwardAsChild: true });
var RadioGroupItem2 = withContext40(
  radio_group_exports.Item,
  "item",
  { forwardAsChild: true }
);
var RadioGroupItemText2 = withContext40(radio_group_exports.ItemText, "itemText", { forwardAsChild: true });
var RadioGroupItemControl2 = withContext40(radio_group_exports.ItemControl, "itemControl", { forwardAsChild: true });
var RadioGroupItemIndicator2 = (0, import_react925.forwardRef)(function RadioGroupItemIndicator22(props34, ref2) {
  const styles = useRadioGroupStyles();
  return (0, import_jsx_runtime456.jsx)(radio_group_exports.ItemContext, { children: (itemState) => (0, import_jsx_runtime456.jsx)(radio_group_exports.ItemControl, { asChild: true, children: (0, import_jsx_runtime456.jsx)(
    Radiomark,
    {
      ref: ref2,
      unstyled: true,
      ...props34,
      checked: itemState.checked,
      disabled: itemState.disabled,
      css: [styles["itemControl"], props34.css]
    }
  ) }) });
});
var RadioGroupContext2 = radio_group_exports.Context;
var RadioGroupItemContext2 = radio_group_exports.ItemContext;
var RadioGroupItemHiddenInput2 = radio_group_exports.ItemHiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/radio-group/namespace.js
var namespace_exports33 = {};
__export(namespace_exports33, {
  Context: () => RadioGroupContext2,
  Item: () => RadioGroupItem2,
  ItemContext: () => RadioGroupItemContext2,
  ItemControl: () => RadioGroupItemControl2,
  ItemHiddenInput: () => RadioGroupItemHiddenInput2,
  ItemIndicator: () => RadioGroupItemIndicator2,
  ItemText: () => RadioGroupItemText2,
  Label: () => RadioGroupLabel2,
  PropsProvider: () => RadioGroupPropsProvider,
  Root: () => RadioGroupRoot2,
  RootProvider: () => RadioGroupRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/rating-group/rating-group.js
var import_jsx_runtime457 = __toESM(require_jsx_runtime(), 1);
var import_react926 = __toESM(require_react(), 1);
var {
  withProvider: withProvider28,
  withContext: withContext41,
  useStyles: useRatingGroupStyles,
  PropsProvider: PropsProvider43
} = createSlotRecipeContext({ key: "ratingGroup" });
var RatingGroupRootProvider2 = withProvider28(rating_group_exports.RootProvider, "root", { forwardAsChild: true });
var RatingGroupRoot2 = withProvider28(rating_group_exports.Root, "root", { forwardAsChild: true });
var RatingGroupPropsProvider = PropsProvider43;
var RatingGroupLabel2 = withContext41(rating_group_exports.Label, "label", { forwardAsChild: true });
var RatingGroupItem2 = withContext41(rating_group_exports.Item, "item", { forwardAsChild: true });
function cloneIcon(icon, type) {
  if (!(0, import_react926.isValidElement)(icon)) return null;
  const props34 = { [`data-${type}`]: "", "aria-hidden": "" };
  return (0, import_react926.cloneElement)(icon, props34);
}
var RatingGroupItemIndicator = (0, import_react926.forwardRef)(function RatingGroupItemIndicator2(props34, ref2) {
  const { icon = (0, import_jsx_runtime457.jsx)(StarIcon, {}), ...rest } = props34;
  const styles = useRatingGroupStyles();
  const itemState = useRatingGroupItemContext();
  return (0, import_jsx_runtime457.jsxs)(
    chakra.span,
    {
      ...rest,
      "data-highlighted": itemState.highlighted ? "" : void 0,
      "data-checked": itemState.checked ? "" : void 0,
      "data-half": itemState.half ? "" : void 0,
      css: [styles.itemIndicator, props34.css],
      ref: ref2,
      children: [
        cloneIcon(icon, "bg"),
        cloneIcon(icon, "fg")
      ]
    }
  );
});
var RatingGroupItems = (props34) => {
  const api = useRatingGroupContext();
  return (0, import_jsx_runtime457.jsx)(For, { each: api.items, children: (index) => (0, import_jsx_runtime457.jsx)(RatingGroupItem2, { index, ...props34, children: (0, import_jsx_runtime457.jsx)(RatingGroupItemIndicator, {}) }, index) });
};
var RatingGroupControl2 = withContext41(rating_group_exports.Control, "control", {
  forwardAsChild: true,
  defaultProps: { children: (0, import_jsx_runtime457.jsx)(RatingGroupItems, {}) }
});
var RatingGroupContext2 = rating_group_exports.Context;
var RatingGroupItemContext2 = rating_group_exports.ItemContext;
var RatingGroupHiddenInput2 = rating_group_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/rating-group/namespace.js
var namespace_exports34 = {};
__export(namespace_exports34, {
  Context: () => RatingGroupContext2,
  Control: () => RatingGroupControl2,
  HiddenInput: () => RatingGroupHiddenInput2,
  Item: () => RatingGroupItem2,
  ItemContext: () => RatingGroupItemContext2,
  ItemIndicator: () => RatingGroupItemIndicator,
  Items: () => RatingGroupItems,
  Label: () => RatingGroupLabel2,
  PropsProvider: () => RatingGroupPropsProvider,
  Root: () => RatingGroupRoot2,
  RootProvider: () => RatingGroupRootProvider2,
  useRatingGroupStyles: () => useRatingGroupStyles
});

// node_modules/@chakra-ui/react/dist/esm/components/segment-group/segment-group.js
var import_jsx_runtime458 = __toESM(require_jsx_runtime(), 1);
var import_react927 = __toESM(require_react(), 1);
var {
  withProvider: withProvider29,
  withContext: withContext42,
  useStyles: useSegmentGroupStyles,
  PropsProvider: PropsProvider44
} = createSlotRecipeContext({ key: "segmentGroup" });
var SegmentGroupRootProvider2 = withProvider29(segment_group_exports.RootProvider, "root", { forwardAsChild: true });
var SegmentGroupRoot2 = withProvider29(segment_group_exports.Root, "root", { forwardAsChild: true });
var SegmentGroupPropsProvider = PropsProvider44;
var SegmentGroupItem2 = withContext42(segment_group_exports.Item, "item", { forwardAsChild: true });
var SegmentGroupItemText2 = withContext42(segment_group_exports.ItemText, "itemText", { forwardAsChild: true });
var SegmentGroupIndicator2 = withContext42(segment_group_exports.Indicator, "indicator", { forwardAsChild: true });
function normalize2(items) {
  return items.map((item) => {
    if (typeof item === "string") return { value: item, label: item };
    return item;
  });
}
var SegmentGroupItems = (props34) => {
  const { items, ...rest } = props34;
  const data = (0, import_react927.useMemo)(() => normalize2(items), [items]);
  return (0, import_jsx_runtime458.jsx)(For, { each: data, children: (item) => (0, import_jsx_runtime458.jsxs)(SegmentGroupItem2, { value: item.value, ...rest, children: [
    (0, import_jsx_runtime458.jsx)(SegmentGroupItemText2, { children: item.label }),
    (0, import_jsx_runtime458.jsx)(SegmentGroupItemHiddenInput2, {})
  ] }, item.value) });
};
var SegmentGroupItemHiddenInput2 = segment_group_exports.ItemHiddenInput;
var SegmentGroupContext2 = segment_group_exports.Context;
var SegmentGroupItemContext2 = segment_group_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/segment-group/namespace.js
var namespace_exports35 = {};
__export(namespace_exports35, {
  Context: () => SegmentGroupContext2,
  Indicator: () => SegmentGroupIndicator2,
  Item: () => SegmentGroupItem2,
  ItemContext: () => SegmentGroupItemContext2,
  ItemHiddenInput: () => SegmentGroupItemHiddenInput2,
  ItemText: () => SegmentGroupItemText2,
  Items: () => SegmentGroupItems,
  PropsProvider: () => SegmentGroupPropsProvider,
  Root: () => SegmentGroupRoot2,
  RootProvider: () => SegmentGroupRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/select/select.js
var import_jsx_runtime459 = __toESM(require_jsx_runtime(), 1);
var {
  withProvider: withProvider30,
  withContext: withContext43,
  useStyles: useSelectStyles,
  PropsProvider: PropsProvider45
} = createSlotRecipeContext({ key: "select" });
var SelectRootProvider2 = withProvider30(select_exports.RootProvider, "root", {
  forwardAsChild: true
});
var SelectRoot2 = withProvider30(
  select_exports.Root,
  "root",
  { forwardAsChild: true }
);
var SelectPropsProvider = PropsProvider45;
var SelectTrigger2 = withContext43(
  select_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var SelectPositioner2 = withContext43(select_exports.Positioner, "positioner", { forwardAsChild: true });
var SelectContent2 = withContext43(
  select_exports.Content,
  "content",
  { forwardAsChild: true }
);
var SelectValueText2 = withContext43(select_exports.ValueText, "valueText", { forwardAsChild: true });
var SelectClearTrigger2 = withContext43(select_exports.ClearTrigger, "clearTrigger", { forwardAsChild: true });
var SelectItemGroup2 = withContext43(select_exports.ItemGroup, "itemGroup", { forwardAsChild: true });
var SelectItemGroupLabel2 = withContext43(select_exports.ItemGroupLabel, "itemGroupLabel", { forwardAsChild: true });
var SelectItem2 = withContext43(
  select_exports.Item,
  "item",
  { forwardAsChild: true }
);
var SelectItemText2 = withContext43(
  select_exports.ItemText,
  "itemText",
  { forwardAsChild: true }
);
var SelectItemIndicator2 = withContext43(select_exports.ItemIndicator, "itemIndicator", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime459.jsx)(CheckIcon, {})
  }
});
var SelectIndicatorGroup = withContext43("div", "indicatorGroup");
var SelectIndicator2 = withContext43(select_exports.Indicator, "indicator", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime459.jsx)(ChevronDownIcon, {})
  }
});
var SelectControl2 = withContext43(
  select_exports.Control,
  "control",
  { forwardAsChild: true }
);
var SelectLabel2 = withContext43(
  select_exports.Label,
  "label",
  { forwardAsChild: true }
);
var SelectContext2 = select_exports.Context;
var SelectHiddenSelect2 = select_exports.HiddenSelect;
var SelectItemContext2 = select_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/select/namespace.js
var namespace_exports36 = {};
__export(namespace_exports36, {
  ClearTrigger: () => SelectClearTrigger2,
  Content: () => SelectContent2,
  Context: () => SelectContext2,
  Control: () => SelectControl2,
  HiddenSelect: () => SelectHiddenSelect2,
  Indicator: () => SelectIndicator2,
  IndicatorGroup: () => SelectIndicatorGroup,
  Item: () => SelectItem2,
  ItemContext: () => SelectItemContext2,
  ItemGroup: () => SelectItemGroup2,
  ItemGroupLabel: () => SelectItemGroupLabel2,
  ItemIndicator: () => SelectItemIndicator2,
  ItemText: () => SelectItemText2,
  Label: () => SelectLabel2,
  Positioner: () => SelectPositioner2,
  PropsProvider: () => SelectPropsProvider,
  Root: () => SelectRoot2,
  RootProvider: () => SelectRootProvider2,
  Trigger: () => SelectTrigger2,
  ValueText: () => SelectValueText2
});

// node_modules/@chakra-ui/react/dist/esm/components/separator/separator.js
var import_jsx_runtime460 = __toESM(require_jsx_runtime(), 1);
var import_react928 = __toESM(require_react(), 1);
var { useRecipeResult: useRecipeResult4, PropsProvider: PropsProvider46 } = createRecipeContext({
  key: "separator"
});
var Separator = (0, import_react928.forwardRef)(
  function Separator2(props34, ref2) {
    const { styles, className, props: otherProps } = useRecipeResult4(props34);
    const orientation = props34.orientation || "horizontal";
    return (0, import_jsx_runtime460.jsx)(
      chakra.span,
      {
        ref: ref2,
        role: isString(orientation) ? "separator" : "presentation",
        "aria-orientation": isString(orientation) ? orientation : void 0,
        ...omit(otherProps, ["orientation"]),
        className: cx(className, props34.className),
        css: [styles, props34.css]
      }
    );
  }
);
var SeparatorPropsProvider = PropsProvider46;

// node_modules/@chakra-ui/react/dist/esm/components/skeleton/skeleton.js
var import_jsx_runtime462 = __toESM(require_jsx_runtime(), 1);
var React9 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/stack/stack.js
var import_jsx_runtime461 = __toESM(require_jsx_runtime(), 1);
var import_react929 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/stack/get-separator-style.js
function getSeparatorStyles(options) {
  const { gap, direction } = options;
  const styles = {
    column: {
      marginY: gap,
      marginX: 0,
      borderInlineStartWidth: 0,
      borderTopWidth: "1px"
    },
    "column-reverse": {
      marginY: gap,
      marginX: 0,
      borderInlineStartWidth: 0,
      borderTopWidth: "1px"
    },
    row: {
      marginX: gap,
      marginY: 0,
      borderInlineStartWidth: "1px",
      borderTopWidth: 0
    },
    "row-reverse": {
      marginX: gap,
      marginY: 0,
      borderInlineStartWidth: "1px",
      borderTopWidth: 0
    }
  };
  return {
    "&": mapObject(direction, (value) => styles[value])
  };
}

// node_modules/@chakra-ui/react/dist/esm/components/stack/stack.js
function getValidChildren(children) {
  return import_react929.Children.toArray(children).filter(
    (child) => (0, import_react929.isValidElement)(child)
  );
}
var Stack = (0, import_react929.forwardRef)(
  function Stack2(props34, ref2) {
    const {
      direction = "column",
      align,
      justify,
      gap = "0.5rem",
      wrap: wrap5,
      children,
      separator,
      className,
      ...rest
    } = props34;
    const separatorStyle = (0, import_react929.useMemo)(
      () => getSeparatorStyles({ gap, direction }),
      [gap, direction]
    );
    const clones = (0, import_react929.useMemo)(() => {
      if (!separator) return children;
      return getValidChildren(children).map((child, index, arr) => {
        const key = typeof child.key !== "undefined" ? child.key : index;
        const sep = (0, import_react929.cloneElement)(separator, {
          css: [separatorStyle, separator.props.css]
        });
        return (0, import_jsx_runtime461.jsxs)(import_react929.Fragment, { children: [
          child,
          index === arr.length - 1 ? null : sep
        ] }, key);
      });
    }, [children, separator, separatorStyle]);
    return (0, import_jsx_runtime461.jsx)(
      chakra.div,
      {
        ref: ref2,
        display: "flex",
        alignItems: align,
        justifyContent: justify,
        flexDirection: direction,
        flexWrap: wrap5,
        gap: separator ? void 0 : gap,
        className: cx("chakra-stack", className),
        ...rest,
        children: clones
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/skeleton/skeleton.js
var { withContext: withContext44, PropsProvider: PropsProvider47 } = createRecipeContext({
  key: "skeleton"
});
var Skeleton = withContext44("div");
var SkeletonPropsProvider = PropsProvider47;
var SkeletonCircle = React9.forwardRef(function SkeletonCircle2(props34, ref2) {
  const { size: size3, ...rest } = props34;
  return (0, import_jsx_runtime462.jsx)(Circle, { size: size3, asChild: true, ref: ref2, children: (0, import_jsx_runtime462.jsx)(Skeleton, { ...rest }) });
});
var SkeletonText = React9.forwardRef(
  function SkeletonText2(props34, ref2) {
    const { noOfLines = 3, gap, rootProps, ...rest } = props34;
    return (0, import_jsx_runtime462.jsx)(Stack, { gap, width: "full", ref: ref2, ...rootProps, children: Array.from({ length: noOfLines }).map((_, index) => (0, import_jsx_runtime462.jsx)(
      Skeleton,
      {
        height: "4",
        _last: { maxW: noOfLines === 1 ? "100%" : "80%" },
        ...rest
      },
      index
    )) });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/skip-nav/skip-nav-link.js
var import_jsx_runtime463 = __toESM(require_jsx_runtime(), 1);
var import_react930 = __toESM(require_react(), 1);
var fallbackId = "chakra-skip-nav";
var SkipNavLink = (0, import_react930.forwardRef)(
  function SkipNavLink2(props34, ref2) {
    const recipe = useRecipe({ key: "skipNavLink", recipe: props34.recipe });
    const [variantProps, localProps] = recipe.splitVariantProps(props34);
    const styles = recipe(variantProps);
    localProps.id || (localProps.id = fallbackId);
    return (0, import_jsx_runtime463.jsx)(
      chakra.a,
      {
        ...localProps,
        ref: ref2,
        href: `#${localProps.id}`,
        css: [styles, props34.css]
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/skip-nav/skip-nav-content.js
var import_jsx_runtime464 = __toESM(require_jsx_runtime(), 1);
var import_react931 = __toESM(require_react(), 1);
var SkipNavContent = (0, import_react931.forwardRef)(
  function SkipNavContent2(props34, ref2) {
    const { id = fallbackId, ...rest } = props34;
    return (0, import_jsx_runtime464.jsx)(
      chakra.div,
      {
        ref: ref2,
        id,
        tabIndex: -1,
        style: { outline: 0 },
        ...rest
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/slider/slider.js
var import_jsx_runtime465 = __toESM(require_jsx_runtime(), 1);
var import_react932 = __toESM(require_react(), 1);
var {
  withProvider: withProvider31,
  withContext: withContext45,
  useStyles: useSliderStyles,
  PropsProvider: PropsProvider48
} = createSlotRecipeContext({ key: "slider" });
var SliderRootProvider2 = withProvider31(slider_exports.RootProvider, "root", { forwardAsChild: true });
var SliderRoot2 = withProvider31(
  slider_exports.Root,
  "root",
  { forwardAsChild: true }
);
var SliderPropsProvider = PropsProvider48;
var SliderTrack2 = withContext45(
  slider_exports.Track,
  "track",
  { forwardAsChild: true }
);
var SliderRange2 = withContext45(
  slider_exports.Range,
  "range",
  { forwardAsChild: true }
);
var SliderThumb2 = withContext45(
  slider_exports.Thumb,
  "thumb",
  { forwardAsChild: true }
);
var SliderValueText2 = withContext45(slider_exports.ValueText, "valueText", { forwardAsChild: true });
var SliderLabel2 = withContext45(
  slider_exports.Label,
  "label",
  { forwardAsChild: true }
);
var SliderMarkerGroup2 = withContext45(slider_exports.MarkerGroup, "markerGroup", { forwardAsChild: true });
var SliderMarker2 = withContext45(
  slider_exports.Marker,
  "marker",
  { forwardAsChild: true }
);
var SliderMarkerIndicator = withContext45("div", "markerIndicator");
var SliderDraggingIndicator2 = withContext45(slider_exports.DraggingIndicator, "draggingIndicator", { forwardAsChild: true });
var SliderThumbs = (props34) => {
  const api = useSliderContext();
  return (0, import_jsx_runtime465.jsx)(For, { each: api.value, children: (_, index) => (0, import_jsx_runtime465.jsx)(SliderThumb2, { index, ...props34, children: (0, import_jsx_runtime465.jsx)(SliderHiddenInput2, {}) }, index) });
};
var SliderMarks = (0, import_react932.forwardRef)(
  function SliderMarks2(props34, ref2) {
    const { marks, ...rest } = props34;
    if (!(marks == null ? void 0 : marks.length)) return null;
    return (0, import_jsx_runtime465.jsx)(SliderMarkerGroup2, { ref: ref2, ...rest, children: marks.map((mark, index) => {
      const value = typeof mark === "number" ? mark : mark.value;
      const label = typeof mark === "number" ? void 0 : mark.label;
      return (0, import_jsx_runtime465.jsxs)(SliderMarker2, { value, children: [
        (0, import_jsx_runtime465.jsx)(SliderMarkerIndicator, {}),
        label != null && (0, import_jsx_runtime465.jsx)("span", { className: "chakra-slider__marker-label", children: label })
      ] }, index);
    }) });
  }
);
var SliderControl2 = withContext45(
  slider_exports.Control,
  "control",
  { forwardAsChild: true }
);
var SliderContext2 = slider_exports.Context;
var SliderHiddenInput2 = slider_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/slider/namespace.js
var namespace_exports37 = {};
__export(namespace_exports37, {
  Context: () => SliderContext2,
  Control: () => SliderControl2,
  DraggingIndicator: () => SliderDraggingIndicator2,
  HiddenInput: () => SliderHiddenInput2,
  Label: () => SliderLabel2,
  Marker: () => SliderMarker2,
  MarkerGroup: () => SliderMarkerGroup2,
  MarkerIndicator: () => SliderMarkerIndicator,
  Marks: () => SliderMarks,
  PropsProvider: () => SliderPropsProvider,
  Range: () => SliderRange2,
  Root: () => SliderRoot2,
  RootProvider: () => SliderRootProvider2,
  Thumb: () => SliderThumb2,
  Thumbs: () => SliderThumbs,
  Track: () => SliderTrack2,
  ValueText: () => SliderValueText2
});

// node_modules/@chakra-ui/react/dist/esm/components/spacer/spacer.js
var Spacer = chakra("div", {
  base: {
    flex: 1,
    justifySelf: "stretch",
    alignSelf: "stretch"
  }
});
Spacer.displayName = "Spacer";

// node_modules/@chakra-ui/react/dist/esm/components/stack/h-stack.js
var import_jsx_runtime466 = __toESM(require_jsx_runtime(), 1);
var import_react933 = __toESM(require_react(), 1);
var HStack = (0, import_react933.forwardRef)(
  function HStack2(props34, ref2) {
    return (0, import_jsx_runtime466.jsx)(Stack, { align: "center", ...props34, direction: "row", ref: ref2 });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/stack/v-stack.js
var import_jsx_runtime467 = __toESM(require_jsx_runtime(), 1);
var import_react934 = __toESM(require_react(), 1);
var VStack = (0, import_react934.forwardRef)(
  function VStack2(props34, ref2) {
    return (0, import_jsx_runtime467.jsx)(Stack, { align: "center", ...props34, direction: "column", ref: ref2 });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/stack/stack-separator.js
var StackSeparator = chakra("div", {
  base: {
    borderWidth: 0,
    alignSelf: "stretch",
    borderColor: "inherit",
    width: "auto",
    height: "auto"
  }
});
StackSeparator.displayName = "StackSeparator";

// node_modules/@chakra-ui/react/dist/esm/components/stat/stat.js
var import_jsx_runtime468 = __toESM(require_jsx_runtime(), 1);
var import_react935 = __toESM(require_react(), 1);
var {
  withProvider: withProvider32,
  withContext: withContext46,
  useStyles: useStatStyles,
  PropsProvider: PropsProvider49
} = createSlotRecipeContext({ key: "stat" });
var StatRoot = withProvider32(
  "dl",
  "root"
);
var StatPropsProvider = PropsProvider49;
var StatLabel = withContext46("dt", "label");
var StatValueText = withContext46(
  "dd",
  "valueText"
);
var StatHelpText = withContext46(
  "span",
  "helpText"
);
var StatValueUnit = withContext46(
  "span",
  "valueUnit"
);
var StatUpIndicator = withContext46(
  "span",
  "indicator",
  {
    defaultProps: {
      "data-type": "up",
      children: (0, import_jsx_runtime468.jsx)(ArrowUpIcon, {})
    }
  }
);
var StatDownIndicator = withContext46("span", "indicator", {
  defaultProps: {
    "data-type": "down",
    children: (0, import_jsx_runtime468.jsx)(ArrowDownIcon, {})
  }
});
var StatGroup = (0, import_react935.forwardRef)(
  function StatGroup2(props34, ref2) {
    const recipe = useSlotRecipe({ key: "stat" });
    const [variantProps, localProps] = (0, import_react935.useMemo)(
      () => recipe.splitVariantProps(props34),
      [props34, recipe]
    );
    return (0, import_jsx_runtime468.jsx)(PropsProvider49, { value: variantProps, children: (0, import_jsx_runtime468.jsx)(
      chakra.div,
      {
        ref: ref2,
        role: "group",
        display: "flex",
        flexWrap: "wrap",
        justifyContent: "space-around",
        alignItems: "flex-start",
        ...localProps
      }
    ) });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/stat/namespace.js
var namespace_exports38 = {};
__export(namespace_exports38, {
  DownIndicator: () => StatDownIndicator,
  HelpText: () => StatHelpText,
  Label: () => StatLabel,
  PropsProvider: () => StatPropsProvider,
  Root: () => StatRoot,
  UpIndicator: () => StatUpIndicator,
  ValueText: () => StatValueText,
  ValueUnit: () => StatValueUnit
});

// node_modules/@chakra-ui/react/dist/esm/components/status/namespace.js
var namespace_exports39 = {};
__export(namespace_exports39, {
  Indicator: () => StatusIndicator,
  PropsProvider: () => StatusPropsProvider,
  Root: () => StatusRoot
});

// node_modules/@chakra-ui/react/dist/esm/components/status/status.js
var {
  withProvider: withProvider33,
  withContext: withContext47,
  useStyles: useStatusStyles,
  PropsProvider: PropsProvider50
} = createSlotRecipeContext({ key: "status" });
var StatusRoot = withProvider33(
  "div",
  "root"
);
var StatusPropsProvider = PropsProvider50;
var StatusIndicator = withContext47("div", "indicator");

// node_modules/@chakra-ui/react/dist/esm/components/steps/steps.js
var import_jsx_runtime469 = __toESM(require_jsx_runtime(), 1);
var import_react936 = __toESM(require_react(), 1);
var {
  withProvider: withProvider34,
  withContext: withContext48,
  useStyles: useStepsStyles,
  PropsProvider: PropsProvider51
} = createSlotRecipeContext({ key: "steps" });
var StepsRootProvider2 = withProvider34(steps_exports.RootProvider, "root", { forwardAsChild: true });
var StepsRoot2 = withProvider34(
  steps_exports.Root,
  "root",
  { forwardAsChild: true }
);
var StepsPropsProvider = PropsProvider51;
var StepsList2 = withContext48(
  steps_exports.List,
  "list",
  { forwardAsChild: true }
);
var StepsItem2 = withContext48(
  steps_exports.Item,
  "item",
  { forwardAsChild: true }
);
var StepsTrigger2 = withContext48(
  steps_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var StepsContent2 = withContext48(
  steps_exports.Content,
  "content",
  { forwardAsChild: true }
);
var StepsCompletedContent2 = withContext48(steps_exports.CompletedContent, "content");
var StepsNumber = (0, import_react936.forwardRef)(
  function StepsNumber2(props34, ref2) {
    return (0, import_jsx_runtime469.jsx)(steps_exports.ItemContext, { children: (api) => (0, import_jsx_runtime469.jsx)(chakra.div, { ref: ref2, ...props34, children: api.index + 1 }) });
  }
);
var StepsTitle = withContext48(
  "div",
  "title"
);
var StepsDescription = withContext48("div", "description");
var StepsSeparator2 = withContext48(
  steps_exports.Separator,
  "separator",
  { forwardAsChild: true }
);
var StepsStatus = (props34) => {
  return (0, import_jsx_runtime469.jsx)(steps_exports.ItemContext, { children: (api) => {
    if (api.current) return (0, import_jsx_runtime469.jsx)(import_jsx_runtime469.Fragment, { children: props34.current ?? props34.incomplete });
    if (api.completed) return (0, import_jsx_runtime469.jsx)(import_jsx_runtime469.Fragment, { children: props34.complete });
    return (0, import_jsx_runtime469.jsx)(import_jsx_runtime469.Fragment, { children: props34.incomplete ?? props34.current });
  } });
};
var StepsIndicator2 = withContext48(
  steps_exports.Indicator,
  "indicator",
  {
    forwardAsChild: true,
    defaultProps: {
      children: (0, import_jsx_runtime469.jsx)(StepsStatus, { complete: (0, import_jsx_runtime469.jsx)(CheckIcon, {}), incomplete: (0, import_jsx_runtime469.jsx)(StepsNumber, {}) })
    }
  }
);
var StepsNextTrigger2 = withContext48(steps_exports.NextTrigger, "nextTrigger", { forwardAsChild: true });
var StepsPrevTrigger2 = withContext48(steps_exports.PrevTrigger, "prevTrigger", { forwardAsChild: true });
var StepsContext2 = steps_exports.Context;
var StepsItemContext2 = steps_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/steps/namespace.js
var namespace_exports40 = {};
__export(namespace_exports40, {
  CompletedContent: () => StepsCompletedContent2,
  Content: () => StepsContent2,
  Context: () => StepsContext2,
  Description: () => StepsDescription,
  Indicator: () => StepsIndicator2,
  Item: () => StepsItem2,
  ItemContext: () => StepsItemContext2,
  List: () => StepsList2,
  NextTrigger: () => StepsNextTrigger2,
  Number: () => StepsNumber,
  PrevTrigger: () => StepsPrevTrigger2,
  PropsProvider: () => StepsPropsProvider,
  Root: () => StepsRoot2,
  RootProvider: () => StepsRootProvider2,
  Separator: () => StepsSeparator2,
  Status: () => StepsStatus,
  Title: () => StepsTitle,
  Trigger: () => StepsTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/switch/switch.js
var import_jsx_runtime470 = __toESM(require_jsx_runtime(), 1);
var import_react937 = __toESM(require_react(), 1);
var {
  withProvider: withProvider35,
  withContext: withContext49,
  useStyles: useSwitchStyles,
  PropsProvider: PropsProvider52
} = createSlotRecipeContext({ key: "switch" });
var SwitchRootProvider2 = withProvider35(switch_exports.RootProvider, "root", { forwardAsChild: true });
var SwitchRoot2 = withProvider35(
  switch_exports.Root,
  "root",
  { forwardAsChild: true }
);
var SwitchPropsProvider = PropsProvider52;
var SwitchLabel2 = withContext49(
  switch_exports.Label,
  "label",
  { forwardAsChild: true }
);
var SwitchThumb2 = withContext49(
  switch_exports.Thumb,
  "thumb",
  { forwardAsChild: true }
);
var SwitchControl2 = withContext49(
  switch_exports.Control,
  "control",
  {
    forwardAsChild: true,
    defaultProps: { children: (0, import_jsx_runtime470.jsx)(SwitchThumb2, {}) }
  }
);
var SwitchIndicator = (0, import_react937.forwardRef)(function SwitchIndicator2(props34, ref2) {
  const api = useSwitchContext();
  const styles = useSwitchStyles();
  const { fallback: fallback4, children, ...rest } = props34;
  return (0, import_jsx_runtime470.jsx)(
    chakra.span,
    {
      ref: ref2,
      "data-checked": dataAttr2(api.checked),
      ...rest,
      css: [styles.indicator, props34.css],
      children: api.checked ? children : fallback4
    }
  );
});
var SwitchThumbIndicator = (0, import_react937.forwardRef)(function SwitchThumbIndicator2(props34, ref2) {
  const api = useSwitchContext();
  const { fallback: fallback4, children, ...rest } = props34;
  return (0, import_jsx_runtime470.jsx)(chakra.span, { ref: ref2, "data-checked": dataAttr2(api.checked), ...rest, children: api.checked ? children : fallback4 });
});
var SwitchContext2 = switch_exports.Context;
var SwitchHiddenInput2 = switch_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/switch/namespace.js
var namespace_exports41 = {};
__export(namespace_exports41, {
  Context: () => SwitchContext2,
  Control: () => SwitchControl2,
  HiddenInput: () => SwitchHiddenInput2,
  Indicator: () => SwitchIndicator,
  Label: () => SwitchLabel2,
  PropsProvider: () => SwitchPropsProvider,
  Root: () => SwitchRoot2,
  RootProvider: () => SwitchRootProvider2,
  Thumb: () => SwitchThumb2,
  ThumbIndicator: () => SwitchThumbIndicator
});

// node_modules/@chakra-ui/react/dist/esm/components/table/table.js
var import_jsx_runtime471 = __toESM(require_jsx_runtime(), 1);
var import_react938 = __toESM(require_react(), 1);
var {
  StylesProvider,
  ClassNamesProvider,
  useRecipeResult: useRecipeResult5,
  withContext: withContext50,
  useStyles: useTableStyles,
  PropsProvider: PropsProvider53
} = createSlotRecipeContext({ key: "table" });
var TableRoot = (0, import_react938.forwardRef)(
  function TableRoot2({ native, ...props34 }, ref2) {
    const { styles, props: rootProps, classNames } = useRecipeResult5(props34);
    const rootCss = (0, import_react938.useMemo)(() => {
      if (!native) return styles.root;
      return {
        ...styles.root,
        "& thead": styles.header,
        "& tbody": styles.body,
        "& tfoot": styles.footer,
        "& thead th": styles.columnHeader,
        "& tr": styles.row,
        "& td": styles.cell,
        "& caption": styles.caption
      };
    }, [styles, native]);
    return (0, import_jsx_runtime471.jsx)(ClassNamesProvider, { value: classNames, children: (0, import_jsx_runtime471.jsx)(StylesProvider, { value: styles, children: (0, import_jsx_runtime471.jsx)(
      chakra.table,
      {
        ref: ref2,
        ...rootProps,
        css: [rootCss, props34.css],
        className: cx(classNames == null ? void 0 : classNames["root"], props34.className)
      }
    ) }) });
  }
);
var TableRootPropsProvider = PropsProvider53;
var TableRow = withContext50(
  "tr",
  "row"
);
var TableScrollArea = chakra("div", {
  base: {
    display: "block",
    whiteSpace: "nowrap",
    WebkitOverflowScrolling: "touch",
    overflow: "auto",
    maxWidth: "100%"
  }
});
var TableHeader = withContext50("thead", "header");
var TableFooter = withContext50("tfoot", "footer");
var TableColumnHeader = withContext50("th", "columnHeader");
var TableCell = withContext50(
  "td",
  "cell"
);
var TableCaption = withContext50("caption", "caption", {
  defaultProps: {
    captionSide: "bottom"
  }
});
var TableBody = withContext50(
  "tbody",
  "body"
);
var TableColumnGroup = withContext50("colgroup");
var TableColumn = withContext50(
  "col"
);

// node_modules/@chakra-ui/react/dist/esm/components/table/namespace.js
var namespace_exports42 = {};
__export(namespace_exports42, {
  Body: () => TableBody,
  Caption: () => TableCaption,
  Cell: () => TableCell,
  Column: () => TableColumn,
  ColumnGroup: () => TableColumnGroup,
  ColumnHeader: () => TableColumnHeader,
  Footer: () => TableFooter,
  Header: () => TableHeader,
  Root: () => TableRoot,
  RootPropsProvider: () => TableRootPropsProvider,
  Row: () => TableRow,
  ScrollArea: () => TableScrollArea
});

// node_modules/@chakra-ui/react/dist/esm/components/tabs/tabs.js
var {
  withProvider: withProvider36,
  withContext: withContext51,
  useStyles: useTabsStyles,
  PropsProvider: PropsProvider54
} = createSlotRecipeContext({ key: "tabs" });
var TabsRootProvider2 = withProvider36(tabs_exports.RootProvider, "root", { forwardAsChild: true });
var TabsRoot2 = withProvider36(
  tabs_exports.Root,
  "root",
  { forwardAsChild: true }
);
var TabsPropsProvider = PropsProvider54;
var TabsTrigger = withContext51(
  tabs_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var TabsContent = withContext51(
  tabs_exports.Content,
  "content",
  { forwardAsChild: true }
);
var TabsContentGroup = withContext51("div", "contentGroup");
var TabsList = withContext51(
  tabs_exports.List,
  "list",
  { forwardAsChild: true }
);
var TabsIndicator = withContext51(
  tabs_exports.Indicator,
  "indicator",
  { forwardAsChild: true }
);
var TabsContext2 = tabs_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/tabs/namespace.js
var namespace_exports43 = {};
__export(namespace_exports43, {
  Content: () => TabsContent,
  ContentGroup: () => TabsContentGroup,
  Context: () => TabsContext2,
  Indicator: () => TabsIndicator,
  List: () => TabsList,
  PropsProvider: () => TabsPropsProvider,
  Root: () => TabsRoot2,
  RootProvider: () => TabsRootProvider2,
  Trigger: () => TabsTrigger
});

// node_modules/@chakra-ui/react/dist/esm/components/tag/tag.js
var import_jsx_runtime472 = __toESM(require_jsx_runtime(), 1);
var {
  withProvider: withProvider37,
  withContext: withContext52,
  useStyles: useTagStyles,
  PropsProvider: PropsProvider55
} = createSlotRecipeContext({ key: "tag" });
var TagRoot = withProvider37(
  "div",
  "root"
);
var TagRootPropsProvider = PropsProvider55;
var TagLabel = withContext52(
  "span",
  "label"
);
var TagCloseTrigger = withContext52("button", "closeTrigger", { defaultProps: { children: (0, import_jsx_runtime472.jsx)(CloseIcon, {}) } });
var TagStartElement = withContext52("span", "startElement");
var TagEndElement = withContext52(
  "span",
  "endElement"
);

// node_modules/@chakra-ui/react/dist/esm/components/tag/namespace.js
var namespace_exports44 = {};
__export(namespace_exports44, {
  CloseTrigger: () => TagCloseTrigger,
  EndElement: () => TagEndElement,
  Label: () => TagLabel,
  Root: () => TagRoot,
  RootPropsProvider: () => TagRootPropsProvider,
  StartElement: () => TagStartElement
});

// node_modules/@chakra-ui/react/dist/esm/components/textarea/textarea.js
var { withContext: withContext53, PropsProvider: PropsProvider56 } = createRecipeContext({
  key: "textarea"
});
var Textarea = withContext53(
  field_exports.Textarea
);
var TextareaPropsProvider = PropsProvider56;

// node_modules/@chakra-ui/react/dist/esm/components/timeline/timeline.js
var {
  withProvider: withProvider38,
  withContext: withContext54,
  useStyles: useTimelineStyles,
  PropsProvider: PropsProvider57
} = createSlotRecipeContext({ key: "timeline" });
var TimelineRoot = withProvider38(
  "div",
  "root",
  { defaultProps: { role: "list" } }
);
var TimelineRootPropsProvider = PropsProvider57;
var TimelineItem = withContext54(
  "div",
  "item",
  { defaultProps: { role: "listitem" } }
);
var TimelineSeparator = withContext54("div", "separator");
var TimelineIndicator = withContext54("div", "indicator");
var TimelineContent = withContext54("div", "content");
var TimelineTitle = withContext54(
  "div",
  "title"
);
var TimelineDescription = withContext54("div", "description");
var TimelineConnector = withContext54("div", "connector");

// node_modules/@chakra-ui/react/dist/esm/components/timeline/namespace.js
var namespace_exports45 = {};
__export(namespace_exports45, {
  Connector: () => TimelineConnector,
  Content: () => TimelineContent,
  Description: () => TimelineDescription,
  Indicator: () => TimelineIndicator,
  Item: () => TimelineItem,
  Root: () => TimelineRoot,
  RootPropsProvider: () => TimelineRootPropsProvider,
  Separator: () => TimelineSeparator,
  Title: () => TimelineTitle
});

// node_modules/@chakra-ui/react/dist/esm/components/toast/toast.js
var import_jsx_runtime473 = __toESM(require_jsx_runtime(), 1);
var import_react939 = __toESM(require_react(), 1);
var {
  withProvider: withProvider39,
  withContext: withContext55,
  useStyles: useToastStyles
} = createSlotRecipeContext({ key: "toast" });
var Toaster2 = chakra(
  Toaster,
  {},
  { forwardAsChild: true }
);
var ToastRoot2 = withProvider39(
  toast_exports.Root,
  "root",
  { forwardAsChild: true }
);
var ToastCloseTrigger2 = withContext55(toast_exports.CloseTrigger, "closeTrigger", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime473.jsx)(CloseIcon, {})
  }
});
var ToastTitle2 = withContext55(
  toast_exports.Title,
  "title",
  { forwardAsChild: true }
);
var ToastDescription2 = withContext55(toast_exports.Description, "description", { forwardAsChild: true });
var ToastActionTrigger2 = withContext55(toast_exports.ActionTrigger, "actionTrigger", { forwardAsChild: true });
var iconMap2 = {
  warning: WarningIcon,
  success: CheckCircleIcon,
  error: WarningIcon
};
var ToastIndicator = (0, import_react939.forwardRef)(
  function ToastIndicator2(props34, ref2) {
    const api = useToastContext();
    const styles = useToastStyles();
    const Component = iconMap2[api.type];
    if (!Component) return null;
    return (0, import_jsx_runtime473.jsx)(Component, { ref: ref2, ...props34, css: [styles.indicator, props34.css] });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/toast/namespace.js
var namespace_exports46 = {};
__export(namespace_exports46, {
  ActionTrigger: () => ToastActionTrigger2,
  CloseTrigger: () => ToastCloseTrigger2,
  Description: () => ToastDescription2,
  Indicator: () => ToastIndicator,
  Root: () => ToastRoot2,
  Title: () => ToastTitle2
});

// node_modules/@chakra-ui/react/dist/esm/components/toggle/toggle.js
var {
  withProvider: withProvider40,
  withContext: withContext56,
  useStyles: useToggleStyles,
  PropsProvider: PropsProvider58
} = createSlotRecipeContext({ key: "toggle" });
var ToggleRootProvider = withProvider40(toggle_exports.Root, "root", { forwardAsChild: true });
var ToggleRoot2 = withProvider40(
  toggle_exports.Root,
  "root",
  { forwardAsChild: true }
);
var TogglePropsProvider = PropsProvider58;
var ToggleIndicator2 = withContext56(toggle_exports.Indicator, "indicator", { forwardAsChild: true });
var ToggleContext2 = toggle_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/toggle/namespace.js
var namespace_exports47 = {};
__export(namespace_exports47, {
  Context: () => ToggleContext2,
  Indicator: () => ToggleIndicator2,
  PropsProvider: () => TogglePropsProvider,
  Root: () => ToggleRoot2
});

// node_modules/@chakra-ui/react/dist/esm/components/tooltip/tooltip.js
var import_jsx_runtime474 = __toESM(require_jsx_runtime(), 1);
var {
  withRootProvider: withRootProvider7,
  withContext: withContext57,
  useStyles: useTooltipStyles,
  PropsProvider: PropsProvider59
} = createSlotRecipeContext({ key: "tooltip" });
var TooltipRootProvider2 = withRootProvider7(
  tooltip_exports.RootProvider
);
var TooltipRoot2 = withRootProvider7(tooltip_exports.Root, {
  defaultProps: { lazyMount: true, unmountOnExit: true }
});
var TooltipPropsProvider = PropsProvider59;
var TooltipTrigger2 = withContext57(tooltip_exports.Trigger, "trigger", { forwardAsChild: true });
var TooltipPositioner2 = withContext57(tooltip_exports.Positioner, "positioner", { forwardAsChild: true });
var TooltipContent2 = withContext57(
  tooltip_exports.Content,
  "content",
  { forwardAsChild: true }
);
var TooltipArrowTip2 = withContext57(tooltip_exports.ArrowTip, "arrowTip", { forwardAsChild: true });
var TooltipArrow2 = withContext57(
  tooltip_exports.Arrow,
  "arrow",
  { forwardAsChild: true, defaultProps: { children: (0, import_jsx_runtime474.jsx)(TooltipArrowTip2, {}) } }
);
var TooltipContext2 = tooltip_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/tooltip/namespace.js
var namespace_exports48 = {};
__export(namespace_exports48, {
  Arrow: () => TooltipArrow2,
  ArrowTip: () => TooltipArrowTip2,
  Content: () => TooltipContent2,
  Context: () => TooltipContext2,
  Positioner: () => TooltipPositioner2,
  PropsProvider: () => TooltipPropsProvider,
  Root: () => TooltipRoot2,
  RootProvider: () => TooltipRootProvider2,
  Trigger: () => TooltipTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/typography/heading.js
var { withContext: withContext58, PropsProvider: PropsProvider60 } = createRecipeContext({
  key: "heading"
});
var Heading = withContext58("h2");
var HeadingPropsProvider = PropsProvider60;

// node_modules/@chakra-ui/react/dist/esm/components/typography/text.js
var { withContext: withContext59, PropsProvider: PropsProvider61 } = createRecipeContext({
  key: "text"
});
var Text = withContext59("p");
var TextPropsProvider = PropsProvider61;

// node_modules/@chakra-ui/react/dist/esm/components/typography/em.js
var Em = chakra("em", {
  base: {
    fontStyle: "italic"
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/typography/strong.js
var Strong = chakra("strong", {
  base: { fontWeight: "semibold" }
});

// node_modules/@chakra-ui/react/dist/esm/components/visually-hidden/visually-hidden.js
var visuallyHiddenStyle2 = {
  border: "0",
  clip: "rect(0, 0, 0, 0)",
  height: "1px",
  width: "1px",
  margin: "-1px",
  padding: "0",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
};
var VisuallyHidden = chakra("span", {
  base: visuallyHiddenStyle2
});
VisuallyHidden.displayName = "VisuallyHidden";

// node_modules/@chakra-ui/react/dist/esm/components/wrap/wrap.js
var import_jsx_runtime475 = __toESM(require_jsx_runtime(), 1);
var import_react940 = __toESM(require_react(), 1);
var Wrap = (0, import_react940.forwardRef)(
  function Wrap2(props34, ref2) {
    const { gap = "0.5rem", justify, direction, align, ...rest } = props34;
    return (0, import_jsx_runtime475.jsx)(
      chakra.div,
      {
        ref: ref2,
        display: "flex",
        flexWrap: "wrap",
        justifyContent: justify,
        alignItems: align,
        flexDirection: direction,
        gap,
        ...rest,
        className: cx("chakra-wrap", props34.className)
      }
    );
  }
);
Wrap.displayName = "Wrap";
var itemStyle = defineStyle({
  display: "flex",
  alignItems: "flex-start"
});
var WrapItem = (0, import_react940.forwardRef)(
  function WrapItem2(props34, ref2) {
    return (0, import_jsx_runtime475.jsx)(
      chakra.div,
      {
        ref: ref2,
        css: [itemStyle, props34.css],
        ...props34,
        className: cx("chakra-wrap__listitem", props34.className)
      }
    );
  }
);
export {
  AbsoluteCenter,
  namespace_exports as Accordion,
  AccordionContext2 as AccordionContext,
  AccordionItem2 as AccordionItem,
  AccordionItemBody,
  AccordionItemContent2 as AccordionItemContent,
  AccordionItemContext2 as AccordionItemContext,
  AccordionItemIndicator2 as AccordionItemIndicator,
  AccordionItemTrigger2 as AccordionItemTrigger,
  AccordionPropsProvider,
  AccordionRoot2 as AccordionRoot,
  AccordionRootProvider2 as AccordionRootProvider,
  namespace_exports2 as ActionBar,
  ActionBarCloseTrigger,
  ActionBarContent,
  ActionBarContext,
  ActionBarPositioner,
  ActionBarPropsProvider,
  ActionBarRoot,
  ActionBarRootProvider,
  ActionBarSelectionTrigger,
  ActionBarSeparator,
  namespace_exports3 as Alert,
  AlertContent,
  AlertDescription,
  AlertIndicator,
  AlertPropsProvider,
  AlertRoot,
  AlertTitle,
  AspectRatio,
  namespace_exports4 as Avatar,
  AvatarContext2 as AvatarContext,
  AvatarFallback2 as AvatarFallback,
  AvatarGroup,
  AvatarIcon,
  AvatarImage2 as AvatarImage,
  AvatarPropsProvider,
  AvatarRoot2 as AvatarRoot,
  AvatarRootProvider2 as AvatarRootProvider,
  Badge,
  BadgePropsProvider,
  Bleed,
  namespace_exports5 as Blockquote,
  BlockquoteCaption,
  BlockquoteContent,
  BlockquoteIcon,
  BlockquotePropsProvider,
  BlockquoteRoot,
  Box,
  namespace_exports6 as Breadcrumb,
  BreadcrumbCurrentLink,
  BreadcrumbEllipsis,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPropsProvider,
  BreadcrumbRoot,
  BreadcrumbSeparator,
  Button,
  ButtonGroup,
  ButtonPropsProvider,
  namespace_exports7 as Card,
  CardBody,
  CardDescription,
  CardFooter,
  CardHeader,
  CardPropsProvider,
  CardRoot,
  CardTitle,
  Center,
  ChakraProvider,
  namespace_exports8 as Checkbox,
  namespace_exports9 as CheckboxCard,
  CheckboxCardAddon,
  CheckboxCardContent,
  CheckboxCardContext,
  CheckboxCardControl,
  CheckboxCardDescription,
  CheckboxCardHiddenInput,
  CheckboxCardIndicator,
  CheckboxCardLabel,
  CheckboxCardRoot,
  CheckboxCardRootPropsProvider,
  CheckboxCardRootProvider,
  CheckboxContext2 as CheckboxContext,
  CheckboxControl2 as CheckboxControl,
  CheckboxGroup2 as CheckboxGroup,
  CheckboxHiddenInput2 as CheckboxHiddenInput,
  CheckboxIndicator2 as CheckboxIndicator,
  CheckboxLabel2 as CheckboxLabel,
  CheckboxPropsProvider,
  CheckboxRoot2 as CheckboxRoot,
  CheckboxRootProvider2 as CheckboxRootProvider,
  Checkmark,
  Circle,
  ClientOnly2 as ClientOnly,
  namespace_exports10 as Clipboard,
  ClipboardContext2 as ClipboardContext,
  ClipboardControl2 as ClipboardControl,
  ClipboardIndicator2 as ClipboardIndicator,
  ClipboardInput2 as ClipboardInput,
  ClipboardLabel2 as ClipboardLabel,
  ClipboardPropsProvider,
  ClipboardRoot2 as ClipboardRoot,
  ClipboardRootProvider2 as ClipboardRootProvider,
  ClipboardTrigger2 as ClipboardTrigger,
  ClipboardValueText2 as ClipboardValueText,
  CloseButton,
  Code,
  CodePropsProvider,
  namespace_exports11 as Collapsible,
  CollapsibleContent2 as CollapsibleContent,
  CollapsibleContext2 as CollapsibleContext,
  CollapsiblePropsProvider,
  CollapsibleRoot2 as CollapsibleRoot,
  CollapsibleRootProvider2 as CollapsibleRootProvider,
  CollapsibleTrigger2 as CollapsibleTrigger,
  namespace_exports12 as ColorPicker,
  ColorPickerArea2 as ColorPickerArea,
  ColorPickerAreaBackground2 as ColorPickerAreaBackground,
  ColorPickerAreaThumb2 as ColorPickerAreaThumb,
  ColorPickerChannelInput2 as ColorPickerChannelInput,
  ColorPickerChannelSlider2 as ColorPickerChannelSlider,
  ColorPickerChannelSliderLabel2 as ColorPickerChannelSliderLabel,
  ColorPickerChannelSliderThumb2 as ColorPickerChannelSliderThumb,
  ColorPickerChannelSliderTrack2 as ColorPickerChannelSliderTrack,
  ColorPickerChannelSliderValueText2 as ColorPickerChannelSliderValueText,
  ColorPickerContent2 as ColorPickerContent,
  ColorPickerContext2 as ColorPickerContext,
  ColorPickerControl2 as ColorPickerControl,
  ColorPickerEyeDropperTrigger2 as ColorPickerEyeDropperTrigger,
  ColorPickerFormatSelect2 as ColorPickerFormatSelect,
  ColorPickerFormatTrigger2 as ColorPickerFormatTrigger,
  ColorPickerHiddenInput2 as ColorPickerHiddenInput,
  ColorPickerLabel2 as ColorPickerLabel,
  ColorPickerPositioner2 as ColorPickerPositioner,
  ColorPickerPropsProvider,
  ColorPickerRoot2 as ColorPickerRoot,
  ColorPickerRootProvider2 as ColorPickerRootProvider,
  ColorPickerSwatch2 as ColorPickerSwatch,
  ColorPickerSwatchGroup2 as ColorPickerSwatchGroup,
  ColorPickerSwatchIndicator2 as ColorPickerSwatchIndicator,
  ColorPickerSwatchTrigger2 as ColorPickerSwatchTrigger,
  ColorPickerTransparencyGrid2 as ColorPickerTransparencyGrid,
  ColorPickerTrigger2 as ColorPickerTrigger,
  ColorPickerValueSwatch2 as ColorPickerValueSwatch,
  ColorPickerValueText2 as ColorPickerValueText,
  ColorPickerView2 as ColorPickerView,
  ColorSwatch,
  ColorSwatchMix,
  ColorSwatchPropsProvider,
  Container,
  ContainerPropsProvider,
  namespace_exports13 as DataList,
  DataListItem,
  DataListItemLabel,
  DataListItemValue,
  DataListPropsProvider,
  DataListRoot,
  namespace_exports14 as Dialog,
  DialogActionTrigger,
  DialogBackdrop2 as DialogBackdrop,
  DialogBody,
  DialogCloseTrigger2 as DialogCloseTrigger,
  DialogContent2 as DialogContent,
  DialogContext2 as DialogContext,
  DialogDescription2 as DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogPositioner2 as DialogPositioner,
  DialogPropsProvider,
  DialogRoot2 as DialogRoot,
  DialogRootProvider2 as DialogRootProvider,
  DialogTitle2 as DialogTitle,
  DialogTrigger2 as DialogTrigger,
  namespace_exports15 as Drawer,
  DrawerActionTrigger,
  DrawerBackdrop,
  DrawerBody,
  DrawerCloseTrigger,
  DrawerContent,
  DrawerContext,
  DrawerDescription,
  DrawerFooter,
  DrawerHeader,
  DrawerPositioner,
  DrawerRoot,
  DrawerRootPropsProvider,
  DrawerRootProvider,
  DrawerTitle,
  DrawerTrigger,
  EMPTY_SLOT_STYLES,
  EMPTY_STYLES,
  namespace_exports16 as Editable,
  EditableArea2 as EditableArea,
  EditableCancelTrigger2 as EditableCancelTrigger,
  EditableContext2 as EditableContext,
  EditableControl2 as EditableControl,
  EditableEditTrigger2 as EditableEditTrigger,
  EditableInput2 as EditableInput,
  EditablePreview2 as EditablePreview,
  EditablePropsProvider,
  EditableRoot2 as EditableRoot,
  EditableRootProvider2 as EditableRootProvider,
  EditableSubmitTrigger2 as EditableSubmitTrigger,
  EditableTextarea,
  Em,
  namespace_exports17 as EmptyState,
  EmptyStateContent,
  EmptyStateDescription,
  EmptyStateIndicator,
  EmptyStatePropsProvider,
  EmptyStateRoot,
  EmptyStateTitle,
  EnvironmentProvider,
  namespace_exports18 as Field,
  FieldErrorIcon,
  FieldErrorText2 as FieldErrorText,
  FieldHelperText2 as FieldHelperText,
  FieldLabel2 as FieldLabel,
  FieldPropsProvider,
  FieldRequiredIndicator2 as FieldRequiredIndicator,
  FieldRoot2 as FieldRoot,
  namespace_exports19 as Fieldset,
  FieldsetContent,
  FieldsetContext2 as FieldsetContext,
  FieldsetErrorText2 as FieldsetErrorText,
  FieldsetHelperText2 as FieldsetHelperText,
  FieldsetLegend2 as FieldsetLegend,
  FieldsetRoot2 as FieldsetRoot,
  namespace_exports20 as FileUpload,
  FileUploadClearTrigger2 as FileUploadClearTrigger,
  FileUploadContext2 as FileUploadContext,
  FileUploadDropzone2 as FileUploadDropzone,
  FileUploadDropzoneContent,
  FileUploadHiddenInput2 as FileUploadHiddenInput,
  FileUploadItem2 as FileUploadItem,
  FileUploadItemContent,
  FileUploadItemDeleteTrigger2 as FileUploadItemDeleteTrigger,
  FileUploadItemGroup2 as FileUploadItemGroup,
  FileUploadItemName2 as FileUploadItemName,
  FileUploadItemPreview2 as FileUploadItemPreview,
  FileUploadItemPreviewImage2 as FileUploadItemPreviewImage,
  FileUploadItemSizeText2 as FileUploadItemSizeText,
  FileUploadLabel2 as FileUploadLabel,
  FileUploadPropsProvider,
  FileUploadRoot2 as FileUploadRoot,
  FileUploadRootProvider2 as FileUploadRootProvider,
  FileUploadTrigger2 as FileUploadTrigger,
  Flex,
  Float,
  FocusTrap3 as FocusTrap,
  For,
  FormatByte2 as FormatByte,
  FormatNumber2 as FormatNumber,
  Grid,
  GridItem,
  Group,
  HStack,
  Heading,
  HeadingPropsProvider,
  Highlight2 as Highlight,
  namespace_exports21 as HoverCard,
  HoverCardArrow2 as HoverCardArrow,
  HoverCardArrowTip2 as HoverCardArrowTip,
  HoverCardContent2 as HoverCardContent,
  HoverCardContext2 as HoverCardContext,
  HoverCardPositioner2 as HoverCardPositioner,
  HoverCardPropsProvider,
  HoverCardRoot2 as HoverCardRoot,
  HoverCardRootProvider2 as HoverCardRootProvider,
  HoverCardTrigger2 as HoverCardTrigger,
  Icon,
  IconButton,
  IconPropsProvider,
  Image,
  Input,
  InputAddon,
  InputElement,
  InputPropsProvider,
  Kbd,
  Link,
  LinkBox,
  LinkOverlay,
  LinkPropsProvider,
  namespace_exports22 as List,
  ListIndicator,
  ListItem,
  ListRoot,
  ListRootPropsProvider,
  Loader,
  LoaderOverlay,
  LocaleProvider,
  Mark,
  MarkPropsProvider,
  namespace_exports23 as Menu,
  MenuArrow2 as MenuArrow,
  MenuArrowTip2 as MenuArrowTip,
  MenuCheckboxItem2 as MenuCheckboxItem,
  MenuContent2 as MenuContent,
  MenuContext2 as MenuContext,
  MenuContextTrigger2 as MenuContextTrigger,
  MenuIndicator2 as MenuIndicator,
  MenuItem2 as MenuItem,
  MenuItemCommand,
  MenuItemContext2 as MenuItemContext,
  MenuItemGroup2 as MenuItemGroup,
  MenuItemGroupLabel2 as MenuItemGroupLabel,
  MenuItemIndicator2 as MenuItemIndicator,
  MenuItemText2 as MenuItemText,
  MenuPositioner2 as MenuPositioner,
  MenuPropsProvider,
  MenuRadioItem2 as MenuRadioItem,
  MenuRadioItemGroup2 as MenuRadioItemGroup,
  MenuRoot2 as MenuRoot,
  MenuRootProvider2 as MenuRootProvider,
  MenuSeparator2 as MenuSeparator,
  MenuTrigger2 as MenuTrigger,
  MenuTriggerItem2 as MenuTriggerItem,
  namespace_exports24 as NativeSelect,
  NativeSelectField,
  NativeSelectIndicator,
  NativeSelectPropsProvider,
  NativeSelectRoot,
  namespace_exports25 as NumberInput,
  NumberInputContext2 as NumberInputContext,
  NumberInputControl2 as NumberInputControl,
  NumberInputDecrementTrigger2 as NumberInputDecrementTrigger,
  NumberInputIncrementTrigger2 as NumberInputIncrementTrigger,
  NumberInputInput2 as NumberInputInput,
  NumberInputLabel2 as NumberInputLabel,
  NumberInputPropsProvider,
  NumberInputRoot2 as NumberInputRoot,
  NumberInputRootProvider2 as NumberInputRootProvider,
  NumberInputScrubber2 as NumberInputScrubber,
  NumberInputValueText2 as NumberInputValueText,
  namespace_exports26 as Pagination,
  PaginationContext2 as PaginationContext,
  PaginationEllipsis2 as PaginationEllipsis,
  PaginationItem2 as PaginationItem,
  PaginationNextTrigger2 as PaginationNextTrigger,
  PaginationPrevTrigger2 as PaginationPrevTrigger,
  PaginationPropsProvider,
  PaginationRoot2 as PaginationRoot,
  PaginationRootProvider2 as PaginationRootProvider,
  namespace_exports27 as PinInput,
  PinInputContext2 as PinInputContext,
  PinInputControl2 as PinInputControl,
  PinInputHiddenInput2 as PinInputHiddenInput,
  PinInputInput2 as PinInputInput,
  PinInputLabel2 as PinInputLabel,
  PinInputPropsProvider,
  PinInputRoot2 as PinInputRoot,
  PinInputRootProvider2 as PinInputRootProvider,
  namespace_exports28 as Popover,
  PopoverAnchor2 as PopoverAnchor,
  PopoverArrow2 as PopoverArrow,
  PopoverArrowTip2 as PopoverArrowTip,
  PopoverBody,
  PopoverCloseTrigger2 as PopoverCloseTrigger,
  PopoverContent2 as PopoverContent,
  PopoverContext2 as PopoverContext,
  PopoverDescription2 as PopoverDescription,
  PopoverFooter,
  PopoverHeader,
  PopoverPositioner2 as PopoverPositioner,
  PopoverPropsProvider,
  PopoverRoot2 as PopoverRoot,
  PopoverRootProvider2 as PopoverRootProvider,
  PopoverTitle2 as PopoverTitle,
  PopoverTrigger2 as PopoverTrigger,
  Portal,
  Presence2 as Presence,
  namespace_exports29 as Progress,
  namespace_exports30 as ProgressCircle,
  ProgressCircleCircle,
  ProgressCircleContext,
  ProgressCircleLabel,
  ProgressCirclePropsProvider,
  ProgressCircleRange2 as ProgressCircleRange,
  ProgressCircleRoot,
  ProgressCircleRootProvider,
  ProgressCircleTrack2 as ProgressCircleTrack,
  ProgressCircleValueText,
  ProgressContext2 as ProgressContext,
  ProgressLabel2 as ProgressLabel,
  ProgressPropsProvider,
  ProgressRange2 as ProgressRange,
  ProgressRoot2 as ProgressRoot,
  ProgressRootProvider2 as ProgressRootProvider,
  ProgressTrack2 as ProgressTrack,
  ProgressValueText2 as ProgressValueText,
  namespace_exports31 as QrCode,
  QrCodeFrame2 as QrCodeFrame,
  QrCodeOverlay2 as QrCodeOverlay,
  QrCodePattern2 as QrCodePattern,
  QrCodePropsProvider,
  QrCodeRoot2 as QrCodeRoot,
  QrCodeRootProvider2 as QrCodeRootProvider,
  namespace_exports32 as RadioCard,
  RadioCardContext,
  RadioCardItem,
  RadioCardItemAddon,
  RadioCardItemContent,
  RadioCardItemControl,
  RadioCardItemDescription,
  RadioCardItemHiddenInput,
  RadioCardItemIndicator,
  RadioCardItemText,
  RadioCardLabel,
  RadioCardPropsProvider,
  RadioCardRoot,
  RadioCardRootProvider,
  namespace_exports33 as RadioGroup,
  RadioGroupContext2 as RadioGroupContext,
  RadioGroupItem2 as RadioGroupItem,
  RadioGroupItemControl2 as RadioGroupItemControl,
  RadioGroupItemHiddenInput2 as RadioGroupItemHiddenInput,
  RadioGroupItemIndicator2 as RadioGroupItemIndicator,
  RadioGroupItemText2 as RadioGroupItemText,
  RadioGroupLabel2 as RadioGroupLabel,
  RadioGroupPropsProvider,
  RadioGroupRoot2 as RadioGroupRoot,
  RadioGroupRootProvider2 as RadioGroupRootProvider,
  Radiomark,
  namespace_exports34 as RatingGroup,
  RatingGroupContext2 as RatingGroupContext,
  RatingGroupControl2 as RatingGroupControl,
  RatingGroupHiddenInput2 as RatingGroupHiddenInput,
  RatingGroupItem2 as RatingGroupItem,
  RatingGroupItemContext2 as RatingGroupItemContext,
  RatingGroupItemIndicator,
  RatingGroupItems,
  RatingGroupLabel2 as RatingGroupLabel,
  RatingGroupPropsProvider,
  RatingGroupRoot2 as RatingGroupRoot,
  RatingGroupRootProvider2 as RatingGroupRootProvider,
  RecipePropsProvider,
  namespace_exports35 as SegmentGroup,
  SegmentGroupContext2 as SegmentGroupContext,
  SegmentGroupIndicator2 as SegmentGroupIndicator,
  SegmentGroupItem2 as SegmentGroupItem,
  SegmentGroupItemContext2 as SegmentGroupItemContext,
  SegmentGroupItemHiddenInput2 as SegmentGroupItemHiddenInput,
  SegmentGroupItemText2 as SegmentGroupItemText,
  SegmentGroupItems,
  SegmentGroupPropsProvider,
  SegmentGroupRoot2 as SegmentGroupRoot,
  SegmentGroupRootProvider2 as SegmentGroupRootProvider,
  namespace_exports36 as Select,
  SelectClearTrigger2 as SelectClearTrigger,
  SelectContent2 as SelectContent,
  SelectContext2 as SelectContext,
  SelectControl2 as SelectControl,
  SelectHiddenSelect2 as SelectHiddenSelect,
  SelectIndicator2 as SelectIndicator,
  SelectIndicatorGroup,
  SelectItem2 as SelectItem,
  SelectItemContext2 as SelectItemContext,
  SelectItemGroup2 as SelectItemGroup,
  SelectItemGroupLabel2 as SelectItemGroupLabel,
  SelectItemIndicator2 as SelectItemIndicator,
  SelectItemText2 as SelectItemText,
  SelectLabel2 as SelectLabel,
  SelectPositioner2 as SelectPositioner,
  SelectPropsProvider,
  SelectRoot2 as SelectRoot,
  SelectRootProvider2 as SelectRootProvider,
  SelectTrigger2 as SelectTrigger,
  SelectValueText2 as SelectValueText,
  Separator,
  SeparatorPropsProvider,
  Show,
  SimpleGrid,
  Skeleton,
  SkeletonCircle,
  SkeletonPropsProvider,
  SkeletonText,
  SkipNavContent,
  SkipNavLink,
  namespace_exports37 as Slider,
  SliderContext2 as SliderContext,
  SliderControl2 as SliderControl,
  SliderDraggingIndicator2 as SliderDraggingIndicator,
  SliderHiddenInput2 as SliderHiddenInput,
  SliderLabel2 as SliderLabel,
  SliderMarker2 as SliderMarker,
  SliderMarkerGroup2 as SliderMarkerGroup,
  SliderMarkerIndicator,
  SliderPropsProvider,
  SliderRange2 as SliderRange,
  SliderRoot2 as SliderRoot,
  SliderRootProvider2 as SliderRootProvider,
  SliderThumb2 as SliderThumb,
  SliderTrack2 as SliderTrack,
  SliderValueText2 as SliderValueText,
  Spacer,
  Span,
  Spinner,
  SpinnerPropsProvider,
  Square,
  Stack,
  StackSeparator,
  namespace_exports38 as Stat,
  StatDownIndicator,
  StatGroup,
  StatHelpText,
  StatLabel,
  StatPropsProvider,
  StatRoot,
  StatUpIndicator,
  StatValueText,
  StatValueUnit,
  namespace_exports39 as Status,
  StatusIndicator,
  StatusPropsProvider,
  StatusRoot,
  namespace_exports40 as Steps,
  StepsCompletedContent2 as StepsCompletedContent,
  StepsContent2 as StepsContent,
  StepsContext2 as StepsContext,
  StepsDescription,
  StepsIndicator2 as StepsIndicator,
  StepsItem2 as StepsItem,
  StepsItemContext2 as StepsItemContext,
  StepsList2 as StepsList,
  StepsNextTrigger2 as StepsNextTrigger,
  StepsNumber,
  StepsPrevTrigger2 as StepsPrevTrigger,
  StepsPropsProvider,
  StepsRoot2 as StepsRoot,
  StepsRootProvider2 as StepsRootProvider,
  StepsSeparator2 as StepsSeparator,
  StepsStatus,
  StepsTitle,
  StepsTrigger2 as StepsTrigger,
  Sticky,
  Strong,
  namespace_exports41 as Switch,
  SwitchContext2 as SwitchContext,
  SwitchControl2 as SwitchControl,
  SwitchHiddenInput2 as SwitchHiddenInput,
  SwitchIndicator,
  SwitchLabel2 as SwitchLabel,
  SwitchPropsProvider,
  SwitchRoot2 as SwitchRoot,
  SwitchRootProvider2 as SwitchRootProvider,
  SwitchThumb2 as SwitchThumb,
  SwitchThumbIndicator,
  namespace_exports42 as Table,
  TableBody,
  TableCaption,
  TableCell,
  TableColumn,
  TableColumnGroup,
  TableColumnHeader,
  TableFooter,
  TableHeader,
  TableRoot,
  TableRootPropsProvider,
  TableRow,
  TableScrollArea,
  namespace_exports43 as Tabs,
  TabsContent,
  TabsContentGroup,
  TabsContext2 as TabsContext,
  TabsIndicator,
  TabsList,
  TabsPropsProvider,
  TabsRoot2 as TabsRoot,
  TabsRootProvider2 as TabsRootProvider,
  TabsTrigger,
  namespace_exports44 as Tag,
  TagCloseTrigger,
  TagEndElement,
  TagLabel,
  TagRoot,
  TagRootPropsProvider,
  TagStartElement,
  Text,
  TextPropsProvider,
  Textarea,
  TextareaPropsProvider,
  Theme,
  namespace_exports45 as Timeline,
  TimelineConnector,
  TimelineContent,
  TimelineDescription,
  TimelineIndicator,
  TimelineItem,
  TimelineRoot,
  TimelineRootPropsProvider,
  TimelineSeparator,
  TimelineTitle,
  namespace_exports46 as Toast,
  ToastActionTrigger2 as ToastActionTrigger,
  ToastCloseTrigger2 as ToastCloseTrigger,
  ToastDescription2 as ToastDescription,
  ToastIndicator,
  ToastRoot2 as ToastRoot,
  ToastTitle2 as ToastTitle,
  Toaster2 as Toaster,
  namespace_exports47 as Toggle,
  ToggleContext2 as ToggleContext,
  ToggleIndicator2 as ToggleIndicator,
  TogglePropsProvider,
  ToggleRoot2 as ToggleRoot,
  namespace_exports48 as Tooltip,
  TooltipArrow2 as TooltipArrow,
  TooltipArrowTip2 as TooltipArrowTip,
  TooltipContent2 as TooltipContent,
  TooltipContext2 as TooltipContext,
  TooltipPositioner2 as TooltipPositioner,
  TooltipPropsProvider,
  TooltipRoot2 as TooltipRoot,
  TooltipRootProvider2 as TooltipRootProvider,
  TooltipTrigger2 as TooltipTrigger,
  VStack,
  VisuallyHidden,
  Wrap,
  WrapItem,
  chakra,
  createContext,
  createIcon,
  createListCollection,
  createRecipeContext,
  createSlotRecipeContext,
  createSystem,
  createToaster,
  defaultBaseConfig,
  defaultConfig,
  defaultSystem,
  defineAnimationStyles,
  defineConditions,
  defineConfig,
  defineGlobalStyles,
  defineKeyframes,
  defineLayerStyles,
  defineRecipe,
  defineSemanticTokens,
  defineSlotRecipe,
  defineStyle,
  defineTextStyles,
  defineTokens,
  isValidSystem,
  mergeConfigs,
  mergeProps,
  mergeRefs,
  parse2 as parseColor,
  useAccordion,
  useAccordionContext,
  useAccordionItemContext,
  useAccordionStyles,
  usePopover as useActionBar,
  usePopoverContext as useActionBarContext,
  useActionBarStyles,
  useAlertStyles,
  useAvatar,
  useAvatarContext,
  useAvatarStyles,
  useBlockquoteStyles,
  useBreadcrumbStyles,
  useBreakpoint,
  useBreakpointValue,
  useCallbackRef,
  useCardStyles,
  useChakraContext,
  useCheckbox,
  useCheckbox as useCheckboxCard,
  useCheckboxContext as useCheckboxCardContext,
  useCheckboxCardStyles,
  useCheckboxContext,
  useCheckboxGroup,
  useCheckboxGroupContext,
  useCheckboxStyles,
  useClipboard,
  useClipboardContext,
  useClipboardStyles,
  useCollapsible,
  useCollapsibleContext,
  useCollapsibleStyles,
  useColorPicker,
  useColorPickerContext,
  useColorPickerStyles,
  useConst,
  useControllableProp,
  useControllableState,
  useDataListStyles,
  useDialog,
  useDialogContext,
  useDialogStyles,
  useDisclosure,
  useDialog as useDrawer,
  useDialogContext as useDrawerContext,
  useDrawerStyles,
  useEditable,
  useEditableContext,
  useEditableStyles,
  useElementRect,
  useEmptyStateStyles,
  useEnvironmentContext,
  useFieldContext,
  useFieldStyles,
  useFieldsetContext,
  useFileUpload,
  useFileUploadContext,
  useFileUploadStyles,
  useForceUpdate,
  useHighlight,
  useHoverCard,
  useHoverCardContext,
  useHoverCardStyles,
  useListStyles,
  useLiveRef,
  useLocaleContext,
  useMediaQuery,
  useMenu,
  useMenuContext,
  useMenuItemContext,
  useMenuStyles,
  useNativeSelectStyles,
  useNumberInput,
  useNumberInputContext,
  useNumberInputStyles,
  usePagination,
  usePaginationContext,
  usePaginationStyles,
  useParentRecipeProps,
  usePinInput,
  usePinInputContext,
  usePinInputStyles,
  usePopover,
  usePopoverContext,
  usePopoverStyles,
  usePrevious,
  useProgress,
  useProgressCircleStyles,
  useProgressContext,
  useProgressStyles,
  useQrCode,
  useQrCodeContext,
  useQrCodeStyles,
  useRadioGroupContext as useRadioCardContext,
  useRadioGroup as useRadioCardGroup,
  useRadioGroupItemContext as useRadioCardItemContext,
  useRadioCardStyles,
  useRadioGroup,
  useRadioGroupContext,
  useRadioGroupItemContext,
  useRadioGroupStyles,
  useRatingGroup,
  useRatingGroupContext,
  useRatingGroupItemContext,
  useRatingGroupStyles,
  useRecipe,
  useSafeLayoutEffect3 as useSafeLayoutEffect,
  useSegmentGroup,
  useSegmentGroupContext,
  useSegmentGroupItemContext,
  useSegmentGroupStyles,
  useSelect,
  useSelectContext,
  useSelectItemContext,
  useSelectStyles,
  useSlider,
  useSliderContext,
  useSliderStyles,
  useSlotRecipe,
  useStatStyles,
  useStatusStyles,
  useSteps,
  useStepsContext,
  useStepsItemContext,
  useStepsStyles,
  useSwitch,
  useSwitchContext,
  useSwitchStyles,
  useTableStyles,
  useTabs,
  useTabsContext,
  useTabsStyles,
  useTagStyles,
  useTimelineStyles,
  useToastStyles,
  useToggle,
  useToggleContext,
  useToggleStyles,
  useToken,
  useTooltip,
  useTooltipContext,
  useTooltipStyles,
  useUpdateEffect2 as useUpdateEffect,
  visuallyHiddenStyle2 as visuallyHiddenStyle
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@chakra-ui_react.js.map
